(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["app"],{

/***/ "./assets/css/app.css":
/*!****************************!*\
  !*** ./assets/css/app.css ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./assets/css/bootstrap.min.css":
/*!**************************************!*\
  !*** ./assets/css/bootstrap.min.css ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./assets/fullcalendar/core/main.css":
/*!*******************************************!*\
  !*** ./assets/fullcalendar/core/main.css ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./assets/fullcalendar/core/main.js":
/*!******************************************!*\
  !*** ./assets/fullcalendar/core/main.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__(/*! core-js/modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");

__webpack_require__(/*! core-js/modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");

__webpack_require__(/*! core-js/modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.concat */ "./node_modules/core-js/modules/es.array.concat.js");

__webpack_require__(/*! core-js/modules/es.array.filter */ "./node_modules/core-js/modules/es.array.filter.js");

__webpack_require__(/*! core-js/modules/es.array.for-each */ "./node_modules/core-js/modules/es.array.for-each.js");

__webpack_require__(/*! core-js/modules/es.array.index-of */ "./node_modules/core-js/modules/es.array.index-of.js");

__webpack_require__(/*! core-js/modules/es.array.is-array */ "./node_modules/core-js/modules/es.array.is-array.js");

__webpack_require__(/*! core-js/modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.join */ "./node_modules/core-js/modules/es.array.join.js");

__webpack_require__(/*! core-js/modules/es.array.map */ "./node_modules/core-js/modules/es.array.map.js");

__webpack_require__(/*! core-js/modules/es.array.reduce */ "./node_modules/core-js/modules/es.array.reduce.js");

__webpack_require__(/*! core-js/modules/es.array.reverse */ "./node_modules/core-js/modules/es.array.reverse.js");

__webpack_require__(/*! core-js/modules/es.array.slice */ "./node_modules/core-js/modules/es.array.slice.js");

__webpack_require__(/*! core-js/modules/es.array.sort */ "./node_modules/core-js/modules/es.array.sort.js");

__webpack_require__(/*! core-js/modules/es.array.splice */ "./node_modules/core-js/modules/es.array.splice.js");

__webpack_require__(/*! core-js/modules/es.date.to-iso-string */ "./node_modules/core-js/modules/es.date.to-iso-string.js");

__webpack_require__(/*! core-js/modules/es.date.to-string */ "./node_modules/core-js/modules/es.date.to-string.js");

__webpack_require__(/*! core-js/modules/es.function.bind */ "./node_modules/core-js/modules/es.function.bind.js");

__webpack_require__(/*! core-js/modules/es.number.constructor */ "./node_modules/core-js/modules/es.number.constructor.js");

__webpack_require__(/*! core-js/modules/es.object.assign */ "./node_modules/core-js/modules/es.object.assign.js");

__webpack_require__(/*! core-js/modules/es.object.create */ "./node_modules/core-js/modules/es.object.create.js");

__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.freeze */ "./node_modules/core-js/modules/es.object.freeze.js");

__webpack_require__(/*! core-js/modules/es.object.get-own-property-names */ "./node_modules/core-js/modules/es.object.get-own-property-names.js");

__webpack_require__(/*! core-js/modules/es.object.get-prototype-of */ "./node_modules/core-js/modules/es.object.get-prototype-of.js");

__webpack_require__(/*! core-js/modules/es.object.keys */ "./node_modules/core-js/modules/es.object.keys.js");

__webpack_require__(/*! core-js/modules/es.object.set-prototype-of */ "./node_modules/core-js/modules/es.object.set-prototype-of.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.parse-int */ "./node_modules/core-js/modules/es.parse-int.js");

__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");

__webpack_require__(/*! core-js/modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");

__webpack_require__(/*! core-js/modules/es.string.pad-start */ "./node_modules/core-js/modules/es.string.pad-start.js");

__webpack_require__(/*! core-js/modules/es.string.replace */ "./node_modules/core-js/modules/es.string.replace.js");

__webpack_require__(/*! core-js/modules/es.string.split */ "./node_modules/core-js/modules/es.string.split.js");

__webpack_require__(/*! core-js/modules/es.string.trim */ "./node_modules/core-js/modules/es.string.trim.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");

__webpack_require__(/*! core-js/modules/web.timers */ "./node_modules/core-js/modules/web.timers.js");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
FullCalendar Core Package v4.3.1
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(this, function (exports) {
  'use strict'; // Creating
  // ----------------------------------------------------------------------------------------------------------------

  var elementPropHash = {
    className: true,
    colSpan: true,
    rowSpan: true
  };
  var containerTagHash = {
    '<tr': 'tbody',
    '<td': 'tr'
  };

  function createElement(tagName, attrs, content) {
    var el = document.createElement(tagName);

    if (attrs) {
      for (var attrName in attrs) {
        if (attrName === 'style') {
          applyStyle(el, attrs[attrName]);
        } else if (elementPropHash[attrName]) {
          el[attrName] = attrs[attrName];
        } else {
          el.setAttribute(attrName, attrs[attrName]);
        }
      }
    }

    if (typeof content === 'string') {
      el.innerHTML = content; // shortcut. no need to process HTML in any way
    } else if (content != null) {
      appendToElement(el, content);
    }

    return el;
  }

  function htmlToElement(html) {
    html = html.trim();
    var container = document.createElement(computeContainerTag(html));
    container.innerHTML = html;
    return container.firstChild;
  }

  function htmlToElements(html) {
    return Array.prototype.slice.call(htmlToNodeList(html));
  }

  function htmlToNodeList(html) {
    html = html.trim();
    var container = document.createElement(computeContainerTag(html));
    container.innerHTML = html;
    return container.childNodes;
  } // assumes html already trimmed and tag names are lowercase


  function computeContainerTag(html) {
    return containerTagHash[html.substr(0, 3) // faster than using regex
    ] || 'div';
  }

  function appendToElement(el, content) {
    var childNodes = normalizeContent(content);

    for (var i = 0; i < childNodes.length; i++) {
      el.appendChild(childNodes[i]);
    }
  }

  function prependToElement(parent, content) {
    var newEls = normalizeContent(content);
    var afterEl = parent.firstChild || null; // if no firstChild, will append to end, but that's okay, b/c there were no children

    for (var i = 0; i < newEls.length; i++) {
      parent.insertBefore(newEls[i], afterEl);
    }
  }

  function insertAfterElement(refEl, content) {
    var newEls = normalizeContent(content);
    var afterEl = refEl.nextSibling || null;

    for (var i = 0; i < newEls.length; i++) {
      refEl.parentNode.insertBefore(newEls[i], afterEl);
    }
  }

  function normalizeContent(content) {
    var els;

    if (typeof content === 'string') {
      els = htmlToElements(content);
    } else if (content instanceof Node) {
      els = [content];
    } else {
      // Node[] or NodeList
      els = Array.prototype.slice.call(content);
    }

    return els;
  }

  function removeElement(el) {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  } // Querying
  // ----------------------------------------------------------------------------------------------------------------
  // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest


  var matchesMethod = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.msMatchesSelector;

  var closestMethod = Element.prototype.closest || function (selector) {
    // polyfill
    var el = this;

    if (!document.documentElement.contains(el)) {
      return null;
    }

    do {
      if (elementMatches(el, selector)) {
        return el;
      }

      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);

    return null;
  };

  function elementClosest(el, selector) {
    return closestMethod.call(el, selector);
  }

  function elementMatches(el, selector) {
    return matchesMethod.call(el, selector);
  } // accepts multiple subject els
  // returns a real array. good for methods like forEach


  function findElements(container, selector) {
    var containers = container instanceof HTMLElement ? [container] : container;
    var allMatches = [];

    for (var i = 0; i < containers.length; i++) {
      var matches = containers[i].querySelectorAll(selector);

      for (var j = 0; j < matches.length; j++) {
        allMatches.push(matches[j]);
      }
    }

    return allMatches;
  } // accepts multiple subject els
  // only queries direct child elements


  function findChildren(parent, selector) {
    var parents = parent instanceof HTMLElement ? [parent] : parent;
    var allMatches = [];

    for (var i = 0; i < parents.length; i++) {
      var childNodes = parents[i].children; // only ever elements

      for (var j = 0; j < childNodes.length; j++) {
        var childNode = childNodes[j];

        if (!selector || elementMatches(childNode, selector)) {
          allMatches.push(childNode);
        }
      }
    }

    return allMatches;
  } // Attributes
  // ----------------------------------------------------------------------------------------------------------------


  function forceClassName(el, className, bool) {
    if (bool) {
      el.classList.add(className);
    } else {
      el.classList.remove(className);
    }
  } // Style
  // ----------------------------------------------------------------------------------------------------------------


  var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;

  function applyStyle(el, props) {
    for (var propName in props) {
      applyStyleProp(el, propName, props[propName]);
    }
  }

  function applyStyleProp(el, name, val) {
    if (val == null) {
      el.style[name] = '';
    } else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {
      el.style[name] = val + 'px';
    } else {
      el.style[name] = val;
    }
  }

  function pointInsideRect(point, rect) {
    return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
  } // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false


  function intersectRects(rect1, rect2) {
    var res = {
      left: Math.max(rect1.left, rect2.left),
      right: Math.min(rect1.right, rect2.right),
      top: Math.max(rect1.top, rect2.top),
      bottom: Math.min(rect1.bottom, rect2.bottom)
    };

    if (res.left < res.right && res.top < res.bottom) {
      return res;
    }

    return false;
  }

  function translateRect(rect, deltaX, deltaY) {
    return {
      left: rect.left + deltaX,
      right: rect.right + deltaX,
      top: rect.top + deltaY,
      bottom: rect.bottom + deltaY
    };
  } // Returns a new point that will have been moved to reside within the given rectangle


  function constrainPoint(point, rect) {
    return {
      left: Math.min(Math.max(point.left, rect.left), rect.right),
      top: Math.min(Math.max(point.top, rect.top), rect.bottom)
    };
  } // Returns a point that is the center of the given rectangle


  function getRectCenter(rect) {
    return {
      left: (rect.left + rect.right) / 2,
      top: (rect.top + rect.bottom) / 2
    };
  } // Subtracts point2's coordinates from point1's coordinates, returning a delta


  function diffPoints(point1, point2) {
    return {
      left: point1.left - point2.left,
      top: point1.top - point2.top
    };
  } // Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side


  var isRtlScrollbarOnLeft = null;

  function getIsRtlScrollbarOnLeft() {
    if (isRtlScrollbarOnLeft === null) {
      isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
    }

    return isRtlScrollbarOnLeft;
  }

  function computeIsRtlScrollbarOnLeft() {
    var outerEl = createElement('div', {
      style: {
        position: 'absolute',
        top: -1000,
        left: 0,
        border: 0,
        padding: 0,
        overflow: 'scroll',
        direction: 'rtl'
      }
    }, '<div></div>');
    document.body.appendChild(outerEl);
    var innerEl = outerEl.firstChild;
    var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
    removeElement(outerEl);
    return res;
  } // The scrollbar width computations in computeEdges are sometimes flawed when it comes to
  // retina displays, rounding, and IE11. Massage them into a usable value.


  function sanitizeScrollbarWidth(width) {
    width = Math.max(0, width); // no negatives

    width = Math.round(width);
    return width;
  }

  function computeEdges(el, getPadding) {
    if (getPadding === void 0) {
      getPadding = false;
    }

    var computedStyle = window.getComputedStyle(el);
    var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
    var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
    var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
    var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0; // must use offset(Width|Height) because compatible with client(Width|Height)

    var scrollbarLeftRight = sanitizeScrollbarWidth(el.offsetWidth - el.clientWidth - borderLeft - borderRight);
    var scrollbarBottom = sanitizeScrollbarWidth(el.offsetHeight - el.clientHeight - borderTop - borderBottom);
    var res = {
      borderLeft: borderLeft,
      borderRight: borderRight,
      borderTop: borderTop,
      borderBottom: borderBottom,
      scrollbarBottom: scrollbarBottom,
      scrollbarLeft: 0,
      scrollbarRight: 0
    };

    if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') {
      // is the scrollbar on the left side?
      res.scrollbarLeft = scrollbarLeftRight;
    } else {
      res.scrollbarRight = scrollbarLeftRight;
    }

    if (getPadding) {
      res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
      res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
      res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
      res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
    }

    return res;
  }

  function computeInnerRect(el, goWithinPadding) {
    if (goWithinPadding === void 0) {
      goWithinPadding = false;
    }

    var outerRect = computeRect(el);
    var edges = computeEdges(el, goWithinPadding);
    var res = {
      left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
      right: outerRect.right - edges.borderRight - edges.scrollbarRight,
      top: outerRect.top + edges.borderTop,
      bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
    };

    if (goWithinPadding) {
      res.left += edges.paddingLeft;
      res.right -= edges.paddingRight;
      res.top += edges.paddingTop;
      res.bottom -= edges.paddingBottom;
    }

    return res;
  }

  function computeRect(el) {
    var rect = el.getBoundingClientRect();
    return {
      left: rect.left + window.pageXOffset,
      top: rect.top + window.pageYOffset,
      right: rect.right + window.pageXOffset,
      bottom: rect.bottom + window.pageYOffset
    };
  }

  function computeViewportRect() {
    return {
      left: window.pageXOffset,
      right: window.pageXOffset + document.documentElement.clientWidth,
      top: window.pageYOffset,
      bottom: window.pageYOffset + document.documentElement.clientHeight
    };
  }

  function computeHeightAndMargins(el) {
    return el.getBoundingClientRect().height + computeVMargins(el);
  }

  function computeVMargins(el) {
    var computed = window.getComputedStyle(el);
    return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);
  } // does not return window


  function getClippingParents(el) {
    var parents = [];

    while (el instanceof HTMLElement) {
      // will stop when gets to document or null
      var computedStyle = window.getComputedStyle(el);

      if (computedStyle.position === 'fixed') {
        break;
      }

      if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
        parents.push(el);
      }

      el = el.parentNode;
    }

    return parents;
  }

  function computeClippingRect(el) {
    return getClippingParents(el).map(function (el) {
      return computeInnerRect(el);
    }).concat(computeViewportRect()).reduce(function (rect0, rect1) {
      return intersectRects(rect0, rect1) || rect1; // should always intersect
    });
  } // Stops a mouse/touch event from doing it's native browser action


  function preventDefault(ev) {
    ev.preventDefault();
  } // Event Delegation
  // ----------------------------------------------------------------------------------------------------------------


  function listenBySelector(container, eventType, selector, handler) {
    function realHandler(ev) {
      var matchedChild = elementClosest(ev.target, selector);

      if (matchedChild) {
        handler.call(matchedChild, ev, matchedChild);
      }
    }

    container.addEventListener(eventType, realHandler);
    return function () {
      container.removeEventListener(eventType, realHandler);
    };
  }

  function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
    var currentMatchedChild;
    return listenBySelector(container, 'mouseover', selector, function (ev, matchedChild) {
      if (matchedChild !== currentMatchedChild) {
        currentMatchedChild = matchedChild;
        onMouseEnter(ev, matchedChild);

        var realOnMouseLeave_1 = function realOnMouseLeave_1(ev) {
          currentMatchedChild = null;
          onMouseLeave(ev, matchedChild);
          matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);
        }; // listen to the next mouseleave, and then unattach


        matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);
      }
    });
  } // Animation
  // ----------------------------------------------------------------------------------------------------------------


  var transitionEventNames = ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend']; // triggered only when the next single subsequent transition finishes

  function whenTransitionDone(el, callback) {
    var realCallback = function realCallback(ev) {
      callback(ev);
      transitionEventNames.forEach(function (eventName) {
        el.removeEventListener(eventName, realCallback);
      });
    };

    transitionEventNames.forEach(function (eventName) {
      el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes
    });
  }

  var DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; // Adding

  function addWeeks(m, n) {
    var a = dateToUtcArray(m);
    a[2] += n * 7;
    return arrayToUtcDate(a);
  }

  function addDays(m, n) {
    var a = dateToUtcArray(m);
    a[2] += n;
    return arrayToUtcDate(a);
  }

  function addMs(m, n) {
    var a = dateToUtcArray(m);
    a[6] += n;
    return arrayToUtcDate(a);
  } // Diffing (all return floats)


  function diffWeeks(m0, m1) {
    return diffDays(m0, m1) / 7;
  }

  function diffDays(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);
  }

  function diffHours(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);
  }

  function diffMinutes(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / (1000 * 60);
  }

  function diffSeconds(m0, m1) {
    return (m1.valueOf() - m0.valueOf()) / 1000;
  }

  function diffDayAndTime(m0, m1) {
    var m0day = startOfDay(m0);
    var m1day = startOfDay(m1);
    return {
      years: 0,
      months: 0,
      days: Math.round(diffDays(m0day, m1day)),
      milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
    };
  } // Diffing Whole Units


  function diffWholeWeeks(m0, m1) {
    var d = diffWholeDays(m0, m1);

    if (d !== null && d % 7 === 0) {
      return d / 7;
    }

    return null;
  }

  function diffWholeDays(m0, m1) {
    if (timeAsMs(m0) === timeAsMs(m1)) {
      return Math.round(diffDays(m0, m1));
    }

    return null;
  } // Start-Of


  function startOfDay(m) {
    return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate()]);
  }

  function startOfHour(m) {
    return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours()]);
  }

  function startOfMinute(m) {
    return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes()]);
  }

  function startOfSecond(m) {
    return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes(), m.getUTCSeconds()]);
  } // Week Computation


  function weekOfYear(marker, dow, doy) {
    var y = marker.getUTCFullYear();
    var w = weekOfGivenYear(marker, y, dow, doy);

    if (w < 1) {
      return weekOfGivenYear(marker, y - 1, dow, doy);
    }

    var nextW = weekOfGivenYear(marker, y + 1, dow, doy);

    if (nextW >= 1) {
      return Math.min(w, nextW);
    }

    return w;
  }

  function weekOfGivenYear(marker, year, dow, doy) {
    var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
    var dayStart = startOfDay(marker);
    var days = Math.round(diffDays(firstWeekStart, dayStart));
    return Math.floor(days / 7) + 1; // zero-indexed
  } // start-of-first-week - start-of-year


  function firstWeekOffset(year, dow, doy) {
    // first-week day -- which january is always in the first week (4 for iso, 1 for other)
    var fwd = 7 + dow - doy; // first-week day local weekday -- which local weekday is fwd

    var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  } // Array Conversion


  function dateToLocalArray(date) {
    return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
  }

  function arrayToLocalDate(a) {
    return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month
    a[3] || 0, a[4] || 0, a[5] || 0);
  }

  function dateToUtcArray(date) {
    return [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];
  }

  function arrayToUtcDate(a) {
    // according to web standards (and Safari), a month index is required.
    // massage if only given a year.
    if (a.length === 1) {
      a = a.concat([0]);
    }

    return new Date(Date.UTC.apply(Date, a));
  } // Other Utils


  function isValidDate(m) {
    return !isNaN(m.valueOf());
  }

  function timeAsMs(m) {
    return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();
  }

  var INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];
  var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/; // Parsing and Creation

  function createDuration(input, unit) {
    var _a;

    if (typeof input === 'string') {
      return parseString(input);
    } else if (_typeof(input) === 'object' && input) {
      // non-null object
      return normalizeObject(input);
    } else if (typeof input === 'number') {
      return normalizeObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));
    } else {
      return null;
    }
  }

  function parseString(s) {
    var m = PARSE_RE.exec(s);

    if (m) {
      var sign = m[1] ? -1 : 1;
      return {
        years: 0,
        months: 0,
        days: sign * (m[2] ? parseInt(m[2], 10) : 0),
        milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours
        (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes
        (m[5] ? parseInt(m[5], 10) : 0) * 1000 + ( // seconds
        m[6] ? parseInt(m[6], 10) : 0) // ms
        )
      };
    }

    return null;
  }

  function normalizeObject(obj) {
    return {
      years: obj.years || obj.year || 0,
      months: obj.months || obj.month || 0,
      days: (obj.days || obj.day || 0) + getWeeksFromInput(obj) * 7,
      milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours
      (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes
      (obj.seconds || obj.second || 0) * 1000 + ( // seconds
      obj.milliseconds || obj.millisecond || obj.ms || 0) // ms

    };
  }

  function getWeeksFromInput(obj) {
    return obj.weeks || obj.week || 0;
  } // Equality


  function durationsEqual(d0, d1) {
    return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
  }

  function isSingleDay(dur) {
    return dur.years === 0 && dur.months === 0 && dur.days === 1 && dur.milliseconds === 0;
  } // Simple Math


  function addDurations(d0, d1) {
    return {
      years: d0.years + d1.years,
      months: d0.months + d1.months,
      days: d0.days + d1.days,
      milliseconds: d0.milliseconds + d1.milliseconds
    };
  }

  function subtractDurations(d1, d0) {
    return {
      years: d1.years - d0.years,
      months: d1.months - d0.months,
      days: d1.days - d0.days,
      milliseconds: d1.milliseconds - d0.milliseconds
    };
  }

  function multiplyDuration(d, n) {
    return {
      years: d.years * n,
      months: d.months * n,
      days: d.days * n,
      milliseconds: d.milliseconds * n
    };
  } // Conversions
  // "Rough" because they are based on average-case Gregorian months/years


  function asRoughYears(dur) {
    return asRoughDays(dur) / 365;
  }

  function asRoughMonths(dur) {
    return asRoughDays(dur) / 30;
  }

  function asRoughDays(dur) {
    return asRoughMs(dur) / 864e5;
  }

  function asRoughMinutes(dur) {
    return asRoughMs(dur) / (1000 * 60);
  }

  function asRoughSeconds(dur) {
    return asRoughMs(dur) / 1000;
  }

  function asRoughMs(dur) {
    return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;
  } // Advanced Math


  function wholeDivideDurations(numerator, denominator) {
    var res = null;

    for (var i = 0; i < INTERNAL_UNITS.length; i++) {
      var unit = INTERNAL_UNITS[i];

      if (denominator[unit]) {
        var localRes = numerator[unit] / denominator[unit];

        if (!isInt(localRes) || res !== null && res !== localRes) {
          return null;
        }

        res = localRes;
      } else if (numerator[unit]) {
        // needs to divide by something but can't!
        return null;
      }
    }

    return res;
  }

  function greatestDurationDenominator(dur, dontReturnWeeks) {
    var ms = dur.milliseconds;

    if (ms) {
      if (ms % 1000 !== 0) {
        return {
          unit: 'millisecond',
          value: ms
        };
      }

      if (ms % (1000 * 60) !== 0) {
        return {
          unit: 'second',
          value: ms / 1000
        };
      }

      if (ms % (1000 * 60 * 60) !== 0) {
        return {
          unit: 'minute',
          value: ms / (1000 * 60)
        };
      }

      if (ms) {
        return {
          unit: 'hour',
          value: ms / (1000 * 60 * 60)
        };
      }
    }

    if (dur.days) {
      if (!dontReturnWeeks && dur.days % 7 === 0) {
        return {
          unit: 'week',
          value: dur.days / 7
        };
      }

      return {
        unit: 'day',
        value: dur.days
      };
    }

    if (dur.months) {
      return {
        unit: 'month',
        value: dur.months
      };
    }

    if (dur.years) {
      return {
        unit: 'year',
        value: dur.years
      };
    }

    return {
      unit: 'millisecond',
      value: 0
    };
  }
  /* FullCalendar-specific DOM Utilities
  ----------------------------------------------------------------------------------------------------------------------*/
  // Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
  // and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.


  function compensateScroll(rowEl, scrollbarWidths) {
    if (scrollbarWidths.left) {
      applyStyle(rowEl, {
        borderLeftWidth: 1,
        marginLeft: scrollbarWidths.left - 1
      });
    }

    if (scrollbarWidths.right) {
      applyStyle(rowEl, {
        borderRightWidth: 1,
        marginRight: scrollbarWidths.right - 1
      });
    }
  } // Undoes compensateScroll and restores all borders/margins


  function uncompensateScroll(rowEl) {
    applyStyle(rowEl, {
      marginLeft: '',
      marginRight: '',
      borderLeftWidth: '',
      borderRightWidth: ''
    });
  } // Make the mouse cursor express that an event is not allowed in the current area


  function disableCursor() {
    document.body.classList.add('fc-not-allowed');
  } // Returns the mouse cursor to its original look


  function enableCursor() {
    document.body.classList.remove('fc-not-allowed');
  } // Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
  // By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
  // any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and
  // reduces the available height.


  function distributeHeight(els, availableHeight, shouldRedistribute) {
    // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
    // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.
    var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element

    var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*

    var flexEls = []; // elements that are allowed to expand. array of DOM nodes

    var flexOffsets = []; // amount of vertical space it takes up

    var flexHeights = []; // actual css height

    var usedHeight = 0;
    undistributeHeight(els); // give all elements their natural height
    // find elements that are below the recommended height (expandable).
    // important to query for heights in a single first pass (to avoid reflow oscillation).

    els.forEach(function (el, i) {
      var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
      var naturalHeight = el.getBoundingClientRect().height;
      var naturalOffset = naturalHeight + computeVMargins(el);

      if (naturalOffset < minOffset) {
        flexEls.push(el);
        flexOffsets.push(naturalOffset);
        flexHeights.push(naturalHeight);
      } else {
        // this element stretches past recommended height (non-expandable). mark the space as occupied.
        usedHeight += naturalOffset;
      }
    }); // readjust the recommended height to only consider the height available to non-maxed-out rows.

    if (shouldRedistribute) {
      availableHeight -= usedHeight;
      minOffset1 = Math.floor(availableHeight / flexEls.length);
      minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
    } // assign heights to all expandable elements


    flexEls.forEach(function (el, i) {
      var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
      var naturalOffset = flexOffsets[i];
      var naturalHeight = flexHeights[i];
      var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding

      if (naturalOffset < minOffset) {
        // we check this again because redistribution might have changed things
        el.style.height = newHeight + 'px';
      }
    });
  } // Undoes distrubuteHeight, restoring all els to their natural height


  function undistributeHeight(els) {
    els.forEach(function (el) {
      el.style.height = '';
    });
  } // Given `els`, a set of <td> cells, find the cell with the largest natural width and set the widths of all the
  // cells to be that width.
  // PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline


  function matchCellWidths(els) {
    var maxInnerWidth = 0;
    els.forEach(function (el) {
      var innerEl = el.firstChild; // hopefully an element

      if (innerEl instanceof HTMLElement) {
        var innerWidth_1 = innerEl.getBoundingClientRect().width;

        if (innerWidth_1 > maxInnerWidth) {
          maxInnerWidth = innerWidth_1;
        }
      }
    });
    maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance

    els.forEach(function (el) {
      el.style.width = maxInnerWidth + 'px';
    });
    return maxInnerWidth;
  } // Given one element that resides inside another,
  // Subtracts the height of the inner element from the outer element.


  function subtractInnerElHeight(outerEl, innerEl) {
    // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
    var reflowStyleProps = {
      position: 'relative',
      left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll

    };
    applyStyle(outerEl, reflowStyleProps);
    applyStyle(innerEl, reflowStyleProps);
    var diff = // grab the dimensions
    outerEl.getBoundingClientRect().height - innerEl.getBoundingClientRect().height; // undo hack

    var resetStyleProps = {
      position: '',
      left: ''
    };
    applyStyle(outerEl, resetStyleProps);
    applyStyle(innerEl, resetStyleProps);
    return diff;
  }
  /* Selection
  ----------------------------------------------------------------------------------------------------------------------*/


  function preventSelection(el) {
    el.classList.add('fc-unselectable');
    el.addEventListener('selectstart', preventDefault);
  }

  function allowSelection(el) {
    el.classList.remove('fc-unselectable');
    el.removeEventListener('selectstart', preventDefault);
  }
  /* Context Menu
  ----------------------------------------------------------------------------------------------------------------------*/


  function preventContextMenu(el) {
    el.addEventListener('contextmenu', preventDefault);
  }

  function allowContextMenu(el) {
    el.removeEventListener('contextmenu', preventDefault);
  }
  /* Object Ordering by Field
  ----------------------------------------------------------------------------------------------------------------------*/


  function parseFieldSpecs(input) {
    var specs = [];
    var tokens = [];
    var i;
    var token;

    if (typeof input === 'string') {
      tokens = input.split(/\s*,\s*/);
    } else if (typeof input === 'function') {
      tokens = [input];
    } else if (Array.isArray(input)) {
      tokens = input;
    }

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];

      if (typeof token === 'string') {
        specs.push(token.charAt(0) === '-' ? {
          field: token.substring(1),
          order: -1
        } : {
          field: token,
          order: 1
        });
      } else if (typeof token === 'function') {
        specs.push({
          func: token
        });
      }
    }

    return specs;
  }

  function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
    var i;
    var cmp;

    for (i = 0; i < fieldSpecs.length; i++) {
      cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);

      if (cmp) {
        return cmp;
      }
    }

    return 0;
  }

  function compareByFieldSpec(obj0, obj1, fieldSpec) {
    if (fieldSpec.func) {
      return fieldSpec.func(obj0, obj1);
    }

    return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
  }

  function flexibleCompare(a, b) {
    if (!a && !b) {
      return 0;
    }

    if (b == null) {
      return -1;
    }

    if (a == null) {
      return 1;
    }

    if (typeof a === 'string' || typeof b === 'string') {
      return String(a).localeCompare(String(b));
    }

    return a - b;
  }
  /* String Utilities
  ----------------------------------------------------------------------------------------------------------------------*/


  function capitaliseFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  function padStart(val, len) {
    var s = String(val);
    return '000'.substr(0, len - s.length) + s;
  }
  /* Number Utilities
  ----------------------------------------------------------------------------------------------------------------------*/


  function compareNumbers(a, b) {
    return a - b;
  }

  function isInt(n) {
    return n % 1 === 0;
  }
  /* Weird Utilities
  ----------------------------------------------------------------------------------------------------------------------*/


  function applyAll(functions, thisObj, args) {
    if (typeof functions === 'function') {
      // supplied a single function
      functions = [functions];
    }

    if (functions) {
      var i = void 0;
      var ret = void 0;

      for (i = 0; i < functions.length; i++) {
        ret = functions[i].apply(thisObj, args) || ret;
      }

      return ret;
    }
  }

  function firstDefined() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    for (var i = 0; i < args.length; i++) {
      if (args[i] !== undefined) {
        return args[i];
      }
    }
  } // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  // https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714


  function debounce(func, wait) {
    var timeout;
    var args;
    var context;
    var timestamp;
    var result;

    var later = function later() {
      var last = new Date().valueOf() - timestamp;

      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        result = func.apply(context, args);
        context = args = null;
      }
    };

    return function () {
      context = this;
      args = arguments;
      timestamp = new Date().valueOf();

      if (!timeout) {
        timeout = setTimeout(later, wait);
      }

      return result;
    };
  } // Number and Boolean are only types that defaults or not computed for
  // TODO: write more comments


  function refineProps(rawProps, processors, defaults, leftoverProps) {
    if (defaults === void 0) {
      defaults = {};
    }

    var refined = {};

    for (var key in processors) {
      var processor = processors[key];

      if (rawProps[key] !== undefined) {
        // found
        if (processor === Function) {
          refined[key] = typeof rawProps[key] === 'function' ? rawProps[key] : null;
        } else if (processor) {
          // a refining function?
          refined[key] = processor(rawProps[key]);
        } else {
          refined[key] = rawProps[key];
        }
      } else if (defaults[key] !== undefined) {
        // there's an explicit default
        refined[key] = defaults[key];
      } else {
        // must compute a default
        if (processor === String) {
          refined[key] = ''; // empty string is default for String
        } else if (!processor || processor === Number || processor === Boolean || processor === Function) {
          refined[key] = null; // assign null for other non-custom processor funcs
        } else {
          refined[key] = processor(null); // run the custom processor func
        }
      }
    }

    if (leftoverProps) {
      for (var key in rawProps) {
        if (processors[key] === undefined) {
          leftoverProps[key] = rawProps[key];
        }
      }
    }

    return refined;
  }
  /* Date stuff that doesn't belong in datelib core
  ----------------------------------------------------------------------------------------------------------------------*/
  // given a timed range, computes an all-day range that has the same exact duration,
  // but whose start time is aligned with the start of the day.


  function computeAlignedDayRange(timedRange) {
    var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
    var start = startOfDay(timedRange.start);
    var end = addDays(start, dayCnt);
    return {
      start: start,
      end: end
    };
  } // given a timed range, computes an all-day range based on how for the end date bleeds into the next day
  // TODO: give nextDayThreshold a default arg


  function computeVisibleDayRange(timedRange, nextDayThreshold) {
    if (nextDayThreshold === void 0) {
      nextDayThreshold = createDuration(0);
    }

    var startDay = null;
    var endDay = null;

    if (timedRange.end) {
      endDay = startOfDay(timedRange.end);
      var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`
      // If the end time is actually inclusively part of the next day and is equal to or
      // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
      // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.

      if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
        endDay = addDays(endDay, 1);
      }
    }

    if (timedRange.start) {
      startDay = startOfDay(timedRange.start); // the beginning of the day the range starts
      // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.

      if (endDay && endDay <= startDay) {
        endDay = addDays(startDay, 1);
      }
    }

    return {
      start: startDay,
      end: endDay
    };
  } // spans from one day into another?


  function isMultiDayRange(range) {
    var visibleRange = computeVisibleDayRange(range);
    return diffDays(visibleRange.start, visibleRange.end) > 1;
  }

  function diffDates(date0, date1, dateEnv, largeUnit) {
    if (largeUnit === 'year') {
      return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');
    } else if (largeUnit === 'month') {
      return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');
    } else {
      return diffDayAndTime(date0, date1); // returns a duration
    }
  }
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
    See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */


  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };

  function parseRecurring(eventInput, allDayDefault, dateEnv, recurringTypes, leftovers) {
    for (var i = 0; i < recurringTypes.length; i++) {
      var localLeftovers = {};
      var parsed = recurringTypes[i].parse(eventInput, localLeftovers, dateEnv);

      if (parsed) {
        var allDay = localLeftovers.allDay;
        delete localLeftovers.allDay; // remove from leftovers

        if (allDay == null) {
          allDay = allDayDefault;

          if (allDay == null) {
            allDay = parsed.allDayGuess;

            if (allDay == null) {
              allDay = false;
            }
          }
        }

        _assign(leftovers, localLeftovers);

        return {
          allDay: allDay,
          duration: parsed.duration,
          typeData: parsed.typeData,
          typeId: i
        };
      }
    }

    return null;
  }
  /*
  Event MUST have a recurringDef
  */


  function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
    var typeDef = recurringTypes[eventDef.recurringDef.typeId];
    var markers = typeDef.expand(eventDef.recurringDef.typeData, {
      start: dateEnv.subtract(framingRange.start, duration),
      end: framingRange.end
    }, dateEnv); // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to

    if (eventDef.allDay) {
      markers = markers.map(startOfDay);
    }

    return markers;
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty; // Merges an array of objects into a single object.
  // The second argument allows for an array of property names who's object values will be merged together.

  function mergeProps(propObjs, complexProps) {
    var dest = {};
    var i;
    var name;
    var complexObjs;
    var j;
    var val;
    var props;

    if (complexProps) {
      for (i = 0; i < complexProps.length; i++) {
        name = complexProps[i];
        complexObjs = []; // collect the trailing object values, stopping when a non-object is discovered

        for (j = propObjs.length - 1; j >= 0; j--) {
          val = propObjs[j][name];

          if (_typeof(val) === 'object' && val) {
            // non-null object
            complexObjs.unshift(val);
          } else if (val !== undefined) {
            dest[name] = val; // if there were no objects, this value will be used

            break;
          }
        } // if the trailing values were objects, use the merged value


        if (complexObjs.length) {
          dest[name] = mergeProps(complexObjs);
        }
      }
    } // copy values into the destination, going from last to first


    for (i = propObjs.length - 1; i >= 0; i--) {
      props = propObjs[i];

      for (name in props) {
        if (!(name in dest)) {
          // if already assigned by previous props or complex props, don't reassign
          dest[name] = props[name];
        }
      }
    }

    return dest;
  }

  function filterHash(hash, func) {
    var filtered = {};

    for (var key in hash) {
      if (func(hash[key], key)) {
        filtered[key] = hash[key];
      }
    }

    return filtered;
  }

  function mapHash(hash, func) {
    var newHash = {};

    for (var key in hash) {
      newHash[key] = func(hash[key], key);
    }

    return newHash;
  }

  function arrayToHash(a) {
    var hash = {};

    for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
      var item = a_1[_i];
      hash[item] = true;
    }

    return hash;
  }

  function hashValuesToArray(obj) {
    var a = [];

    for (var key in obj) {
      a.push(obj[key]);
    }

    return a;
  }

  function isPropsEqual(obj0, obj1) {
    for (var key in obj0) {
      if (hasOwnProperty.call(obj0, key)) {
        if (!(key in obj1)) {
          return false;
        }
      }
    }

    for (var key in obj1) {
      if (hasOwnProperty.call(obj1, key)) {
        if (obj0[key] !== obj1[key]) {
          return false;
        }
      }
    }

    return true;
  }

  function parseEvents(rawEvents, sourceId, calendar, allowOpenRange) {
    var eventStore = createEmptyEventStore();

    for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {
      var rawEvent = rawEvents_1[_i];
      var tuple = parseEvent(rawEvent, sourceId, calendar, allowOpenRange);

      if (tuple) {
        eventTupleToStore(tuple, eventStore);
      }
    }

    return eventStore;
  }

  function eventTupleToStore(tuple, eventStore) {
    if (eventStore === void 0) {
      eventStore = createEmptyEventStore();
    }

    eventStore.defs[tuple.def.defId] = tuple.def;

    if (tuple.instance) {
      eventStore.instances[tuple.instance.instanceId] = tuple.instance;
    }

    return eventStore;
  }

  function expandRecurring(eventStore, framingRange, calendar) {
    var dateEnv = calendar.dateEnv;
    var defs = eventStore.defs,
        instances = eventStore.instances; // remove existing recurring instances

    instances = filterHash(instances, function (instance) {
      return !defs[instance.defId].recurringDef;
    });

    for (var defId in defs) {
      var def = defs[defId];

      if (def.recurringDef) {
        var duration = def.recurringDef.duration;

        if (!duration) {
          duration = def.allDay ? calendar.defaultAllDayEventDuration : calendar.defaultTimedEventDuration;
        }

        var starts = expandRecurringRanges(def, duration, framingRange, calendar.dateEnv, calendar.pluginSystem.hooks.recurringTypes);

        for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {
          var start = starts_1[_i];
          var instance = createEventInstance(defId, {
            start: start,
            end: dateEnv.add(start, duration)
          });
          instances[instance.instanceId] = instance;
        }
      }
    }

    return {
      defs: defs,
      instances: instances
    };
  } // retrieves events that have the same groupId as the instance specified by `instanceId`
  // or they are the same as the instance.
  // why might instanceId not be in the store? an event from another calendar?


  function getRelevantEvents(eventStore, instanceId) {
    var instance = eventStore.instances[instanceId];

    if (instance) {
      var def_1 = eventStore.defs[instance.defId]; // get events/instances with same group

      var newStore = filterEventStoreDefs(eventStore, function (lookDef) {
        return isEventDefsGrouped(def_1, lookDef);
      }); // add the original
      // TODO: wish we could use eventTupleToStore or something like it

      newStore.defs[def_1.defId] = def_1;
      newStore.instances[instance.instanceId] = instance;
      return newStore;
    }

    return createEmptyEventStore();
  }

  function isEventDefsGrouped(def0, def1) {
    return Boolean(def0.groupId && def0.groupId === def1.groupId);
  }

  function transformRawEvents(rawEvents, eventSource, calendar) {
    var calEachTransform = calendar.opt('eventDataTransform');
    var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;

    if (sourceEachTransform) {
      rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
    }

    if (calEachTransform) {
      rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
    }

    return rawEvents;
  }

  function transformEachRawEvent(rawEvents, func) {
    var refinedEvents;

    if (!func) {
      refinedEvents = rawEvents;
    } else {
      refinedEvents = [];

      for (var _i = 0, rawEvents_2 = rawEvents; _i < rawEvents_2.length; _i++) {
        var rawEvent = rawEvents_2[_i];
        var refinedEvent = func(rawEvent);

        if (refinedEvent) {
          refinedEvents.push(refinedEvent);
        } else if (refinedEvent == null) {
          refinedEvents.push(rawEvent);
        } // if a different falsy value, do nothing

      }
    }

    return refinedEvents;
  }

  function createEmptyEventStore() {
    return {
      defs: {},
      instances: {}
    };
  }

  function mergeEventStores(store0, store1) {
    return {
      defs: _assign({}, store0.defs, store1.defs),
      instances: _assign({}, store0.instances, store1.instances)
    };
  }

  function filterEventStoreDefs(eventStore, filterFunc) {
    var defs = filterHash(eventStore.defs, filterFunc);
    var instances = filterHash(eventStore.instances, function (instance) {
      return defs[instance.defId]; // still exists?
    });
    return {
      defs: defs,
      instances: instances
    };
  }

  function parseRange(input, dateEnv) {
    var start = null;
    var end = null;

    if (input.start) {
      start = dateEnv.createMarker(input.start);
    }

    if (input.end) {
      end = dateEnv.createMarker(input.end);
    }

    if (!start && !end) {
      return null;
    }

    if (start && end && end < start) {
      return null;
    }

    return {
      start: start,
      end: end
    };
  } // SIDE-EFFECT: will mutate ranges.
  // Will return a new array result.


  function invertRanges(ranges, constraintRange) {
    var invertedRanges = [];
    var start = constraintRange.start; // the end of the previous range. the start of the new range

    var i;
    var dateRange; // ranges need to be in order. required for our date-walking algorithm

    ranges.sort(compareRanges);

    for (i = 0; i < ranges.length; i++) {
      dateRange = ranges[i]; // add the span of time before the event (if there is any)

      if (dateRange.start > start) {
        // compare millisecond time (skip any ambig logic)
        invertedRanges.push({
          start: start,
          end: dateRange.start
        });
      }

      if (dateRange.end > start) {
        start = dateRange.end;
      }
    } // add the span of time after the last event (if there is any)


    if (start < constraintRange.end) {
      // compare millisecond time (skip any ambig logic)
      invertedRanges.push({
        start: start,
        end: constraintRange.end
      });
    }

    return invertedRanges;
  }

  function compareRanges(range0, range1) {
    return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first
  }

  function intersectRanges(range0, range1) {
    var start = range0.start;
    var end = range0.end;
    var newRange = null;

    if (range1.start !== null) {
      if (start === null) {
        start = range1.start;
      } else {
        start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
      }
    }

    if (range1.end != null) {
      if (end === null) {
        end = range1.end;
      } else {
        end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
      }
    }

    if (start === null || end === null || start < end) {
      newRange = {
        start: start,
        end: end
      };
    }

    return newRange;
  }

  function rangesEqual(range0, range1) {
    return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
  }

  function rangesIntersect(range0, range1) {
    return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
  }

  function rangeContainsRange(outerRange, innerRange) {
    return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
  }

  function rangeContainsMarker(range, date) {
    return (range.start === null || date >= range.start) && (range.end === null || date < range.end);
  } // If the given date is not within the given range, move it inside.
  // (If it's past the end, make it one millisecond before the end).


  function constrainMarkerToRange(date, range) {
    if (range.start != null && date < range.start) {
      return range.start;
    }

    if (range.end != null && date >= range.end) {
      return new Date(range.end.valueOf() - 1);
    }

    return date;
  }

  function removeExact(array, exactVal) {
    var removeCnt = 0;
    var i = 0;

    while (i < array.length) {
      if (array[i] === exactVal) {
        array.splice(i, 1);
        removeCnt++;
      } else {
        i++;
      }
    }

    return removeCnt;
  }

  function isArraysEqual(a0, a1) {
    var len = a0.length;
    var i;

    if (len !== a1.length) {
      // not array? or not same length?
      return false;
    }

    for (i = 0; i < len; i++) {
      if (a0[i] !== a1[i]) {
        return false;
      }
    }

    return true;
  }

  function memoize(workerFunc) {
    var args;
    var res;
    return function () {
      if (!args || !isArraysEqual(args, arguments)) {
        args = arguments;
        res = workerFunc.apply(this, arguments);
      }

      return res;
    };
  }
  /*
  always executes the workerFunc, but if the result is equal to the previous result,
  return the previous result instead.
  */


  function memoizeOutput(workerFunc, equalityFunc) {
    var cachedRes = null;
    return function () {
      var newRes = workerFunc.apply(this, arguments);

      if (cachedRes === null || !(cachedRes === newRes || equalityFunc(cachedRes, newRes))) {
        cachedRes = newRes;
      }

      return cachedRes;
    };
  }

  var EXTENDED_SETTINGS_AND_SEVERITIES = {
    week: 3,
    separator: 0,
    omitZeroMinute: 0,
    meridiem: 0,
    omitCommas: 0
  };
  var STANDARD_DATE_PROP_SEVERITIES = {
    timeZoneName: 7,
    era: 6,
    year: 5,
    month: 4,
    day: 2,
    weekday: 2,
    hour: 1,
    minute: 1,
    second: 1
  };
  var MERIDIEM_RE = /\s*([ap])\.?m\.?/i; // eats up leading spaces too

  var COMMA_RE = /,/g; // we need re for globalness

  var MULTI_SPACE_RE = /\s+/g;
  var LTR_RE = /\u200e/g; // control character

  var UTC_RE = /UTC|GMT/;

  var NativeFormatter =
  /** @class */
  function () {
    function NativeFormatter(formatSettings) {
      var standardDateProps = {};
      var extendedSettings = {};
      var severity = 0;

      for (var name_1 in formatSettings) {
        if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {
          extendedSettings[name_1] = formatSettings[name_1];
          severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);
        } else {
          standardDateProps[name_1] = formatSettings[name_1];

          if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {
            severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);
          }
        }
      }

      this.standardDateProps = standardDateProps;
      this.extendedSettings = extendedSettings;
      this.severity = severity;
      this.buildFormattingFunc = memoize(buildFormattingFunc);
    }

    NativeFormatter.prototype.format = function (date, context) {
      return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
    };

    NativeFormatter.prototype.formatRange = function (start, end, context) {
      var _a = this,
          standardDateProps = _a.standardDateProps,
          extendedSettings = _a.extendedSettings;

      var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);

      if (!diffSeverity) {
        return this.format(start, context);
      }

      var biggestUnitForPartial = diffSeverity;

      if (biggestUnitForPartial > 1 && ( // the two dates are different in a way that's larger scale than time
      standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {
        biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time
      }

      var full0 = this.format(start, context);
      var full1 = this.format(end, context);

      if (full0 === full1) {
        return full0;
      }

      var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
      var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
      var partial0 = partialFormattingFunc(start);
      var partial1 = partialFormattingFunc(end);
      var insertion = findCommonInsertion(full0, partial0, full1, partial1);
      var separator = extendedSettings.separator || '';

      if (insertion) {
        return insertion.before + partial0 + separator + partial1 + insertion.after;
      }

      return full0 + separator + full1;
    };

    NativeFormatter.prototype.getLargestUnit = function () {
      switch (this.severity) {
        case 7:
        case 6:
        case 5:
          return 'year';

        case 4:
          return 'month';

        case 3:
          return 'week';

        default:
          return 'day';
      }
    };

    return NativeFormatter;
  }();

  function buildFormattingFunc(standardDateProps, extendedSettings, context) {
    var standardDatePropCnt = Object.keys(standardDateProps).length;

    if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {
      return function (date) {
        return formatTimeZoneOffset(date.timeZoneOffset);
      };
    }

    if (standardDatePropCnt === 0 && extendedSettings.week) {
      return function (date) {
        return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekLabel, context.locale, extendedSettings.week);
      };
    }

    return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
  }

  function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
    standardDateProps = _assign({}, standardDateProps); // copy

    extendedSettings = _assign({}, extendedSettings); // copy

    sanitizeSettings(standardDateProps, extendedSettings);
    standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers

    var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
    var zeroFormat; // needed?

    if (extendedSettings.omitZeroMinute) {
      var zeroProps = _assign({}, standardDateProps);

      delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings

      zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
    }

    return function (date) {
      var marker = date.marker;
      var format;

      if (zeroFormat && !marker.getUTCMinutes()) {
        format = zeroFormat;
      } else {
        format = normalFormat;
      }

      var s = format.format(marker);
      return postProcess(s, date, standardDateProps, extendedSettings, context);
    };
  }

  function sanitizeSettings(standardDateProps, extendedSettings) {
    // deal with a browser inconsistency where formatting the timezone
    // requires that the hour/minute be present.
    if (standardDateProps.timeZoneName) {
      if (!standardDateProps.hour) {
        standardDateProps.hour = '2-digit';
      }

      if (!standardDateProps.minute) {
        standardDateProps.minute = '2-digit';
      }
    } // only support short timezone names


    if (standardDateProps.timeZoneName === 'long') {
      standardDateProps.timeZoneName = 'short';
    } // if requesting to display seconds, MUST display minutes


    if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
      delete extendedSettings.omitZeroMinute;
    }
  }

  function postProcess(s, date, standardDateProps, extendedSettings, context) {
    s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes

    if (standardDateProps.timeZoneName === 'short') {
      s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : // important to normalize for IE, which does "GMT"
      formatTimeZoneOffset(date.timeZoneOffset));
    }

    if (extendedSettings.omitCommas) {
      s = s.replace(COMMA_RE, '').trim();
    }

    if (extendedSettings.omitZeroMinute) {
      s = s.replace(':00', ''); // zeroFormat doesn't always achieve this
    } // ^ do anything that might create adjacent spaces before this point,
    // because MERIDIEM_RE likes to eat up loading spaces


    if (extendedSettings.meridiem === false) {
      s = s.replace(MERIDIEM_RE, '').trim();
    } else if (extendedSettings.meridiem === 'narrow') {
      // a/p
      s = s.replace(MERIDIEM_RE, function (m0, m1) {
        return m1.toLocaleLowerCase();
      });
    } else if (extendedSettings.meridiem === 'short') {
      // am/pm
      s = s.replace(MERIDIEM_RE, function (m0, m1) {
        return m1.toLocaleLowerCase() + 'm';
      });
    } else if (extendedSettings.meridiem === 'lowercase') {
      // other meridiem transformers already converted to lowercase
      s = s.replace(MERIDIEM_RE, function (m0) {
        return m0.toLocaleLowerCase();
      });
    }

    s = s.replace(MULTI_SPACE_RE, ' ');
    s = s.trim();
    return s;
  }

  function injectTzoStr(s, tzoStr) {
    var replaced = false;
    s = s.replace(UTC_RE, function () {
      replaced = true;
      return tzoStr;
    }); // IE11 doesn't include UTC/GMT in the original string, so append to end

    if (!replaced) {
      s += ' ' + tzoStr;
    }

    return s;
  }

  function formatWeekNumber(num, weekLabel, locale, display) {
    var parts = [];

    if (display === 'narrow') {
      parts.push(weekLabel);
    } else if (display === 'short') {
      parts.push(weekLabel, ' ');
    } // otherwise, considered 'numeric'


    parts.push(locale.simpleNumberFormat.format(num));

    if (locale.options.isRtl) {
      // TODO: use control characters instead?
      parts.reverse();
    }

    return parts.join('');
  } // Range Formatting Utils
  // 0 = exactly the same
  // 1 = different by time
  // and bigger


  function computeMarkerDiffSeverity(d0, d1, ca) {
    if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
      return 5;
    }

    if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
      return 4;
    }

    if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
      return 2;
    }

    if (timeAsMs(d0) !== timeAsMs(d1)) {
      return 1;
    }

    return 0;
  }

  function computePartialFormattingOptions(options, biggestUnit) {
    var partialOptions = {};

    for (var name_2 in options) {
      if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
      STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {
        partialOptions[name_2] = options[name_2];
      }
    }

    return partialOptions;
  }

  function findCommonInsertion(full0, partial0, full1, partial1) {
    var i0 = 0;

    while (i0 < full0.length) {
      var found0 = full0.indexOf(partial0, i0);

      if (found0 === -1) {
        break;
      }

      var before0 = full0.substr(0, found0);
      i0 = found0 + partial0.length;
      var after0 = full0.substr(i0);
      var i1 = 0;

      while (i1 < full1.length) {
        var found1 = full1.indexOf(partial1, i1);

        if (found1 === -1) {
          break;
        }

        var before1 = full1.substr(0, found1);
        i1 = found1 + partial1.length;
        var after1 = full1.substr(i1);

        if (before0 === before1 && after0 === after1) {
          return {
            before: before0,
            after: after0
          };
        }
      }
    }

    return null;
  }
  /*
  TODO: fix the terminology of "formatter" vs "formatting func"
  */

  /*
  At the time of instantiation, this object does not know which cmd-formatting system it will use.
  It receives this at the time of formatting, as a setting.
  */


  var CmdFormatter =
  /** @class */
  function () {
    function CmdFormatter(cmdStr, separator) {
      this.cmdStr = cmdStr;
      this.separator = separator;
    }

    CmdFormatter.prototype.format = function (date, context) {
      return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, this.separator));
    };

    CmdFormatter.prototype.formatRange = function (start, end, context) {
      return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, this.separator));
    };

    return CmdFormatter;
  }();

  var FuncFormatter =
  /** @class */
  function () {
    function FuncFormatter(func) {
      this.func = func;
    }

    FuncFormatter.prototype.format = function (date, context) {
      return this.func(createVerboseFormattingArg(date, null, context));
    };

    FuncFormatter.prototype.formatRange = function (start, end, context) {
      return this.func(createVerboseFormattingArg(start, end, context));
    };

    return FuncFormatter;
  }(); // Formatter Object Creation


  function createFormatter(input, defaultSeparator) {
    if (_typeof(input) === 'object' && input) {
      // non-null object
      if (typeof defaultSeparator === 'string') {
        input = _assign({
          separator: defaultSeparator
        }, input);
      }

      return new NativeFormatter(input);
    } else if (typeof input === 'string') {
      return new CmdFormatter(input, defaultSeparator);
    } else if (typeof input === 'function') {
      return new FuncFormatter(input);
    }
  } // String Utils
  // timeZoneOffset is in minutes


  function buildIsoString(marker, timeZoneOffset, stripZeroTime) {
    if (stripZeroTime === void 0) {
      stripZeroTime = false;
    }

    var s = marker.toISOString();
    s = s.replace('.000', '');

    if (stripZeroTime) {
      s = s.replace('T00:00:00Z', '');
    }

    if (s.length > 10) {
      // time part wasn't stripped, can add timezone info
      if (timeZoneOffset == null) {
        s = s.replace('Z', '');
      } else if (timeZoneOffset !== 0) {
        s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));
      } // otherwise, its UTC-0 and we want to keep the Z

    }

    return s;
  }

  function formatIsoTimeString(marker) {
    return padStart(marker.getUTCHours(), 2) + ':' + padStart(marker.getUTCMinutes(), 2) + ':' + padStart(marker.getUTCSeconds(), 2);
  }

  function formatTimeZoneOffset(minutes, doIso) {
    if (doIso === void 0) {
      doIso = false;
    }

    var sign = minutes < 0 ? '-' : '+';
    var abs = Math.abs(minutes);
    var hours = Math.floor(abs / 60);
    var mins = Math.round(abs % 60);

    if (doIso) {
      return sign + padStart(hours, 2) + ':' + padStart(mins, 2);
    } else {
      return 'GMT' + sign + hours + (mins ? ':' + padStart(mins, 2) : '');
    }
  } // Arg Utils


  function createVerboseFormattingArg(start, end, context, separator) {
    var startInfo = expandZonedMarker(start, context.calendarSystem);
    var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
    return {
      date: startInfo,
      start: startInfo,
      end: endInfo,
      timeZone: context.timeZone,
      localeCodes: context.locale.codes,
      separator: separator
    };
  }

  function expandZonedMarker(dateInfo, calendarSystem) {
    var a = calendarSystem.markerToArray(dateInfo.marker);
    return {
      marker: dateInfo.marker,
      timeZoneOffset: dateInfo.timeZoneOffset,
      array: a,
      year: a[0],
      month: a[1],
      day: a[2],
      hour: a[3],
      minute: a[4],
      second: a[5],
      millisecond: a[6]
    };
  }

  var EventSourceApi =
  /** @class */
  function () {
    function EventSourceApi(calendar, internalEventSource) {
      this.calendar = calendar;
      this.internalEventSource = internalEventSource;
    }

    EventSourceApi.prototype.remove = function () {
      this.calendar.dispatch({
        type: 'REMOVE_EVENT_SOURCE',
        sourceId: this.internalEventSource.sourceId
      });
    };

    EventSourceApi.prototype.refetch = function () {
      this.calendar.dispatch({
        type: 'FETCH_EVENT_SOURCES',
        sourceIds: [this.internalEventSource.sourceId]
      });
    };

    Object.defineProperty(EventSourceApi.prototype, "id", {
      get: function get() {
        return this.internalEventSource.publicId;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventSourceApi.prototype, "url", {
      // only relevant to json-feed event sources
      get: function get() {
        return this.internalEventSource.meta.url;
      },
      enumerable: true,
      configurable: true
    });
    return EventSourceApi;
  }();

  var EventApi =
  /** @class */
  function () {
    function EventApi(calendar, def, instance) {
      this._calendar = calendar;
      this._def = def;
      this._instance = instance || null;
    }
    /*
    TODO: make event struct more responsible for this
    */


    EventApi.prototype.setProp = function (name, val) {
      var _a, _b;

      if (name in DATE_PROPS) ;else if (name in NON_DATE_PROPS) {
        if (typeof NON_DATE_PROPS[name] === 'function') {
          val = NON_DATE_PROPS[name](val);
        }

        this.mutate({
          standardProps: (_a = {}, _a[name] = val, _a)
        });
      } else if (name in UNSCOPED_EVENT_UI_PROPS) {
        var ui = void 0;

        if (typeof UNSCOPED_EVENT_UI_PROPS[name] === 'function') {
          val = UNSCOPED_EVENT_UI_PROPS[name](val);
        }

        if (name === 'color') {
          ui = {
            backgroundColor: val,
            borderColor: val
          };
        } else if (name === 'editable') {
          ui = {
            startEditable: val,
            durationEditable: val
          };
        } else {
          ui = (_b = {}, _b[name] = val, _b);
        }

        this.mutate({
          standardProps: {
            ui: ui
          }
        });
      }
    };

    EventApi.prototype.setExtendedProp = function (name, val) {
      var _a;

      this.mutate({
        extendedProps: (_a = {}, _a[name] = val, _a)
      });
    };

    EventApi.prototype.setStart = function (startInput, options) {
      if (options === void 0) {
        options = {};
      }

      var dateEnv = this._calendar.dateEnv;
      var start = dateEnv.createMarker(startInput);

      if (start && this._instance) {
        // TODO: warning if parsed bad
        var instanceRange = this._instance.range;
        var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?

        if (options.maintainDuration) {
          this.mutate({
            datesDelta: startDelta
          });
        } else {
          this.mutate({
            startDelta: startDelta
          });
        }
      }
    };

    EventApi.prototype.setEnd = function (endInput, options) {
      if (options === void 0) {
        options = {};
      }

      var dateEnv = this._calendar.dateEnv;
      var end;

      if (endInput != null) {
        end = dateEnv.createMarker(endInput);

        if (!end) {
          return; // TODO: warning if parsed bad
        }
      }

      if (this._instance) {
        if (end) {
          var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
          this.mutate({
            endDelta: endDelta
          });
        } else {
          this.mutate({
            standardProps: {
              hasEnd: false
            }
          });
        }
      }
    };

    EventApi.prototype.setDates = function (startInput, endInput, options) {
      if (options === void 0) {
        options = {};
      }

      var dateEnv = this._calendar.dateEnv;
      var standardProps = {
        allDay: options.allDay
      };
      var start = dateEnv.createMarker(startInput);
      var end;

      if (!start) {
        return; // TODO: warning if parsed bad
      }

      if (endInput != null) {
        end = dateEnv.createMarker(endInput);

        if (!end) {
          // TODO: warning if parsed bad
          return;
        }
      }

      if (this._instance) {
        var instanceRange = this._instance.range; // when computing the diff for an event being converted to all-day,
        // compute diff off of the all-day values the way event-mutation does.

        if (options.allDay === true) {
          instanceRange = computeAlignedDayRange(instanceRange);
        }

        var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);

        if (end) {
          var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);

          if (durationsEqual(startDelta, endDelta)) {
            this.mutate({
              datesDelta: startDelta,
              standardProps: standardProps
            });
          } else {
            this.mutate({
              startDelta: startDelta,
              endDelta: endDelta,
              standardProps: standardProps
            });
          }
        } else {
          // means "clear the end"
          standardProps.hasEnd = false;
          this.mutate({
            datesDelta: startDelta,
            standardProps: standardProps
          });
        }
      }
    };

    EventApi.prototype.moveStart = function (deltaInput) {
      var delta = createDuration(deltaInput);

      if (delta) {
        // TODO: warning if parsed bad
        this.mutate({
          startDelta: delta
        });
      }
    };

    EventApi.prototype.moveEnd = function (deltaInput) {
      var delta = createDuration(deltaInput);

      if (delta) {
        // TODO: warning if parsed bad
        this.mutate({
          endDelta: delta
        });
      }
    };

    EventApi.prototype.moveDates = function (deltaInput) {
      var delta = createDuration(deltaInput);

      if (delta) {
        // TODO: warning if parsed bad
        this.mutate({
          datesDelta: delta
        });
      }
    };

    EventApi.prototype.setAllDay = function (allDay, options) {
      if (options === void 0) {
        options = {};
      }

      var standardProps = {
        allDay: allDay
      };
      var maintainDuration = options.maintainDuration;

      if (maintainDuration == null) {
        maintainDuration = this._calendar.opt('allDayMaintainDuration');
      }

      if (this._def.allDay !== allDay) {
        standardProps.hasEnd = maintainDuration;
      }

      this.mutate({
        standardProps: standardProps
      });
    };

    EventApi.prototype.formatRange = function (formatInput) {
      var dateEnv = this._calendar.dateEnv;
      var instance = this._instance;
      var formatter = createFormatter(formatInput, this._calendar.opt('defaultRangeSeparator'));

      if (this._def.hasEnd) {
        return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
          forcedStartTzo: instance.forcedStartTzo,
          forcedEndTzo: instance.forcedEndTzo
        });
      } else {
        return dateEnv.format(instance.range.start, formatter, {
          forcedTzo: instance.forcedStartTzo
        });
      }
    };

    EventApi.prototype.mutate = function (mutation) {
      var def = this._def;
      var instance = this._instance;

      if (instance) {
        this._calendar.dispatch({
          type: 'MUTATE_EVENTS',
          instanceId: instance.instanceId,
          mutation: mutation,
          fromApi: true
        });

        var eventStore = this._calendar.state.eventStore;
        this._def = eventStore.defs[def.defId];
        this._instance = eventStore.instances[instance.instanceId];
      }
    };

    EventApi.prototype.remove = function () {
      this._calendar.dispatch({
        type: 'REMOVE_EVENT_DEF',
        defId: this._def.defId
      });
    };

    Object.defineProperty(EventApi.prototype, "source", {
      get: function get() {
        var sourceId = this._def.sourceId;

        if (sourceId) {
          return new EventSourceApi(this._calendar, this._calendar.state.eventSources[sourceId]);
        }

        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "start", {
      get: function get() {
        return this._instance ? this._calendar.dateEnv.toDate(this._instance.range.start) : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "end", {
      get: function get() {
        return this._instance && this._def.hasEnd ? this._calendar.dateEnv.toDate(this._instance.range.end) : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "id", {
      // computable props that all access the def
      // TODO: find a TypeScript-compatible way to do this at scale
      get: function get() {
        return this._def.publicId;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "groupId", {
      get: function get() {
        return this._def.groupId;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "allDay", {
      get: function get() {
        return this._def.allDay;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "title", {
      get: function get() {
        return this._def.title;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "url", {
      get: function get() {
        return this._def.url;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "rendering", {
      get: function get() {
        return this._def.rendering;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "startEditable", {
      get: function get() {
        return this._def.ui.startEditable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "durationEditable", {
      get: function get() {
        return this._def.ui.durationEditable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "constraint", {
      get: function get() {
        return this._def.ui.constraints[0] || null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "overlap", {
      get: function get() {
        return this._def.ui.overlap;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "allow", {
      get: function get() {
        return this._def.ui.allows[0] || null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "backgroundColor", {
      get: function get() {
        return this._def.ui.backgroundColor;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "borderColor", {
      get: function get() {
        return this._def.ui.borderColor;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "textColor", {
      get: function get() {
        return this._def.ui.textColor;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "classNames", {
      // NOTE: user can't modify these because Object.freeze was called in event-def parsing
      get: function get() {
        return this._def.ui.classNames;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EventApi.prototype, "extendedProps", {
      get: function get() {
        return this._def.extendedProps;
      },
      enumerable: true,
      configurable: true
    });
    return EventApi;
  }();
  /*
  Specifying nextDayThreshold signals that all-day ranges should be sliced.
  */


  function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
    var inverseBgByGroupId = {};
    var inverseBgByDefId = {};
    var defByGroupId = {};
    var bgRanges = [];
    var fgRanges = [];
    var eventUis = compileEventUis(eventStore.defs, eventUiBases);

    for (var defId in eventStore.defs) {
      var def = eventStore.defs[defId];

      if (def.rendering === 'inverse-background') {
        if (def.groupId) {
          inverseBgByGroupId[def.groupId] = [];

          if (!defByGroupId[def.groupId]) {
            defByGroupId[def.groupId] = def;
          }
        } else {
          inverseBgByDefId[defId] = [];
        }
      }
    }

    for (var instanceId in eventStore.instances) {
      var instance = eventStore.instances[instanceId];
      var def = eventStore.defs[instance.defId];
      var ui = eventUis[def.defId];
      var origRange = instance.range;
      var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
      var slicedRange = intersectRanges(normalRange, framingRange);

      if (slicedRange) {
        if (def.rendering === 'inverse-background') {
          if (def.groupId) {
            inverseBgByGroupId[def.groupId].push(slicedRange);
          } else {
            inverseBgByDefId[instance.defId].push(slicedRange);
          }
        } else {
          (def.rendering === 'background' ? bgRanges : fgRanges).push({
            def: def,
            ui: ui,
            instance: instance,
            range: slicedRange,
            isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
            isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
          });
        }
      }
    }

    for (var groupId in inverseBgByGroupId) {
      // BY GROUP
      var ranges = inverseBgByGroupId[groupId];
      var invertedRanges = invertRanges(ranges, framingRange);

      for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {
        var invertedRange = invertedRanges_1[_i];
        var def = defByGroupId[groupId];
        var ui = eventUis[def.defId];
        bgRanges.push({
          def: def,
          ui: ui,
          instance: null,
          range: invertedRange,
          isStart: false,
          isEnd: false
        });
      }
    }

    for (var defId in inverseBgByDefId) {
      var ranges = inverseBgByDefId[defId];
      var invertedRanges = invertRanges(ranges, framingRange);

      for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {
        var invertedRange = invertedRanges_2[_a];
        bgRanges.push({
          def: eventStore.defs[defId],
          ui: eventUis[defId],
          instance: null,
          range: invertedRange,
          isStart: false,
          isEnd: false
        });
      }
    }

    return {
      bg: bgRanges,
      fg: fgRanges
    };
  }

  function hasBgRendering(def) {
    return def.rendering === 'background' || def.rendering === 'inverse-background';
  }

  function filterSegsViaEls(view, segs, isMirror) {
    if (view.hasPublicHandlers('eventRender')) {
      segs = segs.filter(function (seg) {
        var custom = view.publiclyTrigger('eventRender', [{
          event: new EventApi(view.calendar, seg.eventRange.def, seg.eventRange.instance),
          isMirror: isMirror,
          isStart: seg.isStart,
          isEnd: seg.isEnd,
          // TODO: include seg.range once all components consistently generate it
          el: seg.el,
          view: view
        }]);

        if (custom === false) {
          // means don't render at all
          return false;
        } else if (custom && custom !== true) {
          seg.el = custom;
        }

        return true;
      });
    }

    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
      var seg = segs_1[_i];
      setElSeg(seg.el, seg);
    }

    return segs;
  }

  function setElSeg(el, seg) {
    el.fcSeg = seg;
  }

  function getElSeg(el) {
    return el.fcSeg || null;
  } // event ui computation


  function compileEventUis(eventDefs, eventUiBases) {
    return mapHash(eventDefs, function (eventDef) {
      return compileEventUi(eventDef, eventUiBases);
    });
  }

  function compileEventUi(eventDef, eventUiBases) {
    var uis = [];

    if (eventUiBases['']) {
      uis.push(eventUiBases['']);
    }

    if (eventUiBases[eventDef.defId]) {
      uis.push(eventUiBases[eventDef.defId]);
    }

    uis.push(eventDef.ui);
    return combineEventUis(uis);
  } // applies the mutation to ALL defs/instances within the event store


  function applyMutationToEventStore(eventStore, eventConfigBase, mutation, calendar) {
    var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
    var dest = createEmptyEventStore();

    for (var defId in eventStore.defs) {
      var def = eventStore.defs[defId];
      dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, calendar.pluginSystem.hooks.eventDefMutationAppliers, calendar);
    }

    for (var instanceId in eventStore.instances) {
      var instance = eventStore.instances[instanceId];
      var def = dest.defs[instance.defId]; // important to grab the newly modified def

      dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, calendar);
    }

    return dest;
  }

  function applyMutationToEventDef(eventDef, eventConfig, mutation, appliers, calendar) {
    var standardProps = mutation.standardProps || {}; // if hasEnd has not been specified, guess a good value based on deltas.
    // if duration will change, there's no way the default duration will persist,
    // and thus, we need to mark the event as having a real end

    if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
      standardProps.hasEnd = true; // TODO: is this mutation okay?
    }

    var copy = _assign({}, eventDef, standardProps, {
      ui: _assign({}, eventDef.ui, standardProps.ui)
    });

    if (mutation.extendedProps) {
      copy.extendedProps = _assign({}, copy.extendedProps, mutation.extendedProps);
    }

    for (var _i = 0, appliers_1 = appliers; _i < appliers_1.length; _i++) {
      var applier = appliers_1[_i];
      applier(copy, mutation, calendar);
    }

    if (!copy.hasEnd && calendar.opt('forceEventDuration')) {
      copy.hasEnd = true;
    }

    return copy;
  }

  function applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef
  eventConfig, mutation, calendar) {
    var dateEnv = calendar.dateEnv;
    var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
    var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;

    var copy = _assign({}, eventInstance);

    if (forceAllDay) {
      copy.range = computeAlignedDayRange(copy.range);
    }

    if (mutation.datesDelta && eventConfig.startEditable) {
      copy.range = {
        start: dateEnv.add(copy.range.start, mutation.datesDelta),
        end: dateEnv.add(copy.range.end, mutation.datesDelta)
      };
    }

    if (mutation.startDelta && eventConfig.durationEditable) {
      copy.range = {
        start: dateEnv.add(copy.range.start, mutation.startDelta),
        end: copy.range.end
      };
    }

    if (mutation.endDelta && eventConfig.durationEditable) {
      copy.range = {
        start: copy.range.start,
        end: dateEnv.add(copy.range.end, mutation.endDelta)
      };
    }

    if (clearEnd) {
      copy.range = {
        start: copy.range.start,
        end: calendar.getDefaultEventEnd(eventDef.allDay, copy.range.start)
      };
    } // in case event was all-day but the supplied deltas were not
    // better util for this?


    if (eventDef.allDay) {
      copy.range = {
        start: startOfDay(copy.range.start),
        end: startOfDay(copy.range.end)
      };
    } // handle invalid durations


    if (copy.range.end < copy.range.start) {
      copy.range.end = calendar.getDefaultEventEnd(eventDef.allDay, copy.range.start);
    }

    return copy;
  }

  function reduceEventStore(eventStore, action, eventSources, dateProfile, calendar) {
    switch (action.type) {
      case 'RECEIVE_EVENTS':
        // raw
        return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, calendar);

      case 'ADD_EVENTS':
        // already parsed, but not expanded
        return addEvent(eventStore, action.eventStore, // new ones
        dateProfile ? dateProfile.activeRange : null, calendar);

      case 'MERGE_EVENTS':
        // already parsed and expanded
        return mergeEventStores(eventStore, action.eventStore);

      case 'PREV': // TODO: how do we track all actions that affect dateProfile :(

      case 'NEXT':
      case 'SET_DATE':
      case 'SET_VIEW_TYPE':
        if (dateProfile) {
          return expandRecurring(eventStore, dateProfile.activeRange, calendar);
        } else {
          return eventStore;
        }

      case 'CHANGE_TIMEZONE':
        return rezoneDates(eventStore, action.oldDateEnv, calendar.dateEnv);

      case 'MUTATE_EVENTS':
        return applyMutationToRelated(eventStore, action.instanceId, action.mutation, action.fromApi, calendar);

      case 'REMOVE_EVENT_INSTANCES':
        return excludeInstances(eventStore, action.instances);

      case 'REMOVE_EVENT_DEF':
        return filterEventStoreDefs(eventStore, function (eventDef) {
          return eventDef.defId !== action.defId;
        });

      case 'REMOVE_EVENT_SOURCE':
        return excludeEventsBySourceId(eventStore, action.sourceId);

      case 'REMOVE_ALL_EVENT_SOURCES':
        return filterEventStoreDefs(eventStore, function (eventDef) {
          return !eventDef.sourceId; // only keep events with no source id
        });

      case 'REMOVE_ALL_EVENTS':
        return createEmptyEventStore();

      case 'RESET_EVENTS':
        return {
          defs: eventStore.defs,
          instances: eventStore.instances
        };

      default:
        return eventStore;
    }
  }

  function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, calendar) {
    if (eventSource && // not already removed
    fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources
    ) {
        var subset = parseEvents(transformRawEvents(rawEvents, eventSource, calendar), eventSource.sourceId, calendar);

        if (fetchRange) {
          subset = expandRecurring(subset, fetchRange, calendar);
        }

        return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
      }

    return eventStore;
  }

  function addEvent(eventStore, subset, expandRange, calendar) {
    if (expandRange) {
      subset = expandRecurring(subset, expandRange, calendar);
    }

    return mergeEventStores(eventStore, subset);
  }

  function rezoneDates(eventStore, oldDateEnv, newDateEnv) {
    var defs = eventStore.defs;
    var instances = mapHash(eventStore.instances, function (instance) {
      var def = defs[instance.defId];

      if (def.allDay || def.recurringDef) {
        return instance; // isn't dependent on timezone
      } else {
        return _assign({}, instance, {
          range: {
            start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
            end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
          },
          forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,
          forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo
        });
      }
    });
    return {
      defs: defs,
      instances: instances
    };
  }

  function applyMutationToRelated(eventStore, instanceId, mutation, fromApi, calendar) {
    var relevant = getRelevantEvents(eventStore, instanceId);
    var eventConfigBase = fromApi ? {
      '': {
        startEditable: true,
        durationEditable: true,
        constraints: [],
        overlap: null,
        allows: [],
        backgroundColor: '',
        borderColor: '',
        textColor: '',
        classNames: []
      }
    } : calendar.eventUiBases;
    relevant = applyMutationToEventStore(relevant, eventConfigBase, mutation, calendar);
    return mergeEventStores(eventStore, relevant);
  }

  function excludeEventsBySourceId(eventStore, sourceId) {
    return filterEventStoreDefs(eventStore, function (eventDef) {
      return eventDef.sourceId !== sourceId;
    });
  } // QUESTION: why not just return instances? do a general object-property-exclusion util


  function excludeInstances(eventStore, removals) {
    return {
      defs: eventStore.defs,
      instances: filterHash(eventStore.instances, function (instance) {
        return !removals[instance.instanceId];
      })
    };
  } // high-level segmenting-aware tester functions
  // ------------------------------------------------------------------------------------------------------------------------


  function isInteractionValid(interaction, calendar) {
    return isNewPropsValid({
      eventDrag: interaction
    }, calendar); // HACK: the eventDrag props is used for ALL interactions
  }

  function isDateSelectionValid(dateSelection, calendar) {
    return isNewPropsValid({
      dateSelection: dateSelection
    }, calendar);
  }

  function isNewPropsValid(newProps, calendar) {
    var view = calendar.view;

    var props = _assign({
      businessHours: view ? view.props.businessHours : createEmptyEventStore(),
      dateSelection: '',
      eventStore: calendar.state.eventStore,
      eventUiBases: calendar.eventUiBases,
      eventSelection: '',
      eventDrag: null,
      eventResize: null
    }, newProps);

    return (calendar.pluginSystem.hooks.isPropsValid || isPropsValid)(props, calendar);
  }

  function isPropsValid(state, calendar, dateSpanMeta, filterConfig) {
    if (dateSpanMeta === void 0) {
      dateSpanMeta = {};
    }

    if (state.eventDrag && !isInteractionPropsValid(state, calendar, dateSpanMeta, filterConfig)) {
      return false;
    }

    if (state.dateSelection && !isDateSelectionPropsValid(state, calendar, dateSpanMeta, filterConfig)) {
      return false;
    }

    return true;
  } // Moving Event Validation
  // ------------------------------------------------------------------------------------------------------------------------


  function isInteractionPropsValid(state, calendar, dateSpanMeta, filterConfig) {
    var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions

    var subjectEventStore = interaction.mutatedEvents;
    var subjectDefs = subjectEventStore.defs;
    var subjectInstances = subjectEventStore.instances;
    var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {
      '': calendar.selectionConfig
    } // if not a real event, validate as a selection
    );

    if (filterConfig) {
      subjectConfigs = mapHash(subjectConfigs, filterConfig);
    }

    var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances); // exclude the subject events. TODO: exclude defs too?

    var otherDefs = otherEventStore.defs;
    var otherInstances = otherEventStore.instances;
    var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);

    for (var subjectInstanceId in subjectInstances) {
      var subjectInstance = subjectInstances[subjectInstanceId];
      var subjectRange = subjectInstance.range;
      var subjectConfig = subjectConfigs[subjectInstance.defId];
      var subjectDef = subjectDefs[subjectInstance.defId]; // constraint

      if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, calendar)) {
        return false;
      } // overlap


      var overlapFunc = calendar.opt('eventOverlap');

      if (typeof overlapFunc !== 'function') {
        overlapFunc = null;
      }

      for (var otherInstanceId in otherInstances) {
        var otherInstance = otherInstances[otherInstanceId]; // intersect! evaluate

        if (rangesIntersect(subjectRange, otherInstance.range)) {
          var otherOverlap = otherConfigs[otherInstance.defId].overlap; // consider the other event's overlap. only do this if the subject event is a "real" event

          if (otherOverlap === false && interaction.isEvent) {
            return false;
          }

          if (subjectConfig.overlap === false) {
            return false;
          }

          if (overlapFunc && !overlapFunc(new EventApi(calendar, otherDefs[otherInstance.defId], otherInstance), // still event
          new EventApi(calendar, subjectDef, subjectInstance) // moving event
          )) {
            return false;
          }
        }
      } // allow (a function)


      var calendarEventStore = calendar.state.eventStore; // need global-to-calendar, not local to component (splittable)state

      for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {
        var subjectAllow = _a[_i];

        var subjectDateSpan = _assign({}, dateSpanMeta, {
          range: subjectInstance.range,
          allDay: subjectDef.allDay
        });

        var origDef = calendarEventStore.defs[subjectDef.defId];
        var origInstance = calendarEventStore.instances[subjectInstanceId];
        var eventApi = void 0;

        if (origDef) {
          // was previously in the calendar
          eventApi = new EventApi(calendar, origDef, origInstance);
        } else {
          // was an external event
          eventApi = new EventApi(calendar, subjectDef); // no instance, because had no dates
        }

        if (!subjectAllow(calendar.buildDateSpanApi(subjectDateSpan), eventApi)) {
          return false;
        }
      }
    }

    return true;
  } // Date Selection Validation
  // ------------------------------------------------------------------------------------------------------------------------


  function isDateSelectionPropsValid(state, calendar, dateSpanMeta, filterConfig) {
    var relevantEventStore = state.eventStore;
    var relevantDefs = relevantEventStore.defs;
    var relevantInstances = relevantEventStore.instances;
    var selection = state.dateSelection;
    var selectionRange = selection.range;
    var selectionConfig = calendar.selectionConfig;

    if (filterConfig) {
      selectionConfig = filterConfig(selectionConfig);
    } // constraint


    if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, calendar)) {
      return false;
    } // overlap


    var overlapFunc = calendar.opt('selectOverlap');

    if (typeof overlapFunc !== 'function') {
      overlapFunc = null;
    }

    for (var relevantInstanceId in relevantInstances) {
      var relevantInstance = relevantInstances[relevantInstanceId]; // intersect! evaluate

      if (rangesIntersect(selectionRange, relevantInstance.range)) {
        if (selectionConfig.overlap === false) {
          return false;
        }

        if (overlapFunc && !overlapFunc(new EventApi(calendar, relevantDefs[relevantInstance.defId], relevantInstance))) {
          return false;
        }
      }
    } // allow (a function)


    for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {
      var selectionAllow = _a[_i];

      var fullDateSpan = _assign({}, dateSpanMeta, selection);

      if (!selectionAllow(calendar.buildDateSpanApi(fullDateSpan), null)) {
        return false;
      }
    }

    return true;
  } // Constraint Utils
  // ------------------------------------------------------------------------------------------------------------------------


  function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, calendar) {
    for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {
      var constraint = constraints_1[_i];

      if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, calendar), subjectRange)) {
        return false;
      }
    }

    return true;
  }

  function constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours
  otherEventStore, // for if constraint is an even group ID
  businessHoursUnexpanded, // for if constraint is 'businessHours'
  calendar // for expanding businesshours
  ) {
    if (constraint === 'businessHours') {
      return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, calendar));
    } else if (typeof constraint === 'string') {
      // an group ID
      return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) {
        return eventDef.groupId === constraint;
      }));
    } else if (_typeof(constraint) === 'object' && constraint) {
      // non-null object
      return eventStoreToRanges(expandRecurring(constraint, subjectRange, calendar));
    }

    return []; // if it's false
  } // TODO: move to event-store file?


  function eventStoreToRanges(eventStore) {
    var instances = eventStore.instances;
    var ranges = [];

    for (var instanceId in instances) {
      ranges.push(instances[instanceId].range);
    }

    return ranges;
  } // TODO: move to geom file?


  function anyRangesContainRange(outerRanges, innerRange) {
    for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {
      var outerRange = outerRanges_1[_i];

      if (rangeContainsRange(outerRange, innerRange)) {
        return true;
      }
    }

    return false;
  } // Parsing
  // ------------------------------------------------------------------------------------------------------------------------


  function normalizeConstraint(input, calendar) {
    if (Array.isArray(input)) {
      return parseEvents(input, '', calendar, true); // allowOpenRange=true
    } else if (_typeof(input) === 'object' && input) {
      // non-null object
      return parseEvents([input], '', calendar, true); // allowOpenRange=true
    } else if (input != null) {
      return String(input);
    } else {
      return null;
    }
  }

  function htmlEscape(s) {
    return (s + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&#039;').replace(/"/g, '&quot;').replace(/\n/g, '<br />');
  } // Given a hash of CSS properties, returns a string of CSS.
  // Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.


  function cssToStr(cssProps) {
    var statements = [];

    for (var name_1 in cssProps) {
      var val = cssProps[name_1];

      if (val != null && val !== '') {
        statements.push(name_1 + ':' + val);
      }
    }

    return statements.join(';');
  } // Given an object hash of HTML attribute names to values,
  // generates a string that can be injected between < > in HTML


  function attrsToStr(attrs) {
    var parts = [];

    for (var name_2 in attrs) {
      var val = attrs[name_2];

      if (val != null) {
        parts.push(name_2 + '="' + htmlEscape(val) + '"');
      }
    }

    return parts.join(' ');
  }

  function parseClassName(raw) {
    if (Array.isArray(raw)) {
      return raw;
    } else if (typeof raw === 'string') {
      return raw.split(/\s+/);
    } else {
      return [];
    }
  }

  var UNSCOPED_EVENT_UI_PROPS = {
    editable: Boolean,
    startEditable: Boolean,
    durationEditable: Boolean,
    constraint: null,
    overlap: null,
    allow: null,
    className: parseClassName,
    classNames: parseClassName,
    color: String,
    backgroundColor: String,
    borderColor: String,
    textColor: String
  };

  function processUnscopedUiProps(rawProps, calendar, leftovers) {
    var props = refineProps(rawProps, UNSCOPED_EVENT_UI_PROPS, {}, leftovers);
    var constraint = normalizeConstraint(props.constraint, calendar);
    return {
      startEditable: props.startEditable != null ? props.startEditable : props.editable,
      durationEditable: props.durationEditable != null ? props.durationEditable : props.editable,
      constraints: constraint != null ? [constraint] : [],
      overlap: props.overlap,
      allows: props.allow != null ? [props.allow] : [],
      backgroundColor: props.backgroundColor || props.color,
      borderColor: props.borderColor || props.color,
      textColor: props.textColor,
      classNames: props.classNames.concat(props.className)
    };
  }

  function processScopedUiProps(prefix, rawScoped, calendar, leftovers) {
    var rawUnscoped = {};
    var wasFound = {};

    for (var key in UNSCOPED_EVENT_UI_PROPS) {
      var scopedKey = prefix + capitaliseFirstLetter(key);
      rawUnscoped[key] = rawScoped[scopedKey];
      wasFound[scopedKey] = true;
    }

    if (prefix === 'event') {
      rawUnscoped.editable = rawScoped.editable; // special case. there is no 'eventEditable', just 'editable'
    }

    if (leftovers) {
      for (var key in rawScoped) {
        if (!wasFound[key]) {
          leftovers[key] = rawScoped[key];
        }
      }
    }

    return processUnscopedUiProps(rawUnscoped, calendar);
  }

  var EMPTY_EVENT_UI = {
    startEditable: null,
    durationEditable: null,
    constraints: [],
    overlap: null,
    allows: [],
    backgroundColor: '',
    borderColor: '',
    textColor: '',
    classNames: []
  }; // prevent against problems with <2 args!

  function combineEventUis(uis) {
    return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
  }

  function combineTwoEventUis(item0, item1) {
    return {
      startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
      durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
      constraints: item0.constraints.concat(item1.constraints),
      overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,
      allows: item0.allows.concat(item1.allows),
      backgroundColor: item1.backgroundColor || item0.backgroundColor,
      borderColor: item1.borderColor || item0.borderColor,
      textColor: item1.textColor || item0.textColor,
      classNames: item0.classNames.concat(item1.classNames)
    };
  }

  var NON_DATE_PROPS = {
    id: String,
    groupId: String,
    title: String,
    url: String,
    rendering: String,
    extendedProps: null
  };
  var DATE_PROPS = {
    start: null,
    date: null,
    end: null,
    allDay: null
  };
  var uid = 0;

  function parseEvent(raw, sourceId, calendar, allowOpenRange) {
    var allDayDefault = computeIsAllDayDefault(sourceId, calendar);
    var leftovers0 = {};
    var recurringRes = parseRecurring(raw, // raw, but with single-event stuff stripped out
    allDayDefault, calendar.dateEnv, calendar.pluginSystem.hooks.recurringTypes, leftovers0 // will populate with non-recurring props
    );

    if (recurringRes) {
      var def = parseEventDef(leftovers0, sourceId, recurringRes.allDay, Boolean(recurringRes.duration), calendar);
      def.recurringDef = {
        typeId: recurringRes.typeId,
        typeData: recurringRes.typeData,
        duration: recurringRes.duration
      };
      return {
        def: def,
        instance: null
      };
    } else {
      var leftovers1 = {};
      var singleRes = parseSingle(raw, allDayDefault, calendar, leftovers1, allowOpenRange);

      if (singleRes) {
        var def = parseEventDef(leftovers1, sourceId, singleRes.allDay, singleRes.hasEnd, calendar);
        var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
        return {
          def: def,
          instance: instance
        };
      }
    }

    return null;
  }
  /*
  Will NOT populate extendedProps with the leftover properties.
  Will NOT populate date-related props.
  The EventNonDateInput has been normalized (id => publicId, etc).
  */


  function parseEventDef(raw, sourceId, allDay, hasEnd, calendar) {
    var leftovers = {};
    var def = pluckNonDateProps(raw, calendar, leftovers);
    def.defId = String(uid++);
    def.sourceId = sourceId;
    def.allDay = allDay;
    def.hasEnd = hasEnd;

    for (var _i = 0, _a = calendar.pluginSystem.hooks.eventDefParsers; _i < _a.length; _i++) {
      var eventDefParser = _a[_i];
      var newLeftovers = {};
      eventDefParser(def, leftovers, newLeftovers);
      leftovers = newLeftovers;
    }

    def.extendedProps = _assign(leftovers, def.extendedProps || {}); // help out EventApi from having user modify props

    Object.freeze(def.ui.classNames);
    Object.freeze(def.extendedProps);
    return def;
  }

  function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
    return {
      instanceId: String(uid++),
      defId: defId,
      range: range,
      forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
      forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
    };
  }

  function parseSingle(raw, allDayDefault, calendar, leftovers, allowOpenRange) {
    var props = pluckDateProps(raw, leftovers);
    var allDay = props.allDay;
    var startMeta;
    var startMarker = null;
    var hasEnd = false;
    var endMeta;
    var endMarker = null;
    startMeta = calendar.dateEnv.createMarkerMeta(props.start);

    if (startMeta) {
      startMarker = startMeta.marker;
    } else if (!allowOpenRange) {
      return null;
    }

    if (props.end != null) {
      endMeta = calendar.dateEnv.createMarkerMeta(props.end);
    }

    if (allDay == null) {
      if (allDayDefault != null) {
        allDay = allDayDefault;
      } else {
        // fall back to the date props LAST
        allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
      }
    }

    if (allDay && startMarker) {
      startMarker = startOfDay(startMarker);
    }

    if (endMeta) {
      endMarker = endMeta.marker;

      if (allDay) {
        endMarker = startOfDay(endMarker);
      }

      if (startMarker && endMarker <= startMarker) {
        endMarker = null;
      }
    }

    if (endMarker) {
      hasEnd = true;
    } else if (!allowOpenRange) {
      hasEnd = calendar.opt('forceEventDuration') || false;
      endMarker = calendar.dateEnv.add(startMarker, allDay ? calendar.defaultAllDayEventDuration : calendar.defaultTimedEventDuration);
    }

    return {
      allDay: allDay,
      hasEnd: hasEnd,
      range: {
        start: startMarker,
        end: endMarker
      },
      forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
      forcedEndTzo: endMeta ? endMeta.forcedTzo : null
    };
  }

  function pluckDateProps(raw, leftovers) {
    var props = refineProps(raw, DATE_PROPS, {}, leftovers);
    props.start = props.start !== null ? props.start : props.date;
    delete props.date;
    return props;
  }

  function pluckNonDateProps(raw, calendar, leftovers) {
    var preLeftovers = {};
    var props = refineProps(raw, NON_DATE_PROPS, {}, preLeftovers);
    var ui = processUnscopedUiProps(preLeftovers, calendar, leftovers);
    props.publicId = props.id;
    delete props.id;
    props.ui = ui;
    return props;
  }

  function computeIsAllDayDefault(sourceId, calendar) {
    var res = null;

    if (sourceId) {
      var source = calendar.state.eventSources[sourceId];
      res = source.allDayDefault;
    }

    if (res == null) {
      res = calendar.opt('allDayDefault');
    }

    return res;
  }

  var DEF_DEFAULTS = {
    startTime: '09:00',
    endTime: '17:00',
    daysOfWeek: [1, 2, 3, 4, 5],
    rendering: 'inverse-background',
    classNames: 'fc-nonbusiness',
    groupId: '_businessHours' // so multiple defs get grouped

  };
  /*
  TODO: pass around as EventDefHash!!!
  */

  function parseBusinessHours(input, calendar) {
    return parseEvents(refineInputs(input), '', calendar);
  }

  function refineInputs(input) {
    var rawDefs;

    if (input === true) {
      rawDefs = [{}]; // will get DEF_DEFAULTS verbatim
    } else if (Array.isArray(input)) {
      // if specifying an array, every sub-definition NEEDS a day-of-week
      rawDefs = input.filter(function (rawDef) {
        return rawDef.daysOfWeek;
      });
    } else if (_typeof(input) === 'object' && input) {
      // non-null object
      rawDefs = [input];
    } else {
      // is probably false
      rawDefs = [];
    }

    rawDefs = rawDefs.map(function (rawDef) {
      return _assign({}, DEF_DEFAULTS, rawDef);
    });
    return rawDefs;
  }

  function memoizeRendering(renderFunc, unrenderFunc, dependencies) {
    if (dependencies === void 0) {
      dependencies = [];
    }

    var dependents = [];
    var thisContext;
    var prevArgs;

    function unrender() {
      if (prevArgs) {
        for (var _i = 0, dependents_1 = dependents; _i < dependents_1.length; _i++) {
          var dependent = dependents_1[_i];
          dependent.unrender();
        }

        if (unrenderFunc) {
          unrenderFunc.apply(thisContext, prevArgs);
        }

        prevArgs = null;
      }
    }

    function res() {
      if (!prevArgs || !isArraysEqual(prevArgs, arguments)) {
        unrender();
        thisContext = this;
        prevArgs = arguments;
        renderFunc.apply(this, arguments);
      }
    }

    res.dependents = dependents;
    res.unrender = unrender;

    for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
      var dependency = dependencies_1[_i];
      dependency.dependents.push(res);
    }

    return res;
  }

  var EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere

  var Splitter =
  /** @class */
  function () {
    function Splitter() {
      this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);
      this.splitDateSelection = memoize(this._splitDateSpan);
      this.splitEventStore = memoize(this._splitEventStore);
      this.splitIndividualUi = memoize(this._splitIndividualUi);
      this.splitEventDrag = memoize(this._splitInteraction);
      this.splitEventResize = memoize(this._splitInteraction);
      this.eventUiBuilders = {}; // TODO: typescript protection
    }

    Splitter.prototype.splitProps = function (props) {
      var _this = this;

      var keyInfos = this.getKeyInfo(props);
      var defKeys = this.getKeysForEventDefs(props.eventStore);
      var dateSelections = this.splitDateSelection(props.dateSelection);
      var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*

      var eventStores = this.splitEventStore(props.eventStore, defKeys);
      var eventDrags = this.splitEventDrag(props.eventDrag);
      var eventResizes = this.splitEventResize(props.eventResize);
      var splitProps = {};
      this.eventUiBuilders = mapHash(keyInfos, function (info, key) {
        return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);
      });

      for (var key in keyInfos) {
        var keyInfo = keyInfos[key];
        var eventStore = eventStores[key] || EMPTY_EVENT_STORE;
        var buildEventUi = this.eventUiBuilders[key];
        splitProps[key] = {
          businessHours: keyInfo.businessHours || props.businessHours,
          dateSelection: dateSelections[key] || null,
          eventStore: eventStore,
          eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),
          eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',
          eventDrag: eventDrags[key] || null,
          eventResize: eventResizes[key] || null
        };
      }

      return splitProps;
    };

    Splitter.prototype._splitDateSpan = function (dateSpan) {
      var dateSpans = {};

      if (dateSpan) {
        var keys = this.getKeysForDateSpan(dateSpan);

        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          dateSpans[key] = dateSpan;
        }
      }

      return dateSpans;
    };

    Splitter.prototype._getKeysForEventDefs = function (eventStore) {
      var _this = this;

      return mapHash(eventStore.defs, function (eventDef) {
        return _this.getKeysForEventDef(eventDef);
      });
    };

    Splitter.prototype._splitEventStore = function (eventStore, defKeys) {
      var defs = eventStore.defs,
          instances = eventStore.instances;
      var splitStores = {};

      for (var defId in defs) {
        for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {
          var key = _a[_i];

          if (!splitStores[key]) {
            splitStores[key] = createEmptyEventStore();
          }

          splitStores[key].defs[defId] = defs[defId];
        }
      }

      for (var instanceId in instances) {
        var instance = instances[instanceId];

        for (var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++) {
          var key = _c[_b];

          if (splitStores[key]) {
            // must have already been created
            splitStores[key].instances[instanceId] = instance;
          }
        }
      }

      return splitStores;
    };

    Splitter.prototype._splitIndividualUi = function (eventUiBases, defKeys) {
      var splitHashes = {};

      for (var defId in eventUiBases) {
        if (defId) {
          // not the '' key
          for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {
            var key = _a[_i];

            if (!splitHashes[key]) {
              splitHashes[key] = {};
            }

            splitHashes[key][defId] = eventUiBases[defId];
          }
        }
      }

      return splitHashes;
    };

    Splitter.prototype._splitInteraction = function (interaction) {
      var splitStates = {};

      if (interaction) {
        var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents) // can't use cached. might be events from other calendar
        ); // can't rely on defKeys because event data is mutated


        var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);

        var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);

        var populate = function populate(key) {
          if (!splitStates[key]) {
            splitStates[key] = {
              affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,
              mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,
              isEvent: interaction.isEvent,
              origSeg: interaction.origSeg
            };
          }
        };

        for (var key in affectedStores_1) {
          populate(key);
        }

        for (var key in mutatedStores_1) {
          populate(key);
        }
      }

      return splitStates;
    };

    return Splitter;
  }();

  function buildEventUiForKey(allUi, eventUiForKey, individualUi) {
    var baseParts = [];

    if (allUi) {
      baseParts.push(allUi);
    }

    if (eventUiForKey) {
      baseParts.push(eventUiForKey);
    }

    var stuff = {
      '': combineEventUis(baseParts)
    };

    if (individualUi) {
      _assign(stuff, individualUi);
    }

    return stuff;
  } // Generates HTML for an anchor to another view into the calendar.
  // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
  // `gotoOptions` can either be a DateMarker, or an object with the form:
  // { date, type, forceOff }
  // `type` is a view-type like "day" or "week". default value is "day".
  // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.


  function buildGotoAnchorHtml(component, gotoOptions, attrs, innerHtml) {
    var dateEnv = component.dateEnv;
    var date;
    var type;
    var forceOff;
    var finalOptions;

    if (gotoOptions instanceof Date) {
      date = gotoOptions; // a single date-like input
    } else {
      date = gotoOptions.date;
      type = gotoOptions.type;
      forceOff = gotoOptions.forceOff;
    }

    finalOptions = {
      date: dateEnv.formatIso(date, {
        omitTime: true
      }),
      type: type || 'day'
    };

    if (typeof attrs === 'string') {
      innerHtml = attrs;
      attrs = null;
    }

    attrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space

    innerHtml = innerHtml || '';

    if (!forceOff && component.opt('navLinks')) {
      return '<a' + attrs + ' data-goto="' + htmlEscape(JSON.stringify(finalOptions)) + '">' + innerHtml + '</a>';
    } else {
      return '<span' + attrs + '>' + innerHtml + '</span>';
    }
  }

  function getAllDayHtml(component) {
    return component.opt('allDayHtml') || htmlEscape(component.opt('allDayText'));
  } // Computes HTML classNames for a single-day element


  function getDayClasses(date, dateProfile, context, noThemeHighlight) {
    var calendar = context.calendar,
        view = context.view,
        theme = context.theme,
        dateEnv = context.dateEnv;
    var classes = [];
    var todayStart;
    var todayEnd;

    if (!rangeContainsMarker(dateProfile.activeRange, date)) {
      classes.push('fc-disabled-day');
    } else {
      classes.push('fc-' + DAY_IDS[date.getUTCDay()]);

      if (view.opt('monthMode') && dateEnv.getMonth(date) !== dateEnv.getMonth(dateProfile.currentRange.start)) {
        classes.push('fc-other-month');
      }

      todayStart = startOfDay(calendar.getNow());
      todayEnd = addDays(todayStart, 1);

      if (date < todayStart) {
        classes.push('fc-past');
      } else if (date >= todayEnd) {
        classes.push('fc-future');
      } else {
        classes.push('fc-today');

        if (noThemeHighlight !== true) {
          classes.push(theme.getClass('today'));
        }
      }
    }

    return classes;
  } // given a function that resolves a result asynchronously.
  // the function can either call passed-in success and failure callbacks,
  // or it can return a promise.
  // if you need to pass additional params to func, bind them first.


  function unpromisify(func, success, failure) {
    // guard against success/failure callbacks being called more than once
    // and guard against a promise AND callback being used together.
    var isResolved = false;

    var wrappedSuccess = function wrappedSuccess() {
      if (!isResolved) {
        isResolved = true;
        success.apply(this, arguments);
      }
    };

    var wrappedFailure = function wrappedFailure() {
      if (!isResolved) {
        isResolved = true;

        if (failure) {
          failure.apply(this, arguments);
        }
      }
    };

    var res = func(wrappedSuccess, wrappedFailure);

    if (res && typeof res.then === 'function') {
      res.then(wrappedSuccess, wrappedFailure);
    }
  }

  var Mixin =
  /** @class */
  function () {
    function Mixin() {} // mix into a CLASS


    Mixin.mixInto = function (destClass) {
      this.mixIntoObj(destClass.prototype);
    }; // mix into ANY object


    Mixin.mixIntoObj = function (destObj) {
      var _this = this;

      Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
        if (!destObj[name]) {
          // if destination doesn't already define it
          destObj[name] = _this.prototype[name];
        }
      });
    };
    /*
    will override existing methods
    TODO: remove! not used anymore
    */


    Mixin.mixOver = function (destClass) {
      var _this = this;

      Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
        destClass.prototype[name] = _this.prototype[name];
      });
    };

    return Mixin;
  }();
  /*
  USAGE:
    import { default as EmitterMixin, EmitterInterface } from './EmitterMixin'
  in class:
    on: EmitterInterface['on']
    one: EmitterInterface['one']
    off: EmitterInterface['off']
    trigger: EmitterInterface['trigger']
    triggerWith: EmitterInterface['triggerWith']
    hasHandlers: EmitterInterface['hasHandlers']
  after class:
    EmitterMixin.mixInto(TheClass)
  */


  var EmitterMixin =
  /** @class */
  function (_super) {
    __extends(EmitterMixin, _super);

    function EmitterMixin() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    EmitterMixin.prototype.on = function (type, handler) {
      addToHash(this._handlers || (this._handlers = {}), type, handler);
      return this; // for chaining
    }; // todo: add comments


    EmitterMixin.prototype.one = function (type, handler) {
      addToHash(this._oneHandlers || (this._oneHandlers = {}), type, handler);
      return this; // for chaining
    };

    EmitterMixin.prototype.off = function (type, handler) {
      if (this._handlers) {
        removeFromHash(this._handlers, type, handler);
      }

      if (this._oneHandlers) {
        removeFromHash(this._oneHandlers, type, handler);
      }

      return this; // for chaining
    };

    EmitterMixin.prototype.trigger = function (type) {
      var args = [];

      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }

      this.triggerWith(type, this, args);
      return this; // for chaining
    };

    EmitterMixin.prototype.triggerWith = function (type, context, args) {
      if (this._handlers) {
        applyAll(this._handlers[type], context, args);
      }

      if (this._oneHandlers) {
        applyAll(this._oneHandlers[type], context, args);
        delete this._oneHandlers[type]; // will never fire again
      }

      return this; // for chaining
    };

    EmitterMixin.prototype.hasHandlers = function (type) {
      return this._handlers && this._handlers[type] && this._handlers[type].length || this._oneHandlers && this._oneHandlers[type] && this._oneHandlers[type].length;
    };

    return EmitterMixin;
  }(Mixin);

  function addToHash(hash, type, handler) {
    (hash[type] || (hash[type] = [])).push(handler);
  }

  function removeFromHash(hash, type, handler) {
    if (handler) {
      if (hash[type]) {
        hash[type] = hash[type].filter(function (func) {
          return func !== handler;
        });
      }
    } else {
      delete hash[type]; // remove all handler funcs for this type
    }
  }
  /*
  Records offset information for a set of elements, relative to an origin element.
  Can record the left/right OR the top/bottom OR both.
  Provides methods for querying the cache by position.
  */


  var PositionCache =
  /** @class */
  function () {
    function PositionCache(originEl, els, isHorizontal, isVertical) {
      this.originEl = originEl;
      this.els = els;
      this.isHorizontal = isHorizontal;
      this.isVertical = isVertical;
    } // Queries the els for coordinates and stores them.
    // Call this method before using and of the get* methods below.


    PositionCache.prototype.build = function () {
      var originEl = this.originEl;
      var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left

      if (this.isHorizontal) {
        this.buildElHorizontals(originClientRect.left);
      }

      if (this.isVertical) {
        this.buildElVerticals(originClientRect.top);
      }
    }; // Populates the left/right internal coordinate arrays


    PositionCache.prototype.buildElHorizontals = function (originClientLeft) {
      var lefts = [];
      var rights = [];

      for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
        var el = _a[_i];
        var rect = el.getBoundingClientRect();
        lefts.push(rect.left - originClientLeft);
        rights.push(rect.right - originClientLeft);
      }

      this.lefts = lefts;
      this.rights = rights;
    }; // Populates the top/bottom internal coordinate arrays


    PositionCache.prototype.buildElVerticals = function (originClientTop) {
      var tops = [];
      var bottoms = [];

      for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
        var el = _a[_i];
        var rect = el.getBoundingClientRect();
        tops.push(rect.top - originClientTop);
        bottoms.push(rect.bottom - originClientTop);
      }

      this.tops = tops;
      this.bottoms = bottoms;
    }; // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
    // If no intersection is made, returns undefined.


    PositionCache.prototype.leftToIndex = function (leftPosition) {
      var lefts = this.lefts;
      var rights = this.rights;
      var len = lefts.length;
      var i;

      for (i = 0; i < len; i++) {
        if (leftPosition >= lefts[i] && leftPosition < rights[i]) {
          return i;
        }
      }
    }; // Given a top offset (from document top), returns the index of the el that it vertically intersects.
    // If no intersection is made, returns undefined.


    PositionCache.prototype.topToIndex = function (topPosition) {
      var tops = this.tops;
      var bottoms = this.bottoms;
      var len = tops.length;
      var i;

      for (i = 0; i < len; i++) {
        if (topPosition >= tops[i] && topPosition < bottoms[i]) {
          return i;
        }
      }
    }; // Gets the width of the element at the given index


    PositionCache.prototype.getWidth = function (leftIndex) {
      return this.rights[leftIndex] - this.lefts[leftIndex];
    }; // Gets the height of the element at the given index


    PositionCache.prototype.getHeight = function (topIndex) {
      return this.bottoms[topIndex] - this.tops[topIndex];
    };

    return PositionCache;
  }();
  /*
  An object for getting/setting scroll-related information for an element.
  Internally, this is done very differently for window versus DOM element,
  so this object serves as a common interface.
  */


  var ScrollController =
  /** @class */
  function () {
    function ScrollController() {}

    ScrollController.prototype.getMaxScrollTop = function () {
      return this.getScrollHeight() - this.getClientHeight();
    };

    ScrollController.prototype.getMaxScrollLeft = function () {
      return this.getScrollWidth() - this.getClientWidth();
    };

    ScrollController.prototype.canScrollVertically = function () {
      return this.getMaxScrollTop() > 0;
    };

    ScrollController.prototype.canScrollHorizontally = function () {
      return this.getMaxScrollLeft() > 0;
    };

    ScrollController.prototype.canScrollUp = function () {
      return this.getScrollTop() > 0;
    };

    ScrollController.prototype.canScrollDown = function () {
      return this.getScrollTop() < this.getMaxScrollTop();
    };

    ScrollController.prototype.canScrollLeft = function () {
      return this.getScrollLeft() > 0;
    };

    ScrollController.prototype.canScrollRight = function () {
      return this.getScrollLeft() < this.getMaxScrollLeft();
    };

    return ScrollController;
  }();

  var ElementScrollController =
  /** @class */
  function (_super) {
    __extends(ElementScrollController, _super);

    function ElementScrollController(el) {
      var _this = _super.call(this) || this;

      _this.el = el;
      return _this;
    }

    ElementScrollController.prototype.getScrollTop = function () {
      return this.el.scrollTop;
    };

    ElementScrollController.prototype.getScrollLeft = function () {
      return this.el.scrollLeft;
    };

    ElementScrollController.prototype.setScrollTop = function (top) {
      this.el.scrollTop = top;
    };

    ElementScrollController.prototype.setScrollLeft = function (left) {
      this.el.scrollLeft = left;
    };

    ElementScrollController.prototype.getScrollWidth = function () {
      return this.el.scrollWidth;
    };

    ElementScrollController.prototype.getScrollHeight = function () {
      return this.el.scrollHeight;
    };

    ElementScrollController.prototype.getClientHeight = function () {
      return this.el.clientHeight;
    };

    ElementScrollController.prototype.getClientWidth = function () {
      return this.el.clientWidth;
    };

    return ElementScrollController;
  }(ScrollController);

  var WindowScrollController =
  /** @class */
  function (_super) {
    __extends(WindowScrollController, _super);

    function WindowScrollController() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    WindowScrollController.prototype.getScrollTop = function () {
      return window.pageYOffset;
    };

    WindowScrollController.prototype.getScrollLeft = function () {
      return window.pageXOffset;
    };

    WindowScrollController.prototype.setScrollTop = function (n) {
      window.scroll(window.pageXOffset, n);
    };

    WindowScrollController.prototype.setScrollLeft = function (n) {
      window.scroll(n, window.pageYOffset);
    };

    WindowScrollController.prototype.getScrollWidth = function () {
      return document.documentElement.scrollWidth;
    };

    WindowScrollController.prototype.getScrollHeight = function () {
      return document.documentElement.scrollHeight;
    };

    WindowScrollController.prototype.getClientHeight = function () {
      return document.documentElement.clientHeight;
    };

    WindowScrollController.prototype.getClientWidth = function () {
      return document.documentElement.clientWidth;
    };

    return WindowScrollController;
  }(ScrollController);
  /*
  Embodies a div that has potential scrollbars
  */


  var ScrollComponent =
  /** @class */
  function (_super) {
    __extends(ScrollComponent, _super);

    function ScrollComponent(overflowX, overflowY) {
      var _this = _super.call(this, createElement('div', {
        className: 'fc-scroller'
      })) || this;

      _this.overflowX = overflowX;
      _this.overflowY = overflowY;

      _this.applyOverflow();

      return _this;
    } // sets to natural height, unlocks overflow


    ScrollComponent.prototype.clear = function () {
      this.setHeight('auto');
      this.applyOverflow();
    };

    ScrollComponent.prototype.destroy = function () {
      removeElement(this.el);
    }; // Overflow
    // -----------------------------------------------------------------------------------------------------------------


    ScrollComponent.prototype.applyOverflow = function () {
      applyStyle(this.el, {
        overflowX: this.overflowX,
        overflowY: this.overflowY
      });
    }; // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
    // Useful for preserving scrollbar widths regardless of future resizes.
    // Can pass in scrollbarWidths for optimization.


    ScrollComponent.prototype.lockOverflow = function (scrollbarWidths) {
      var overflowX = this.overflowX;
      var overflowY = this.overflowY;
      scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();

      if (overflowX === 'auto') {
        overflowX = scrollbarWidths.bottom || // horizontal scrollbars?
        this.canScrollHorizontally() // OR scrolling pane with massless scrollbars?
        ? 'scroll' : 'hidden';
      }

      if (overflowY === 'auto') {
        overflowY = scrollbarWidths.left || scrollbarWidths.right || // horizontal scrollbars?
        this.canScrollVertically() // OR scrolling pane with massless scrollbars?
        ? 'scroll' : 'hidden';
      }

      applyStyle(this.el, {
        overflowX: overflowX,
        overflowY: overflowY
      });
    };

    ScrollComponent.prototype.setHeight = function (height) {
      applyStyleProp(this.el, 'height', height);
    };

    ScrollComponent.prototype.getScrollbarWidths = function () {
      var edges = computeEdges(this.el);
      return {
        left: edges.scrollbarLeft,
        right: edges.scrollbarRight,
        bottom: edges.scrollbarBottom
      };
    };

    return ScrollComponent;
  }(ElementScrollController);

  var Theme =
  /** @class */
  function () {
    function Theme(calendarOptions) {
      this.calendarOptions = calendarOptions;
      this.processIconOverride();
    }

    Theme.prototype.processIconOverride = function () {
      if (this.iconOverrideOption) {
        this.setIconOverride(this.calendarOptions[this.iconOverrideOption]);
      }
    };

    Theme.prototype.setIconOverride = function (iconOverrideHash) {
      var iconClassesCopy;
      var buttonName;

      if (_typeof(iconOverrideHash) === 'object' && iconOverrideHash) {
        // non-null object
        iconClassesCopy = _assign({}, this.iconClasses);

        for (buttonName in iconOverrideHash) {
          iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
        }

        this.iconClasses = iconClassesCopy;
      } else if (iconOverrideHash === false) {
        this.iconClasses = {};
      }
    };

    Theme.prototype.applyIconOverridePrefix = function (className) {
      var prefix = this.iconOverridePrefix;

      if (prefix && className.indexOf(prefix) !== 0) {
        // if not already present
        className = prefix + className;
      }

      return className;
    };

    Theme.prototype.getClass = function (key) {
      return this.classes[key] || '';
    };

    Theme.prototype.getIconClass = function (buttonName) {
      var className = this.iconClasses[buttonName];

      if (className) {
        return this.baseIconClass + ' ' + className;
      }

      return '';
    };

    Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {
      var className;

      if (this.iconOverrideCustomButtonOption) {
        className = customButtonProps[this.iconOverrideCustomButtonOption];

        if (className) {
          return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);
        }
      }

      return '';
    };

    return Theme;
  }();

  Theme.prototype.classes = {};
  Theme.prototype.iconClasses = {};
  Theme.prototype.baseIconClass = '';
  Theme.prototype.iconOverridePrefix = '';
  var guid = 0;

  var Component =
  /** @class */
  function () {
    function Component(context, isView) {
      // HACK to populate view at top of component instantiation call chain
      if (isView) {
        context.view = this;
      }

      this.uid = String(guid++);
      this.context = context;
      this.dateEnv = context.dateEnv;
      this.theme = context.theme;
      this.view = context.view;
      this.calendar = context.calendar;
      this.isRtl = this.opt('dir') === 'rtl';
    }

    Component.addEqualityFuncs = function (newFuncs) {
      this.prototype.equalityFuncs = _assign({}, this.prototype.equalityFuncs, newFuncs);
    };

    Component.prototype.opt = function (name) {
      return this.context.options[name];
    };

    Component.prototype.receiveProps = function (props) {
      var _a = recycleProps(this.props || {}, props, this.equalityFuncs),
          anyChanges = _a.anyChanges,
          comboProps = _a.comboProps;

      this.props = comboProps;

      if (anyChanges) {
        this.render(comboProps);
      }
    };

    Component.prototype.render = function (props) {}; // after destroy is called, this component won't ever be used again


    Component.prototype.destroy = function () {};

    return Component;
  }();

  Component.prototype.equalityFuncs = {};
  /*
  Reuses old values when equal. If anything is unequal, returns newProps as-is.
  Great for PureComponent, but won't be feasible with React, so just eliminate and use React's DOM diffing.
  */

  function recycleProps(oldProps, newProps, equalityFuncs) {
    var comboProps = {}; // some old, some new

    var anyChanges = false;

    for (var key in newProps) {
      if (key in oldProps && (oldProps[key] === newProps[key] || equalityFuncs[key] && equalityFuncs[key](oldProps[key], newProps[key]))) {
        // equal to old? use old prop
        comboProps[key] = oldProps[key];
      } else {
        comboProps[key] = newProps[key];
        anyChanges = true;
      }
    }

    for (var key in oldProps) {
      if (!(key in newProps)) {
        anyChanges = true;
        break;
      }
    }

    return {
      anyChanges: anyChanges,
      comboProps: comboProps
    };
  }
  /*
  PURPOSES:
  - hook up to fg, fill, and mirror renderers
  - interface for dragging and hits
  */


  var DateComponent =
  /** @class */
  function (_super) {
    __extends(DateComponent, _super);

    function DateComponent(context, el, isView) {
      var _this = _super.call(this, context, isView) || this;

      _this.el = el;
      return _this;
    }

    DateComponent.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      removeElement(this.el);
    }; // TODO: WHAT ABOUT (sourceSeg && sourceSeg.component.doesDragMirror)
    //
    // Event Drag-n-Drop Rendering (for both events and external elements)
    // ---------------------------------------------------------------------------------------------------------------

    /*
    renderEventDragSegs(state: EventSegUiInteractionState) {
      if (state) {
        let { isEvent, segs, sourceSeg } = state
                if (this.eventRenderer) {
          this.eventRenderer.hideByHash(state.affectedInstances)
        }
                // if the user is dragging something that is considered an event with real event data,
        // and this component likes to do drag mirrors OR the component where the seg came from
        // likes to do drag mirrors, then render a drag mirror.
        if (isEvent && (this.doesDragMirror || sourceSeg && sourceSeg.component.doesDragMirror)) {
          if (this.mirrorRenderer) {
            this.mirrorRenderer.renderSegs(segs, { isDragging: true, sourceSeg })
          }
        }
                // if it would be impossible to render a drag mirror OR this component likes to render
        // highlights, then render a highlight.
        if (!isEvent || this.doesDragHighlight) {
          if (this.fillRenderer) {
            this.fillRenderer.renderSegs('highlight', segs)
          }
        }
      }
    }
    */
    // Hit System
    // -----------------------------------------------------------------------------------------------------------------


    DateComponent.prototype.buildPositionCaches = function () {};

    DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
      return null; // this should be abstract
    }; // Validation
    // -----------------------------------------------------------------------------------------------------------------


    DateComponent.prototype.isInteractionValid = function (interaction) {
      var calendar = this.calendar;
      var dateProfile = this.props.dateProfile; // HACK

      var instances = interaction.mutatedEvents.instances;

      if (dateProfile) {
        // HACK for DayTile
        for (var instanceId in instances) {
          if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
            return false;
          }
        }
      }

      return isInteractionValid(interaction, calendar);
    };

    DateComponent.prototype.isDateSelectionValid = function (selection) {
      var dateProfile = this.props.dateProfile; // HACK

      if (dateProfile && // HACK for DayTile
      !rangeContainsRange(dateProfile.validRange, selection.range)) {
        return false;
      }

      return isDateSelectionValid(selection, this.calendar);
    }; // Triggering
    // -----------------------------------------------------------------------------------------------------------------
    // TODO: move to Calendar


    DateComponent.prototype.publiclyTrigger = function (name, args) {
      var calendar = this.calendar;
      return calendar.publiclyTrigger(name, args);
    };

    DateComponent.prototype.publiclyTriggerAfterSizing = function (name, args) {
      var calendar = this.calendar;
      return calendar.publiclyTriggerAfterSizing(name, args);
    };

    DateComponent.prototype.hasPublicHandlers = function (name) {
      var calendar = this.calendar;
      return calendar.hasPublicHandlers(name);
    };

    DateComponent.prototype.triggerRenderedSegs = function (segs, isMirrors) {
      var calendar = this.calendar;

      if (this.hasPublicHandlers('eventPositioned')) {
        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
          var seg = segs_1[_i];
          this.publiclyTriggerAfterSizing('eventPositioned', [{
            event: new EventApi(calendar, seg.eventRange.def, seg.eventRange.instance),
            isMirror: isMirrors,
            isStart: seg.isStart,
            isEnd: seg.isEnd,
            el: seg.el,
            view: this // safe to cast because this method is only called on context.view

          }]);
        }
      }

      if (!calendar.state.loadingLevel) {
        // avoid initial empty state while pending
        calendar.afterSizingTriggers._eventsPositioned = [null]; // fire once
      }
    };

    DateComponent.prototype.triggerWillRemoveSegs = function (segs, isMirrors) {
      var calendar = this.calendar;

      for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
        var seg = segs_2[_i];
        calendar.trigger('eventElRemove', seg.el);
      }

      if (this.hasPublicHandlers('eventDestroy')) {
        for (var _a = 0, segs_3 = segs; _a < segs_3.length; _a++) {
          var seg = segs_3[_a];
          this.publiclyTrigger('eventDestroy', [{
            event: new EventApi(calendar, seg.eventRange.def, seg.eventRange.instance),
            isMirror: isMirrors,
            el: seg.el,
            view: this // safe to cast because this method is only called on context.view

          }]);
        }
      }
    }; // Pointer Interaction Utils
    // -----------------------------------------------------------------------------------------------------------------


    DateComponent.prototype.isValidSegDownEl = function (el) {
      return !this.props.eventDrag && // HACK
      !this.props.eventResize && // HACK
      !elementClosest(el, '.fc-mirror') && (this.isPopover() || !this.isInPopover(el)); // ^above line ensures we don't detect a seg interaction within a nested component.
      // it's a HACK because it only supports a popover as the nested component.
    };

    DateComponent.prototype.isValidDateDownEl = function (el) {
      var segEl = elementClosest(el, this.fgSegSelector);
      return (!segEl || segEl.classList.contains('fc-mirror')) && !elementClosest(el, '.fc-more') && // a "more.." link
      !elementClosest(el, 'a[data-goto]') && // a clickable nav link
      !this.isInPopover(el);
    };

    DateComponent.prototype.isPopover = function () {
      return this.el.classList.contains('fc-popover');
    };

    DateComponent.prototype.isInPopover = function (el) {
      return Boolean(elementClosest(el, '.fc-popover'));
    };

    return DateComponent;
  }(Component);

  DateComponent.prototype.fgSegSelector = '.fc-event-container > *';
  DateComponent.prototype.bgSegSelector = '.fc-bgevent:not(.fc-nonbusiness)';
  var uid$1 = 0;

  function createPlugin(input) {
    return {
      id: String(uid$1++),
      deps: input.deps || [],
      reducers: input.reducers || [],
      eventDefParsers: input.eventDefParsers || [],
      isDraggableTransformers: input.isDraggableTransformers || [],
      eventDragMutationMassagers: input.eventDragMutationMassagers || [],
      eventDefMutationAppliers: input.eventDefMutationAppliers || [],
      dateSelectionTransformers: input.dateSelectionTransformers || [],
      datePointTransforms: input.datePointTransforms || [],
      dateSpanTransforms: input.dateSpanTransforms || [],
      views: input.views || {},
      viewPropsTransformers: input.viewPropsTransformers || [],
      isPropsValid: input.isPropsValid || null,
      externalDefTransforms: input.externalDefTransforms || [],
      eventResizeJoinTransforms: input.eventResizeJoinTransforms || [],
      viewContainerModifiers: input.viewContainerModifiers || [],
      eventDropTransformers: input.eventDropTransformers || [],
      componentInteractions: input.componentInteractions || [],
      calendarInteractions: input.calendarInteractions || [],
      themeClasses: input.themeClasses || {},
      eventSourceDefs: input.eventSourceDefs || [],
      cmdFormatter: input.cmdFormatter,
      recurringTypes: input.recurringTypes || [],
      namedTimeZonedImpl: input.namedTimeZonedImpl,
      defaultView: input.defaultView || '',
      elementDraggingImpl: input.elementDraggingImpl,
      optionChangeHandlers: input.optionChangeHandlers || {}
    };
  }

  var PluginSystem =
  /** @class */
  function () {
    function PluginSystem() {
      this.hooks = {
        reducers: [],
        eventDefParsers: [],
        isDraggableTransformers: [],
        eventDragMutationMassagers: [],
        eventDefMutationAppliers: [],
        dateSelectionTransformers: [],
        datePointTransforms: [],
        dateSpanTransforms: [],
        views: {},
        viewPropsTransformers: [],
        isPropsValid: null,
        externalDefTransforms: [],
        eventResizeJoinTransforms: [],
        viewContainerModifiers: [],
        eventDropTransformers: [],
        componentInteractions: [],
        calendarInteractions: [],
        themeClasses: {},
        eventSourceDefs: [],
        cmdFormatter: null,
        recurringTypes: [],
        namedTimeZonedImpl: null,
        defaultView: '',
        elementDraggingImpl: null,
        optionChangeHandlers: {}
      };
      this.addedHash = {};
    }

    PluginSystem.prototype.add = function (plugin) {
      if (!this.addedHash[plugin.id]) {
        this.addedHash[plugin.id] = true;

        for (var _i = 0, _a = plugin.deps; _i < _a.length; _i++) {
          var dep = _a[_i];
          this.add(dep);
        }

        this.hooks = combineHooks(this.hooks, plugin);
      }
    };

    return PluginSystem;
  }();

  function combineHooks(hooks0, hooks1) {
    return {
      reducers: hooks0.reducers.concat(hooks1.reducers),
      eventDefParsers: hooks0.eventDefParsers.concat(hooks1.eventDefParsers),
      isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
      eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
      eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
      dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
      datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
      dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
      views: _assign({}, hooks0.views, hooks1.views),
      viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
      isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
      externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
      eventResizeJoinTransforms: hooks0.eventResizeJoinTransforms.concat(hooks1.eventResizeJoinTransforms),
      viewContainerModifiers: hooks0.viewContainerModifiers.concat(hooks1.viewContainerModifiers),
      eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
      calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
      componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
      themeClasses: _assign({}, hooks0.themeClasses, hooks1.themeClasses),
      eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
      cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
      recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
      namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
      defaultView: hooks0.defaultView || hooks1.defaultView,
      elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
      optionChangeHandlers: _assign({}, hooks0.optionChangeHandlers, hooks1.optionChangeHandlers)
    };
  }

  var eventSourceDef = {
    ignoreRange: true,
    parseMeta: function parseMeta(raw) {
      if (Array.isArray(raw)) {
        // short form
        return raw;
      } else if (Array.isArray(raw.events)) {
        return raw.events;
      }

      return null;
    },
    fetch: function fetch(arg, success) {
      success({
        rawEvents: arg.eventSource.meta
      });
    }
  };
  var ArrayEventSourcePlugin = createPlugin({
    eventSourceDefs: [eventSourceDef]
  });
  var eventSourceDef$1 = {
    parseMeta: function parseMeta(raw) {
      if (typeof raw === 'function') {
        // short form
        return raw;
      } else if (typeof raw.events === 'function') {
        return raw.events;
      }

      return null;
    },
    fetch: function fetch(arg, success, failure) {
      var dateEnv = arg.calendar.dateEnv;
      var func = arg.eventSource.meta;
      unpromisify(func.bind(null, {
        start: dateEnv.toDate(arg.range.start),
        end: dateEnv.toDate(arg.range.end),
        startStr: dateEnv.formatIso(arg.range.start),
        endStr: dateEnv.formatIso(arg.range.end),
        timeZone: dateEnv.timeZone
      }), function (rawEvents) {
        success({
          rawEvents: rawEvents
        }); // needs an object response
      }, failure // send errorObj directly to failure callback
      );
    }
  };
  var FuncEventSourcePlugin = createPlugin({
    eventSourceDefs: [eventSourceDef$1]
  });

  function requestJson(method, url, params, successCallback, failureCallback) {
    method = method.toUpperCase();
    var body = null;

    if (method === 'GET') {
      url = injectQueryStringParams(url, params);
    } else {
      body = encodeParams(params);
    }

    var xhr = new XMLHttpRequest();
    xhr.open(method, url, true);

    if (method !== 'GET') {
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    }

    xhr.onload = function () {
      if (xhr.status >= 200 && xhr.status < 400) {
        try {
          var res = JSON.parse(xhr.responseText);
          successCallback(res, xhr);
        } catch (err) {
          failureCallback('Failure parsing JSON', xhr);
        }
      } else {
        failureCallback('Request failed', xhr);
      }
    };

    xhr.onerror = function () {
      failureCallback('Request failed', xhr);
    };

    xhr.send(body);
  }

  function injectQueryStringParams(url, params) {
    return url + (url.indexOf('?') === -1 ? '?' : '&') + encodeParams(params);
  }

  function encodeParams(params) {
    var parts = [];

    for (var key in params) {
      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
    }

    return parts.join('&');
  }

  var eventSourceDef$2 = {
    parseMeta: function parseMeta(raw) {
      if (typeof raw === 'string') {
        // short form
        raw = {
          url: raw
        };
      } else if (!raw || _typeof(raw) !== 'object' || !raw.url) {
        return null;
      }

      return {
        url: raw.url,
        method: (raw.method || 'GET').toUpperCase(),
        extraParams: raw.extraParams,
        startParam: raw.startParam,
        endParam: raw.endParam,
        timeZoneParam: raw.timeZoneParam
      };
    },
    fetch: function fetch(arg, success, failure) {
      var meta = arg.eventSource.meta;
      var requestParams = buildRequestParams(meta, arg.range, arg.calendar);
      requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {
        success({
          rawEvents: rawEvents,
          xhr: xhr
        });
      }, function (errorMessage, xhr) {
        failure({
          message: errorMessage,
          xhr: xhr
        });
      });
    }
  };
  var JsonFeedEventSourcePlugin = createPlugin({
    eventSourceDefs: [eventSourceDef$2]
  });

  function buildRequestParams(meta, range, calendar) {
    var dateEnv = calendar.dateEnv;
    var startParam;
    var endParam;
    var timeZoneParam;
    var customRequestParams;
    var params = {};
    startParam = meta.startParam;

    if (startParam == null) {
      startParam = calendar.opt('startParam');
    }

    endParam = meta.endParam;

    if (endParam == null) {
      endParam = calendar.opt('endParam');
    }

    timeZoneParam = meta.timeZoneParam;

    if (timeZoneParam == null) {
      timeZoneParam = calendar.opt('timeZoneParam');
    } // retrieve any outbound GET/POST data from the options


    if (typeof meta.extraParams === 'function') {
      // supplied as a function that returns a key/value object
      customRequestParams = meta.extraParams();
    } else {
      // probably supplied as a straight key/value object
      customRequestParams = meta.extraParams || {};
    }

    _assign(params, customRequestParams);

    params[startParam] = dateEnv.formatIso(range.start);
    params[endParam] = dateEnv.formatIso(range.end);

    if (dateEnv.timeZone !== 'local') {
      params[timeZoneParam] = dateEnv.timeZone;
    }

    return params;
  }

  var recurring = {
    parse: function parse(rawEvent, leftoverProps, dateEnv) {
      var createMarker = dateEnv.createMarker.bind(dateEnv);
      var processors = {
        daysOfWeek: null,
        startTime: createDuration,
        endTime: createDuration,
        startRecur: createMarker,
        endRecur: createMarker
      };
      var props = refineProps(rawEvent, processors, {}, leftoverProps);
      var anyValid = false;

      for (var propName in props) {
        if (props[propName] != null) {
          anyValid = true;
          break;
        }
      }

      if (anyValid) {
        var duration = null;

        if ('duration' in leftoverProps) {
          duration = createDuration(leftoverProps.duration);
          delete leftoverProps.duration;
        }

        if (!duration && props.startTime && props.endTime) {
          duration = subtractDurations(props.endTime, props.startTime);
        }

        return {
          allDayGuess: Boolean(!props.startTime && !props.endTime),
          duration: duration,
          typeData: props // doesn't need endTime anymore but oh well

        };
      }

      return null;
    },
    expand: function expand(typeData, framingRange, dateEnv) {
      var clippedFramingRange = intersectRanges(framingRange, {
        start: typeData.startRecur,
        end: typeData.endRecur
      });

      if (clippedFramingRange) {
        return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
      } else {
        return [];
      }
    }
  };
  var SimpleRecurrencePlugin = createPlugin({
    recurringTypes: [recurring]
  });

  function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {
    var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
    var dayMarker = startOfDay(framingRange.start);
    var endMarker = framingRange.end;
    var instanceStarts = [];

    while (dayMarker < endMarker) {
      var instanceStart // if everyday, or this particular day-of-week
      = void 0; // if everyday, or this particular day-of-week

      if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
        if (startTime) {
          instanceStart = dateEnv.add(dayMarker, startTime);
        } else {
          instanceStart = dayMarker;
        }

        instanceStarts.push(instanceStart);
      }

      dayMarker = addDays(dayMarker, 1);
    }

    return instanceStarts;
  }

  var DefaultOptionChangeHandlers = createPlugin({
    optionChangeHandlers: {
      events: function events(_events, calendar, deepEqual) {
        handleEventSources([_events], calendar, deepEqual);
      },
      eventSources: handleEventSources,
      plugins: handlePlugins
    }
  });

  function handleEventSources(inputs, calendar, deepEqual) {
    var unfoundSources = hashValuesToArray(calendar.state.eventSources);
    var newInputs = [];

    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
      var input = inputs_1[_i];
      var inputFound = false;

      for (var i = 0; i < unfoundSources.length; i++) {
        if (deepEqual(unfoundSources[i]._raw, input)) {
          unfoundSources.splice(i, 1); // delete

          inputFound = true;
          break;
        }
      }

      if (!inputFound) {
        newInputs.push(input);
      }
    }

    for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {
      var unfoundSource = unfoundSources_1[_a];
      calendar.dispatch({
        type: 'REMOVE_EVENT_SOURCE',
        sourceId: unfoundSource.sourceId
      });
    }

    for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {
      var newInput = newInputs_1[_b];
      calendar.addEventSource(newInput);
    }
  } // shortcoming: won't remove plugins


  function handlePlugins(inputs, calendar) {
    calendar.addPluginInputs(inputs); // will gracefully handle duplicates
  }

  var config = {}; // TODO: make these options

  var globalDefaults = {
    defaultRangeSeparator: ' - ',
    titleRangeSeparator: " \u2013 ",
    defaultTimedEventDuration: '01:00:00',
    defaultAllDayEventDuration: {
      day: 1
    },
    forceEventDuration: false,
    nextDayThreshold: '00:00:00',
    // display
    columnHeader: true,
    defaultView: '',
    aspectRatio: 1.35,
    header: {
      left: 'title',
      center: '',
      right: 'today prev,next'
    },
    weekends: true,
    weekNumbers: false,
    weekNumberCalculation: 'local',
    editable: false,
    // nowIndicator: false,
    scrollTime: '06:00:00',
    minTime: '00:00:00',
    maxTime: '24:00:00',
    showNonCurrentDates: true,
    // event ajax
    lazyFetching: true,
    startParam: 'start',
    endParam: 'end',
    timeZoneParam: 'timeZone',
    timeZone: 'local',
    // allDayDefault: undefined,
    // locale
    locales: [],
    locale: '',
    // dir: will get this from the default locale
    // buttonIcons: null,
    // allows setting a min-height to the event segment to prevent short events overlapping each other
    timeGridEventMinHeight: 0,
    themeSystem: 'standard',
    // eventResizableFromStart: false,
    dragRevertDuration: 500,
    dragScroll: true,
    allDayMaintainDuration: false,
    // selectable: false,
    unselectAuto: true,
    // selectMinDistance: 0,
    dropAccept: '*',
    eventOrder: 'start,-duration,allDay,title',
    // ^ if start tie, longer events go before shorter. final tie-breaker is title text
    // rerenderDelay: null,
    eventLimit: false,
    eventLimitClick: 'popover',
    dayPopoverFormat: {
      month: 'long',
      day: 'numeric',
      year: 'numeric'
    },
    handleWindowResize: true,
    windowResizeDelay: 100,
    longPressDelay: 1000,
    eventDragMinDistance: 5 // only applies to mouse

  };
  var rtlDefaults = {
    header: {
      left: 'next,prev today',
      center: '',
      right: 'title'
    },
    buttonIcons: {
      // TODO: make RTL support the responibility of the theme
      prev: 'fc-icon-chevron-right',
      next: 'fc-icon-chevron-left',
      prevYear: 'fc-icon-chevrons-right',
      nextYear: 'fc-icon-chevrons-left'
    }
  };
  var complexOptions = ['header', 'footer', 'buttonText', 'buttonIcons']; // Merges an array of option objects into a single object

  function mergeOptions(optionObjs) {
    return mergeProps(optionObjs, complexOptions);
  } // TODO: move this stuff to a "plugin"-related file...


  var INTERNAL_PLUGINS = [ArrayEventSourcePlugin, FuncEventSourcePlugin, JsonFeedEventSourcePlugin, SimpleRecurrencePlugin, DefaultOptionChangeHandlers];

  function refinePluginDefs(pluginInputs) {
    var plugins = [];

    for (var _i = 0, pluginInputs_1 = pluginInputs; _i < pluginInputs_1.length; _i++) {
      var pluginInput = pluginInputs_1[_i];

      if (typeof pluginInput === 'string') {
        var globalName = 'FullCalendar' + capitaliseFirstLetter(pluginInput);

        if (!window[globalName]) {
          console.warn('Plugin file not loaded for ' + pluginInput);
        } else {
          plugins.push(window[globalName]["default"]); // is an ES6 module
        }
      } else {
        plugins.push(pluginInput);
      }
    }

    return INTERNAL_PLUGINS.concat(plugins);
  }

  var RAW_EN_LOCALE = {
    code: 'en',
    week: {
      dow: 0,
      doy: 4 // 4 days need to be within the year to be considered the first week

    },
    dir: 'ltr',
    buttonText: {
      prev: 'prev',
      next: 'next',
      prevYear: 'prev year',
      nextYear: 'next year',
      year: 'year',
      today: 'today',
      month: 'month',
      week: 'week',
      day: 'day',
      list: 'list'
    },
    weekLabel: 'W',
    allDayText: 'all-day',
    eventLimitText: 'more',
    noEventsMessage: 'No events to display'
  };

  function parseRawLocales(explicitRawLocales) {
    var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';
    var globalArray = window['FullCalendarLocalesAll'] || []; // from locales-all.js

    var globalObject = window['FullCalendarLocales'] || {}; // from locales/*.js. keys are meaningless

    var allRawLocales = globalArray.concat( // globalArray is low prio
    hashValuesToArray(globalObject), // medium prio
    explicitRawLocales // highest prio
    );
    var rawLocaleMap = {
      en: RAW_EN_LOCALE // necessary?

    };

    for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {
      var rawLocale = allRawLocales_1[_i];
      rawLocaleMap[rawLocale.code] = rawLocale;
    }

    return {
      map: rawLocaleMap,
      defaultCode: defaultCode
    };
  }

  function buildLocale(inputSingular, available) {
    if (_typeof(inputSingular) === 'object' && !Array.isArray(inputSingular)) {
      return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
    } else {
      return queryLocale(inputSingular, available);
    }
  }

  function queryLocale(codeArg, available) {
    var codes = [].concat(codeArg || []); // will convert to array

    var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
    return parseLocale(codeArg, codes, raw);
  }

  function queryRawLocale(codes, available) {
    for (var i = 0; i < codes.length; i++) {
      var parts = codes[i].toLocaleLowerCase().split('-');

      for (var j = parts.length; j > 0; j--) {
        var simpleId = parts.slice(0, j).join('-');

        if (available[simpleId]) {
          return available[simpleId];
        }
      }
    }

    return null;
  }

  function parseLocale(codeArg, codes, raw) {
    var merged = mergeProps([RAW_EN_LOCALE, raw], ['buttonText']);
    delete merged.code; // don't want this part of the options

    var week = merged.week;
    delete merged.week;
    return {
      codeArg: codeArg,
      codes: codes,
      week: week,
      simpleNumberFormat: new Intl.NumberFormat(codeArg),
      options: merged
    };
  }

  var OptionsManager =
  /** @class */
  function () {
    function OptionsManager(overrides) {
      this.overrides = _assign({}, overrides); // make a copy

      this.dynamicOverrides = {};
      this.compute();
    }

    OptionsManager.prototype.mutate = function (updates, removals, isDynamic) {
      var overrideHash = isDynamic ? this.dynamicOverrides : this.overrides;

      _assign(overrideHash, updates);

      for (var _i = 0, removals_1 = removals; _i < removals_1.length; _i++) {
        var propName = removals_1[_i];
        delete overrideHash[propName];
      }

      this.compute();
    }; // Computes the flattened options hash for the calendar and assigns to `this.options`.
    // Assumes this.overrides and this.dynamicOverrides have already been initialized.


    OptionsManager.prototype.compute = function () {
      // TODO: not a very efficient system
      var locales = firstDefined( // explicit locale option given?
      this.dynamicOverrides.locales, this.overrides.locales, globalDefaults.locales);
      var locale = firstDefined( // explicit locales option given?
      this.dynamicOverrides.locale, this.overrides.locale, globalDefaults.locale);
      var available = parseRawLocales(locales);
      var localeDefaults = buildLocale(locale || available.defaultCode, available.map).options;
      var dir = firstDefined( // based on options computed so far, is direction RTL?
      this.dynamicOverrides.dir, this.overrides.dir, localeDefaults.dir);
      var dirDefaults = dir === 'rtl' ? rtlDefaults : {};
      this.dirDefaults = dirDefaults;
      this.localeDefaults = localeDefaults;
      this.computed = mergeOptions([globalDefaults, dirDefaults, localeDefaults, this.overrides, this.dynamicOverrides]);
    };

    return OptionsManager;
  }();

  var calendarSystemClassMap = {};

  function registerCalendarSystem(name, theClass) {
    calendarSystemClassMap[name] = theClass;
  }

  function createCalendarSystem(name) {
    return new calendarSystemClassMap[name]();
  }

  var GregorianCalendarSystem =
  /** @class */
  function () {
    function GregorianCalendarSystem() {}

    GregorianCalendarSystem.prototype.getMarkerYear = function (d) {
      return d.getUTCFullYear();
    };

    GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {
      return d.getUTCMonth();
    };

    GregorianCalendarSystem.prototype.getMarkerDay = function (d) {
      return d.getUTCDate();
    };

    GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {
      return arrayToUtcDate(arr);
    };

    GregorianCalendarSystem.prototype.markerToArray = function (marker) {
      return dateToUtcArray(marker);
    };

    return GregorianCalendarSystem;
  }();

  registerCalendarSystem('gregory', GregorianCalendarSystem);
  var ISO_RE = /^\s*(\d{4})(-(\d{2})(-(\d{2})([T ](\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;

  function parse(str) {
    var m = ISO_RE.exec(str);

    if (m) {
      var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number('0.' + m[12]) * 1000 : 0));

      if (isValidDate(marker)) {
        var timeZoneOffset = null;

        if (m[13]) {
          timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));
        }

        return {
          marker: marker,
          isTimeUnspecified: !m[6],
          timeZoneOffset: timeZoneOffset
        };
      }
    }

    return null;
  }

  var DateEnv =
  /** @class */
  function () {
    function DateEnv(settings) {
      var timeZone = this.timeZone = settings.timeZone;
      var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';

      if (settings.namedTimeZoneImpl && isNamedTimeZone) {
        this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
      }

      this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
      this.calendarSystem = createCalendarSystem(settings.calendarSystem);
      this.locale = settings.locale;
      this.weekDow = settings.locale.week.dow;
      this.weekDoy = settings.locale.week.doy;

      if (settings.weekNumberCalculation === 'ISO') {
        this.weekDow = 1;
        this.weekDoy = 4;
      }

      if (typeof settings.firstDay === 'number') {
        this.weekDow = settings.firstDay;
      }

      if (typeof settings.weekNumberCalculation === 'function') {
        this.weekNumberFunc = settings.weekNumberCalculation;
      }

      this.weekLabel = settings.weekLabel != null ? settings.weekLabel : settings.locale.options.weekLabel;
      this.cmdFormatter = settings.cmdFormatter;
    } // Creating / Parsing


    DateEnv.prototype.createMarker = function (input) {
      var meta = this.createMarkerMeta(input);

      if (meta === null) {
        return null;
      }

      return meta.marker;
    };

    DateEnv.prototype.createNowMarker = function () {
      if (this.canComputeOffset) {
        return this.timestampToMarker(new Date().valueOf());
      } else {
        // if we can't compute the current date val for a timezone,
        // better to give the current local date vals than UTC
        return arrayToUtcDate(dateToLocalArray(new Date()));
      }
    };

    DateEnv.prototype.createMarkerMeta = function (input) {
      if (typeof input === 'string') {
        return this.parse(input);
      }

      var marker = null;

      if (typeof input === 'number') {
        marker = this.timestampToMarker(input);
      } else if (input instanceof Date) {
        input = input.valueOf();

        if (!isNaN(input)) {
          marker = this.timestampToMarker(input);
        }
      } else if (Array.isArray(input)) {
        marker = arrayToUtcDate(input);
      }

      if (marker === null || !isValidDate(marker)) {
        return null;
      }

      return {
        marker: marker,
        isTimeUnspecified: false,
        forcedTzo: null
      };
    };

    DateEnv.prototype.parse = function (s) {
      var parts = parse(s);

      if (parts === null) {
        return null;
      }

      var marker = parts.marker;
      var forcedTzo = null;

      if (parts.timeZoneOffset !== null) {
        if (this.canComputeOffset) {
          marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);
        } else {
          forcedTzo = parts.timeZoneOffset;
        }
      }

      return {
        marker: marker,
        isTimeUnspecified: parts.isTimeUnspecified,
        forcedTzo: forcedTzo
      };
    }; // Accessors


    DateEnv.prototype.getYear = function (marker) {
      return this.calendarSystem.getMarkerYear(marker);
    };

    DateEnv.prototype.getMonth = function (marker) {
      return this.calendarSystem.getMarkerMonth(marker);
    }; // Adding / Subtracting


    DateEnv.prototype.add = function (marker, dur) {
      var a = this.calendarSystem.markerToArray(marker);
      a[0] += dur.years;
      a[1] += dur.months;
      a[2] += dur.days;
      a[6] += dur.milliseconds;
      return this.calendarSystem.arrayToMarker(a);
    };

    DateEnv.prototype.subtract = function (marker, dur) {
      var a = this.calendarSystem.markerToArray(marker);
      a[0] -= dur.years;
      a[1] -= dur.months;
      a[2] -= dur.days;
      a[6] -= dur.milliseconds;
      return this.calendarSystem.arrayToMarker(a);
    };

    DateEnv.prototype.addYears = function (marker, n) {
      var a = this.calendarSystem.markerToArray(marker);
      a[0] += n;
      return this.calendarSystem.arrayToMarker(a);
    };

    DateEnv.prototype.addMonths = function (marker, n) {
      var a = this.calendarSystem.markerToArray(marker);
      a[1] += n;
      return this.calendarSystem.arrayToMarker(a);
    }; // Diffing Whole Units


    DateEnv.prototype.diffWholeYears = function (m0, m1) {
      var calendarSystem = this.calendarSystem;

      if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
        return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
      }

      return null;
    };

    DateEnv.prototype.diffWholeMonths = function (m0, m1) {
      var calendarSystem = this.calendarSystem;

      if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
        return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
      }

      return null;
    }; // Range / Duration


    DateEnv.prototype.greatestWholeUnit = function (m0, m1) {
      var n = this.diffWholeYears(m0, m1);

      if (n !== null) {
        return {
          unit: 'year',
          value: n
        };
      }

      n = this.diffWholeMonths(m0, m1);

      if (n !== null) {
        return {
          unit: 'month',
          value: n
        };
      }

      n = diffWholeWeeks(m0, m1);

      if (n !== null) {
        return {
          unit: 'week',
          value: n
        };
      }

      n = diffWholeDays(m0, m1);

      if (n !== null) {
        return {
          unit: 'day',
          value: n
        };
      }

      n = diffHours(m0, m1);

      if (isInt(n)) {
        return {
          unit: 'hour',
          value: n
        };
      }

      n = diffMinutes(m0, m1);

      if (isInt(n)) {
        return {
          unit: 'minute',
          value: n
        };
      }

      n = diffSeconds(m0, m1);

      if (isInt(n)) {
        return {
          unit: 'second',
          value: n
        };
      }

      return {
        unit: 'millisecond',
        value: m1.valueOf() - m0.valueOf()
      };
    };

    DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {
      // TODO: can use greatestWholeUnit
      var diff;

      if (d.years) {
        diff = this.diffWholeYears(m0, m1);

        if (diff !== null) {
          return diff / asRoughYears(d);
        }
      }

      if (d.months) {
        diff = this.diffWholeMonths(m0, m1);

        if (diff !== null) {
          return diff / asRoughMonths(d);
        }
      }

      if (d.days) {
        diff = diffWholeDays(m0, m1);

        if (diff !== null) {
          return diff / asRoughDays(d);
        }
      }

      return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);
    }; // Start-Of


    DateEnv.prototype.startOf = function (m, unit) {
      if (unit === 'year') {
        return this.startOfYear(m);
      } else if (unit === 'month') {
        return this.startOfMonth(m);
      } else if (unit === 'week') {
        return this.startOfWeek(m);
      } else if (unit === 'day') {
        return startOfDay(m);
      } else if (unit === 'hour') {
        return startOfHour(m);
      } else if (unit === 'minute') {
        return startOfMinute(m);
      } else if (unit === 'second') {
        return startOfSecond(m);
      }
    };

    DateEnv.prototype.startOfYear = function (m) {
      return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m)]);
    };

    DateEnv.prototype.startOfMonth = function (m) {
      return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m)]);
    };

    DateEnv.prototype.startOfWeek = function (m) {
      return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m), m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7]);
    }; // Week Number


    DateEnv.prototype.computeWeekNumber = function (marker) {
      if (this.weekNumberFunc) {
        return this.weekNumberFunc(this.toDate(marker));
      } else {
        return weekOfYear(marker, this.weekDow, this.weekDoy);
      }
    }; // TODO: choke on timeZoneName: long


    DateEnv.prototype.format = function (marker, formatter, dateOptions) {
      if (dateOptions === void 0) {
        dateOptions = {};
      }

      return formatter.format({
        marker: marker,
        timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
      }, this);
    };

    DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {
      if (dateOptions === void 0) {
        dateOptions = {};
      }

      if (dateOptions.isEndExclusive) {
        end = addMs(end, -1);
      }

      return formatter.formatRange({
        marker: start,
        timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)
      }, {
        marker: end,
        timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
      }, this);
    };

    DateEnv.prototype.formatIso = function (marker, extraOptions) {
      if (extraOptions === void 0) {
        extraOptions = {};
      }

      var timeZoneOffset = null;

      if (!extraOptions.omitTimeZoneOffset) {
        if (extraOptions.forcedTzo != null) {
          timeZoneOffset = extraOptions.forcedTzo;
        } else {
          timeZoneOffset = this.offsetForMarker(marker);
        }
      }

      return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
    }; // TimeZone


    DateEnv.prototype.timestampToMarker = function (ms) {
      if (this.timeZone === 'local') {
        return arrayToUtcDate(dateToLocalArray(new Date(ms)));
      } else if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {
        return new Date(ms);
      } else {
        return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
      }
    };

    DateEnv.prototype.offsetForMarker = function (m) {
      if (this.timeZone === 'local') {
        return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert "inverse" offset to "normal" offset
      } else if (this.timeZone === 'UTC') {
        return 0;
      } else if (this.namedTimeZoneImpl) {
        return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));
      }

      return null;
    }; // Conversion


    DateEnv.prototype.toDate = function (m, forcedTzo) {
      if (this.timeZone === 'local') {
        return arrayToLocalDate(dateToUtcArray(m));
      } else if (this.timeZone === 'UTC') {
        return new Date(m.valueOf()); // make sure it's a copy
      } else if (!this.namedTimeZoneImpl) {
        return new Date(m.valueOf() - (forcedTzo || 0));
      } else {
        return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60 // convert minutes -> ms
        );
      }
    };

    return DateEnv;
  }();

  var SIMPLE_SOURCE_PROPS = {
    id: String,
    allDayDefault: Boolean,
    eventDataTransform: Function,
    success: Function,
    failure: Function
  };
  var uid$2 = 0;

  function doesSourceNeedRange(eventSource, calendar) {
    var defs = calendar.pluginSystem.hooks.eventSourceDefs;
    return !defs[eventSource.sourceDefId].ignoreRange;
  }

  function parseEventSource(raw, calendar) {
    var defs = calendar.pluginSystem.hooks.eventSourceDefs;

    for (var i = defs.length - 1; i >= 0; i--) {
      // later-added plugins take precedence
      var def = defs[i];
      var meta = def.parseMeta(raw);

      if (meta) {
        var res = parseEventSourceProps(_typeof(raw) === 'object' ? raw : {}, meta, i, calendar);
        res._raw = raw;
        return res;
      }
    }

    return null;
  }

  function parseEventSourceProps(raw, meta, sourceDefId, calendar) {
    var leftovers0 = {};
    var props = refineProps(raw, SIMPLE_SOURCE_PROPS, {}, leftovers0);
    var leftovers1 = {};
    var ui = processUnscopedUiProps(leftovers0, calendar, leftovers1);
    props.isFetching = false;
    props.latestFetchId = '';
    props.fetchRange = null;
    props.publicId = String(raw.id || '');
    props.sourceId = String(uid$2++);
    props.sourceDefId = sourceDefId;
    props.meta = meta;
    props.ui = ui;
    props.extendedProps = leftovers1;
    return props;
  }

  function reduceEventSources(eventSources, action, dateProfile, calendar) {
    switch (action.type) {
      case 'ADD_EVENT_SOURCES':
        // already parsed
        return addSources(eventSources, action.sources, dateProfile ? dateProfile.activeRange : null, calendar);

      case 'REMOVE_EVENT_SOURCE':
        return removeSource(eventSources, action.sourceId);

      case 'PREV': // TODO: how do we track all actions that affect dateProfile :(

      case 'NEXT':
      case 'SET_DATE':
      case 'SET_VIEW_TYPE':
        if (dateProfile) {
          return fetchDirtySources(eventSources, dateProfile.activeRange, calendar);
        } else {
          return eventSources;
        }

      case 'FETCH_EVENT_SOURCES':
      case 'CHANGE_TIMEZONE':
        return fetchSourcesByIds(eventSources, action.sourceIds ? arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, calendar), dateProfile ? dateProfile.activeRange : null, calendar);

      case 'RECEIVE_EVENTS':
      case 'RECEIVE_EVENT_ERROR':
        return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);

      case 'REMOVE_ALL_EVENT_SOURCES':
        return {};

      default:
        return eventSources;
    }
  }

  var uid$3 = 0;

  function addSources(eventSourceHash, sources, fetchRange, calendar) {
    var hash = {};

    for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {
      var source = sources_1[_i];
      hash[source.sourceId] = source;
    }

    if (fetchRange) {
      hash = fetchDirtySources(hash, fetchRange, calendar);
    }

    return _assign({}, eventSourceHash, hash);
  }

  function removeSource(eventSourceHash, sourceId) {
    return filterHash(eventSourceHash, function (eventSource) {
      return eventSource.sourceId !== sourceId;
    });
  }

  function fetchDirtySources(sourceHash, fetchRange, calendar) {
    return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) {
      return isSourceDirty(eventSource, fetchRange, calendar);
    }), fetchRange, calendar);
  }

  function isSourceDirty(eventSource, fetchRange, calendar) {
    if (!doesSourceNeedRange(eventSource, calendar)) {
      return !eventSource.latestFetchId;
    } else {
      return !calendar.opt('lazyFetching') || !eventSource.fetchRange || fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
    }
  }

  function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, calendar) {
    var nextSources = {};

    for (var sourceId in prevSources) {
      var source = prevSources[sourceId];

      if (sourceIdHash[sourceId]) {
        nextSources[sourceId] = fetchSource(source, fetchRange, calendar);
      } else {
        nextSources[sourceId] = source;
      }
    }

    return nextSources;
  }

  function fetchSource(eventSource, fetchRange, calendar) {
    var sourceDef = calendar.pluginSystem.hooks.eventSourceDefs[eventSource.sourceDefId];
    var fetchId = String(uid$3++);
    sourceDef.fetch({
      eventSource: eventSource,
      calendar: calendar,
      range: fetchRange
    }, function (res) {
      var rawEvents = res.rawEvents;
      var calSuccess = calendar.opt('eventSourceSuccess');
      var calSuccessRes;
      var sourceSuccessRes;

      if (eventSource.success) {
        sourceSuccessRes = eventSource.success(rawEvents, res.xhr);
      }

      if (calSuccess) {
        calSuccessRes = calSuccess(rawEvents, res.xhr);
      }

      rawEvents = sourceSuccessRes || calSuccessRes || rawEvents;
      calendar.dispatch({
        type: 'RECEIVE_EVENTS',
        sourceId: eventSource.sourceId,
        fetchId: fetchId,
        fetchRange: fetchRange,
        rawEvents: rawEvents
      });
    }, function (error) {
      var callFailure = calendar.opt('eventSourceFailure');
      console.warn(error.message, error);

      if (eventSource.failure) {
        eventSource.failure(error);
      }

      if (callFailure) {
        callFailure(error);
      }

      calendar.dispatch({
        type: 'RECEIVE_EVENT_ERROR',
        sourceId: eventSource.sourceId,
        fetchId: fetchId,
        fetchRange: fetchRange,
        error: error
      });
    });
    return _assign({}, eventSource, {
      isFetching: true,
      latestFetchId: fetchId
    });
  }

  function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
    var _a;

    var eventSource = sourceHash[sourceId];

    if (eventSource && // not already removed
    fetchId === eventSource.latestFetchId) {
      return _assign({}, sourceHash, (_a = {}, _a[sourceId] = _assign({}, eventSource, {
        isFetching: false,
        fetchRange: fetchRange
      }), _a));
    }

    return sourceHash;
  }

  function excludeStaticSources(eventSources, calendar) {
    return filterHash(eventSources, function (eventSource) {
      return doesSourceNeedRange(eventSource, calendar);
    });
  }

  var DateProfileGenerator =
  /** @class */
  function () {
    function DateProfileGenerator(viewSpec, calendar) {
      this.viewSpec = viewSpec;
      this.options = viewSpec.options;
      this.dateEnv = calendar.dateEnv;
      this.calendar = calendar;
      this.initHiddenDays();
    }
    /* Date Range Computation
    ------------------------------------------------------------------------------------------------------------------*/
    // Builds a structure with info about what the dates/ranges will be for the "prev" view.


    DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate) {
      var dateEnv = this.dateEnv;
      var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
      currentDateProfile.dateIncrement);
      return this.build(prevDate, -1);
    }; // Builds a structure with info about what the dates/ranges will be for the "next" view.


    DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate) {
      var dateEnv = this.dateEnv;
      var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
      currentDateProfile.dateIncrement);
      return this.build(nextDate, 1);
    }; // Builds a structure holding dates/ranges for rendering around the given date.
    // Optional direction param indicates whether the date is being incremented/decremented
    // from its previous value. decremented = -1, incremented = 1 (default).


    DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {
      if (forceToValid === void 0) {
        forceToValid = false;
      }

      var validRange;
      var minTime = null;
      var maxTime = null;
      var currentInfo;
      var isRangeAllDay;
      var renderRange;
      var activeRange;
      var isValid;
      validRange = this.buildValidRange();
      validRange = this.trimHiddenDays(validRange);

      if (forceToValid) {
        currentDate = constrainMarkerToRange(currentDate, validRange);
      }

      currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
      isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
      renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
      renderRange = this.trimHiddenDays(renderRange);
      activeRange = renderRange;

      if (!this.options.showNonCurrentDates) {
        activeRange = intersectRanges(activeRange, currentInfo.range);
      }

      minTime = createDuration(this.options.minTime);
      maxTime = createDuration(this.options.maxTime);
      activeRange = this.adjustActiveRange(activeRange, minTime, maxTime);
      activeRange = intersectRanges(activeRange, validRange); // might return null
      // it's invalid if the originally requested date is not contained,
      // or if the range is completely outside of the valid range.

      isValid = rangesIntersect(currentInfo.range, validRange);
      return {
        // constraint for where prev/next operations can go and where events can be dragged/resized to.
        // an object with optional start and end properties.
        validRange: validRange,
        // range the view is formally responsible for.
        // for example, a month view might have 1st-31st, excluding padded dates
        currentRange: currentInfo.range,
        // name of largest unit being displayed, like "month" or "week"
        currentRangeUnit: currentInfo.unit,
        isRangeAllDay: isRangeAllDay,
        // dates that display events and accept drag-n-drop
        // will be `null` if no dates accept events
        activeRange: activeRange,
        // date range with a rendered skeleton
        // includes not-active days that need some sort of DOM
        renderRange: renderRange,
        // Duration object that denotes the first visible time of any given day
        minTime: minTime,
        // Duration object that denotes the exclusive visible end time of any given day
        maxTime: maxTime,
        isValid: isValid,
        // how far the current date will move for a prev/next operation
        dateIncrement: this.buildDateIncrement(currentInfo.duration) // pass a fallback (might be null) ^

      };
    }; // Builds an object with optional start/end properties.
    // Indicates the minimum/maximum dates to display.
    // not responsible for trimming hidden days.


    DateProfileGenerator.prototype.buildValidRange = function () {
      return this.getRangeOption('validRange', this.calendar.getNow()) || {
        start: null,
        end: null
      }; // completely open-ended
    }; // Builds a structure with info about the "current" range, the range that is
    // highlighted as being the current month for example.
    // See build() for a description of `direction`.
    // Guaranteed to have `range` and `unit` properties. `duration` is optional.


    DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {
      var _a = this,
          viewSpec = _a.viewSpec,
          dateEnv = _a.dateEnv;

      var duration = null;
      var unit = null;
      var range = null;
      var dayCount;

      if (viewSpec.duration) {
        duration = viewSpec.duration;
        unit = viewSpec.durationUnit;
        range = this.buildRangeFromDuration(date, direction, duration, unit);
      } else if (dayCount = this.options.dayCount) {
        unit = 'day';
        range = this.buildRangeFromDayCount(date, direction, dayCount);
      } else if (range = this.buildCustomVisibleRange(date)) {
        unit = dateEnv.greatestWholeUnit(range.start, range.end).unit;
      } else {
        duration = this.getFallbackDuration();
        unit = greatestDurationDenominator(duration).unit;
        range = this.buildRangeFromDuration(date, direction, duration, unit);
      }

      return {
        duration: duration,
        unit: unit,
        range: range
      };
    };

    DateProfileGenerator.prototype.getFallbackDuration = function () {
      return createDuration({
        day: 1
      });
    }; // Returns a new activeRange to have time values (un-ambiguate)
    // minTime or maxTime causes the range to expand.


    DateProfileGenerator.prototype.adjustActiveRange = function (range, minTime, maxTime) {
      var dateEnv = this.dateEnv;
      var start = range.start;
      var end = range.end;

      if (this.viewSpec["class"].prototype.usesMinMaxTime) {
        // expand active range if minTime is negative (why not when positive?)
        if (asRoughDays(minTime) < 0) {
          start = startOfDay(start); // necessary?

          start = dateEnv.add(start, minTime);
        } // expand active range if maxTime is beyond one day (why not when positive?)


        if (asRoughDays(maxTime) > 1) {
          end = startOfDay(end); // necessary?

          end = addDays(end, -1);
          end = dateEnv.add(end, maxTime);
        }
      }

      return {
        start: start,
        end: end
      };
    }; // Builds the "current" range when it is specified as an explicit duration.
    // `unit` is the already-computed greatestDurationDenominator unit of duration.


    DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {
      var dateEnv = this.dateEnv;
      var alignment = this.options.dateAlignment;
      var dateIncrementInput;
      var dateIncrementDuration;
      var start;
      var end;
      var res; // compute what the alignment should be

      if (!alignment) {
        dateIncrementInput = this.options.dateIncrement;

        if (dateIncrementInput) {
          dateIncrementDuration = createDuration(dateIncrementInput); // use the smaller of the two units

          if (asRoughMs(dateIncrementDuration) < asRoughMs(duration)) {
            alignment = greatestDurationDenominator(dateIncrementDuration, !getWeeksFromInput(dateIncrementInput)).unit;
          } else {
            alignment = unit;
          }
        } else {
          alignment = unit;
        }
      } // if the view displays a single day or smaller


      if (asRoughDays(duration) <= 1) {
        if (this.isHiddenDay(start)) {
          start = this.skipHiddenDays(start, direction);
          start = startOfDay(start);
        }
      }

      function computeRes() {
        start = dateEnv.startOf(date, alignment);
        end = dateEnv.add(start, duration);
        res = {
          start: start,
          end: end
        };
      }

      computeRes(); // if range is completely enveloped by hidden days, go past the hidden days

      if (!this.trimHiddenDays(res)) {
        date = this.skipHiddenDays(date, direction);
        computeRes();
      }

      return res;
    }; // Builds the "current" range when a dayCount is specified.


    DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {
      var dateEnv = this.dateEnv;
      var customAlignment = this.options.dateAlignment;
      var runningCount = 0;
      var start = date;
      var end;

      if (customAlignment) {
        start = dateEnv.startOf(start, customAlignment);
      }

      start = startOfDay(start);
      start = this.skipHiddenDays(start, direction);
      end = start;

      do {
        end = addDays(end, 1);

        if (!this.isHiddenDay(end)) {
          runningCount++;
        }
      } while (runningCount < dayCount);

      return {
        start: start,
        end: end
      };
    }; // Builds a normalized range object for the "visible" range,
    // which is a way to define the currentRange and activeRange at the same time.


    DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {
      var dateEnv = this.dateEnv;
      var visibleRange = this.getRangeOption('visibleRange', dateEnv.toDate(date));

      if (visibleRange && (visibleRange.start == null || visibleRange.end == null)) {
        return null;
      }

      return visibleRange;
    }; // Computes the range that will represent the element/cells for *rendering*,
    // but which may have voided days/times.
    // not responsible for trimming hidden days.


    DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
      return currentRange;
    }; // Compute the duration value that should be added/substracted to the current date
    // when a prev/next operation happens.


    DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {
      var dateIncrementInput = this.options.dateIncrement;
      var customAlignment;

      if (dateIncrementInput) {
        return createDuration(dateIncrementInput);
      } else if (customAlignment = this.options.dateAlignment) {
        return createDuration(1, customAlignment);
      } else if (fallback) {
        return fallback;
      } else {
        return createDuration({
          days: 1
        });
      }
    }; // Arguments after name will be forwarded to a hypothetical function value
    // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
    // Always clone your objects if you fear mutation.


    DateProfileGenerator.prototype.getRangeOption = function (name) {
      var otherArgs = [];

      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }

      var val = this.options[name];

      if (typeof val === 'function') {
        val = val.apply(null, otherArgs);
      }

      if (val) {
        val = parseRange(val, this.dateEnv);
      }

      if (val) {
        val = computeVisibleDayRange(val);
      }

      return val;
    };
    /* Hidden Days
    ------------------------------------------------------------------------------------------------------------------*/
    // Initializes internal variables related to calculating hidden days-of-week


    DateProfileGenerator.prototype.initHiddenDays = function () {
      var hiddenDays = this.options.hiddenDays || []; // array of day-of-week indices that are hidden

      var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)

      var dayCnt = 0;
      var i;

      if (this.options.weekends === false) {
        hiddenDays.push(0, 6); // 0=sunday, 6=saturday
      }

      for (i = 0; i < 7; i++) {
        if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {
          dayCnt++;
        }
      }

      if (!dayCnt) {
        throw new Error('invalid hiddenDays'); // all days were hidden? bad.
      }

      this.isHiddenDayHash = isHiddenDayHash;
    }; // Remove days from the beginning and end of the range that are computed as hidden.
    // If the whole range is trimmed off, returns null


    DateProfileGenerator.prototype.trimHiddenDays = function (range) {
      var start = range.start;
      var end = range.end;

      if (start) {
        start = this.skipHiddenDays(start);
      }

      if (end) {
        end = this.skipHiddenDays(end, -1, true);
      }

      if (start == null || end == null || start < end) {
        return {
          start: start,
          end: end
        };
      }

      return null;
    }; // Is the current day hidden?
    // `day` is a day-of-week index (0-6), or a Date (used for UTC)


    DateProfileGenerator.prototype.isHiddenDay = function (day) {
      if (day instanceof Date) {
        day = day.getUTCDay();
      }

      return this.isHiddenDayHash[day];
    }; // Incrementing the current day until it is no longer a hidden day, returning a copy.
    // DOES NOT CONSIDER validRange!
    // If the initial value of `date` is not a hidden day, don't do anything.
    // Pass `isExclusive` as `true` if you are dealing with an end date.
    // `inc` defaults to `1` (increment one day forward each time)


    DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {
      if (inc === void 0) {
        inc = 1;
      }

      if (isExclusive === void 0) {
        isExclusive = false;
      }

      while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
        date = addDays(date, inc);
      }

      return date;
    };

    return DateProfileGenerator;
  }(); // TODO: find a way to avoid comparing DateProfiles. it's tedious


  function isDateProfilesEqual(p0, p1) {
    return rangesEqual(p0.validRange, p1.validRange) && rangesEqual(p0.activeRange, p1.activeRange) && rangesEqual(p0.renderRange, p1.renderRange) && durationsEqual(p0.minTime, p1.minTime) && durationsEqual(p0.maxTime, p1.maxTime);
    /*
    TODO: compare more?
      currentRange: DateRange
      currentRangeUnit: string
      isRangeAllDay: boolean
      isValid: boolean
      dateIncrement: Duration
    */
  }

  function reduce(state, action, calendar) {
    var viewType = reduceViewType(state.viewType, action);
    var dateProfile = reduceDateProfile(state.dateProfile, action, state.currentDate, viewType, calendar);
    var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendar);

    var nextState = _assign({}, state, {
      viewType: viewType,
      dateProfile: dateProfile,
      currentDate: reduceCurrentDate(state.currentDate, action, dateProfile),
      eventSources: eventSources,
      eventStore: reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendar),
      dateSelection: reduceDateSelection(state.dateSelection, action, calendar),
      eventSelection: reduceSelectedEvent(state.eventSelection, action),
      eventDrag: reduceEventDrag(state.eventDrag, action, eventSources, calendar),
      eventResize: reduceEventResize(state.eventResize, action, eventSources, calendar),
      eventSourceLoadingLevel: computeLoadingLevel(eventSources),
      loadingLevel: computeLoadingLevel(eventSources)
    });

    for (var _i = 0, _a = calendar.pluginSystem.hooks.reducers; _i < _a.length; _i++) {
      var reducerFunc = _a[_i];
      nextState = reducerFunc(nextState, action, calendar);
    } // console.log(action.type, nextState)


    return nextState;
  }

  function reduceViewType(currentViewType, action) {
    switch (action.type) {
      case 'SET_VIEW_TYPE':
        return action.viewType;

      default:
        return currentViewType;
    }
  }

  function reduceDateProfile(currentDateProfile, action, currentDate, viewType, calendar) {
    var newDateProfile;

    switch (action.type) {
      case 'PREV':
        newDateProfile = calendar.dateProfileGenerators[viewType].buildPrev(currentDateProfile, currentDate);
        break;

      case 'NEXT':
        newDateProfile = calendar.dateProfileGenerators[viewType].buildNext(currentDateProfile, currentDate);
        break;

      case 'SET_DATE':
        if (!currentDateProfile.activeRange || !rangeContainsMarker(currentDateProfile.currentRange, action.dateMarker)) {
          newDateProfile = calendar.dateProfileGenerators[viewType].build(action.dateMarker, undefined, true // forceToValid
          );
        }

        break;

      case 'SET_VIEW_TYPE':
        var generator = calendar.dateProfileGenerators[viewType];

        if (!generator) {
          throw new Error(viewType ? 'The FullCalendar view "' + viewType + '" does not exist. Make sure your plugins are loaded correctly.' : 'No available FullCalendar view plugins.');
        }

        newDateProfile = generator.build(action.dateMarker || currentDate, undefined, true // forceToValid
        );
        break;
    }

    if (newDateProfile && newDateProfile.isValid && !(currentDateProfile && isDateProfilesEqual(currentDateProfile, newDateProfile))) {
      return newDateProfile;
    } else {
      return currentDateProfile;
    }
  }

  function reduceCurrentDate(currentDate, action, dateProfile) {
    switch (action.type) {
      case 'PREV':
      case 'NEXT':
        if (!rangeContainsMarker(dateProfile.currentRange, currentDate)) {
          return dateProfile.currentRange.start;
        } else {
          return currentDate;
        }

      case 'SET_DATE':
      case 'SET_VIEW_TYPE':
        var newDate = action.dateMarker || currentDate;

        if (dateProfile.activeRange && !rangeContainsMarker(dateProfile.activeRange, newDate)) {
          return dateProfile.currentRange.start;
        } else {
          return newDate;
        }

      default:
        return currentDate;
    }
  }

  function reduceDateSelection(currentSelection, action, calendar) {
    switch (action.type) {
      case 'SELECT_DATES':
        return action.selection;

      case 'UNSELECT_DATES':
        return null;

      default:
        return currentSelection;
    }
  }

  function reduceSelectedEvent(currentInstanceId, action) {
    switch (action.type) {
      case 'SELECT_EVENT':
        return action.eventInstanceId;

      case 'UNSELECT_EVENT':
        return '';

      default:
        return currentInstanceId;
    }
  }

  function reduceEventDrag(currentDrag, action, sources, calendar) {
    switch (action.type) {
      case 'SET_EVENT_DRAG':
        var newDrag = action.state;
        return {
          affectedEvents: newDrag.affectedEvents,
          mutatedEvents: newDrag.mutatedEvents,
          isEvent: newDrag.isEvent,
          origSeg: newDrag.origSeg
        };

      case 'UNSET_EVENT_DRAG':
        return null;

      default:
        return currentDrag;
    }
  }

  function reduceEventResize(currentResize, action, sources, calendar) {
    switch (action.type) {
      case 'SET_EVENT_RESIZE':
        var newResize = action.state;
        return {
          affectedEvents: newResize.affectedEvents,
          mutatedEvents: newResize.mutatedEvents,
          isEvent: newResize.isEvent,
          origSeg: newResize.origSeg
        };

      case 'UNSET_EVENT_RESIZE':
        return null;

      default:
        return currentResize;
    }
  }

  function computeLoadingLevel(eventSources) {
    var cnt = 0;

    for (var sourceId in eventSources) {
      if (eventSources[sourceId].isFetching) {
        cnt++;
      }
    }

    return cnt;
  }

  var STANDARD_PROPS = {
    start: null,
    end: null,
    allDay: Boolean
  };

  function parseDateSpan(raw, dateEnv, defaultDuration) {
    var span = parseOpenDateSpan(raw, dateEnv);
    var range = span.range;

    if (!range.start) {
      return null;
    }

    if (!range.end) {
      if (defaultDuration == null) {
        return null;
      } else {
        range.end = dateEnv.add(range.start, defaultDuration);
      }
    }

    return span;
  }
  /*
  TODO: somehow combine with parseRange?
  Will return null if the start/end props were present but parsed invalidly.
  */


  function parseOpenDateSpan(raw, dateEnv) {
    var leftovers = {};
    var standardProps = refineProps(raw, STANDARD_PROPS, {}, leftovers);
    var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
    var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
    var allDay = standardProps.allDay;

    if (allDay == null) {
      allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
    } // use this leftover object as the selection object


    leftovers.range = {
      start: startMeta ? startMeta.marker : null,
      end: endMeta ? endMeta.marker : null
    };
    leftovers.allDay = allDay;
    return leftovers;
  }

  function isDateSpansEqual(span0, span1) {
    return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
  } // the NON-DATE-RELATED props


  function isSpanPropsEqual(span0, span1) {
    for (var propName in span1) {
      if (propName !== 'range' && propName !== 'allDay') {
        if (span0[propName] !== span1[propName]) {
          return false;
        }
      }
    } // are there any props that span0 has that span1 DOESN'T have?
    // both have range/allDay, so no need to special-case.


    for (var propName in span0) {
      if (!(propName in span1)) {
        return false;
      }
    }

    return true;
  }

  function buildDateSpanApi(span, dateEnv) {
    return {
      start: dateEnv.toDate(span.range.start),
      end: dateEnv.toDate(span.range.end),
      startStr: dateEnv.formatIso(span.range.start, {
        omitTime: span.allDay
      }),
      endStr: dateEnv.formatIso(span.range.end, {
        omitTime: span.allDay
      }),
      allDay: span.allDay
    };
  }

  function buildDatePointApi(span, dateEnv) {
    return {
      date: dateEnv.toDate(span.range.start),
      dateStr: dateEnv.formatIso(span.range.start, {
        omitTime: span.allDay
      }),
      allDay: span.allDay
    };
  }

  function fabricateEventRange(dateSpan, eventUiBases, calendar) {
    var def = parseEventDef({
      editable: false
    }, '', // sourceId
    dateSpan.allDay, true, // hasEnd
    calendar);
    return {
      def: def,
      ui: compileEventUi(def, eventUiBases),
      instance: createEventInstance(def.defId, dateSpan.range),
      range: dateSpan.range,
      isStart: true,
      isEnd: true
    };
  }

  function compileViewDefs(defaultConfigs, overrideConfigs) {
    var hash = {};
    var viewType;

    for (viewType in defaultConfigs) {
      ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
    }

    for (viewType in overrideConfigs) {
      ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
    }

    return hash;
  }

  function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
    if (hash[viewType]) {
      return hash[viewType];
    }

    var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);

    if (viewDef) {
      hash[viewType] = viewDef;
    }

    return viewDef;
  }

  function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
    var defaultConfig = defaultConfigs[viewType];
    var overrideConfig = overrideConfigs[viewType];

    var queryProp = function queryProp(name) {
      return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
    };

    var theClass = queryProp('class');
    var superType = queryProp('superType');

    if (!superType && theClass) {
      superType = findViewNameBySubclass(theClass, overrideConfigs) || findViewNameBySubclass(theClass, defaultConfigs);
    }

    var superDef = null;

    if (superType) {
      if (superType === viewType) {
        throw new Error('Can\'t have a custom view type that references itself');
      }

      superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
    }

    if (!theClass && superDef) {
      theClass = superDef["class"];
    }

    if (!theClass) {
      return null; // don't throw a warning, might be settings for a single-unit view
    }

    return {
      type: viewType,
      "class": theClass,
      defaults: _assign({}, superDef ? superDef.defaults : {}, defaultConfig ? defaultConfig.options : {}),
      overrides: _assign({}, superDef ? superDef.overrides : {}, overrideConfig ? overrideConfig.options : {})
    };
  }

  function findViewNameBySubclass(viewSubclass, configs) {
    var superProto = Object.getPrototypeOf(viewSubclass.prototype);

    for (var viewType in configs) {
      var parsed = configs[viewType]; // need DIRECT subclass, so instanceof won't do it

      if (parsed["class"] && parsed["class"].prototype === superProto) {
        return viewType;
      }
    }

    return '';
  }

  function parseViewConfigs(inputs) {
    return mapHash(inputs, parseViewConfig);
  }

  var VIEW_DEF_PROPS = {
    type: String,
    "class": null
  };

  function parseViewConfig(input) {
    if (typeof input === 'function') {
      input = {
        "class": input
      };
    }

    var options = {};
    var props = refineProps(input, VIEW_DEF_PROPS, {}, options);
    return {
      superType: props.type,
      "class": props["class"],
      options: options
    };
  }

  function buildViewSpecs(defaultInputs, optionsManager) {
    var defaultConfigs = parseViewConfigs(defaultInputs);
    var overrideConfigs = parseViewConfigs(optionsManager.overrides.views);
    var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
    return mapHash(viewDefs, function (viewDef) {
      return buildViewSpec(viewDef, overrideConfigs, optionsManager);
    });
  }

  function buildViewSpec(viewDef, overrideConfigs, optionsManager) {
    var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || optionsManager.dynamicOverrides.duration || optionsManager.overrides.duration;
    var duration = null;
    var durationUnit = '';
    var singleUnit = '';
    var singleUnitOverrides = {};

    if (durationInput) {
      duration = createDuration(durationInput);

      if (duration) {
        // valid?
        var denom = greatestDurationDenominator(duration, !getWeeksFromInput(durationInput));
        durationUnit = denom.unit;

        if (denom.value === 1) {
          singleUnit = durationUnit;
          singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].options : {};
        }
      }
    }

    var queryButtonText = function queryButtonText(options) {
      var buttonTextMap = options.buttonText || {};
      var buttonTextKey = viewDef.defaults.buttonTextKey;

      if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
        return buttonTextMap[buttonTextKey];
      }

      if (buttonTextMap[viewDef.type] != null) {
        return buttonTextMap[viewDef.type];
      }

      if (buttonTextMap[singleUnit] != null) {
        return buttonTextMap[singleUnit];
      }
    };

    return {
      type: viewDef.type,
      "class": viewDef["class"],
      duration: duration,
      durationUnit: durationUnit,
      singleUnit: singleUnit,
      options: _assign({}, globalDefaults, viewDef.defaults, optionsManager.dirDefaults, optionsManager.localeDefaults, optionsManager.overrides, singleUnitOverrides, viewDef.overrides, optionsManager.dynamicOverrides),
      buttonTextOverride: queryButtonText(optionsManager.dynamicOverrides) || queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence
      viewDef.overrides.buttonText,
      buttonTextDefault: queryButtonText(optionsManager.localeDefaults) || queryButtonText(optionsManager.dirDefaults) || viewDef.defaults.buttonText || queryButtonText(globalDefaults) || viewDef.type // fall back to given view name

    };
  }

  var Toolbar =
  /** @class */
  function (_super) {
    __extends(Toolbar, _super);

    function Toolbar(context, extraClassName) {
      var _this = _super.call(this, context) || this;

      _this._renderLayout = memoizeRendering(_this.renderLayout, _this.unrenderLayout);
      _this._updateTitle = memoizeRendering(_this.updateTitle, null, [_this._renderLayout]);
      _this._updateActiveButton = memoizeRendering(_this.updateActiveButton, null, [_this._renderLayout]);
      _this._updateToday = memoizeRendering(_this.updateToday, null, [_this._renderLayout]);
      _this._updatePrev = memoizeRendering(_this.updatePrev, null, [_this._renderLayout]);
      _this._updateNext = memoizeRendering(_this.updateNext, null, [_this._renderLayout]);
      _this.el = createElement('div', {
        className: 'fc-toolbar ' + extraClassName
      });
      return _this;
    }

    Toolbar.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      this._renderLayout.unrender(); // should unrender everything else


      removeElement(this.el);
    };

    Toolbar.prototype.render = function (props) {
      this._renderLayout(props.layout);

      this._updateTitle(props.title);

      this._updateActiveButton(props.activeButton);

      this._updateToday(props.isTodayEnabled);

      this._updatePrev(props.isPrevEnabled);

      this._updateNext(props.isNextEnabled);
    };

    Toolbar.prototype.renderLayout = function (layout) {
      var el = this.el;
      this.viewsWithButtons = [];
      appendToElement(el, this.renderSection('left', layout.left));
      appendToElement(el, this.renderSection('center', layout.center));
      appendToElement(el, this.renderSection('right', layout.right));
    };

    Toolbar.prototype.unrenderLayout = function () {
      this.el.innerHTML = '';
    };

    Toolbar.prototype.renderSection = function (position, buttonStr) {
      var _this = this;

      var _a = this,
          theme = _a.theme,
          calendar = _a.calendar;

      var optionsManager = calendar.optionsManager;
      var viewSpecs = calendar.viewSpecs;
      var sectionEl = createElement('div', {
        className: 'fc-' + position
      });
      var calendarCustomButtons = optionsManager.computed.customButtons || {};
      var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};
      var calendarButtonText = optionsManager.computed.buttonText || {};

      if (buttonStr) {
        buttonStr.split(' ').forEach(function (buttonGroupStr, i) {
          var groupChildren = [];
          var isOnlyButtons = true;
          var groupEl;
          buttonGroupStr.split(',').forEach(function (buttonName, j) {
            var customButtonProps;
            var viewSpec;
            var buttonClick;
            var buttonIcon; // only one of these will be set

            var buttonText; // "

            var buttonInnerHtml;
            var buttonClasses;
            var buttonEl;
            var buttonAriaAttr;

            if (buttonName === 'title') {
              groupChildren.push(htmlToElement('<h2>&nbsp;</h2>')); // we always want it to take up height

              isOnlyButtons = false;
            } else {
              if (customButtonProps = calendarCustomButtons[buttonName]) {
                buttonClick = function buttonClick(ev) {
                  if (customButtonProps.click) {
                    customButtonProps.click.call(buttonEl, ev);
                  }
                };

                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName)) || (buttonText = customButtonProps.text);
              } else if (viewSpec = viewSpecs[buttonName]) {
                _this.viewsWithButtons.push(buttonName);

                buttonClick = function buttonClick() {
                  calendar.changeView(buttonName);
                };

                (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName)) || (buttonText = viewSpec.buttonTextDefault);
              } else if (calendar[buttonName]) {
                // a calendar method
                buttonClick = function buttonClick() {
                  calendar[buttonName]();
                };

                (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName)) || (buttonText = calendarButtonText[buttonName]); //            ^ everything else is considered default
              }

              if (buttonClick) {
                buttonClasses = ['fc-' + buttonName + '-button', theme.getClass('button')];

                if (buttonText) {
                  buttonInnerHtml = htmlEscape(buttonText);
                  buttonAriaAttr = '';
                } else if (buttonIcon) {
                  buttonInnerHtml = "<span class='" + buttonIcon + "'></span>";
                  buttonAriaAttr = ' aria-label="' + buttonName + '"';
                }

                buttonEl = htmlToElement( // type="button" so that it doesn't submit a form
                '<button type="button" class="' + buttonClasses.join(' ') + '"' + buttonAriaAttr + '>' + buttonInnerHtml + '</button>');
                buttonEl.addEventListener('click', buttonClick);
                groupChildren.push(buttonEl);
              }
            }
          });

          if (groupChildren.length > 1) {
            groupEl = document.createElement('div');
            var buttonGroupClassName = theme.getClass('buttonGroup');

            if (isOnlyButtons && buttonGroupClassName) {
              groupEl.classList.add(buttonGroupClassName);
            }

            appendToElement(groupEl, groupChildren);
            sectionEl.appendChild(groupEl);
          } else {
            appendToElement(sectionEl, groupChildren); // 1 or 0 children
          }
        });
      }

      return sectionEl;
    };

    Toolbar.prototype.updateToday = function (isTodayEnabled) {
      this.toggleButtonEnabled('today', isTodayEnabled);
    };

    Toolbar.prototype.updatePrev = function (isPrevEnabled) {
      this.toggleButtonEnabled('prev', isPrevEnabled);
    };

    Toolbar.prototype.updateNext = function (isNextEnabled) {
      this.toggleButtonEnabled('next', isNextEnabled);
    };

    Toolbar.prototype.updateTitle = function (text) {
      findElements(this.el, 'h2').forEach(function (titleEl) {
        titleEl.innerText = text;
      });
    };

    Toolbar.prototype.updateActiveButton = function (buttonName) {
      var className = this.theme.getClass('buttonActive');
      findElements(this.el, 'button').forEach(function (buttonEl) {
        if (buttonName && buttonEl.classList.contains('fc-' + buttonName + '-button')) {
          buttonEl.classList.add(className);
        } else {
          buttonEl.classList.remove(className);
        }
      });
    };

    Toolbar.prototype.toggleButtonEnabled = function (buttonName, bool) {
      findElements(this.el, '.fc-' + buttonName + '-button').forEach(function (buttonEl) {
        buttonEl.disabled = !bool;
      });
    };

    return Toolbar;
  }(Component);

  var CalendarComponent =
  /** @class */
  function (_super) {
    __extends(CalendarComponent, _super);

    function CalendarComponent(context, el) {
      var _this = _super.call(this, context) || this;

      _this._renderToolbars = memoizeRendering(_this.renderToolbars);
      _this.buildViewPropTransformers = memoize(buildViewPropTransformers);
      _this.el = el;
      prependToElement(el, _this.contentEl = createElement('div', {
        className: 'fc-view-container'
      }));
      var calendar = _this.calendar;

      for (var _i = 0, _a = calendar.pluginSystem.hooks.viewContainerModifiers; _i < _a.length; _i++) {
        var modifyViewContainer = _a[_i];
        modifyViewContainer(_this.contentEl, calendar);
      }

      _this.toggleElClassNames(true);

      _this.computeTitle = memoize(computeTitle);
      _this.parseBusinessHours = memoize(function (input) {
        return parseBusinessHours(input, _this.calendar);
      });
      return _this;
    }

    CalendarComponent.prototype.destroy = function () {
      if (this.header) {
        this.header.destroy();
      }

      if (this.footer) {
        this.footer.destroy();
      }

      if (this.view) {
        this.view.destroy();
      }

      removeElement(this.contentEl);
      this.toggleElClassNames(false);

      _super.prototype.destroy.call(this);
    };

    CalendarComponent.prototype.toggleElClassNames = function (bool) {
      var classList = this.el.classList;
      var dirClassName = 'fc-' + this.opt('dir');
      var themeClassName = this.theme.getClass('widget');

      if (bool) {
        classList.add('fc');
        classList.add(dirClassName);
        classList.add(themeClassName);
      } else {
        classList.remove('fc');
        classList.remove(dirClassName);
        classList.remove(themeClassName);
      }
    };

    CalendarComponent.prototype.render = function (props) {
      this.freezeHeight();
      var title = this.computeTitle(props.dateProfile, props.viewSpec.options);

      this._renderToolbars(props.viewSpec, props.dateProfile, props.currentDate, props.dateProfileGenerator, title);

      this.renderView(props, title);
      this.updateSize();
      this.thawHeight();
    };

    CalendarComponent.prototype.renderToolbars = function (viewSpec, dateProfile, currentDate, dateProfileGenerator, title) {
      var headerLayout = this.opt('header');
      var footerLayout = this.opt('footer');
      var now = this.calendar.getNow();
      var todayInfo = dateProfileGenerator.build(now);
      var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate);
      var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate);
      var toolbarProps = {
        title: title,
        activeButton: viewSpec.type,
        isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
        isPrevEnabled: prevInfo.isValid,
        isNextEnabled: nextInfo.isValid
      };

      if (headerLayout) {
        if (!this.header) {
          this.header = new Toolbar(this.context, 'fc-header-toolbar');
          prependToElement(this.el, this.header.el);
        }

        this.header.receiveProps(_assign({
          layout: headerLayout
        }, toolbarProps));
      } else if (this.header) {
        this.header.destroy();
        this.header = null;
      }

      if (footerLayout) {
        if (!this.footer) {
          this.footer = new Toolbar(this.context, 'fc-footer-toolbar');
          appendToElement(this.el, this.footer.el);
        }

        this.footer.receiveProps(_assign({
          layout: footerLayout
        }, toolbarProps));
      } else if (this.footer) {
        this.footer.destroy();
        this.footer = null;
      }
    };

    CalendarComponent.prototype.renderView = function (props, title) {
      var view = this.view;
      var viewSpec = props.viewSpec,
          dateProfileGenerator = props.dateProfileGenerator;

      if (!view || view.viewSpec !== viewSpec) {
        if (view) {
          view.destroy();
        }

        view = this.view = new viewSpec['class']({
          calendar: this.calendar,
          view: null,
          dateEnv: this.dateEnv,
          theme: this.theme,
          options: viewSpec.options
        }, viewSpec, dateProfileGenerator, this.contentEl);
      } else {
        view.addScroll(view.queryScroll());
      }

      view.title = title; // for the API

      var viewProps = {
        dateProfile: props.dateProfile,
        businessHours: this.parseBusinessHours(viewSpec.options.businessHours),
        eventStore: props.eventStore,
        eventUiBases: props.eventUiBases,
        dateSelection: props.dateSelection,
        eventSelection: props.eventSelection,
        eventDrag: props.eventDrag,
        eventResize: props.eventResize
      };
      var transformers = this.buildViewPropTransformers(this.calendar.pluginSystem.hooks.viewPropsTransformers);

      for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
        var transformer = transformers_1[_i];

        _assign(viewProps, transformer.transform(viewProps, viewSpec, props, view));
      }

      view.receiveProps(viewProps);
    }; // Sizing
    // -----------------------------------------------------------------------------------------------------------------


    CalendarComponent.prototype.updateSize = function (isResize) {
      if (isResize === void 0) {
        isResize = false;
      }

      var view = this.view;

      if (isResize) {
        view.addScroll(view.queryScroll());
      }

      if (isResize || this.isHeightAuto == null) {
        this.computeHeightVars();
      }

      view.updateSize(isResize, this.viewHeight, this.isHeightAuto);
      view.updateNowIndicator(); // we need to guarantee this will run after updateSize

      view.popScroll(isResize);
    };

    CalendarComponent.prototype.computeHeightVars = function () {
      var calendar = this.calendar; // yuck. need to handle dynamic options

      var heightInput = calendar.opt('height');
      var contentHeightInput = calendar.opt('contentHeight');
      this.isHeightAuto = heightInput === 'auto' || contentHeightInput === 'auto';

      if (typeof contentHeightInput === 'number') {
        // exists and not 'auto'
        this.viewHeight = contentHeightInput;
      } else if (typeof contentHeightInput === 'function') {
        // exists and is a function
        this.viewHeight = contentHeightInput();
      } else if (typeof heightInput === 'number') {
        // exists and not 'auto'
        this.viewHeight = heightInput - this.queryToolbarsHeight();
      } else if (typeof heightInput === 'function') {
        // exists and is a function
        this.viewHeight = heightInput() - this.queryToolbarsHeight();
      } else if (heightInput === 'parent') {
        // set to height of parent element
        var parentEl = this.el.parentNode;
        this.viewHeight = parentEl.getBoundingClientRect().height - this.queryToolbarsHeight();
      } else {
        this.viewHeight = Math.round(this.contentEl.getBoundingClientRect().width / Math.max(calendar.opt('aspectRatio'), .5));
      }
    };

    CalendarComponent.prototype.queryToolbarsHeight = function () {
      var height = 0;

      if (this.header) {
        height += computeHeightAndMargins(this.header.el);
      }

      if (this.footer) {
        height += computeHeightAndMargins(this.footer.el);
      }

      return height;
    }; // Height "Freezing"
    // -----------------------------------------------------------------------------------------------------------------


    CalendarComponent.prototype.freezeHeight = function () {
      applyStyle(this.el, {
        height: this.el.getBoundingClientRect().height,
        overflow: 'hidden'
      });
    };

    CalendarComponent.prototype.thawHeight = function () {
      applyStyle(this.el, {
        height: '',
        overflow: ''
      });
    };

    return CalendarComponent;
  }(Component); // Title and Date Formatting
  // -----------------------------------------------------------------------------------------------------------------
  // Computes what the title at the top of the calendar should be for this view


  function computeTitle(dateProfile, viewOptions) {
    var range; // for views that span a large unit of time, show the proper interval, ignoring stray days before and after

    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
      range = dateProfile.currentRange;
    } else {
      // for day units or smaller, use the actual day range
      range = dateProfile.activeRange;
    }

    return this.dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || computeTitleFormat(dateProfile), viewOptions.titleRangeSeparator), {
      isEndExclusive: dateProfile.isRangeAllDay
    });
  } // Generates the format string that should be used to generate the title for the current date range.
  // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.


  function computeTitleFormat(dateProfile) {
    var currentRangeUnit = dateProfile.currentRangeUnit;

    if (currentRangeUnit === 'year') {
      return {
        year: 'numeric'
      };
    } else if (currentRangeUnit === 'month') {
      return {
        year: 'numeric',
        month: 'long'
      }; // like "September 2014"
    } else {
      var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);

      if (days !== null && days > 1) {
        // multi-day range. shorter, like "Sep 9 - 10 2014"
        return {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        };
      } else {
        // one day. longer, like "September 9 2014"
        return {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        };
      }
    }
  } // Plugin
  // -----------------------------------------------------------------------------------------------------------------


  function buildViewPropTransformers(theClasses) {
    return theClasses.map(function (theClass) {
      return new theClass();
    });
  }

  var Interaction =
  /** @class */
  function () {
    function Interaction(settings) {
      this.component = settings.component;
    }

    Interaction.prototype.destroy = function () {};

    return Interaction;
  }();

  function parseInteractionSettings(component, input) {
    return {
      component: component,
      el: input.el,
      useEventCenter: input.useEventCenter != null ? input.useEventCenter : true
    };
  }

  function interactionSettingsToStore(settings) {
    var _a;

    return _a = {}, _a[settings.component.uid] = settings, _a;
  } // global state


  var interactionSettingsStore = {};
  /*
  Detects when the user clicks on an event within a DateComponent
  */

  var EventClicking =
  /** @class */
  function (_super) {
    __extends(EventClicking, _super);

    function EventClicking(settings) {
      var _this = _super.call(this, settings) || this;

      _this.handleSegClick = function (ev, segEl) {
        var component = _this.component;
        var seg = getElSeg(segEl);

        if (seg && // might be the <div> surrounding the more link
        component.isValidSegDownEl(ev.target)) {
          // our way to simulate a link click for elements that can't be <a> tags
          // grab before trigger fired in case trigger trashes DOM thru rerendering
          var hasUrlContainer = elementClosest(ev.target, '.fc-has-url');
          var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';
          component.publiclyTrigger('eventClick', [{
            el: segEl,
            event: new EventApi(component.calendar, seg.eventRange.def, seg.eventRange.instance),
            jsEvent: ev,
            view: component.view
          }]);

          if (url && !ev.defaultPrevented) {
            window.location.href = url;
          }
        }
      };

      var component = settings.component;
      _this.destroy = listenBySelector(component.el, 'click', component.fgSegSelector + ',' + component.bgSegSelector, _this.handleSegClick);
      return _this;
    }

    return EventClicking;
  }(Interaction);
  /*
  Triggers events and adds/removes core classNames when the user's pointer
  enters/leaves event-elements of a component.
  */


  var EventHovering =
  /** @class */
  function (_super) {
    __extends(EventHovering, _super);

    function EventHovering(settings) {
      var _this = _super.call(this, settings) || this; // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it


      _this.handleEventElRemove = function (el) {
        if (el === _this.currentSegEl) {
          _this.handleSegLeave(null, _this.currentSegEl);
        }
      };

      _this.handleSegEnter = function (ev, segEl) {
        if (getElSeg(segEl)) {
          // TODO: better way to make sure not hovering over more+ link or its wrapper
          segEl.classList.add('fc-allow-mouse-resize');
          _this.currentSegEl = segEl;

          _this.triggerEvent('eventMouseEnter', ev, segEl);
        }
      };

      _this.handleSegLeave = function (ev, segEl) {
        if (_this.currentSegEl) {
          segEl.classList.remove('fc-allow-mouse-resize');
          _this.currentSegEl = null;

          _this.triggerEvent('eventMouseLeave', ev, segEl);
        }
      };

      var component = settings.component;
      _this.removeHoverListeners = listenToHoverBySelector(component.el, component.fgSegSelector + ',' + component.bgSegSelector, _this.handleSegEnter, _this.handleSegLeave);
      component.calendar.on('eventElRemove', _this.handleEventElRemove);
      return _this;
    }

    EventHovering.prototype.destroy = function () {
      this.removeHoverListeners();
      this.component.calendar.off('eventElRemove', this.handleEventElRemove);
    };

    EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {
      var component = this.component;
      var seg = getElSeg(segEl);

      if (!ev || component.isValidSegDownEl(ev.target)) {
        component.publiclyTrigger(publicEvName, [{
          el: segEl,
          event: new EventApi(this.component.calendar, seg.eventRange.def, seg.eventRange.instance),
          jsEvent: ev,
          view: component.view
        }]);
      }
    };

    return EventHovering;
  }(Interaction);

  var StandardTheme =
  /** @class */
  function (_super) {
    __extends(StandardTheme, _super);

    function StandardTheme() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    return StandardTheme;
  }(Theme);

  StandardTheme.prototype.classes = {
    widget: 'fc-unthemed',
    widgetHeader: 'fc-widget-header',
    widgetContent: 'fc-widget-content',
    buttonGroup: 'fc-button-group',
    button: 'fc-button fc-button-primary',
    buttonActive: 'fc-button-active',
    popoverHeader: 'fc-widget-header',
    popoverContent: 'fc-widget-content',
    // day grid
    headerRow: 'fc-widget-header',
    dayRow: 'fc-widget-content',
    // list view
    listView: 'fc-widget-content'
  };
  StandardTheme.prototype.baseIconClass = 'fc-icon';
  StandardTheme.prototype.iconClasses = {
    close: 'fc-icon-x',
    prev: 'fc-icon-chevron-left',
    next: 'fc-icon-chevron-right',
    prevYear: 'fc-icon-chevrons-left',
    nextYear: 'fc-icon-chevrons-right'
  };
  StandardTheme.prototype.iconOverrideOption = 'buttonIcons';
  StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
  StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';

  var Calendar =
  /** @class */
  function () {
    function Calendar(el, overrides) {
      var _this = this;

      this.parseRawLocales = memoize(parseRawLocales);
      this.buildLocale = memoize(buildLocale);
      this.buildDateEnv = memoize(buildDateEnv);
      this.buildTheme = memoize(buildTheme);
      this.buildEventUiSingleBase = memoize(this._buildEventUiSingleBase);
      this.buildSelectionConfig = memoize(this._buildSelectionConfig);
      this.buildEventUiBySource = memoizeOutput(buildEventUiBySource, isPropsEqual);
      this.buildEventUiBases = memoize(buildEventUiBases);
      this.interactionsStore = {};
      this.actionQueue = [];
      this.isReducing = false; // isDisplaying: boolean = false // installed in DOM? accepting renders?

      this.needsRerender = false; // needs a render?

      this.needsFullRerender = false;
      this.isRendering = false; // currently in the executeRender function?

      this.renderingPauseDepth = 0;
      this.buildDelayedRerender = memoize(buildDelayedRerender);
      this.afterSizingTriggers = {};
      this.isViewUpdated = false;
      this.isDatesUpdated = false;
      this.isEventsUpdated = false;
      this.el = el;
      this.optionsManager = new OptionsManager(overrides || {});
      this.pluginSystem = new PluginSystem(); // only do once. don't do in handleOptions. because can't remove plugins

      this.addPluginInputs(this.optionsManager.computed.plugins || []);
      this.handleOptions(this.optionsManager.computed);
      this.publiclyTrigger('_init'); // for tests

      this.hydrate();
      this.calendarInteractions = this.pluginSystem.hooks.calendarInteractions.map(function (calendarInteractionClass) {
        return new calendarInteractionClass(_this);
      });
    }

    Calendar.prototype.addPluginInputs = function (pluginInputs) {
      var pluginDefs = refinePluginDefs(pluginInputs);

      for (var _i = 0, pluginDefs_1 = pluginDefs; _i < pluginDefs_1.length; _i++) {
        var pluginDef = pluginDefs_1[_i];
        this.pluginSystem.add(pluginDef);
      }
    };

    Object.defineProperty(Calendar.prototype, "view", {
      // public API
      get: function get() {
        return this.component ? this.component.view : null;
      },
      enumerable: true,
      configurable: true
    }); // Public API for rendering
    // -----------------------------------------------------------------------------------------------------------------

    Calendar.prototype.render = function () {
      if (!this.component) {
        this.renderableEventStore = createEmptyEventStore();
        this.bindHandlers();
        this.executeRender();
      } else {
        this.requestRerender(true);
      }
    };

    Calendar.prototype.destroy = function () {
      if (this.component) {
        this.unbindHandlers();
        this.component.destroy(); // don't null-out. in case API needs access

        this.component = null; // umm ???

        for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {
          var interaction = _a[_i];
          interaction.destroy();
        }

        this.publiclyTrigger('_destroyed');
      }
    }; // Handlers
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.bindHandlers = function () {
      var _this = this; // event delegation for nav links


      this.removeNavLinkListener = listenBySelector(this.el, 'click', 'a[data-goto]', function (ev, anchorEl) {
        var gotoOptions = anchorEl.getAttribute('data-goto');
        gotoOptions = gotoOptions ? JSON.parse(gotoOptions) : {};
        var dateEnv = _this.dateEnv;
        var dateMarker = dateEnv.createMarker(gotoOptions.date);
        var viewType = gotoOptions.type; // property like "navLinkDayClick". might be a string or a function

        var customAction = _this.viewOpt('navLink' + capitaliseFirstLetter(viewType) + 'Click');

        if (typeof customAction === 'function') {
          customAction(dateEnv.toDate(dateMarker), ev);
        } else {
          if (typeof customAction === 'string') {
            viewType = customAction;
          }

          _this.zoomTo(dateMarker, viewType);
        }
      });

      if (this.opt('handleWindowResize')) {
        window.addEventListener('resize', this.windowResizeProxy = debounce( // prevents rapid calls
        this.windowResize.bind(this), this.opt('windowResizeDelay')));
      }
    };

    Calendar.prototype.unbindHandlers = function () {
      this.removeNavLinkListener();

      if (this.windowResizeProxy) {
        window.removeEventListener('resize', this.windowResizeProxy);
        this.windowResizeProxy = null;
      }
    }; // Dispatcher
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.hydrate = function () {
      var _this = this;

      this.state = this.buildInitialState();
      var rawSources = this.opt('eventSources') || [];
      var singleRawSource = this.opt('events');
      var sources = []; // parsed

      if (singleRawSource) {
        rawSources.unshift(singleRawSource);
      }

      for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {
        var rawSource = rawSources_1[_i];
        var source = parseEventSource(rawSource, this);

        if (source) {
          sources.push(source);
        }
      }

      this.batchRendering(function () {
        _this.dispatch({
          type: 'INIT'
        }); // pass in sources here?


        _this.dispatch({
          type: 'ADD_EVENT_SOURCES',
          sources: sources
        });

        _this.dispatch({
          type: 'SET_VIEW_TYPE',
          viewType: _this.opt('defaultView') || _this.pluginSystem.hooks.defaultView
        });
      });
    };

    Calendar.prototype.buildInitialState = function () {
      return {
        viewType: null,
        loadingLevel: 0,
        eventSourceLoadingLevel: 0,
        currentDate: this.getInitialDate(),
        dateProfile: null,
        eventSources: {},
        eventStore: createEmptyEventStore(),
        dateSelection: null,
        eventSelection: '',
        eventDrag: null,
        eventResize: null
      };
    };

    Calendar.prototype.dispatch = function (action) {
      this.actionQueue.push(action);

      if (!this.isReducing) {
        this.isReducing = true;
        var oldState = this.state;

        while (this.actionQueue.length) {
          this.state = this.reduce(this.state, this.actionQueue.shift(), this);
        }

        var newState = this.state;
        this.isReducing = false;

        if (!oldState.loadingLevel && newState.loadingLevel) {
          this.publiclyTrigger('loading', [true]);
        } else if (oldState.loadingLevel && !newState.loadingLevel) {
          this.publiclyTrigger('loading', [false]);
        }

        var view = this.component && this.component.view;

        if (oldState.eventStore !== newState.eventStore || this.needsFullRerender) {
          if (oldState.eventStore) {
            this.isEventsUpdated = true;
          }
        }

        if (oldState.dateProfile !== newState.dateProfile || this.needsFullRerender) {
          if (oldState.dateProfile && view) {
            // why would view be null!?
            this.publiclyTrigger('datesDestroy', [{
              view: view,
              el: view.el
            }]);
          }

          this.isDatesUpdated = true;
        }

        if (oldState.viewType !== newState.viewType || this.needsFullRerender) {
          if (oldState.viewType && view) {
            // why would view be null!?
            this.publiclyTrigger('viewSkeletonDestroy', [{
              view: view,
              el: view.el
            }]);
          }

          this.isViewUpdated = true;
        }

        this.requestRerender();
      }
    };

    Calendar.prototype.reduce = function (state, action, calendar) {
      return reduce(state, action, calendar);
    }; // Render Queue
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.requestRerender = function (needsFull) {
      if (needsFull === void 0) {
        needsFull = false;
      }

      this.needsRerender = true;
      this.needsFullRerender = this.needsFullRerender || needsFull;
      this.delayedRerender(); // will call a debounced-version of tryRerender
    };

    Calendar.prototype.tryRerender = function () {
      if (this.component && // must be accepting renders
      this.needsRerender && // indicates that a rerender was requested
      !this.renderingPauseDepth && // not paused
      !this.isRendering // not currently in the render loop
      ) {
          this.executeRender();
        }
    };

    Calendar.prototype.batchRendering = function (func) {
      this.renderingPauseDepth++;
      func();
      this.renderingPauseDepth--;

      if (this.needsRerender) {
        this.requestRerender();
      }
    }; // Rendering
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.executeRender = function () {
      var needsFullRerender = this.needsFullRerender; // save before clearing
      // clear these BEFORE the render so that new values will accumulate during render

      this.needsRerender = false;
      this.needsFullRerender = false;
      this.isRendering = true;
      this.renderComponent(needsFullRerender);
      this.isRendering = false; // received a rerender request while rendering

      if (this.needsRerender) {
        this.delayedRerender();
      }
    };
    /*
    don't call this directly. use executeRender instead
    */


    Calendar.prototype.renderComponent = function (needsFull) {
      var _a = this,
          state = _a.state,
          component = _a.component;

      var viewType = state.viewType;
      var viewSpec = this.viewSpecs[viewType];
      var savedScroll = needsFull && component ? component.view.queryScroll() : null;

      if (!viewSpec) {
        throw new Error("View type \"" + viewType + "\" is not valid");
      } // if event sources are still loading and progressive rendering hasn't been enabled,
      // keep rendering the last fully loaded set of events


      var renderableEventStore = this.renderableEventStore = state.eventSourceLoadingLevel && !this.opt('progressiveEventRendering') ? this.renderableEventStore : state.eventStore;
      var eventUiSingleBase = this.buildEventUiSingleBase(viewSpec.options);
      var eventUiBySource = this.buildEventUiBySource(state.eventSources);
      var eventUiBases = this.eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);

      if (needsFull || !component) {
        if (component) {
          component.freezeHeight(); // next component will unfreeze it

          component.destroy();
        }

        component = this.component = new CalendarComponent({
          calendar: this,
          view: null,
          dateEnv: this.dateEnv,
          theme: this.theme,
          options: this.optionsManager.computed
        }, this.el);
        this.isViewUpdated = true;
        this.isDatesUpdated = true;
        this.isEventsUpdated = true;
      }

      component.receiveProps(_assign({}, state, {
        viewSpec: viewSpec,
        dateProfile: state.dateProfile,
        dateProfileGenerator: this.dateProfileGenerators[viewType],
        eventStore: renderableEventStore,
        eventUiBases: eventUiBases,
        dateSelection: state.dateSelection,
        eventSelection: state.eventSelection,
        eventDrag: state.eventDrag,
        eventResize: state.eventResize
      }));

      if (savedScroll) {
        component.view.applyScroll(savedScroll, false);
      }

      if (this.isViewUpdated) {
        this.isViewUpdated = false;
        this.publiclyTrigger('viewSkeletonRender', [{
          view: component.view,
          el: component.view.el
        }]);
      }

      if (this.isDatesUpdated) {
        this.isDatesUpdated = false;
        this.publiclyTrigger('datesRender', [{
          view: component.view,
          el: component.view.el
        }]);
      }

      if (this.isEventsUpdated) {
        this.isEventsUpdated = false;
      }

      this.releaseAfterSizingTriggers();
    }; // Options
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.setOption = function (name, val) {
      var _a;

      this.mutateOptions((_a = {}, _a[name] = val, _a), [], true);
    };

    Calendar.prototype.getOption = function (name) {
      return this.optionsManager.computed[name];
    };

    Calendar.prototype.opt = function (name) {
      return this.optionsManager.computed[name];
    };

    Calendar.prototype.viewOpt = function (name) {
      return this.viewOpts()[name];
    };

    Calendar.prototype.viewOpts = function () {
      return this.viewSpecs[this.state.viewType].options;
    };
    /*
    handles option changes (like a diff)
    */


    Calendar.prototype.mutateOptions = function (updates, removals, isDynamic, deepEqual) {
      var _this = this;

      var changeHandlers = this.pluginSystem.hooks.optionChangeHandlers;
      var normalUpdates = {};
      var specialUpdates = {};
      var oldDateEnv = this.dateEnv; // do this before handleOptions

      var isTimeZoneDirty = false;
      var isSizeDirty = false;
      var anyDifficultOptions = Boolean(removals.length);

      for (var name_1 in updates) {
        if (changeHandlers[name_1]) {
          specialUpdates[name_1] = updates[name_1];
        } else {
          normalUpdates[name_1] = updates[name_1];
        }
      }

      for (var name_2 in normalUpdates) {
        if (/^(height|contentHeight|aspectRatio)$/.test(name_2)) {
          isSizeDirty = true;
        } else if (/^(defaultDate|defaultView)$/.test(name_2)) ;else {
          anyDifficultOptions = true;

          if (name_2 === 'timeZone') {
            isTimeZoneDirty = true;
          }
        }
      }

      this.optionsManager.mutate(normalUpdates, removals, isDynamic);

      if (anyDifficultOptions) {
        this.handleOptions(this.optionsManager.computed);
        this.needsFullRerender = true;
      }

      this.batchRendering(function () {
        if (anyDifficultOptions) {
          if (isTimeZoneDirty) {
            _this.dispatch({
              type: 'CHANGE_TIMEZONE',
              oldDateEnv: oldDateEnv
            });
          }
          /* HACK
          has the same effect as calling this.requestRerender(true)
          but recomputes the state's dateProfile
          */


          _this.dispatch({
            type: 'SET_VIEW_TYPE',
            viewType: _this.state.viewType
          });
        } else if (isSizeDirty) {
          _this.updateSize();
        } // special updates


        if (deepEqual) {
          for (var name_3 in specialUpdates) {
            changeHandlers[name_3](specialUpdates[name_3], _this, deepEqual);
          }
        }
      });
    };
    /*
    rebuilds things based off of a complete set of refined options
    */


    Calendar.prototype.handleOptions = function (options) {
      var _this = this;

      var pluginHooks = this.pluginSystem.hooks;
      this.defaultAllDayEventDuration = createDuration(options.defaultAllDayEventDuration);
      this.defaultTimedEventDuration = createDuration(options.defaultTimedEventDuration);
      this.delayedRerender = this.buildDelayedRerender(options.rerenderDelay);
      this.theme = this.buildTheme(options);
      var available = this.parseRawLocales(options.locales);
      this.availableRawLocales = available.map;
      var locale = this.buildLocale(options.locale || available.defaultCode, available.map);
      this.dateEnv = this.buildDateEnv(locale, options.timeZone, pluginHooks.namedTimeZonedImpl, options.firstDay, options.weekNumberCalculation, options.weekLabel, pluginHooks.cmdFormatter);
      this.selectionConfig = this.buildSelectionConfig(options); // needs dateEnv. do after :(
      // ineffecient to do every time?

      this.viewSpecs = buildViewSpecs(pluginHooks.views, this.optionsManager); // ineffecient to do every time?

      this.dateProfileGenerators = mapHash(this.viewSpecs, function (viewSpec) {
        return new viewSpec["class"].prototype.dateProfileGeneratorClass(viewSpec, _this);
      });
    };

    Calendar.prototype.getAvailableLocaleCodes = function () {
      return Object.keys(this.availableRawLocales);
    };

    Calendar.prototype._buildSelectionConfig = function (rawOpts) {
      return processScopedUiProps('select', rawOpts, this);
    };

    Calendar.prototype._buildEventUiSingleBase = function (rawOpts) {
      if (rawOpts.editable) {
        // so 'editable' affected events
        rawOpts = _assign({}, rawOpts, {
          eventEditable: true
        });
      }

      return processScopedUiProps('event', rawOpts, this);
    }; // Trigger
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.hasPublicHandlers = function (name) {
      return this.hasHandlers(name) || this.opt(name); // handler specified in options
    };

    Calendar.prototype.publiclyTrigger = function (name, args) {
      var optHandler = this.opt(name);
      this.triggerWith(name, this, args);

      if (optHandler) {
        return optHandler.apply(this, args);
      }
    };

    Calendar.prototype.publiclyTriggerAfterSizing = function (name, args) {
      var afterSizingTriggers = this.afterSizingTriggers;
      (afterSizingTriggers[name] || (afterSizingTriggers[name] = [])).push(args);
    };

    Calendar.prototype.releaseAfterSizingTriggers = function () {
      var afterSizingTriggers = this.afterSizingTriggers;

      for (var name_4 in afterSizingTriggers) {
        for (var _i = 0, _a = afterSizingTriggers[name_4]; _i < _a.length; _i++) {
          var args = _a[_i];
          this.publiclyTrigger(name_4, args);
        }
      }

      this.afterSizingTriggers = {};
    }; // View
    // -----------------------------------------------------------------------------------------------------------------
    // Returns a boolean about whether the view is okay to instantiate at some point


    Calendar.prototype.isValidViewType = function (viewType) {
      return Boolean(this.viewSpecs[viewType]);
    };

    Calendar.prototype.changeView = function (viewType, dateOrRange) {
      var dateMarker = null;

      if (dateOrRange) {
        if (dateOrRange.start && dateOrRange.end) {
          // a range
          this.optionsManager.mutate({
            visibleRange: dateOrRange
          }, []); // will not rerender

          this.handleOptions(this.optionsManager.computed); // ...but yuck
        } else {
          // a date
          dateMarker = this.dateEnv.createMarker(dateOrRange); // just like gotoDate
        }
      }

      this.unselect();
      this.dispatch({
        type: 'SET_VIEW_TYPE',
        viewType: viewType,
        dateMarker: dateMarker
      });
    }; // Forces navigation to a view for the given date.
    // `viewType` can be a specific view name or a generic one like "week" or "day".
    // needs to change


    Calendar.prototype.zoomTo = function (dateMarker, viewType) {
      var spec;
      viewType = viewType || 'day'; // day is default zoom

      spec = this.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
      this.unselect();

      if (spec) {
        this.dispatch({
          type: 'SET_VIEW_TYPE',
          viewType: spec.type,
          dateMarker: dateMarker
        });
      } else {
        this.dispatch({
          type: 'SET_DATE',
          dateMarker: dateMarker
        });
      }
    }; // Given a duration singular unit, like "week" or "day", finds a matching view spec.
    // Preference is given to views that have corresponding buttons.


    Calendar.prototype.getUnitViewSpec = function (unit) {
      var component = this.component;
      var viewTypes = [];
      var i;
      var spec; // put views that have buttons first. there will be duplicates, but oh

      if (component.header) {
        viewTypes.push.apply(viewTypes, component.header.viewsWithButtons);
      }

      if (component.footer) {
        viewTypes.push.apply(viewTypes, component.footer.viewsWithButtons);
      }

      for (var viewType in this.viewSpecs) {
        viewTypes.push(viewType);
      }

      for (i = 0; i < viewTypes.length; i++) {
        spec = this.viewSpecs[viewTypes[i]];

        if (spec) {
          if (spec.singleUnit === unit) {
            return spec;
          }
        }
      }
    }; // Current Date
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.getInitialDate = function () {
      var defaultDateInput = this.opt('defaultDate'); // compute the initial ambig-timezone date

      if (defaultDateInput != null) {
        return this.dateEnv.createMarker(defaultDateInput);
      } else {
        return this.getNow(); // getNow already returns unzoned
      }
    };

    Calendar.prototype.prev = function () {
      this.unselect();
      this.dispatch({
        type: 'PREV'
      });
    };

    Calendar.prototype.next = function () {
      this.unselect();
      this.dispatch({
        type: 'NEXT'
      });
    };

    Calendar.prototype.prevYear = function () {
      this.unselect();
      this.dispatch({
        type: 'SET_DATE',
        dateMarker: this.dateEnv.addYears(this.state.currentDate, -1)
      });
    };

    Calendar.prototype.nextYear = function () {
      this.unselect();
      this.dispatch({
        type: 'SET_DATE',
        dateMarker: this.dateEnv.addYears(this.state.currentDate, 1)
      });
    };

    Calendar.prototype.today = function () {
      this.unselect();
      this.dispatch({
        type: 'SET_DATE',
        dateMarker: this.getNow()
      });
    };

    Calendar.prototype.gotoDate = function (zonedDateInput) {
      this.unselect();
      this.dispatch({
        type: 'SET_DATE',
        dateMarker: this.dateEnv.createMarker(zonedDateInput)
      });
    };

    Calendar.prototype.incrementDate = function (deltaInput) {
      var delta = createDuration(deltaInput);

      if (delta) {
        // else, warn about invalid input?
        this.unselect();
        this.dispatch({
          type: 'SET_DATE',
          dateMarker: this.dateEnv.add(this.state.currentDate, delta)
        });
      }
    }; // for external API


    Calendar.prototype.getDate = function () {
      return this.dateEnv.toDate(this.state.currentDate);
    }; // Date Formatting Utils
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.formatDate = function (d, formatter) {
      var dateEnv = this.dateEnv;
      return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));
    }; // `settings` is for formatter AND isEndExclusive


    Calendar.prototype.formatRange = function (d0, d1, settings) {
      var dateEnv = this.dateEnv;
      return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings, this.opt('defaultRangeSeparator')), settings);
    };

    Calendar.prototype.formatIso = function (d, omitTime) {
      var dateEnv = this.dateEnv;
      return dateEnv.formatIso(dateEnv.createMarker(d), {
        omitTime: omitTime
      });
    }; // Sizing
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.windowResize = function (ev) {
      if (!this.isHandlingWindowResize && this.component && // why?
      ev.target === window // not a jqui resize event
      ) {
          this.isHandlingWindowResize = true;
          this.updateSize();
          this.publiclyTrigger('windowResize', [this.view]);
          this.isHandlingWindowResize = false;
        }
    };

    Calendar.prototype.updateSize = function () {
      if (this.component) {
        // when?
        this.component.updateSize(true);
      }
    }; // Component Registration
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.registerInteractiveComponent = function (component, settingsInput) {
      var settings = parseInteractionSettings(component, settingsInput);
      var DEFAULT_INTERACTIONS = [EventClicking, EventHovering];
      var interactionClasses = DEFAULT_INTERACTIONS.concat(this.pluginSystem.hooks.componentInteractions);
      var interactions = interactionClasses.map(function (interactionClass) {
        return new interactionClass(settings);
      });
      this.interactionsStore[component.uid] = interactions;
      interactionSettingsStore[component.uid] = settings;
    };

    Calendar.prototype.unregisterInteractiveComponent = function (component) {
      for (var _i = 0, _a = this.interactionsStore[component.uid]; _i < _a.length; _i++) {
        var listener = _a[_i];
        listener.destroy();
      }

      delete this.interactionsStore[component.uid];
      delete interactionSettingsStore[component.uid];
    }; // Date Selection / Event Selection / DayClick
    // -----------------------------------------------------------------------------------------------------------------
    // this public method receives start/end dates in any format, with any timezone
    // NOTE: args were changed from v3


    Calendar.prototype.select = function (dateOrObj, endDate) {
      var selectionInput;

      if (endDate == null) {
        if (dateOrObj.start != null) {
          selectionInput = dateOrObj;
        } else {
          selectionInput = {
            start: dateOrObj,
            end: null
          };
        }
      } else {
        selectionInput = {
          start: dateOrObj,
          end: endDate
        };
      }

      var selection = parseDateSpan(selectionInput, this.dateEnv, createDuration({
        days: 1
      }) // TODO: cache this?
      );

      if (selection) {
        // throw parse error otherwise?
        this.dispatch({
          type: 'SELECT_DATES',
          selection: selection
        });
        this.triggerDateSelect(selection);
      }
    }; // public method


    Calendar.prototype.unselect = function (pev) {
      if (this.state.dateSelection) {
        this.dispatch({
          type: 'UNSELECT_DATES'
        });
        this.triggerDateUnselect(pev);
      }
    };

    Calendar.prototype.triggerDateSelect = function (selection, pev) {
      var arg = _assign({}, this.buildDateSpanApi(selection), {
        jsEvent: pev ? pev.origEvent : null,
        view: this.view
      });

      this.publiclyTrigger('select', [arg]);
    };

    Calendar.prototype.triggerDateUnselect = function (pev) {
      this.publiclyTrigger('unselect', [{
        jsEvent: pev ? pev.origEvent : null,
        view: this.view
      }]);
    }; // TODO: receive pev?


    Calendar.prototype.triggerDateClick = function (dateSpan, dayEl, view, ev) {
      var arg = _assign({}, this.buildDatePointApi(dateSpan), {
        dayEl: dayEl,
        jsEvent: ev,
        // Is this always a mouse event? See #4655
        view: view
      });

      this.publiclyTrigger('dateClick', [arg]);
    };

    Calendar.prototype.buildDatePointApi = function (dateSpan) {
      var props = {};

      for (var _i = 0, _a = this.pluginSystem.hooks.datePointTransforms; _i < _a.length; _i++) {
        var transform = _a[_i];

        _assign(props, transform(dateSpan, this));
      }

      _assign(props, buildDatePointApi(dateSpan, this.dateEnv));

      return props;
    };

    Calendar.prototype.buildDateSpanApi = function (dateSpan) {
      var props = {};

      for (var _i = 0, _a = this.pluginSystem.hooks.dateSpanTransforms; _i < _a.length; _i++) {
        var transform = _a[_i];

        _assign(props, transform(dateSpan, this));
      }

      _assign(props, buildDateSpanApi(dateSpan, this.dateEnv));

      return props;
    }; // Date Utils
    // -----------------------------------------------------------------------------------------------------------------
    // Returns a DateMarker for the current date, as defined by the client's computer or from the `now` option


    Calendar.prototype.getNow = function () {
      var now = this.opt('now');

      if (typeof now === 'function') {
        now = now();
      }

      if (now == null) {
        return this.dateEnv.createNowMarker();
      }

      return this.dateEnv.createMarker(now);
    }; // Event-Date Utilities
    // -----------------------------------------------------------------------------------------------------------------
    // Given an event's allDay status and start date, return what its fallback end date should be.
    // TODO: rename to computeDefaultEventEnd


    Calendar.prototype.getDefaultEventEnd = function (allDay, marker) {
      var end = marker;

      if (allDay) {
        end = startOfDay(end);
        end = this.dateEnv.add(end, this.defaultAllDayEventDuration);
      } else {
        end = this.dateEnv.add(end, this.defaultTimedEventDuration);
      }

      return end;
    }; // Public Events API
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.addEvent = function (eventInput, sourceInput) {
      if (eventInput instanceof EventApi) {
        var def = eventInput._def;
        var instance = eventInput._instance; // not already present? don't want to add an old snapshot

        if (!this.state.eventStore.defs[def.defId]) {
          this.dispatch({
            type: 'ADD_EVENTS',
            eventStore: eventTupleToStore({
              def: def,
              instance: instance
            }) // TODO: better util for two args?

          });
        }

        return eventInput;
      }

      var sourceId;

      if (sourceInput instanceof EventSourceApi) {
        sourceId = sourceInput.internalEventSource.sourceId;
      } else if (sourceInput != null) {
        var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function

        if (!sourceApi) {
          console.warn('Could not find an event source with ID "' + sourceInput + '"'); // TODO: test

          return null;
        } else {
          sourceId = sourceApi.internalEventSource.sourceId;
        }
      }

      var tuple = parseEvent(eventInput, sourceId, this);

      if (tuple) {
        this.dispatch({
          type: 'ADD_EVENTS',
          eventStore: eventTupleToStore(tuple)
        });
        return new EventApi(this, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
      }

      return null;
    }; // TODO: optimize


    Calendar.prototype.getEventById = function (id) {
      var _a = this.state.eventStore,
          defs = _a.defs,
          instances = _a.instances;
      id = String(id);

      for (var defId in defs) {
        var def = defs[defId];

        if (def.publicId === id) {
          if (def.recurringDef) {
            return new EventApi(this, def, null);
          } else {
            for (var instanceId in instances) {
              var instance = instances[instanceId];

              if (instance.defId === def.defId) {
                return new EventApi(this, def, instance);
              }
            }
          }
        }
      }

      return null;
    };

    Calendar.prototype.getEvents = function () {
      var _a = this.state.eventStore,
          defs = _a.defs,
          instances = _a.instances;
      var eventApis = [];

      for (var id in instances) {
        var instance = instances[id];
        var def = defs[instance.defId];
        eventApis.push(new EventApi(this, def, instance));
      }

      return eventApis;
    };

    Calendar.prototype.removeAllEvents = function () {
      this.dispatch({
        type: 'REMOVE_ALL_EVENTS'
      });
    };

    Calendar.prototype.rerenderEvents = function () {
      this.dispatch({
        type: 'RESET_EVENTS'
      });
    }; // Public Event Sources API
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.getEventSources = function () {
      var sourceHash = this.state.eventSources;
      var sourceApis = [];

      for (var internalId in sourceHash) {
        sourceApis.push(new EventSourceApi(this, sourceHash[internalId]));
      }

      return sourceApis;
    };

    Calendar.prototype.getEventSourceById = function (id) {
      var sourceHash = this.state.eventSources;
      id = String(id);

      for (var sourceId in sourceHash) {
        if (sourceHash[sourceId].publicId === id) {
          return new EventSourceApi(this, sourceHash[sourceId]);
        }
      }

      return null;
    };

    Calendar.prototype.addEventSource = function (sourceInput) {
      if (sourceInput instanceof EventSourceApi) {
        // not already present? don't want to add an old snapshot
        if (!this.state.eventSources[sourceInput.internalEventSource.sourceId]) {
          this.dispatch({
            type: 'ADD_EVENT_SOURCES',
            sources: [sourceInput.internalEventSource]
          });
        }

        return sourceInput;
      }

      var eventSource = parseEventSource(sourceInput, this);

      if (eventSource) {
        // TODO: error otherwise?
        this.dispatch({
          type: 'ADD_EVENT_SOURCES',
          sources: [eventSource]
        });
        return new EventSourceApi(this, eventSource);
      }

      return null;
    };

    Calendar.prototype.removeAllEventSources = function () {
      this.dispatch({
        type: 'REMOVE_ALL_EVENT_SOURCES'
      });
    };

    Calendar.prototype.refetchEvents = function () {
      this.dispatch({
        type: 'FETCH_EVENT_SOURCES'
      });
    }; // Scroll
    // -----------------------------------------------------------------------------------------------------------------


    Calendar.prototype.scrollToTime = function (timeInput) {
      var duration = createDuration(timeInput);

      if (duration) {
        this.component.view.scrollToDuration(duration);
      }
    };

    return Calendar;
  }();

  EmitterMixin.mixInto(Calendar); // for memoizers
  // -----------------------------------------------------------------------------------------------------------------

  function buildDateEnv(locale, timeZone, namedTimeZoneImpl, firstDay, weekNumberCalculation, weekLabel, cmdFormatter) {
    return new DateEnv({
      calendarSystem: 'gregory',
      timeZone: timeZone,
      namedTimeZoneImpl: namedTimeZoneImpl,
      locale: locale,
      weekNumberCalculation: weekNumberCalculation,
      firstDay: firstDay,
      weekLabel: weekLabel,
      cmdFormatter: cmdFormatter
    });
  }

  function buildTheme(calendarOptions) {
    var themeClass = this.pluginSystem.hooks.themeClasses[calendarOptions.themeSystem] || StandardTheme;
    return new themeClass(calendarOptions);
  }

  function buildDelayedRerender(wait) {
    var func = this.tryRerender.bind(this);

    if (wait != null) {
      func = debounce(func, wait);
    }

    return func;
  }

  function buildEventUiBySource(eventSources) {
    return mapHash(eventSources, function (eventSource) {
      return eventSource.ui;
    });
  }

  function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
    var eventUiBases = {
      '': eventUiSingleBase
    };

    for (var defId in eventDefs) {
      var def = eventDefs[defId];

      if (def.sourceId && eventUiBySource[def.sourceId]) {
        eventUiBases[defId] = eventUiBySource[def.sourceId];
      }
    }

    return eventUiBases;
  }

  var View =
  /** @class */
  function (_super) {
    __extends(View, _super);

    function View(context, viewSpec, dateProfileGenerator, parentEl) {
      var _this = _super.call(this, context, createElement('div', {
        className: 'fc-view fc-' + viewSpec.type + '-view'
      }), true // isView (HACK)
      ) || this;

      _this.renderDatesMem = memoizeRendering(_this.renderDatesWrap, _this.unrenderDatesWrap);
      _this.renderBusinessHoursMem = memoizeRendering(_this.renderBusinessHours, _this.unrenderBusinessHours, [_this.renderDatesMem]);
      _this.renderDateSelectionMem = memoizeRendering(_this.renderDateSelectionWrap, _this.unrenderDateSelectionWrap, [_this.renderDatesMem]);
      _this.renderEventsMem = memoizeRendering(_this.renderEvents, _this.unrenderEvents, [_this.renderDatesMem]);
      _this.renderEventSelectionMem = memoizeRendering(_this.renderEventSelectionWrap, _this.unrenderEventSelectionWrap, [_this.renderEventsMem]);
      _this.renderEventDragMem = memoizeRendering(_this.renderEventDragWrap, _this.unrenderEventDragWrap, [_this.renderDatesMem]);
      _this.renderEventResizeMem = memoizeRendering(_this.renderEventResizeWrap, _this.unrenderEventResizeWrap, [_this.renderDatesMem]);
      _this.viewSpec = viewSpec;
      _this.dateProfileGenerator = dateProfileGenerator;
      _this.type = viewSpec.type;
      _this.eventOrderSpecs = parseFieldSpecs(_this.opt('eventOrder'));
      _this.nextDayThreshold = createDuration(_this.opt('nextDayThreshold'));
      parentEl.appendChild(_this.el);

      _this.initialize();

      return _this;
    }

    View.prototype.initialize = function () {};

    Object.defineProperty(View.prototype, "activeStart", {
      // Date Setting/Unsetting
      // -----------------------------------------------------------------------------------------------------------------
      get: function get() {
        return this.dateEnv.toDate(this.props.dateProfile.activeRange.start);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(View.prototype, "activeEnd", {
      get: function get() {
        return this.dateEnv.toDate(this.props.dateProfile.activeRange.end);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(View.prototype, "currentStart", {
      get: function get() {
        return this.dateEnv.toDate(this.props.dateProfile.currentRange.start);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(View.prototype, "currentEnd", {
      get: function get() {
        return this.dateEnv.toDate(this.props.dateProfile.currentRange.end);
      },
      enumerable: true,
      configurable: true
    }); // General Rendering
    // -----------------------------------------------------------------------------------------------------------------

    View.prototype.render = function (props) {
      this.renderDatesMem(props.dateProfile);
      this.renderBusinessHoursMem(props.businessHours);
      this.renderDateSelectionMem(props.dateSelection);
      this.renderEventsMem(props.eventStore);
      this.renderEventSelectionMem(props.eventSelection);
      this.renderEventDragMem(props.eventDrag);
      this.renderEventResizeMem(props.eventResize);
    };

    View.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      this.renderDatesMem.unrender(); // should unrender everything else
    }; // Sizing
    // -----------------------------------------------------------------------------------------------------------------


    View.prototype.updateSize = function (isResize, viewHeight, isAuto) {
      var calendar = this.calendar;

      if (isResize || // HACKS...
      calendar.isViewUpdated || calendar.isDatesUpdated || calendar.isEventsUpdated) {
        // sort of the catch-all sizing
        // anything that might cause dimension changes
        this.updateBaseSize(isResize, viewHeight, isAuto);
      }
    };

    View.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {}; // Date Rendering
    // -----------------------------------------------------------------------------------------------------------------


    View.prototype.renderDatesWrap = function (dateProfile) {
      this.renderDates(dateProfile);
      this.addScroll({
        duration: createDuration(this.opt('scrollTime'))
      });
      this.startNowIndicator(dateProfile); // shouldn't render yet because updateSize will be called soon
    };

    View.prototype.unrenderDatesWrap = function () {
      this.stopNowIndicator();
      this.unrenderDates();
    };

    View.prototype.renderDates = function (dateProfile) {};

    View.prototype.unrenderDates = function () {}; // Business Hours
    // -----------------------------------------------------------------------------------------------------------------


    View.prototype.renderBusinessHours = function (businessHours) {};

    View.prototype.unrenderBusinessHours = function () {}; // Date Selection
    // -----------------------------------------------------------------------------------------------------------------


    View.prototype.renderDateSelectionWrap = function (selection) {
      if (selection) {
        this.renderDateSelection(selection);
      }
    };

    View.prototype.unrenderDateSelectionWrap = function (selection) {
      if (selection) {
        this.unrenderDateSelection(selection);
      }
    };

    View.prototype.renderDateSelection = function (selection) {};

    View.prototype.unrenderDateSelection = function (selection) {}; // Event Rendering
    // -----------------------------------------------------------------------------------------------------------------


    View.prototype.renderEvents = function (eventStore) {};

    View.prototype.unrenderEvents = function () {}; // util for subclasses


    View.prototype.sliceEvents = function (eventStore, allDay) {
      var props = this.props;
      return sliceEventStore(eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? this.nextDayThreshold : null).fg;
    };

    View.prototype.computeEventDraggable = function (eventDef, eventUi) {
      var transformers = this.calendar.pluginSystem.hooks.isDraggableTransformers;
      var val = eventUi.startEditable;

      for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
        var transformer = transformers_1[_i];
        val = transformer(val, eventDef, eventUi, this);
      }

      return val;
    };

    View.prototype.computeEventStartResizable = function (eventDef, eventUi) {
      return eventUi.durationEditable && this.opt('eventResizableFromStart');
    };

    View.prototype.computeEventEndResizable = function (eventDef, eventUi) {
      return eventUi.durationEditable;
    }; // Event Selection
    // -----------------------------------------------------------------------------------------------------------------


    View.prototype.renderEventSelectionWrap = function (instanceId) {
      if (instanceId) {
        this.renderEventSelection(instanceId);
      }
    };

    View.prototype.unrenderEventSelectionWrap = function (instanceId) {
      if (instanceId) {
        this.unrenderEventSelection(instanceId);
      }
    };

    View.prototype.renderEventSelection = function (instanceId) {};

    View.prototype.unrenderEventSelection = function (instanceId) {}; // Event Drag
    // -----------------------------------------------------------------------------------------------------------------


    View.prototype.renderEventDragWrap = function (state) {
      if (state) {
        this.renderEventDrag(state);
      }
    };

    View.prototype.unrenderEventDragWrap = function (state) {
      if (state) {
        this.unrenderEventDrag(state);
      }
    };

    View.prototype.renderEventDrag = function (state) {};

    View.prototype.unrenderEventDrag = function (state) {}; // Event Resize
    // -----------------------------------------------------------------------------------------------------------------


    View.prototype.renderEventResizeWrap = function (state) {
      if (state) {
        this.renderEventResize(state);
      }
    };

    View.prototype.unrenderEventResizeWrap = function (state) {
      if (state) {
        this.unrenderEventResize(state);
      }
    };

    View.prototype.renderEventResize = function (state) {};

    View.prototype.unrenderEventResize = function (state) {};
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    // Immediately render the current time indicator and begins re-rendering it at an interval,
    // which is defined by this.getNowIndicatorUnit().
    // TODO: somehow do this for the current whole day's background too


    View.prototype.startNowIndicator = function (dateProfile) {
      var _this = this;

      var dateEnv = this.dateEnv;
      var unit;
      var update;
      var delay; // ms wait value

      if (this.opt('nowIndicator')) {
        unit = this.getNowIndicatorUnit(dateProfile);

        if (unit) {
          update = this.updateNowIndicator.bind(this);
          this.initialNowDate = this.calendar.getNow();
          this.initialNowQueriedMs = new Date().valueOf(); // wait until the beginning of the next interval

          delay = dateEnv.add(dateEnv.startOf(this.initialNowDate, unit), createDuration(1, unit)).valueOf() - this.initialNowDate.valueOf(); // TODO: maybe always use setTimeout, waiting until start of next unit

          this.nowIndicatorTimeoutID = setTimeout(function () {
            _this.nowIndicatorTimeoutID = null;
            update();

            if (unit === 'second') {
              delay = 1000; // every second
            } else {
              delay = 1000 * 60; // otherwise, every minute
            }

            _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
          }, delay);
        } // rendering will be initiated in updateSize

      }
    }; // rerenders the now indicator, computing the new current time from the amount of time that has passed
    // since the initial getNow call.


    View.prototype.updateNowIndicator = function () {
      if (this.props.dateProfile && // a way to determine if dates were rendered yet
      this.initialNowDate // activated before?
      ) {
          this.unrenderNowIndicator(); // won't unrender if unnecessary

          this.renderNowIndicator(addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs));
          this.isNowIndicatorRendered = true;
        }
    }; // Immediately unrenders the view's current time indicator and stops any re-rendering timers.
    // Won't cause side effects if indicator isn't rendered.


    View.prototype.stopNowIndicator = function () {
      if (this.isNowIndicatorRendered) {
        if (this.nowIndicatorTimeoutID) {
          clearTimeout(this.nowIndicatorTimeoutID);
          this.nowIndicatorTimeoutID = null;
        }

        if (this.nowIndicatorIntervalID) {
          clearInterval(this.nowIndicatorIntervalID);
          this.nowIndicatorIntervalID = null;
        }

        this.unrenderNowIndicator();
        this.isNowIndicatorRendered = false;
      }
    };

    View.prototype.getNowIndicatorUnit = function (dateProfile) {// subclasses should implement
    }; // Renders a current time indicator at the given datetime


    View.prototype.renderNowIndicator = function (date) {// SUBCLASSES MUST PASS TO CHILDREN!
    }; // Undoes the rendering actions from renderNowIndicator


    View.prototype.unrenderNowIndicator = function () {// SUBCLASSES MUST PASS TO CHILDREN!
    };
    /* Scroller
    ------------------------------------------------------------------------------------------------------------------*/


    View.prototype.addScroll = function (scroll) {
      var queuedScroll = this.queuedScroll || (this.queuedScroll = {});

      _assign(queuedScroll, scroll);
    };

    View.prototype.popScroll = function (isResize) {
      this.applyQueuedScroll(isResize);
      this.queuedScroll = null;
    };

    View.prototype.applyQueuedScroll = function (isResize) {
      this.applyScroll(this.queuedScroll || {}, isResize);
    };

    View.prototype.queryScroll = function () {
      var scroll = {};

      if (this.props.dateProfile) {
        // dates rendered yet?
        _assign(scroll, this.queryDateScroll());
      }

      return scroll;
    };

    View.prototype.applyScroll = function (scroll, isResize) {
      var duration = scroll.duration;

      if (duration != null) {
        delete scroll.duration;

        if (this.props.dateProfile) {
          // dates rendered yet?
          _assign(scroll, this.computeDateScroll(duration));
        }
      }

      if (this.props.dateProfile) {
        // dates rendered yet?
        this.applyDateScroll(scroll);
      }
    };

    View.prototype.computeDateScroll = function (duration) {
      return {}; // subclasses must implement
    };

    View.prototype.queryDateScroll = function () {
      return {}; // subclasses must implement
    };

    View.prototype.applyDateScroll = function (scroll) {// subclasses must implement
    }; // for API


    View.prototype.scrollToDuration = function (duration) {
      this.applyScroll({
        duration: duration
      }, false);
    };

    return View;
  }(DateComponent);

  EmitterMixin.mixInto(View);
  View.prototype.usesMinMaxTime = false;
  View.prototype.dateProfileGeneratorClass = DateProfileGenerator;

  var FgEventRenderer =
  /** @class */
  function () {
    function FgEventRenderer(context) {
      this.segs = [];
      this.isSizeDirty = false;
      this.context = context;
    }

    FgEventRenderer.prototype.renderSegs = function (segs, mirrorInfo) {
      this.rangeUpdated(); // called too frequently :(
      // render an `.el` on each seg
      // returns a subset of the segs. segs that were actually rendered

      segs = this.renderSegEls(segs, mirrorInfo);
      this.segs = segs;
      this.attachSegs(segs, mirrorInfo);
      this.isSizeDirty = true;
      this.context.view.triggerRenderedSegs(this.segs, Boolean(mirrorInfo));
    };

    FgEventRenderer.prototype.unrender = function (_segs, mirrorInfo) {
      this.context.view.triggerWillRemoveSegs(this.segs, Boolean(mirrorInfo));
      this.detachSegs(this.segs);
      this.segs = [];
    }; // Updates values that rely on options and also relate to range


    FgEventRenderer.prototype.rangeUpdated = function () {
      var options = this.context.options;
      var displayEventTime;
      var displayEventEnd;
      this.eventTimeFormat = createFormatter(options.eventTimeFormat || this.computeEventTimeFormat(), options.defaultRangeSeparator);
      displayEventTime = options.displayEventTime;

      if (displayEventTime == null) {
        displayEventTime = this.computeDisplayEventTime(); // might be based off of range
      }

      displayEventEnd = options.displayEventEnd;

      if (displayEventEnd == null) {
        displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
      }

      this.displayEventTime = displayEventTime;
      this.displayEventEnd = displayEventEnd;
    }; // Renders and assigns an `el` property for each foreground event segment.
    // Only returns segments that successfully rendered.


    FgEventRenderer.prototype.renderSegEls = function (segs, mirrorInfo) {
      var html = '';
      var i;

      if (segs.length) {
        // don't build an empty html string
        // build a large concatenation of event segment HTML
        for (i = 0; i < segs.length; i++) {
          html += this.renderSegHtml(segs[i], mirrorInfo);
        } // Grab individual elements from the combined HTML string. Use each as the default rendering.
        // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.


        htmlToElements(html).forEach(function (el, i) {
          var seg = segs[i];

          if (el) {
            seg.el = el;
          }
        });
        segs = filterSegsViaEls(this.context.view, segs, Boolean(mirrorInfo));
      }

      return segs;
    }; // Generic utility for generating the HTML classNames for an event segment's element


    FgEventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable, mirrorInfo) {
      var classes = ['fc-event', seg.isStart ? 'fc-start' : 'fc-not-start', seg.isEnd ? 'fc-end' : 'fc-not-end'].concat(seg.eventRange.ui.classNames);

      if (isDraggable) {
        classes.push('fc-draggable');
      }

      if (isResizable) {
        classes.push('fc-resizable');
      }

      if (mirrorInfo) {
        classes.push('fc-mirror');

        if (mirrorInfo.isDragging) {
          classes.push('fc-dragging');
        }

        if (mirrorInfo.isResizing) {
          classes.push('fc-resizing');
        }
      }

      return classes;
    }; // Compute the text that should be displayed on an event's element.
    // `range` can be the Event object itself, or something range-like, with at least a `start`.
    // If event times are disabled, or the event has no time, will return a blank string.
    // If not specified, formatter will default to the eventTimeFormat setting,
    // and displayEnd will default to the displayEventEnd setting.


    FgEventRenderer.prototype.getTimeText = function (eventRange, formatter, displayEnd) {
      var def = eventRange.def,
          instance = eventRange.instance;
      return this._getTimeText(instance.range.start, def.hasEnd ? instance.range.end : null, def.allDay, formatter, displayEnd, instance.forcedStartTzo, instance.forcedEndTzo);
    };

    FgEventRenderer.prototype._getTimeText = function (start, end, allDay, formatter, displayEnd, forcedStartTzo, forcedEndTzo) {
      var dateEnv = this.context.dateEnv;

      if (formatter == null) {
        formatter = this.eventTimeFormat;
      }

      if (displayEnd == null) {
        displayEnd = this.displayEventEnd;
      }

      if (this.displayEventTime && !allDay) {
        if (displayEnd && end) {
          return dateEnv.formatRange(start, end, formatter, {
            forcedStartTzo: forcedStartTzo,
            forcedEndTzo: forcedEndTzo
          });
        } else {
          return dateEnv.format(start, formatter, {
            forcedTzo: forcedStartTzo
          });
        }
      }

      return '';
    };

    FgEventRenderer.prototype.computeEventTimeFormat = function () {
      return {
        hour: 'numeric',
        minute: '2-digit',
        omitZeroMinute: true
      };
    };

    FgEventRenderer.prototype.computeDisplayEventTime = function () {
      return true;
    };

    FgEventRenderer.prototype.computeDisplayEventEnd = function () {
      return true;
    }; // Utility for generating event skin-related CSS properties


    FgEventRenderer.prototype.getSkinCss = function (ui) {
      return {
        'background-color': ui.backgroundColor,
        'border-color': ui.borderColor,
        color: ui.textColor
      };
    };

    FgEventRenderer.prototype.sortEventSegs = function (segs) {
      var specs = this.context.view.eventOrderSpecs;
      var objs = segs.map(buildSegCompareObj);
      objs.sort(function (obj0, obj1) {
        return compareByFieldSpecs(obj0, obj1, specs);
      });
      return objs.map(function (c) {
        return c._seg;
      });
    };

    FgEventRenderer.prototype.computeSizes = function (force) {
      if (force || this.isSizeDirty) {
        this.computeSegSizes(this.segs);
      }
    };

    FgEventRenderer.prototype.assignSizes = function (force) {
      if (force || this.isSizeDirty) {
        this.assignSegSizes(this.segs);
        this.isSizeDirty = false;
      }
    };

    FgEventRenderer.prototype.computeSegSizes = function (segs) {};

    FgEventRenderer.prototype.assignSegSizes = function (segs) {}; // Manipulation on rendered segs


    FgEventRenderer.prototype.hideByHash = function (hash) {
      if (hash) {
        for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
          var seg = _a[_i];

          if (hash[seg.eventRange.instance.instanceId]) {
            seg.el.style.visibility = 'hidden';
          }
        }
      }
    };

    FgEventRenderer.prototype.showByHash = function (hash) {
      if (hash) {
        for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
          var seg = _a[_i];

          if (hash[seg.eventRange.instance.instanceId]) {
            seg.el.style.visibility = '';
          }
        }
      }
    };

    FgEventRenderer.prototype.selectByInstanceId = function (instanceId) {
      if (instanceId) {
        for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
          var seg = _a[_i];
          var eventInstance = seg.eventRange.instance;

          if (eventInstance && eventInstance.instanceId === instanceId && seg.el // necessary?
          ) {
              seg.el.classList.add('fc-selected');
            }
        }
      }
    };

    FgEventRenderer.prototype.unselectByInstanceId = function (instanceId) {
      if (instanceId) {
        for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
          var seg = _a[_i];

          if (seg.el) {
            // necessary?
            seg.el.classList.remove('fc-selected');
          }
        }
      }
    };

    return FgEventRenderer;
  }(); // returns a object with all primitive props that can be compared


  function buildSegCompareObj(seg) {
    var eventDef = seg.eventRange.def;
    var range = seg.eventRange.instance.range;
    var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events

    var end = range.end ? range.end.valueOf() : 0; // "

    return _assign({}, eventDef.extendedProps, eventDef, {
      id: eventDef.publicId,
      start: start,
      end: end,
      duration: end - start,
      allDay: Number(eventDef.allDay),
      _seg: seg // for later retrieval

    });
  }

  var FillRenderer =
  /** @class */
  function () {
    function FillRenderer(context) {
      this.fillSegTag = 'div';
      this.dirtySizeFlags = {};
      this.context = context;
      this.containerElsByType = {};
      this.segsByType = {};
    }

    FillRenderer.prototype.getSegsByType = function (type) {
      return this.segsByType[type] || [];
    };

    FillRenderer.prototype.renderSegs = function (type, segs) {
      var _a;

      var renderedSegs = this.renderSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs

      var containerEls = this.attachSegs(type, renderedSegs);

      if (containerEls) {
        (_a = this.containerElsByType[type] || (this.containerElsByType[type] = [])).push.apply(_a, containerEls);
      }

      this.segsByType[type] = renderedSegs;

      if (type === 'bgEvent') {
        this.context.view.triggerRenderedSegs(renderedSegs, false); // isMirror=false
      }

      this.dirtySizeFlags[type] = true;
    }; // Unrenders a specific type of fill that is currently rendered on the grid


    FillRenderer.prototype.unrender = function (type) {
      var segs = this.segsByType[type];

      if (segs) {
        if (type === 'bgEvent') {
          this.context.view.triggerWillRemoveSegs(segs, false); // isMirror=false
        }

        this.detachSegs(type, segs);
      }
    }; // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
    // Only returns segments that successfully rendered.


    FillRenderer.prototype.renderSegEls = function (type, segs) {
      var _this = this;

      var html = '';
      var i;

      if (segs.length) {
        // build a large concatenation of segment HTML
        for (i = 0; i < segs.length; i++) {
          html += this.renderSegHtml(type, segs[i]);
        } // Grab individual elements from the combined HTML string. Use each as the default rendering.
        // Then, compute the 'el' for each segment.


        htmlToElements(html).forEach(function (el, i) {
          var seg = segs[i];

          if (el) {
            seg.el = el;
          }
        });

        if (type === 'bgEvent') {
          segs = filterSegsViaEls(this.context.view, segs, false // isMirror. background events can never be mirror elements
          );
        } // correct element type? (would be bad if a non-TD were inserted into a table for example)


        segs = segs.filter(function (seg) {
          return elementMatches(seg.el, _this.fillSegTag);
        });
      }

      return segs;
    }; // Builds the HTML needed for one fill segment. Generic enough to work with different types.


    FillRenderer.prototype.renderSegHtml = function (type, seg) {
      var css = null;
      var classNames = [];

      if (type !== 'highlight' && type !== 'businessHours') {
        css = {
          'background-color': seg.eventRange.ui.backgroundColor
        };
      }

      if (type !== 'highlight') {
        classNames = classNames.concat(seg.eventRange.ui.classNames);
      }

      if (type === 'businessHours') {
        classNames.push('fc-bgevent');
      } else {
        classNames.push('fc-' + type.toLowerCase());
      }

      return '<' + this.fillSegTag + (classNames.length ? ' class="' + classNames.join(' ') + '"' : '') + (css ? ' style="' + cssToStr(css) + '"' : '') + '></' + this.fillSegTag + '>';
    };

    FillRenderer.prototype.detachSegs = function (type, segs) {
      var containerEls = this.containerElsByType[type];

      if (containerEls) {
        containerEls.forEach(removeElement);
        delete this.containerElsByType[type];
      }
    };

    FillRenderer.prototype.computeSizes = function (force) {
      for (var type in this.segsByType) {
        if (force || this.dirtySizeFlags[type]) {
          this.computeSegSizes(this.segsByType[type]);
        }
      }
    };

    FillRenderer.prototype.assignSizes = function (force) {
      for (var type in this.segsByType) {
        if (force || this.dirtySizeFlags[type]) {
          this.assignSegSizes(this.segsByType[type]);
        }
      }

      this.dirtySizeFlags = {};
    };

    FillRenderer.prototype.computeSegSizes = function (segs) {};

    FillRenderer.prototype.assignSegSizes = function (segs) {};

    return FillRenderer;
  }();

  var NamedTimeZoneImpl =
  /** @class */
  function () {
    function NamedTimeZoneImpl(timeZoneName) {
      this.timeZoneName = timeZoneName;
    }

    return NamedTimeZoneImpl;
  }();
  /*
  An abstraction for a dragging interaction originating on an event.
  Does higher-level things than PointerDragger, such as possibly:
  - a "mirror" that moves with the pointer
  - a minimum number of pixels or other criteria for a true drag to begin
    subclasses must emit:
  - pointerdown
  - dragstart
  - dragmove
  - pointerup
  - dragend
  */


  var ElementDragging =
  /** @class */
  function () {
    function ElementDragging(el) {
      this.emitter = new EmitterMixin();
    }

    ElementDragging.prototype.destroy = function () {};

    ElementDragging.prototype.setMirrorIsVisible = function (bool) {// optional if subclass doesn't want to support a mirror
    };

    ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {// optional if subclass doesn't want to support a mirror
    };

    ElementDragging.prototype.setAutoScrollEnabled = function (bool) {// optional
    };

    return ElementDragging;
  }();

  function formatDate(dateInput, settings) {
    if (settings === void 0) {
      settings = {};
    }

    var dateEnv = buildDateEnv$1(settings);
    var formatter = createFormatter(settings);
    var dateMeta = dateEnv.createMarkerMeta(dateInput);

    if (!dateMeta) {
      // TODO: warning?
      return '';
    }

    return dateEnv.format(dateMeta.marker, formatter, {
      forcedTzo: dateMeta.forcedTzo
    });
  }

  function formatRange(startInput, endInput, settings // mixture of env and formatter settings
  ) {
    var dateEnv = buildDateEnv$1(_typeof(settings) === 'object' && settings ? settings : {}); // pass in if non-null object

    var formatter = createFormatter(settings, globalDefaults.defaultRangeSeparator);
    var startMeta = dateEnv.createMarkerMeta(startInput);
    var endMeta = dateEnv.createMarkerMeta(endInput);

    if (!startMeta || !endMeta) {
      // TODO: warning?
      return '';
    }

    return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {
      forcedStartTzo: startMeta.forcedTzo,
      forcedEndTzo: endMeta.forcedTzo,
      isEndExclusive: settings.isEndExclusive
    });
  } // TODO: more DRY and optimized


  function buildDateEnv$1(settings) {
    var locale = buildLocale(settings.locale || 'en', parseRawLocales([]).map); // TODO: don't hardcode 'en' everywhere
    // ensure required settings

    settings = _assign({
      timeZone: globalDefaults.timeZone,
      calendarSystem: 'gregory'
    }, settings, {
      locale: locale
    });
    return new DateEnv(settings);
  }

  var DRAG_META_PROPS = {
    startTime: createDuration,
    duration: createDuration,
    create: Boolean,
    sourceId: String
  };
  var DRAG_META_DEFAULTS = {
    create: true
  };

  function parseDragMeta(raw) {
    var leftoverProps = {};
    var refined = refineProps(raw, DRAG_META_PROPS, DRAG_META_DEFAULTS, leftoverProps);
    refined.leftoverProps = leftoverProps;
    return refined;
  } // Computes a default column header formatting string if `colFormat` is not explicitly defined


  function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
    // if more than one week row, or if there are a lot of columns with not much space,
    // put just the day numbers will be in each cell
    if (!datesRepDistinctDays || dayCnt > 10) {
      return {
        weekday: 'short'
      }; // "Sat"
    } else if (dayCnt > 1) {
      return {
        weekday: 'short',
        month: 'numeric',
        day: 'numeric',
        omitCommas: true
      }; // "Sat 11/12"
    } else {
      return {
        weekday: 'long'
      }; // "Saturday"
    }
  }

  function renderDateCell(dateMarker, dateProfile, datesRepDistinctDays, colCnt, colHeadFormat, context, colspan, otherAttrs) {
    var view = context.view,
        dateEnv = context.dateEnv,
        theme = context.theme,
        options = context.options;
    var isDateValid = rangeContainsMarker(dateProfile.activeRange, dateMarker); // TODO: called too frequently. cache somehow.

    var classNames = ['fc-day-header', theme.getClass('widgetHeader')];
    var innerHtml;

    if (typeof options.columnHeaderHtml === 'function') {
      innerHtml = options.columnHeaderHtml(dateEnv.toDate(dateMarker));
    } else if (typeof options.columnHeaderText === 'function') {
      innerHtml = htmlEscape(options.columnHeaderText(dateEnv.toDate(dateMarker)));
    } else {
      innerHtml = htmlEscape(dateEnv.format(dateMarker, colHeadFormat));
    } // if only one row of days, the classNames on the header can represent the specific days beneath


    if (datesRepDistinctDays) {
      classNames = classNames.concat( // includes the day-of-week class
      // noThemeHighlight=true (don't highlight the header)
      getDayClasses(dateMarker, dateProfile, context, true));
    } else {
      classNames.push('fc-' + DAY_IDS[dateMarker.getUTCDay()]); // only add the day-of-week class
    }

    return '' + '<th class="' + classNames.join(' ') + '"' + (isDateValid && datesRepDistinctDays ? ' data-date="' + dateEnv.formatIso(dateMarker, {
      omitTime: true
    }) + '"' : '') + (colspan > 1 ? ' colspan="' + colspan + '"' : '') + (otherAttrs ? ' ' + otherAttrs : '') + '>' + (isDateValid ? // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
    buildGotoAnchorHtml(view, {
      date: dateMarker,
      forceOff: !datesRepDistinctDays || colCnt === 1
    }, innerHtml) : // if not valid, display text, but no link
    innerHtml) + '</th>';
  }

  var DayHeader =
  /** @class */
  function (_super) {
    __extends(DayHeader, _super);

    function DayHeader(context, parentEl) {
      var _this = _super.call(this, context) || this;

      parentEl.innerHTML = ''; // because might be nbsp

      parentEl.appendChild(_this.el = htmlToElement('<div class="fc-row ' + _this.theme.getClass('headerRow') + '">' + '<table class="' + _this.theme.getClass('tableGrid') + '">' + '<thead></thead>' + '</table>' + '</div>'));
      _this.thead = _this.el.querySelector('thead');
      return _this;
    }

    DayHeader.prototype.destroy = function () {
      removeElement(this.el);
    };

    DayHeader.prototype.render = function (props) {
      var dates = props.dates,
          datesRepDistinctDays = props.datesRepDistinctDays;
      var parts = [];

      if (props.renderIntroHtml) {
        parts.push(props.renderIntroHtml());
      }

      var colHeadFormat = createFormatter(this.opt('columnHeaderFormat') || computeFallbackHeaderFormat(datesRepDistinctDays, dates.length));

      for (var _i = 0, dates_1 = dates; _i < dates_1.length; _i++) {
        var date = dates_1[_i];
        parts.push(renderDateCell(date, props.dateProfile, datesRepDistinctDays, dates.length, colHeadFormat, this.context));
      }

      if (this.isRtl) {
        parts.reverse();
      }

      this.thead.innerHTML = '<tr>' + parts.join('') + '</tr>';
    };

    return DayHeader;
  }(Component);

  var DaySeries =
  /** @class */
  function () {
    function DaySeries(range, dateProfileGenerator) {
      var date = range.start;
      var end = range.end;
      var indices = [];
      var dates = [];
      var dayIndex = -1;

      while (date < end) {
        // loop each day from start to end
        if (dateProfileGenerator.isHiddenDay(date)) {
          indices.push(dayIndex + 0.5); // mark that it's between indices
        } else {
          dayIndex++;
          indices.push(dayIndex);
          dates.push(date);
        }

        date = addDays(date, 1);
      }

      this.dates = dates;
      this.indices = indices;
      this.cnt = dates.length;
    }

    DaySeries.prototype.sliceRange = function (range) {
      var firstIndex = this.getDateDayIndex(range.start); // inclusive first index

      var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index

      var clippedFirstIndex = Math.max(0, firstIndex);
      var clippedLastIndex = Math.min(this.cnt - 1, lastIndex); // deal with in-between indices

      clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell

      clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell

      if (clippedFirstIndex <= clippedLastIndex) {
        return {
          firstIndex: clippedFirstIndex,
          lastIndex: clippedLastIndex,
          isStart: firstIndex === clippedFirstIndex,
          isEnd: lastIndex === clippedLastIndex
        };
      } else {
        return null;
      }
    }; // Given a date, returns its chronolocial cell-index from the first cell of the grid.
    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
    // If before the first offset, returns a negative number.
    // If after the last offset, returns an offset past the last cell offset.
    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.


    DaySeries.prototype.getDateDayIndex = function (date) {
      var indices = this.indices;
      var dayOffset = Math.floor(diffDays(this.dates[0], date));

      if (dayOffset < 0) {
        return indices[0] - 1;
      } else if (dayOffset >= indices.length) {
        return indices[indices.length - 1] + 1;
      } else {
        return indices[dayOffset];
      }
    };

    return DaySeries;
  }();

  var DayTable =
  /** @class */
  function () {
    function DayTable(daySeries, breakOnWeeks) {
      var dates = daySeries.dates;
      var daysPerRow;
      var firstDay;
      var rowCnt;

      if (breakOnWeeks) {
        // count columns until the day-of-week repeats
        firstDay = dates[0].getUTCDay();

        for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow++) {
          if (dates[daysPerRow].getUTCDay() === firstDay) {
            break;
          }
        }

        rowCnt = Math.ceil(dates.length / daysPerRow);
      } else {
        rowCnt = 1;
        daysPerRow = dates.length;
      }

      this.rowCnt = rowCnt;
      this.colCnt = daysPerRow;
      this.daySeries = daySeries;
      this.cells = this.buildCells();
      this.headerDates = this.buildHeaderDates();
    }

    DayTable.prototype.buildCells = function () {
      var rows = [];

      for (var row = 0; row < this.rowCnt; row++) {
        var cells = [];

        for (var col = 0; col < this.colCnt; col++) {
          cells.push(this.buildCell(row, col));
        }

        rows.push(cells);
      }

      return rows;
    };

    DayTable.prototype.buildCell = function (row, col) {
      return {
        date: this.daySeries.dates[row * this.colCnt + col]
      };
    };

    DayTable.prototype.buildHeaderDates = function () {
      var dates = [];

      for (var col = 0; col < this.colCnt; col++) {
        dates.push(this.cells[0][col].date);
      }

      return dates;
    };

    DayTable.prototype.sliceRange = function (range) {
      var colCnt = this.colCnt;
      var seriesSeg = this.daySeries.sliceRange(range);
      var segs = [];

      if (seriesSeg) {
        var firstIndex = seriesSeg.firstIndex,
            lastIndex = seriesSeg.lastIndex;
        var index = firstIndex;

        while (index <= lastIndex) {
          var row = Math.floor(index / colCnt);
          var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
          segs.push({
            row: row,
            firstCol: index % colCnt,
            lastCol: (nextIndex - 1) % colCnt,
            isStart: seriesSeg.isStart && index === firstIndex,
            isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
          });
          index = nextIndex;
        }
      }

      return segs;
    };

    return DayTable;
  }();

  var Slicer =
  /** @class */
  function () {
    function Slicer() {
      this.sliceBusinessHours = memoize(this._sliceBusinessHours);
      this.sliceDateSelection = memoize(this._sliceDateSpan);
      this.sliceEventStore = memoize(this._sliceEventStore);
      this.sliceEventDrag = memoize(this._sliceInteraction);
      this.sliceEventResize = memoize(this._sliceInteraction);
    }

    Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, component) {
      var extraArgs = [];

      for (var _i = 4; _i < arguments.length; _i++) {
        extraArgs[_i - 4] = arguments[_i];
      }

      var eventUiBases = props.eventUiBases;
      var eventSegs = this.sliceEventStore.apply(this, [props.eventStore, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs));
      return {
        dateSelectionSegs: this.sliceDateSelection.apply(this, [props.dateSelection, eventUiBases, component].concat(extraArgs)),
        businessHourSegs: this.sliceBusinessHours.apply(this, [props.businessHours, dateProfile, nextDayThreshold, component].concat(extraArgs)),
        fgEventSegs: eventSegs.fg,
        bgEventSegs: eventSegs.bg,
        eventDrag: this.sliceEventDrag.apply(this, [props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs)),
        eventResize: this.sliceEventResize.apply(this, [props.eventResize, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs)),
        eventSelection: props.eventSelection
      }; // TODO: give interactionSegs?
    };

    Slicer.prototype.sliceNowDate = function ( // does not memoize
    date, component) {
      var extraArgs = [];

      for (var _i = 2; _i < arguments.length; _i++) {
        extraArgs[_i - 2] = arguments[_i];
      }

      return this._sliceDateSpan.apply(this, [{
        range: {
          start: date,
          end: addMs(date, 1)
        },
        allDay: false
      }, {}, component].concat(extraArgs));
    };

    Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, component) {
      var extraArgs = [];

      for (var _i = 4; _i < arguments.length; _i++) {
        extraArgs[_i - 4] = arguments[_i];
      }

      if (!businessHours) {
        return [];
      }

      return this._sliceEventStore.apply(this, [expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), component.calendar), {}, dateProfile, nextDayThreshold, component].concat(extraArgs)).bg;
    };

    Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold, component) {
      var extraArgs = [];

      for (var _i = 5; _i < arguments.length; _i++) {
        extraArgs[_i - 5] = arguments[_i];
      }

      if (eventStore) {
        var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
        return {
          bg: this.sliceEventRanges(rangeRes.bg, component, extraArgs),
          fg: this.sliceEventRanges(rangeRes.fg, component, extraArgs)
        };
      } else {
        return {
          bg: [],
          fg: []
        };
      }
    };

    Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold, component) {
      var extraArgs = [];

      for (var _i = 5; _i < arguments.length; _i++) {
        extraArgs[_i - 5] = arguments[_i];
      }

      if (!interaction) {
        return null;
      }

      var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
      return {
        segs: this.sliceEventRanges(rangeRes.fg, component, extraArgs),
        affectedInstances: interaction.affectedEvents.instances,
        isEvent: interaction.isEvent,
        sourceSeg: interaction.origSeg
      };
    };

    Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, component) {
      var extraArgs = [];

      for (var _i = 3; _i < arguments.length; _i++) {
        extraArgs[_i - 3] = arguments[_i];
      }

      if (!dateSpan) {
        return [];
      }

      var eventRange = fabricateEventRange(dateSpan, eventUiBases, component.calendar);
      var segs = this.sliceRange.apply(this, [dateSpan.range].concat(extraArgs));

      for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {
        var seg = segs_1[_a];
        seg.component = component;
        seg.eventRange = eventRange;
      }

      return segs;
    };
    /*
    "complete" seg means it has component and eventRange
    */


    Slicer.prototype.sliceEventRanges = function (eventRanges, component, // TODO: kill
    extraArgs) {
      var segs = [];

      for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {
        var eventRange = eventRanges_1[_i];
        segs.push.apply(segs, this.sliceEventRange(eventRange, component, extraArgs));
      }

      return segs;
    };
    /*
    "complete" seg means it has component and eventRange
    */


    Slicer.prototype.sliceEventRange = function (eventRange, component, // TODO: kill
    extraArgs) {
      var segs = this.sliceRange.apply(this, [eventRange.range].concat(extraArgs));

      for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
        var seg = segs_2[_i];
        seg.component = component;
        seg.eventRange = eventRange;
        seg.isStart = eventRange.isStart && seg.isStart;
        seg.isEnd = eventRange.isEnd && seg.isEnd;
      }

      return segs;
    };

    return Slicer;
  }();
  /*
  for incorporating minTime/maxTime if appropriate
  TODO: should be part of DateProfile!
  TimelineDateProfile already does this btw
  */


  function computeActiveRange(dateProfile, isComponentAllDay) {
    var range = dateProfile.activeRange;

    if (isComponentAllDay) {
      return range;
    }

    return {
      start: addMs(range.start, dateProfile.minTime.milliseconds),
      end: addMs(range.end, dateProfile.maxTime.milliseconds - 864e5) // 864e5 = ms in a day

    };
  } // exports
  // --------------------------------------------------------------------------------------------------


  var version = '4.3.1';
  exports.Calendar = Calendar;
  exports.Component = Component;
  exports.DateComponent = DateComponent;
  exports.DateEnv = DateEnv;
  exports.DateProfileGenerator = DateProfileGenerator;
  exports.DayHeader = DayHeader;
  exports.DaySeries = DaySeries;
  exports.DayTable = DayTable;
  exports.ElementDragging = ElementDragging;
  exports.ElementScrollController = ElementScrollController;
  exports.EmitterMixin = EmitterMixin;
  exports.EventApi = EventApi;
  exports.FgEventRenderer = FgEventRenderer;
  exports.FillRenderer = FillRenderer;
  exports.Interaction = Interaction;
  exports.Mixin = Mixin;
  exports.NamedTimeZoneImpl = NamedTimeZoneImpl;
  exports.PositionCache = PositionCache;
  exports.ScrollComponent = ScrollComponent;
  exports.ScrollController = ScrollController;
  exports.Slicer = Slicer;
  exports.Splitter = Splitter;
  exports.Theme = Theme;
  exports.View = View;
  exports.WindowScrollController = WindowScrollController;
  exports.addDays = addDays;
  exports.addDurations = addDurations;
  exports.addMs = addMs;
  exports.addWeeks = addWeeks;
  exports.allowContextMenu = allowContextMenu;
  exports.allowSelection = allowSelection;
  exports.appendToElement = appendToElement;
  exports.applyAll = applyAll;
  exports.applyMutationToEventStore = applyMutationToEventStore;
  exports.applyStyle = applyStyle;
  exports.applyStyleProp = applyStyleProp;
  exports.asRoughMinutes = asRoughMinutes;
  exports.asRoughMs = asRoughMs;
  exports.asRoughSeconds = asRoughSeconds;
  exports.buildGotoAnchorHtml = buildGotoAnchorHtml;
  exports.buildSegCompareObj = buildSegCompareObj;
  exports.capitaliseFirstLetter = capitaliseFirstLetter;
  exports.combineEventUis = combineEventUis;
  exports.compareByFieldSpec = compareByFieldSpec;
  exports.compareByFieldSpecs = compareByFieldSpecs;
  exports.compareNumbers = compareNumbers;
  exports.compensateScroll = compensateScroll;
  exports.computeClippingRect = computeClippingRect;
  exports.computeEdges = computeEdges;
  exports.computeFallbackHeaderFormat = computeFallbackHeaderFormat;
  exports.computeHeightAndMargins = computeHeightAndMargins;
  exports.computeInnerRect = computeInnerRect;
  exports.computeRect = computeRect;
  exports.computeVisibleDayRange = computeVisibleDayRange;
  exports.config = config;
  exports.constrainPoint = constrainPoint;
  exports.createDuration = createDuration;
  exports.createElement = createElement;
  exports.createEmptyEventStore = createEmptyEventStore;
  exports.createEventInstance = createEventInstance;
  exports.createFormatter = createFormatter;
  exports.createPlugin = createPlugin;
  exports.cssToStr = cssToStr;
  exports.debounce = debounce;
  exports.diffDates = diffDates;
  exports.diffDayAndTime = diffDayAndTime;
  exports.diffDays = diffDays;
  exports.diffPoints = diffPoints;
  exports.diffWeeks = diffWeeks;
  exports.diffWholeDays = diffWholeDays;
  exports.diffWholeWeeks = diffWholeWeeks;
  exports.disableCursor = disableCursor;
  exports.distributeHeight = distributeHeight;
  exports.elementClosest = elementClosest;
  exports.elementMatches = elementMatches;
  exports.enableCursor = enableCursor;
  exports.eventTupleToStore = eventTupleToStore;
  exports.filterEventStoreDefs = filterEventStoreDefs;
  exports.filterHash = filterHash;
  exports.findChildren = findChildren;
  exports.findElements = findElements;
  exports.flexibleCompare = flexibleCompare;
  exports.forceClassName = forceClassName;
  exports.formatDate = formatDate;
  exports.formatIsoTimeString = formatIsoTimeString;
  exports.formatRange = formatRange;
  exports.getAllDayHtml = getAllDayHtml;
  exports.getClippingParents = getClippingParents;
  exports.getDayClasses = getDayClasses;
  exports.getElSeg = getElSeg;
  exports.getRectCenter = getRectCenter;
  exports.getRelevantEvents = getRelevantEvents;
  exports.globalDefaults = globalDefaults;
  exports.greatestDurationDenominator = greatestDurationDenominator;
  exports.hasBgRendering = hasBgRendering;
  exports.htmlEscape = htmlEscape;
  exports.htmlToElement = htmlToElement;
  exports.insertAfterElement = insertAfterElement;
  exports.interactionSettingsStore = interactionSettingsStore;
  exports.interactionSettingsToStore = interactionSettingsToStore;
  exports.intersectRanges = intersectRanges;
  exports.intersectRects = intersectRects;
  exports.isArraysEqual = isArraysEqual;
  exports.isDateSpansEqual = isDateSpansEqual;
  exports.isInt = isInt;
  exports.isInteractionValid = isInteractionValid;
  exports.isMultiDayRange = isMultiDayRange;
  exports.isPropsEqual = isPropsEqual;
  exports.isPropsValid = isPropsValid;
  exports.isSingleDay = isSingleDay;
  exports.isValidDate = isValidDate;
  exports.listenBySelector = listenBySelector;
  exports.mapHash = mapHash;
  exports.matchCellWidths = matchCellWidths;
  exports.memoize = memoize;
  exports.memoizeOutput = memoizeOutput;
  exports.memoizeRendering = memoizeRendering;
  exports.mergeEventStores = mergeEventStores;
  exports.multiplyDuration = multiplyDuration;
  exports.padStart = padStart;
  exports.parseBusinessHours = parseBusinessHours;
  exports.parseDragMeta = parseDragMeta;
  exports.parseEventDef = parseEventDef;
  exports.parseFieldSpecs = parseFieldSpecs;
  exports.parseMarker = parse;
  exports.pointInsideRect = pointInsideRect;
  exports.prependToElement = prependToElement;
  exports.preventContextMenu = preventContextMenu;
  exports.preventDefault = preventDefault;
  exports.preventSelection = preventSelection;
  exports.processScopedUiProps = processScopedUiProps;
  exports.rangeContainsMarker = rangeContainsMarker;
  exports.rangeContainsRange = rangeContainsRange;
  exports.rangesEqual = rangesEqual;
  exports.rangesIntersect = rangesIntersect;
  exports.refineProps = refineProps;
  exports.removeElement = removeElement;
  exports.removeExact = removeExact;
  exports.renderDateCell = renderDateCell;
  exports.requestJson = requestJson;
  exports.sliceEventStore = sliceEventStore;
  exports.startOfDay = startOfDay;
  exports.subtractInnerElHeight = subtractInnerElHeight;
  exports.translateRect = translateRect;
  exports.uncompensateScroll = uncompensateScroll;
  exports.undistributeHeight = undistributeHeight;
  exports.unpromisify = unpromisify;
  exports.version = version;
  exports.whenTransitionDone = whenTransitionDone;
  exports.wholeDivideDurations = wholeDivideDurations;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./assets/fullcalendar/daygrid/main.css":
/*!**********************************************!*\
  !*** ./assets/fullcalendar/daygrid/main.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./assets/fullcalendar/daygrid/main.js":
/*!*********************************************!*\
  !*** ./assets/fullcalendar/daygrid/main.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__(/*! core-js/modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");

__webpack_require__(/*! core-js/modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");

__webpack_require__(/*! core-js/modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.concat */ "./node_modules/core-js/modules/es.array.concat.js");

__webpack_require__(/*! core-js/modules/es.array.filter */ "./node_modules/core-js/modules/es.array.filter.js");

__webpack_require__(/*! core-js/modules/es.array.for-each */ "./node_modules/core-js/modules/es.array.for-each.js");

__webpack_require__(/*! core-js/modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.join */ "./node_modules/core-js/modules/es.array.join.js");

__webpack_require__(/*! core-js/modules/es.array.reverse */ "./node_modules/core-js/modules/es.array.reverse.js");

__webpack_require__(/*! core-js/modules/es.array.slice */ "./node_modules/core-js/modules/es.array.slice.js");

__webpack_require__(/*! core-js/modules/es.array.sort */ "./node_modules/core-js/modules/es.array.sort.js");

__webpack_require__(/*! core-js/modules/es.function.bind */ "./node_modules/core-js/modules/es.function.bind.js");

__webpack_require__(/*! core-js/modules/es.object.assign */ "./node_modules/core-js/modules/es.object.assign.js");

__webpack_require__(/*! core-js/modules/es.object.create */ "./node_modules/core-js/modules/es.object.create.js");

__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.set-prototype-of */ "./node_modules/core-js/modules/es.object.set-prototype-of.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
FullCalendar Day Grid Plugin v4.3.0
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, __webpack_require__(/*! @fullcalendar/core */ "./node_modules/@fullcalendar/core/main.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! @fullcalendar/core */ "./node_modules/@fullcalendar/core/main.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(this, function (exports, core) {
  'use strict';
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
    See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */

  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };

  var DayGridDateProfileGenerator =
  /** @class */
  function (_super) {
    __extends(DayGridDateProfileGenerator, _super);

    function DayGridDateProfileGenerator() {
      return _super !== null && _super.apply(this, arguments) || this;
    } // Computes the date range that will be rendered.


    DayGridDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
      var dateEnv = this.dateEnv;

      var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);

      var start = renderRange.start;
      var end = renderRange.end;
      var endOfWeek; // year and month views should be aligned with weeks. this is already done for week

      if (/^(year|month)$/.test(currentRangeUnit)) {
        start = dateEnv.startOfWeek(start); // make end-of-week if not already

        endOfWeek = dateEnv.startOfWeek(end);

        if (endOfWeek.valueOf() !== end.valueOf()) {
          end = core.addWeeks(endOfWeek, 1);
        }
      } // ensure 6 weeks


      if (this.options.monthMode && this.options.fixedWeekCount) {
        var rowCnt = Math.ceil( // could be partial weeks due to hiddenDays
        core.diffWeeks(start, end));
        end = core.addWeeks(end, 6 - rowCnt);
      }

      return {
        start: start,
        end: end
      };
    };

    return DayGridDateProfileGenerator;
  }(core.DateProfileGenerator);
  /* A rectangular panel that is absolutely positioned over other content
  ------------------------------------------------------------------------------------------------------------------------
  Options:
    - className (string)
    - content (HTML string, element, or element array)
    - parentEl
    - top
    - left
    - right (the x coord of where the right edge should be. not a "CSS" right)
    - autoHide (boolean)
    - show (callback)
    - hide (callback)
  */


  var Popover =
  /** @class */
  function () {
    function Popover(options) {
      var _this = this;

      this.isHidden = true;
      this.margin = 10; // the space required between the popover and the edges of the scroll container
      // Triggered when the user clicks *anywhere* in the document, for the autoHide feature

      this.documentMousedown = function (ev) {
        // only hide the popover if the click happened outside the popover
        if (_this.el && !_this.el.contains(ev.target)) {
          _this.hide();
        }
      };

      this.options = options;
    } // Shows the popover on the specified position. Renders it if not already


    Popover.prototype.show = function () {
      if (this.isHidden) {
        if (!this.el) {
          this.render();
        }

        this.el.style.display = '';
        this.position();
        this.isHidden = false;
        this.trigger('show');
      }
    }; // Hides the popover, through CSS, but does not remove it from the DOM


    Popover.prototype.hide = function () {
      if (!this.isHidden) {
        this.el.style.display = 'none';
        this.isHidden = true;
        this.trigger('hide');
      }
    }; // Creates `this.el` and renders content inside of it


    Popover.prototype.render = function () {
      var _this = this;

      var options = this.options;
      var el = this.el = core.createElement('div', {
        className: 'fc-popover ' + (options.className || ''),
        style: {
          top: '0',
          left: '0'
        }
      });

      if (typeof options.content === 'function') {
        options.content(el);
      }

      options.parentEl.appendChild(el); // when a click happens on anything inside with a 'fc-close' className, hide the popover

      core.listenBySelector(el, 'click', '.fc-close', function (ev) {
        _this.hide();
      });

      if (options.autoHide) {
        document.addEventListener('mousedown', this.documentMousedown);
      }
    }; // Hides and unregisters any handlers


    Popover.prototype.destroy = function () {
      this.hide();

      if (this.el) {
        core.removeElement(this.el);
        this.el = null;
      }

      document.removeEventListener('mousedown', this.documentMousedown);
    }; // Positions the popover optimally, using the top/left/right options


    Popover.prototype.position = function () {
      var options = this.options;
      var el = this.el;
      var elDims = el.getBoundingClientRect(); // only used for width,height

      var origin = core.computeRect(el.offsetParent);
      var clippingRect = core.computeClippingRect(options.parentEl);
      var top; // the "position" (not "offset") values for the popover

      var left; //
      // compute top and left

      top = options.top || 0;

      if (options.left !== undefined) {
        left = options.left;
      } else if (options.right !== undefined) {
        left = options.right - elDims.width; // derive the left value from the right value
      } else {
        left = 0;
      } // constrain to the view port. if constrained by two edges, give precedence to top/left


      top = Math.min(top, clippingRect.bottom - elDims.height - this.margin);
      top = Math.max(top, clippingRect.top + this.margin);
      left = Math.min(left, clippingRect.right - elDims.width - this.margin);
      left = Math.max(left, clippingRect.left + this.margin);
      core.applyStyle(el, {
        top: top - origin.top,
        left: left - origin.left
      });
    }; // Triggers a callback. Calls a function in the option hash of the same name.
    // Arguments beyond the first `name` are forwarded on.
    // TODO: better code reuse for this. Repeat code
    // can kill this???


    Popover.prototype.trigger = function (name) {
      if (this.options[name]) {
        this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
      }
    };

    return Popover;
  }();
  /* Event-rendering methods for the DayGrid class
  ----------------------------------------------------------------------------------------------------------------------*/
  // "Simple" is bad a name. has nothing to do with SimpleDayGrid


  var SimpleDayGridEventRenderer =
  /** @class */
  function (_super) {
    __extends(SimpleDayGridEventRenderer, _super);

    function SimpleDayGridEventRenderer() {
      return _super !== null && _super.apply(this, arguments) || this;
    } // Builds the HTML to be used for the default element for an individual segment


    SimpleDayGridEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {
      var _a = this.context,
          view = _a.view,
          options = _a.options;
      var eventRange = seg.eventRange;
      var eventDef = eventRange.def;
      var eventUi = eventRange.ui;
      var allDay = eventDef.allDay;
      var isDraggable = view.computeEventDraggable(eventDef, eventUi);
      var isResizableFromStart = allDay && seg.isStart && view.computeEventStartResizable(eventDef, eventUi);
      var isResizableFromEnd = allDay && seg.isEnd && view.computeEventEndResizable(eventDef, eventUi);
      var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);
      var skinCss = core.cssToStr(this.getSkinCss(eventUi));
      var timeHtml = '';
      var timeText;
      var titleHtml;
      classes.unshift('fc-day-grid-event', 'fc-h-event'); // Only display a timed events time if it is the starting segment

      if (seg.isStart) {
        timeText = this.getTimeText(eventRange);

        if (timeText) {
          timeHtml = '<span class="fc-time">' + core.htmlEscape(timeText) + '</span>';
        }
      }

      titleHtml = '<span class="fc-title">' + (core.htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height
      '</span>';
      return '<a class="' + classes.join(' ') + '"' + (eventDef.url ? ' href="' + core.htmlEscape(eventDef.url) + '"' : '') + (skinCss ? ' style="' + skinCss + '"' : '') + '>' + '<div class="fc-content">' + (options.dir === 'rtl' ? titleHtml + ' ' + timeHtml : // put a natural space in between
      timeHtml + ' ' + titleHtml //
      ) + '</div>' + (isResizableFromStart ? '<div class="fc-resizer fc-start-resizer"></div>' : '') + (isResizableFromEnd ? '<div class="fc-resizer fc-end-resizer"></div>' : '') + '</a>';
    }; // Computes a default event time formatting string if `eventTimeFormat` is not explicitly defined


    SimpleDayGridEventRenderer.prototype.computeEventTimeFormat = function () {
      return {
        hour: 'numeric',
        minute: '2-digit',
        omitZeroMinute: true,
        meridiem: 'narrow'
      };
    };

    SimpleDayGridEventRenderer.prototype.computeDisplayEventEnd = function () {
      return false; // TODO: somehow consider the originating DayGrid's column count
    };

    return SimpleDayGridEventRenderer;
  }(core.FgEventRenderer);
  /* Event-rendering methods for the DayGrid class
  ----------------------------------------------------------------------------------------------------------------------*/


  var DayGridEventRenderer =
  /** @class */
  function (_super) {
    __extends(DayGridEventRenderer, _super);

    function DayGridEventRenderer(dayGrid) {
      var _this = _super.call(this, dayGrid.context) || this;

      _this.dayGrid = dayGrid;
      return _this;
    } // Renders the given foreground event segments onto the grid


    DayGridEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
      var rowStructs = this.rowStructs = this.renderSegRows(segs); // append to each row's content skeleton

      this.dayGrid.rowEls.forEach(function (rowNode, i) {
        rowNode.querySelector('.fc-content-skeleton > table').appendChild(rowStructs[i].tbodyEl);
      }); // removes the "more.." events popover

      if (!mirrorInfo) {
        this.dayGrid.removeSegPopover();
      }
    }; // Unrenders all currently rendered foreground event segments


    DayGridEventRenderer.prototype.detachSegs = function () {
      var rowStructs = this.rowStructs || [];
      var rowStruct;

      while (rowStruct = rowStructs.pop()) {
        core.removeElement(rowStruct.tbodyEl);
      }

      this.rowStructs = null;
    }; // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
    // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
    // PRECONDITION: each segment shoud already have a rendered and assigned `.el`


    DayGridEventRenderer.prototype.renderSegRows = function (segs) {
      var rowStructs = [];
      var segRows;
      var row;
      segRows = this.groupSegRows(segs); // group into nested arrays
      // iterate each row of segment groupings

      for (row = 0; row < segRows.length; row++) {
        rowStructs.push(this.renderSegRow(row, segRows[row]));
      }

      return rowStructs;
    }; // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
    // the segments. Returns object with a bunch of internal data about how the render was calculated.
    // NOTE: modifies rowSegs


    DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {
      var dayGrid = this.dayGrid;
      var colCnt = dayGrid.colCnt,
          isRtl = dayGrid.isRtl;
      var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels

      var levelCnt = Math.max(1, segLevels.length); // ensure at least one level

      var tbody = document.createElement('tbody');
      var segMatrix = []; // lookup for which segments are rendered into which level+col cells

      var cellMatrix = []; // lookup for all <td> elements of the level+col matrix

      var loneCellMatrix = []; // lookup for <td> elements that only take up a single column

      var i;
      var levelSegs;
      var col;
      var tr;
      var j;
      var seg;
      var td; // populates empty cells from the current column (`col`) to `endCol`

      function emptyCellsUntil(endCol) {
        while (col < endCol) {
          // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
          td = (loneCellMatrix[i - 1] || [])[col];

          if (td) {
            td.rowSpan = (td.rowSpan || 1) + 1;
          } else {
            td = document.createElement('td');
            tr.appendChild(td);
          }

          cellMatrix[i][col] = td;
          loneCellMatrix[i][col] = td;
          col++;
        }
      }

      for (i = 0; i < levelCnt; i++) {
        // iterate through all levels
        levelSegs = segLevels[i];
        col = 0;
        tr = document.createElement('tr');
        segMatrix.push([]);
        cellMatrix.push([]);
        loneCellMatrix.push([]); // levelCnt might be 1 even though there are no actual levels. protect against this.
        // this single empty row is useful for styling.

        if (levelSegs) {
          for (j = 0; j < levelSegs.length; j++) {
            // iterate through segments in level
            seg = levelSegs[j];
            var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;
            var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;
            emptyCellsUntil(leftCol); // create a container that occupies or more columns. append the event element.

            td = core.createElement('td', {
              className: 'fc-event-container'
            }, seg.el);

            if (leftCol !== rightCol) {
              td.colSpan = rightCol - leftCol + 1;
            } else {
              // a single-column segment
              loneCellMatrix[i][col] = td;
            }

            while (col <= rightCol) {
              cellMatrix[i][col] = td;
              segMatrix[i][col] = seg;
              col++;
            }

            tr.appendChild(td);
          }
        }

        emptyCellsUntil(colCnt); // finish off the row

        var introHtml = dayGrid.renderProps.renderIntroHtml();

        if (introHtml) {
          if (dayGrid.isRtl) {
            core.appendToElement(tr, introHtml);
          } else {
            core.prependToElement(tr, introHtml);
          }
        }

        tbody.appendChild(tr);
      }

      return {
        row: row,
        tbodyEl: tbody,
        cellMatrix: cellMatrix,
        segMatrix: segMatrix,
        segLevels: segLevels,
        segs: rowSegs
      };
    }; // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
    // NOTE: modifies segs


    DayGridEventRenderer.prototype.buildSegLevels = function (segs) {
      var _a = this.dayGrid,
          isRtl = _a.isRtl,
          colCnt = _a.colCnt;
      var levels = [];
      var i;
      var seg;
      var j; // Give preference to elements with certain criteria, so they have
      // a chance to be closer to the top.

      segs = this.sortEventSegs(segs);

      for (i = 0; i < segs.length; i++) {
        seg = segs[i]; // loop through levels, starting with the topmost, until the segment doesn't collide with other segments

        for (j = 0; j < levels.length; j++) {
          if (!isDaySegCollision(seg, levels[j])) {
            break;
          }
        } // `j` now holds the desired subrow index


        seg.level = j;
        seg.leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol; // for sorting only

        seg.rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol // for sorting only
        ;
        (levels[j] || (levels[j] = [])).push(seg);
      } // order segments left-to-right. very important if calendar is RTL


      for (j = 0; j < levels.length; j++) {
        levels[j].sort(compareDaySegCols);
      }

      return levels;
    }; // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row


    DayGridEventRenderer.prototype.groupSegRows = function (segs) {
      var segRows = [];
      var i;

      for (i = 0; i < this.dayGrid.rowCnt; i++) {
        segRows.push([]);
      }

      for (i = 0; i < segs.length; i++) {
        segRows[segs[i].row].push(segs[i]);
      }

      return segRows;
    }; // Computes a default `displayEventEnd` value if one is not expliclty defined


    DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {
      return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day
    };

    return DayGridEventRenderer;
  }(SimpleDayGridEventRenderer); // Computes whether two segments' columns collide. They are assumed to be in the same row.


  function isDaySegCollision(seg, otherSegs) {
    var i;
    var otherSeg;

    for (i = 0; i < otherSegs.length; i++) {
      otherSeg = otherSegs[i];

      if (otherSeg.firstCol <= seg.lastCol && otherSeg.lastCol >= seg.firstCol) {
        return true;
      }
    }

    return false;
  } // A cmp function for determining the leftmost event


  function compareDaySegCols(a, b) {
    return a.leftCol - b.leftCol;
  }

  var DayGridMirrorRenderer =
  /** @class */
  function (_super) {
    __extends(DayGridMirrorRenderer, _super);

    function DayGridMirrorRenderer() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    DayGridMirrorRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
      var sourceSeg = mirrorInfo.sourceSeg;
      var rowStructs = this.rowStructs = this.renderSegRows(segs); // inject each new event skeleton into each associated row

      this.dayGrid.rowEls.forEach(function (rowNode, row) {
        var skeletonEl = core.htmlToElement('<div class="fc-mirror-skeleton"><table></table></div>'); // will be absolutely positioned

        var skeletonTopEl;
        var skeletonTop; // If there is an original segment, match the top position. Otherwise, put it at the row's top level

        if (sourceSeg && sourceSeg.row === row) {
          skeletonTopEl = sourceSeg.el;
        } else {
          skeletonTopEl = rowNode.querySelector('.fc-content-skeleton tbody');

          if (!skeletonTopEl) {
            // when no events
            skeletonTopEl = rowNode.querySelector('.fc-content-skeleton table');
          }
        }

        skeletonTop = skeletonTopEl.getBoundingClientRect().top - rowNode.getBoundingClientRect().top; // the offsetParent origin

        skeletonEl.style.top = skeletonTop + 'px';
        skeletonEl.querySelector('table').appendChild(rowStructs[row].tbodyEl);
        rowNode.appendChild(skeletonEl);
      });
    };

    return DayGridMirrorRenderer;
  }(DayGridEventRenderer);

  var EMPTY_CELL_HTML = '<td style="pointer-events:none"></td>';

  var DayGridFillRenderer =
  /** @class */
  function (_super) {
    __extends(DayGridFillRenderer, _super);

    function DayGridFillRenderer(dayGrid) {
      var _this = _super.call(this, dayGrid.context) || this;

      _this.fillSegTag = 'td'; // override the default tag name

      _this.dayGrid = dayGrid;
      return _this;
    }

    DayGridFillRenderer.prototype.renderSegs = function (type, segs) {
      // don't render timed background events
      if (type === 'bgEvent') {
        segs = segs.filter(function (seg) {
          return seg.eventRange.def.allDay;
        });
      }

      _super.prototype.renderSegs.call(this, type, segs);
    };

    DayGridFillRenderer.prototype.attachSegs = function (type, segs) {
      var els = [];
      var i;
      var seg;
      var skeletonEl;

      for (i = 0; i < segs.length; i++) {
        seg = segs[i];
        skeletonEl = this.renderFillRow(type, seg);
        this.dayGrid.rowEls[seg.row].appendChild(skeletonEl);
        els.push(skeletonEl);
      }

      return els;
    }; // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.


    DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {
      var dayGrid = this.dayGrid;
      var colCnt = dayGrid.colCnt,
          isRtl = dayGrid.isRtl;
      var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;
      var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;
      var startCol = leftCol;
      var endCol = rightCol + 1;
      var className;
      var skeletonEl;
      var trEl;

      if (type === 'businessHours') {
        className = 'bgevent';
      } else {
        className = type.toLowerCase();
      }

      skeletonEl = core.htmlToElement('<div class="fc-' + className + '-skeleton">' + '<table><tr></tr></table>' + '</div>');
      trEl = skeletonEl.getElementsByTagName('tr')[0];

      if (startCol > 0) {
        core.appendToElement(trEl, // will create (startCol + 1) td's
        new Array(startCol + 1).join(EMPTY_CELL_HTML));
      }

      seg.el.colSpan = endCol - startCol;
      trEl.appendChild(seg.el);

      if (endCol < colCnt) {
        core.appendToElement(trEl, // will create (colCnt - endCol) td's
        new Array(colCnt - endCol + 1).join(EMPTY_CELL_HTML));
      }

      var introHtml = dayGrid.renderProps.renderIntroHtml();

      if (introHtml) {
        if (dayGrid.isRtl) {
          core.appendToElement(trEl, introHtml);
        } else {
          core.prependToElement(trEl, introHtml);
        }
      }

      return skeletonEl;
    };

    return DayGridFillRenderer;
  }(core.FillRenderer);

  var DayTile =
  /** @class */
  function (_super) {
    __extends(DayTile, _super);

    function DayTile(context, el) {
      var _this = _super.call(this, context, el) || this;

      var eventRenderer = _this.eventRenderer = new DayTileEventRenderer(_this);
      var renderFrame = _this.renderFrame = core.memoizeRendering(_this._renderFrame);
      _this.renderFgEvents = core.memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderFrame]);
      _this.renderEventSelection = core.memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);
      _this.renderEventDrag = core.memoizeRendering(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);
      _this.renderEventResize = core.memoizeRendering(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);
      context.calendar.registerInteractiveComponent(_this, {
        el: _this.el,
        useEventCenter: false
      });
      return _this;
    }

    DayTile.prototype.render = function (props) {
      this.renderFrame(props.date);
      this.renderFgEvents(props.fgSegs);
      this.renderEventSelection(props.eventSelection);
      this.renderEventDrag(props.eventDragInstances);
      this.renderEventResize(props.eventResizeInstances);
    };

    DayTile.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      this.renderFrame.unrender(); // should unrender everything else

      this.calendar.unregisterInteractiveComponent(this);
    };

    DayTile.prototype._renderFrame = function (date) {
      var _a = this,
          theme = _a.theme,
          dateEnv = _a.dateEnv;

      var title = dateEnv.format(date, core.createFormatter(this.opt('dayPopoverFormat')) // TODO: cache
      );
      this.el.innerHTML = '<div class="fc-header ' + theme.getClass('popoverHeader') + '">' + '<span class="fc-title">' + core.htmlEscape(title) + '</span>' + '<span class="fc-close ' + theme.getIconClass('close') + '"></span>' + '</div>' + '<div class="fc-body ' + theme.getClass('popoverContent') + '">' + '<div class="fc-event-container"></div>' + '</div>';
      this.segContainerEl = this.el.querySelector('.fc-event-container');
    };

    DayTile.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
      var date = this.props.date; // HACK

      if (positionLeft < elWidth && positionTop < elHeight) {
        return {
          component: this,
          dateSpan: {
            allDay: true,
            range: {
              start: date,
              end: core.addDays(date, 1)
            }
          },
          dayEl: this.el,
          rect: {
            left: 0,
            top: 0,
            right: elWidth,
            bottom: elHeight
          },
          layer: 1
        };
      }
    };

    return DayTile;
  }(core.DateComponent);

  var DayTileEventRenderer =
  /** @class */
  function (_super) {
    __extends(DayTileEventRenderer, _super);

    function DayTileEventRenderer(dayTile) {
      var _this = _super.call(this, dayTile.context) || this;

      _this.dayTile = dayTile;
      return _this;
    }

    DayTileEventRenderer.prototype.attachSegs = function (segs) {
      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
        var seg = segs_1[_i];
        this.dayTile.segContainerEl.appendChild(seg.el);
      }
    };

    DayTileEventRenderer.prototype.detachSegs = function (segs) {
      for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
        var seg = segs_2[_i];
        core.removeElement(seg.el);
      }
    };

    return DayTileEventRenderer;
  }(SimpleDayGridEventRenderer);

  var DayBgRow =
  /** @class */
  function () {
    function DayBgRow(context) {
      this.context = context;
    }

    DayBgRow.prototype.renderHtml = function (props) {
      var parts = [];

      if (props.renderIntroHtml) {
        parts.push(props.renderIntroHtml());
      }

      for (var _i = 0, _a = props.cells; _i < _a.length; _i++) {
        var cell = _a[_i];
        parts.push(renderCellHtml(cell.date, props.dateProfile, this.context, cell.htmlAttrs));
      }

      if (!props.cells.length) {
        parts.push('<td class="fc-day ' + this.context.theme.getClass('widgetContent') + '"></td>');
      }

      if (this.context.options.dir === 'rtl') {
        parts.reverse();
      }

      return '<tr>' + parts.join('') + '</tr>';
    };

    return DayBgRow;
  }();

  function renderCellHtml(date, dateProfile, context, otherAttrs) {
    var dateEnv = context.dateEnv,
        theme = context.theme;
    var isDateValid = core.rangeContainsMarker(dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.

    var classes = core.getDayClasses(date, dateProfile, context);
    classes.unshift('fc-day', theme.getClass('widgetContent'));
    return '<td class="' + classes.join(' ') + '"' + (isDateValid ? ' data-date="' + dateEnv.formatIso(date, {
      omitTime: true
    }) + '"' : '') + (otherAttrs ? ' ' + otherAttrs : '') + '></td>';
  }

  var DAY_NUM_FORMAT = core.createFormatter({
    day: 'numeric'
  });
  var WEEK_NUM_FORMAT = core.createFormatter({
    week: 'numeric'
  });

  var DayGrid =
  /** @class */
  function (_super) {
    __extends(DayGrid, _super);

    function DayGrid(context, el, renderProps) {
      var _this = _super.call(this, context, el) || this;

      _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid

      _this.isCellSizesDirty = false;
      var eventRenderer = _this.eventRenderer = new DayGridEventRenderer(_this);
      var fillRenderer = _this.fillRenderer = new DayGridFillRenderer(_this);
      _this.mirrorRenderer = new DayGridMirrorRenderer(_this);
      var renderCells = _this.renderCells = core.memoizeRendering(_this._renderCells, _this._unrenderCells);
      _this.renderBusinessHours = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'), [renderCells]);
      _this.renderDateSelection = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'highlight'), fillRenderer.unrender.bind(fillRenderer, 'highlight'), [renderCells]);
      _this.renderBgEvents = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'), [renderCells]);
      _this.renderFgEvents = core.memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderCells]);
      _this.renderEventSelection = core.memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);
      _this.renderEventDrag = core.memoizeRendering(_this._renderEventDrag, _this._unrenderEventDrag, [renderCells]);
      _this.renderEventResize = core.memoizeRendering(_this._renderEventResize, _this._unrenderEventResize, [renderCells]);
      _this.renderProps = renderProps;
      return _this;
    }

    DayGrid.prototype.render = function (props) {
      var cells = props.cells;
      this.rowCnt = cells.length;
      this.colCnt = cells[0].length;
      this.renderCells(cells, props.isRigid);
      this.renderBusinessHours(props.businessHourSegs);
      this.renderDateSelection(props.dateSelectionSegs);
      this.renderBgEvents(props.bgEventSegs);
      this.renderFgEvents(props.fgEventSegs);
      this.renderEventSelection(props.eventSelection);
      this.renderEventDrag(props.eventDrag);
      this.renderEventResize(props.eventResize);

      if (this.segPopoverTile) {
        this.updateSegPopoverTile();
      }
    };

    DayGrid.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      this.renderCells.unrender(); // will unrender everything else
    };

    DayGrid.prototype.getCellRange = function (row, col) {
      var start = this.props.cells[row][col].date;
      var end = core.addDays(start, 1);
      return {
        start: start,
        end: end
      };
    };

    DayGrid.prototype.updateSegPopoverTile = function (date, segs) {
      var ownProps = this.props;
      this.segPopoverTile.receiveProps({
        date: date || this.segPopoverTile.props.date,
        fgSegs: segs || this.segPopoverTile.props.fgSegs,
        eventSelection: ownProps.eventSelection,
        eventDragInstances: ownProps.eventDrag ? ownProps.eventDrag.affectedInstances : null,
        eventResizeInstances: ownProps.eventResize ? ownProps.eventResize.affectedInstances : null
      });
    };
    /* Date Rendering
    ------------------------------------------------------------------------------------------------------------------*/


    DayGrid.prototype._renderCells = function (cells, isRigid) {
      var _a = this,
          view = _a.view,
          dateEnv = _a.dateEnv;

      var _b = this,
          rowCnt = _b.rowCnt,
          colCnt = _b.colCnt;

      var html = '';
      var row;
      var col;

      for (row = 0; row < rowCnt; row++) {
        html += this.renderDayRowHtml(row, isRigid);
      }

      this.el.innerHTML = html;
      this.rowEls = core.findElements(this.el, '.fc-row');
      this.cellEls = core.findElements(this.el, '.fc-day, .fc-disabled-day');

      if (this.isRtl) {
        this.cellEls.reverse();
      }

      this.rowPositions = new core.PositionCache(this.el, this.rowEls, false, true // vertical
      );
      this.colPositions = new core.PositionCache(this.el, this.cellEls.slice(0, colCnt), // only the first row
      true, false // horizontal
      ); // trigger dayRender with each cell's element

      for (row = 0; row < rowCnt; row++) {
        for (col = 0; col < colCnt; col++) {
          this.publiclyTrigger('dayRender', [{
            date: dateEnv.toDate(cells[row][col].date),
            el: this.getCellEl(row, col),
            view: view
          }]);
        }
      }

      this.isCellSizesDirty = true;
    };

    DayGrid.prototype._unrenderCells = function () {
      this.removeSegPopover();
    }; // Generates the HTML for a single row, which is a div that wraps a table.
    // `row` is the row number.


    DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {
      var theme = this.theme;
      var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];

      if (isRigid) {
        classes.push('fc-rigid');
      }

      var bgRow = new DayBgRow(this.context);
      return '' + '<div class="' + classes.join(' ') + '">' + '<div class="fc-bg">' + '<table class="' + theme.getClass('tableGrid') + '">' + bgRow.renderHtml({
        cells: this.props.cells[row],
        dateProfile: this.props.dateProfile,
        renderIntroHtml: this.renderProps.renderBgIntroHtml
      }) + '</table>' + '</div>' + '<div class="fc-content-skeleton">' + '<table>' + (this.getIsNumbersVisible() ? '<thead>' + this.renderNumberTrHtml(row) + '</thead>' : '') + '</table>' + '</div>' + '</div>';
    };

    DayGrid.prototype.getIsNumbersVisible = function () {
      return this.getIsDayNumbersVisible() || this.renderProps.cellWeekNumbersVisible || this.renderProps.colWeekNumbersVisible;
    };

    DayGrid.prototype.getIsDayNumbersVisible = function () {
      return this.rowCnt > 1;
    };
    /* Grid Number Rendering
    ------------------------------------------------------------------------------------------------------------------*/


    DayGrid.prototype.renderNumberTrHtml = function (row) {
      var intro = this.renderProps.renderNumberIntroHtml(row, this);
      return '' + '<tr>' + (this.isRtl ? '' : intro) + this.renderNumberCellsHtml(row) + (this.isRtl ? intro : '') + '</tr>';
    };

    DayGrid.prototype.renderNumberCellsHtml = function (row) {
      var htmls = [];
      var col;
      var date;

      for (col = 0; col < this.colCnt; col++) {
        date = this.props.cells[row][col].date;
        htmls.push(this.renderNumberCellHtml(date));
      }

      if (this.isRtl) {
        htmls.reverse();
      }

      return htmls.join('');
    }; // Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
    // The number row will only exist if either day numbers or week numbers are turned on.


    DayGrid.prototype.renderNumberCellHtml = function (date) {
      var _a = this,
          view = _a.view,
          dateEnv = _a.dateEnv;

      var html = '';
      var isDateValid = core.rangeContainsMarker(this.props.dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.

      var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;
      var classes;
      var weekCalcFirstDow;

      if (!isDayNumberVisible && !this.renderProps.cellWeekNumbersVisible) {
        // no numbers in day cell (week number must be along the side)
        return '<td></td>'; //  will create an empty space above events :(
      }

      classes = core.getDayClasses(date, this.props.dateProfile, this.context);
      classes.unshift('fc-day-top');

      if (this.renderProps.cellWeekNumbersVisible) {
        weekCalcFirstDow = dateEnv.weekDow;
      }

      html += '<td class="' + classes.join(' ') + '"' + (isDateValid ? ' data-date="' + dateEnv.formatIso(date, {
        omitTime: true
      }) + '"' : '') + '>';

      if (this.renderProps.cellWeekNumbersVisible && date.getUTCDay() === weekCalcFirstDow) {
        html += core.buildGotoAnchorHtml(view, {
          date: date,
          type: 'week'
        }, {
          'class': 'fc-week-number'
        }, dateEnv.format(date, WEEK_NUM_FORMAT) // inner HTML
        );
      }

      if (isDayNumberVisible) {
        html += core.buildGotoAnchorHtml(view, date, {
          'class': 'fc-day-number'
        }, dateEnv.format(date, DAY_NUM_FORMAT) // inner HTML
        );
      }

      html += '</td>';
      return html;
    };
    /* Sizing
    ------------------------------------------------------------------------------------------------------------------*/


    DayGrid.prototype.updateSize = function (isResize) {
      var _a = this,
          fillRenderer = _a.fillRenderer,
          eventRenderer = _a.eventRenderer,
          mirrorRenderer = _a.mirrorRenderer;

      if (isResize || this.isCellSizesDirty || this.view.calendar.isEventsUpdated // hack
      ) {
          this.buildPositionCaches();
          this.isCellSizesDirty = false;
        }

      fillRenderer.computeSizes(isResize);
      eventRenderer.computeSizes(isResize);
      mirrorRenderer.computeSizes(isResize);
      fillRenderer.assignSizes(isResize);
      eventRenderer.assignSizes(isResize);
      mirrorRenderer.assignSizes(isResize);
    };

    DayGrid.prototype.buildPositionCaches = function () {
      this.buildColPositions();
      this.buildRowPositions();
    };

    DayGrid.prototype.buildColPositions = function () {
      this.colPositions.build();
    };

    DayGrid.prototype.buildRowPositions = function () {
      this.rowPositions.build();
      this.rowPositions.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
    };
    /* Hit System
    ------------------------------------------------------------------------------------------------------------------*/


    DayGrid.prototype.positionToHit = function (leftPosition, topPosition) {
      var _a = this,
          colPositions = _a.colPositions,
          rowPositions = _a.rowPositions;

      var col = colPositions.leftToIndex(leftPosition);
      var row = rowPositions.topToIndex(topPosition);

      if (row != null && col != null) {
        return {
          row: row,
          col: col,
          dateSpan: {
            range: this.getCellRange(row, col),
            allDay: true
          },
          dayEl: this.getCellEl(row, col),
          relativeRect: {
            left: colPositions.lefts[col],
            right: colPositions.rights[col],
            top: rowPositions.tops[row],
            bottom: rowPositions.bottoms[row]
          }
        };
      }
    };
    /* Cell System
    ------------------------------------------------------------------------------------------------------------------*/
    // FYI: the first column is the leftmost column, regardless of date


    DayGrid.prototype.getCellEl = function (row, col) {
      return this.cellEls[row * this.colCnt + col];
    };
    /* Event Drag Visualization
    ------------------------------------------------------------------------------------------------------------------*/


    DayGrid.prototype._renderEventDrag = function (state) {
      if (state) {
        this.eventRenderer.hideByHash(state.affectedInstances);
        this.fillRenderer.renderSegs('highlight', state.segs);
      }
    };

    DayGrid.prototype._unrenderEventDrag = function (state) {
      if (state) {
        this.eventRenderer.showByHash(state.affectedInstances);
        this.fillRenderer.unrender('highlight');
      }
    };
    /* Event Resize Visualization
    ------------------------------------------------------------------------------------------------------------------*/


    DayGrid.prototype._renderEventResize = function (state) {
      if (state) {
        this.eventRenderer.hideByHash(state.affectedInstances);
        this.fillRenderer.renderSegs('highlight', state.segs);
        this.mirrorRenderer.renderSegs(state.segs, {
          isResizing: true,
          sourceSeg: state.sourceSeg
        });
      }
    };

    DayGrid.prototype._unrenderEventResize = function (state) {
      if (state) {
        this.eventRenderer.showByHash(state.affectedInstances);
        this.fillRenderer.unrender('highlight');
        this.mirrorRenderer.unrender(state.segs, {
          isResizing: true,
          sourceSeg: state.sourceSeg
        });
      }
    };
    /* More+ Link Popover
    ------------------------------------------------------------------------------------------------------------------*/


    DayGrid.prototype.removeSegPopover = function () {
      if (this.segPopover) {
        this.segPopover.hide(); // in handler, will call segPopover's removeElement
      }
    }; // Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
    // `levelLimit` can be false (don't limit), a number, or true (should be computed).


    DayGrid.prototype.limitRows = function (levelLimit) {
      var rowStructs = this.eventRenderer.rowStructs || [];
      var row; // row #

      var rowLevelLimit;

      for (row = 0; row < rowStructs.length; row++) {
        this.unlimitRow(row);

        if (!levelLimit) {
          rowLevelLimit = false;
        } else if (typeof levelLimit === 'number') {
          rowLevelLimit = levelLimit;
        } else {
          rowLevelLimit = this.computeRowLevelLimit(row);
        }

        if (rowLevelLimit !== false) {
          this.limitRow(row, rowLevelLimit);
        }
      }
    }; // Computes the number of levels a row will accomodate without going outside its bounds.
    // Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
    // `row` is the row number.


    DayGrid.prototype.computeRowLevelLimit = function (row) {
      var rowEl = this.rowEls[row]; // the containing "fake" row div

      var rowBottom = rowEl.getBoundingClientRect().bottom; // relative to viewport!

      var trEls = core.findChildren(this.eventRenderer.rowStructs[row].tbodyEl);
      var i;
      var trEl; // Reveal one level <tr> at a time and stop when we find one out of bounds

      for (i = 0; i < trEls.length; i++) {
        trEl = trEls[i];
        trEl.classList.remove('fc-limited'); // reset to original state (reveal)

        if (trEl.getBoundingClientRect().bottom > rowBottom) {
          return i;
        }
      }

      return false; // should not limit at all
    }; // Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
    // `row` is the row number.
    // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.


    DayGrid.prototype.limitRow = function (row, levelLimit) {
      var _this = this;

      var _a = this,
          colCnt = _a.colCnt,
          isRtl = _a.isRtl;

      var rowStruct = this.eventRenderer.rowStructs[row];
      var moreNodes = []; // array of "more" <a> links and <td> DOM nodes

      var col = 0; // col #, left-to-right (not chronologically)

      var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right

      var cellMatrix; // a matrix (by level, then column) of all <td> elements in the row

      var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes

      var i;
      var seg;
      var segsBelow; // array of segment objects below `seg` in the current `col`

      var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies

      var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)

      var td;
      var rowSpan;
      var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell

      var j;
      var moreTd;
      var moreWrap;
      var moreLink; // Iterates through empty level cells and places "more" links inside if need be

      var emptyCellsUntil = function emptyCellsUntil(endCol) {
        while (col < endCol) {
          segsBelow = _this.getCellSegs(row, col, levelLimit);

          if (segsBelow.length) {
            td = cellMatrix[levelLimit - 1][col];
            moreLink = _this.renderMoreLink(row, col, segsBelow);
            moreWrap = core.createElement('div', null, moreLink);
            td.appendChild(moreWrap);
            moreNodes.push(moreWrap);
          }

          col++;
        }
      };

      if (levelLimit && levelLimit < rowStruct.segLevels.length) {
        // is it actually over the limit?
        levelSegs = rowStruct.segLevels[levelLimit - 1];
        cellMatrix = rowStruct.cellMatrix;
        limitedNodes = core.findChildren(rowStruct.tbodyEl).slice(levelLimit); // get level <tr> elements past the limit

        limitedNodes.forEach(function (node) {
          node.classList.add('fc-limited'); // hide elements and get a simple DOM-nodes array
        }); // iterate though segments in the last allowable level

        for (i = 0; i < levelSegs.length; i++) {
          seg = levelSegs[i];
          var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;
          var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;
          emptyCellsUntil(leftCol); // process empty cells before the segment
          // determine *all* segments below `seg` that occupy the same columns

          colSegsBelow = [];
          totalSegsBelow = 0;

          while (col <= rightCol) {
            segsBelow = this.getCellSegs(row, col, levelLimit);
            colSegsBelow.push(segsBelow);
            totalSegsBelow += segsBelow.length;
            col++;
          }

          if (totalSegsBelow) {
            // do we need to replace this segment with one or many "more" links?
            td = cellMatrix[levelLimit - 1][leftCol]; // the segment's parent cell

            rowSpan = td.rowSpan || 1;
            segMoreNodes = []; // make a replacement <td> for each column the segment occupies. will be one for each colspan

            for (j = 0; j < colSegsBelow.length; j++) {
              moreTd = core.createElement('td', {
                className: 'fc-more-cell',
                rowSpan: rowSpan
              });
              segsBelow = colSegsBelow[j];
              moreLink = this.renderMoreLink(row, leftCol + j, [seg].concat(segsBelow) // count seg as hidden too
              );
              moreWrap = core.createElement('div', null, moreLink);
              moreTd.appendChild(moreWrap);
              segMoreNodes.push(moreTd);
              moreNodes.push(moreTd);
            }

            td.classList.add('fc-limited');
            core.insertAfterElement(td, segMoreNodes);
            limitedNodes.push(td);
          }
        }

        emptyCellsUntil(this.colCnt); // finish off the level

        rowStruct.moreEls = moreNodes; // for easy undoing later

        rowStruct.limitedEls = limitedNodes; // for easy undoing later
      }
    }; // Reveals all levels and removes all "more"-related elements for a grid's row.
    // `row` is a row number.


    DayGrid.prototype.unlimitRow = function (row) {
      var rowStruct = this.eventRenderer.rowStructs[row];

      if (rowStruct.moreEls) {
        rowStruct.moreEls.forEach(core.removeElement);
        rowStruct.moreEls = null;
      }

      if (rowStruct.limitedEls) {
        rowStruct.limitedEls.forEach(function (limitedEl) {
          limitedEl.classList.remove('fc-limited');
        });
        rowStruct.limitedEls = null;
      }
    }; // Renders an <a> element that represents hidden event element for a cell.
    // Responsible for attaching click handler as well.


    DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {
      var _this = this;

      var _a = this,
          view = _a.view,
          dateEnv = _a.dateEnv;

      var a = core.createElement('a', {
        className: 'fc-more'
      });
      a.innerText = this.getMoreLinkText(hiddenSegs.length);
      a.addEventListener('click', function (ev) {
        var clickOption = _this.opt('eventLimitClick');

        var _col = _this.isRtl ? _this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?


        var date = _this.props.cells[row][_col].date;
        var moreEl = ev.currentTarget;

        var dayEl = _this.getCellEl(row, col);

        var allSegs = _this.getCellSegs(row, col); // rescope the segments to be within the cell's date


        var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);

        var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);

        if (typeof clickOption === 'function') {
          // the returned value can be an atomic option
          clickOption = _this.publiclyTrigger('eventLimitClick', [{
            date: dateEnv.toDate(date),
            allDay: true,
            dayEl: dayEl,
            moreEl: moreEl,
            segs: reslicedAllSegs,
            hiddenSegs: reslicedHiddenSegs,
            jsEvent: ev,
            view: view
          }]);
        }

        if (clickOption === 'popover') {
          _this.showSegPopover(row, col, moreEl, reslicedAllSegs);
        } else if (typeof clickOption === 'string') {
          // a view name
          view.calendar.zoomTo(date, clickOption);
        }
      });
      return a;
    }; // Reveals the popover that displays all events within a cell


    DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {
      var _this = this;

      var _a = this,
          calendar = _a.calendar,
          view = _a.view,
          theme = _a.theme;

      var _col = this.isRtl ? this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?


      var moreWrap = moreLink.parentNode; // the <div> wrapper around the <a>

      var topEl; // the element we want to match the top coordinate of

      var options;

      if (this.rowCnt === 1) {
        topEl = view.el; // will cause the popover to cover any sort of header
      } else {
        topEl = this.rowEls[row]; // will align with top of row
      }

      options = {
        className: 'fc-more-popover ' + theme.getClass('popover'),
        parentEl: view.el,
        top: core.computeRect(topEl).top,
        autoHide: true,
        content: function content(el) {
          _this.segPopoverTile = new DayTile(_this.context, el);

          _this.updateSegPopoverTile(_this.props.cells[row][_col].date, segs);
        },
        hide: function hide() {
          _this.segPopoverTile.destroy();

          _this.segPopoverTile = null;

          _this.segPopover.destroy();

          _this.segPopover = null;
        }
      }; // Determine horizontal coordinate.
      // We use the moreWrap instead of the <td> to avoid border confusion.

      if (this.isRtl) {
        options.right = core.computeRect(moreWrap).right + 1; // +1 to be over cell border
      } else {
        options.left = core.computeRect(moreWrap).left - 1; // -1 to be over cell border
      }

      this.segPopover = new Popover(options);
      this.segPopover.show();
      calendar.releaseAfterSizingTriggers(); // hack for eventPositioned
    }; // Given the events within an array of segment objects, reslice them to be in a single day


    DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {
      var dayStart = dayDate;
      var dayEnd = core.addDays(dayStart, 1);
      var dayRange = {
        start: dayStart,
        end: dayEnd
      };
      var newSegs = [];

      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
        var seg = segs_1[_i];
        var eventRange = seg.eventRange;
        var origRange = eventRange.range;
        var slicedRange = core.intersectRanges(origRange, dayRange);

        if (slicedRange) {
          newSegs.push(_assign({}, seg, {
            eventRange: {
              def: eventRange.def,
              ui: _assign({}, eventRange.ui, {
                durationEditable: false
              }),
              instance: eventRange.instance,
              range: slicedRange
            },
            isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),
            isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()
          }));
        }
      }

      return newSegs;
    }; // Generates the text that should be inside a "more" link, given the number of events it represents


    DayGrid.prototype.getMoreLinkText = function (num) {
      var opt = this.opt('eventLimitText');

      if (typeof opt === 'function') {
        return opt(num);
      } else {
        return '+' + num + ' ' + opt;
      }
    }; // Returns segments within a given cell.
    // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.


    DayGrid.prototype.getCellSegs = function (row, col, startLevel) {
      var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;
      var level = startLevel || 0;
      var segs = [];
      var seg;

      while (level < segMatrix.length) {
        seg = segMatrix[level][col];

        if (seg) {
          segs.push(seg);
        }

        level++;
      }

      return segs;
    };

    return DayGrid;
  }(core.DateComponent);

  var WEEK_NUM_FORMAT$1 = core.createFormatter({
    week: 'numeric'
  });
  /* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.
  ----------------------------------------------------------------------------------------------------------------------*/
  // It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
  // It is responsible for managing width/height.

  var DayGridView =
  /** @class */
  function (_super) {
    __extends(DayGridView, _super);

    function DayGridView(context, viewSpec, dateProfileGenerator, parentEl) {
      var _this = _super.call(this, context, viewSpec, dateProfileGenerator, parentEl) || this;
      /* Header Rendering
      ------------------------------------------------------------------------------------------------------------------*/
      // Generates the HTML that will go before the day-of week header cells


      _this.renderHeadIntroHtml = function () {
        var theme = _this.theme;

        if (_this.colWeekNumbersVisible) {
          return '' + '<th class="fc-week-number ' + theme.getClass('widgetHeader') + '" ' + _this.weekNumberStyleAttr() + '>' + '<span>' + // needed for matchCellWidths
          core.htmlEscape(_this.opt('weekLabel')) + '</span>' + '</th>';
        }

        return '';
      };
      /* Day Grid Rendering
      ------------------------------------------------------------------------------------------------------------------*/
      // Generates the HTML that will go before content-skeleton cells that display the day/week numbers


      _this.renderDayGridNumberIntroHtml = function (row, dayGrid) {
        var dateEnv = _this.dateEnv;
        var weekStart = dayGrid.props.cells[row][0].date;

        if (_this.colWeekNumbersVisible) {
          return '' + '<td class="fc-week-number" ' + _this.weekNumberStyleAttr() + '>' + core.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
          _this, {
            date: weekStart,
            type: 'week',
            forceOff: dayGrid.colCnt === 1
          }, dateEnv.format(weekStart, WEEK_NUM_FORMAT$1) // inner HTML
          ) + '</td>';
        }

        return '';
      }; // Generates the HTML that goes before the day bg cells for each day-row


      _this.renderDayGridBgIntroHtml = function () {
        var theme = _this.theme;

        if (_this.colWeekNumbersVisible) {
          return '<td class="fc-week-number ' + theme.getClass('widgetContent') + '" ' + _this.weekNumberStyleAttr() + '></td>';
        }

        return '';
      }; // Generates the HTML that goes before every other type of row generated by DayGrid.
      // Affects mirror-skeleton and highlight-skeleton rows.


      _this.renderDayGridIntroHtml = function () {
        if (_this.colWeekNumbersVisible) {
          return '<td class="fc-week-number" ' + _this.weekNumberStyleAttr() + '></td>';
        }

        return '';
      };

      _this.el.classList.add('fc-dayGrid-view');

      _this.el.innerHTML = _this.renderSkeletonHtml();
      _this.scroller = new core.ScrollComponent('hidden', // overflow x
      'auto' // overflow y
      );
      var dayGridContainerEl = _this.scroller.el;

      _this.el.querySelector('.fc-body > tr > td').appendChild(dayGridContainerEl);

      dayGridContainerEl.classList.add('fc-day-grid-container');
      var dayGridEl = core.createElement('div', {
        className: 'fc-day-grid'
      });
      dayGridContainerEl.appendChild(dayGridEl);
      var cellWeekNumbersVisible;

      if (_this.opt('weekNumbers')) {
        if (_this.opt('weekNumbersWithinDays')) {
          cellWeekNumbersVisible = true;
          _this.colWeekNumbersVisible = false;
        } else {
          cellWeekNumbersVisible = false;
          _this.colWeekNumbersVisible = true;
        }
      } else {
        _this.colWeekNumbersVisible = false;
        cellWeekNumbersVisible = false;
      }

      _this.dayGrid = new DayGrid(_this.context, dayGridEl, {
        renderNumberIntroHtml: _this.renderDayGridNumberIntroHtml,
        renderBgIntroHtml: _this.renderDayGridBgIntroHtml,
        renderIntroHtml: _this.renderDayGridIntroHtml,
        colWeekNumbersVisible: _this.colWeekNumbersVisible,
        cellWeekNumbersVisible: cellWeekNumbersVisible
      });
      return _this;
    }

    DayGridView.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      this.dayGrid.destroy();
      this.scroller.destroy();
    }; // Builds the HTML skeleton for the view.
    // The day-grid component will render inside of a container defined by this HTML.


    DayGridView.prototype.renderSkeletonHtml = function () {
      var theme = this.theme;
      return '' + '<table class="' + theme.getClass('tableGrid') + '">' + (this.opt('columnHeader') ? '<thead class="fc-head">' + '<tr>' + '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' + '</tr>' + '</thead>' : '') + '<tbody class="fc-body">' + '<tr>' + '<td class="' + theme.getClass('widgetContent') + '"></td>' + '</tr>' + '</tbody>' + '</table>';
    }; // Generates an HTML attribute string for setting the width of the week number column, if it is known


    DayGridView.prototype.weekNumberStyleAttr = function () {
      if (this.weekNumberWidth != null) {
        return 'style="width:' + this.weekNumberWidth + 'px"';
      }

      return '';
    }; // Determines whether each row should have a constant height


    DayGridView.prototype.hasRigidRows = function () {
      var eventLimit = this.opt('eventLimit');
      return eventLimit && typeof eventLimit !== 'number';
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/


    DayGridView.prototype.updateSize = function (isResize, viewHeight, isAuto) {
      _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto); // will call updateBaseSize. important that executes first


      this.dayGrid.updateSize(isResize);
    }; // Refreshes the horizontal dimensions of the view


    DayGridView.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {
      var dayGrid = this.dayGrid;
      var eventLimit = this.opt('eventLimit');
      var headRowEl = this.header ? this.header.el : null; // HACK

      var scrollerHeight;
      var scrollbarWidths; // hack to give the view some height prior to dayGrid's columns being rendered
      // TODO: separate setting height from scroller VS dayGrid.

      if (!dayGrid.rowEls) {
        if (!isAuto) {
          scrollerHeight = this.computeScrollerHeight(viewHeight);
          this.scroller.setHeight(scrollerHeight);
        }

        return;
      }

      if (this.colWeekNumbersVisible) {
        // Make sure all week number cells running down the side have the same width.
        this.weekNumberWidth = core.matchCellWidths(core.findElements(this.el, '.fc-week-number'));
      } // reset all heights to be natural


      this.scroller.clear();

      if (headRowEl) {
        core.uncompensateScroll(headRowEl);
      }

      dayGrid.removeSegPopover(); // kill the "more" popover if displayed
      // is the event limit a constant level number?

      if (eventLimit && typeof eventLimit === 'number') {
        dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
      } // distribute the height to the rows
      // (viewHeight is a "recommended" value if isAuto)


      scrollerHeight = this.computeScrollerHeight(viewHeight);
      this.setGridHeight(scrollerHeight, isAuto); // is the event limit dynamically calculated?

      if (eventLimit && typeof eventLimit !== 'number') {
        dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
      }

      if (!isAuto) {
        // should we force dimensions of the scroll container?
        this.scroller.setHeight(scrollerHeight);
        scrollbarWidths = this.scroller.getScrollbarWidths();

        if (scrollbarWidths.left || scrollbarWidths.right) {
          // using scrollbars?
          if (headRowEl) {
            core.compensateScroll(headRowEl, scrollbarWidths);
          } // doing the scrollbar compensation might have created text overflow which created more height. redo


          scrollerHeight = this.computeScrollerHeight(viewHeight);
          this.scroller.setHeight(scrollerHeight);
        } // guarantees the same scrollbar widths


        this.scroller.lockOverflow(scrollbarWidths);
      }
    }; // given a desired total height of the view, returns what the height of the scroller should be


    DayGridView.prototype.computeScrollerHeight = function (viewHeight) {
      return viewHeight - core.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    }; // Sets the height of just the DayGrid component in this view


    DayGridView.prototype.setGridHeight = function (height, isAuto) {
      if (this.opt('monthMode')) {
        // if auto, make the height of each row the height that it would be if there were 6 weeks
        if (isAuto) {
          height *= this.dayGrid.rowCnt / 6;
        }

        core.distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
      } else {
        if (isAuto) {
          core.undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
        } else {
          core.distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
        }
      }
    };
    /* Scroll
    ------------------------------------------------------------------------------------------------------------------*/


    DayGridView.prototype.computeDateScroll = function (duration) {
      return {
        top: 0
      };
    };

    DayGridView.prototype.queryDateScroll = function () {
      return {
        top: this.scroller.getScrollTop()
      };
    };

    DayGridView.prototype.applyDateScroll = function (scroll) {
      if (scroll.top !== undefined) {
        this.scroller.setScrollTop(scroll.top);
      }
    };

    return DayGridView;
  }(core.View);

  DayGridView.prototype.dateProfileGeneratorClass = DayGridDateProfileGenerator;

  var SimpleDayGrid =
  /** @class */
  function (_super) {
    __extends(SimpleDayGrid, _super);

    function SimpleDayGrid(context, dayGrid) {
      var _this = _super.call(this, context, dayGrid.el) || this;

      _this.slicer = new DayGridSlicer();
      _this.dayGrid = dayGrid;
      context.calendar.registerInteractiveComponent(_this, {
        el: _this.dayGrid.el
      });
      return _this;
    }

    SimpleDayGrid.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      this.calendar.unregisterInteractiveComponent(this);
    };

    SimpleDayGrid.prototype.render = function (props) {
      var dayGrid = this.dayGrid;
      var dateProfile = props.dateProfile,
          dayTable = props.dayTable;
      dayGrid.receiveProps(_assign({}, this.slicer.sliceProps(props, dateProfile, props.nextDayThreshold, dayGrid, dayTable), {
        dateProfile: dateProfile,
        cells: dayTable.cells,
        isRigid: props.isRigid
      }));
    };

    SimpleDayGrid.prototype.buildPositionCaches = function () {
      this.dayGrid.buildPositionCaches();
    };

    SimpleDayGrid.prototype.queryHit = function (positionLeft, positionTop) {
      var rawHit = this.dayGrid.positionToHit(positionLeft, positionTop);

      if (rawHit) {
        return {
          component: this.dayGrid,
          dateSpan: rawHit.dateSpan,
          dayEl: rawHit.dayEl,
          rect: {
            left: rawHit.relativeRect.left,
            right: rawHit.relativeRect.right,
            top: rawHit.relativeRect.top,
            bottom: rawHit.relativeRect.bottom
          },
          layer: 0
        };
      }
    };

    return SimpleDayGrid;
  }(core.DateComponent);

  var DayGridSlicer =
  /** @class */
  function (_super) {
    __extends(DayGridSlicer, _super);

    function DayGridSlicer() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    DayGridSlicer.prototype.sliceRange = function (dateRange, dayTable) {
      return dayTable.sliceRange(dateRange);
    };

    return DayGridSlicer;
  }(core.Slicer);

  var DayGridView$1 =
  /** @class */
  function (_super) {
    __extends(DayGridView, _super);

    function DayGridView(_context, viewSpec, dateProfileGenerator, parentEl) {
      var _this = _super.call(this, _context, viewSpec, dateProfileGenerator, parentEl) || this;

      _this.buildDayTable = core.memoize(buildDayTable);

      if (_this.opt('columnHeader')) {
        _this.header = new core.DayHeader(_this.context, _this.el.querySelector('.fc-head-container'));
      }

      _this.simpleDayGrid = new SimpleDayGrid(_this.context, _this.dayGrid);
      return _this;
    }

    DayGridView.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      if (this.header) {
        this.header.destroy();
      }

      this.simpleDayGrid.destroy();
    };

    DayGridView.prototype.render = function (props) {
      _super.prototype.render.call(this, props);

      var dateProfile = this.props.dateProfile;
      var dayTable = this.dayTable = this.buildDayTable(dateProfile, this.dateProfileGenerator);

      if (this.header) {
        this.header.receiveProps({
          dateProfile: dateProfile,
          dates: dayTable.headerDates,
          datesRepDistinctDays: dayTable.rowCnt === 1,
          renderIntroHtml: this.renderHeadIntroHtml
        });
      }

      this.simpleDayGrid.receiveProps({
        dateProfile: dateProfile,
        dayTable: dayTable,
        businessHours: props.businessHours,
        dateSelection: props.dateSelection,
        eventStore: props.eventStore,
        eventUiBases: props.eventUiBases,
        eventSelection: props.eventSelection,
        eventDrag: props.eventDrag,
        eventResize: props.eventResize,
        isRigid: this.hasRigidRows(),
        nextDayThreshold: this.nextDayThreshold
      });
    };

    return DayGridView;
  }(DayGridView);

  function buildDayTable(dateProfile, dateProfileGenerator) {
    var daySeries = new core.DaySeries(dateProfile.renderRange, dateProfileGenerator);
    return new core.DayTable(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
  }

  var main = core.createPlugin({
    defaultView: 'dayGridMonth',
    views: {
      dayGrid: DayGridView$1,
      dayGridDay: {
        type: 'dayGrid',
        duration: {
          days: 1
        }
      },
      dayGridWeek: {
        type: 'dayGrid',
        duration: {
          weeks: 1
        }
      },
      dayGridMonth: {
        type: 'dayGrid',
        duration: {
          months: 1
        },
        monthMode: true,
        fixedWeekCount: true
      }
    }
  });
  exports.AbstractDayGridView = DayGridView;
  exports.DayBgRow = DayBgRow;
  exports.DayGrid = DayGrid;
  exports.DayGridSlicer = DayGridSlicer;
  exports.DayGridView = DayGridView$1;
  exports.SimpleDayGrid = SimpleDayGrid;
  exports.buildBasicDayTable = buildDayTable;
  exports["default"] = main;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./assets/fullcalendar/interaction/main.js":
/*!*************************************************!*\
  !*** ./assets/fullcalendar/interaction/main.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__(/*! core-js/modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");

__webpack_require__(/*! core-js/modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");

__webpack_require__(/*! core-js/modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.map */ "./node_modules/core-js/modules/es.array.map.js");

__webpack_require__(/*! core-js/modules/es.array.slice */ "./node_modules/core-js/modules/es.array.slice.js");

__webpack_require__(/*! core-js/modules/es.array.sort */ "./node_modules/core-js/modules/es.array.sort.js");

__webpack_require__(/*! core-js/modules/es.date.now */ "./node_modules/core-js/modules/es.date.now.js");

__webpack_require__(/*! core-js/modules/es.date.to-string */ "./node_modules/core-js/modules/es.date.to-string.js");

__webpack_require__(/*! core-js/modules/es.function.bind */ "./node_modules/core-js/modules/es.function.bind.js");

__webpack_require__(/*! core-js/modules/es.function.name */ "./node_modules/core-js/modules/es.function.name.js");

__webpack_require__(/*! core-js/modules/es.object.assign */ "./node_modules/core-js/modules/es.object.assign.js");

__webpack_require__(/*! core-js/modules/es.object.create */ "./node_modules/core-js/modules/es.object.create.js");

__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.set-prototype-of */ "./node_modules/core-js/modules/es.object.set-prototype-of.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");

__webpack_require__(/*! core-js/modules/web.timers */ "./node_modules/core-js/modules/web.timers.js");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
FullCalendar Interaction Plugin v4.3.0
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, __webpack_require__(/*! @fullcalendar/core */ "./node_modules/@fullcalendar/core/main.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! @fullcalendar/core */ "./node_modules/@fullcalendar/core/main.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(this, function (exports, core) {
  'use strict';
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
    See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */

  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };

  core.config.touchMouseIgnoreWait = 500;
  var ignoreMouseDepth = 0;
  var listenerCnt = 0;
  var isWindowTouchMoveCancelled = false;
  /*
  Uses a "pointer" abstraction, which monitors UI events for both mouse and touch.
  Tracks when the pointer "drags" on a certain element, meaning down+move+up.
    Also, tracks if there was touch-scrolling.
  Also, can prevent touch-scrolling from happening.
  Also, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.
    emits:
  - pointerdown
  - pointermove
  - pointerup
  */

  var PointerDragging =
  /** @class */
  function () {
    function PointerDragging(containerEl) {
      var _this = this;

      this.subjectEl = null;
      this.downEl = null; // options that can be directly assigned by caller

      this.selector = ''; // will cause subjectEl in all emitted events to be this element

      this.handleSelector = '';
      this.shouldIgnoreMove = false;
      this.shouldWatchScroll = true; // for simulating pointermove on scroll
      // internal states

      this.isDragging = false;
      this.isTouchDragging = false;
      this.wasTouchScroll = false; // Mouse
      // ----------------------------------------------------------------------------------------------------

      this.handleMouseDown = function (ev) {
        if (!_this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && _this.tryStart(ev)) {
          var pev = _this.createEventFromMouse(ev, true);

          _this.emitter.trigger('pointerdown', pev);

          _this.initScrollWatch(pev);

          if (!_this.shouldIgnoreMove) {
            document.addEventListener('mousemove', _this.handleMouseMove);
          }

          document.addEventListener('mouseup', _this.handleMouseUp);
        }
      };

      this.handleMouseMove = function (ev) {
        var pev = _this.createEventFromMouse(ev);

        _this.recordCoords(pev);

        _this.emitter.trigger('pointermove', pev);
      };

      this.handleMouseUp = function (ev) {
        document.removeEventListener('mousemove', _this.handleMouseMove);
        document.removeEventListener('mouseup', _this.handleMouseUp);

        _this.emitter.trigger('pointerup', _this.createEventFromMouse(ev));

        _this.cleanup(); // call last so that pointerup has access to props

      }; // Touch
      // ----------------------------------------------------------------------------------------------------


      this.handleTouchStart = function (ev) {
        if (_this.tryStart(ev)) {
          _this.isTouchDragging = true;

          var pev = _this.createEventFromTouch(ev, true);

          _this.emitter.trigger('pointerdown', pev);

          _this.initScrollWatch(pev); // unlike mouse, need to attach to target, not document
          // https://stackoverflow.com/a/45760014


          var target = ev.target;

          if (!_this.shouldIgnoreMove) {
            target.addEventListener('touchmove', _this.handleTouchMove);
          }

          target.addEventListener('touchend', _this.handleTouchEnd);
          target.addEventListener('touchcancel', _this.handleTouchEnd); // treat it as a touch end
          // attach a handler to get called when ANY scroll action happens on the page.
          // this was impossible to do with normal on/off because 'scroll' doesn't bubble.
          // http://stackoverflow.com/a/32954565/96342

          window.addEventListener('scroll', _this.handleTouchScroll, true // useCapture
          );
        }
      };

      this.handleTouchMove = function (ev) {
        var pev = _this.createEventFromTouch(ev);

        _this.recordCoords(pev);

        _this.emitter.trigger('pointermove', pev);
      };

      this.handleTouchEnd = function (ev) {
        if (_this.isDragging) {
          // done to guard against touchend followed by touchcancel
          var target = ev.target;
          target.removeEventListener('touchmove', _this.handleTouchMove);
          target.removeEventListener('touchend', _this.handleTouchEnd);
          target.removeEventListener('touchcancel', _this.handleTouchEnd);
          window.removeEventListener('scroll', _this.handleTouchScroll, true); // useCaptured=true

          _this.emitter.trigger('pointerup', _this.createEventFromTouch(ev));

          _this.cleanup(); // call last so that pointerup has access to props


          _this.isTouchDragging = false;
          startIgnoringMouse();
        }
      };

      this.handleTouchScroll = function () {
        _this.wasTouchScroll = true;
      };

      this.handleScroll = function (ev) {
        if (!_this.shouldIgnoreMove) {
          var pageX = window.pageXOffset - _this.prevScrollX + _this.prevPageX;
          var pageY = window.pageYOffset - _this.prevScrollY + _this.prevPageY;

          _this.emitter.trigger('pointermove', {
            origEvent: ev,
            isTouch: _this.isTouchDragging,
            subjectEl: _this.subjectEl,
            pageX: pageX,
            pageY: pageY,
            deltaX: pageX - _this.origPageX,
            deltaY: pageY - _this.origPageY
          });
        }
      };

      this.containerEl = containerEl;
      this.emitter = new core.EmitterMixin();
      containerEl.addEventListener('mousedown', this.handleMouseDown);
      containerEl.addEventListener('touchstart', this.handleTouchStart, {
        passive: true
      });
      listenerCreated();
    }

    PointerDragging.prototype.destroy = function () {
      this.containerEl.removeEventListener('mousedown', this.handleMouseDown);
      this.containerEl.removeEventListener('touchstart', this.handleTouchStart, {
        passive: true
      });
      listenerDestroyed();
    };

    PointerDragging.prototype.tryStart = function (ev) {
      var subjectEl = this.querySubjectEl(ev);
      var downEl = ev.target;

      if (subjectEl && (!this.handleSelector || core.elementClosest(downEl, this.handleSelector))) {
        this.subjectEl = subjectEl;
        this.downEl = downEl;
        this.isDragging = true; // do this first so cancelTouchScroll will work

        this.wasTouchScroll = false;
        return true;
      }

      return false;
    };

    PointerDragging.prototype.cleanup = function () {
      isWindowTouchMoveCancelled = false;
      this.isDragging = false;
      this.subjectEl = null;
      this.downEl = null; // keep wasTouchScroll around for later access

      this.destroyScrollWatch();
    };

    PointerDragging.prototype.querySubjectEl = function (ev) {
      if (this.selector) {
        return core.elementClosest(ev.target, this.selector);
      } else {
        return this.containerEl;
      }
    };

    PointerDragging.prototype.shouldIgnoreMouse = function () {
      return ignoreMouseDepth || this.isTouchDragging;
    }; // can be called by user of this class, to cancel touch-based scrolling for the current drag


    PointerDragging.prototype.cancelTouchScroll = function () {
      if (this.isDragging) {
        isWindowTouchMoveCancelled = true;
      }
    }; // Scrolling that simulates pointermoves
    // ----------------------------------------------------------------------------------------------------


    PointerDragging.prototype.initScrollWatch = function (ev) {
      if (this.shouldWatchScroll) {
        this.recordCoords(ev);
        window.addEventListener('scroll', this.handleScroll, true); // useCapture=true
      }
    };

    PointerDragging.prototype.recordCoords = function (ev) {
      if (this.shouldWatchScroll) {
        this.prevPageX = ev.pageX;
        this.prevPageY = ev.pageY;
        this.prevScrollX = window.pageXOffset;
        this.prevScrollY = window.pageYOffset;
      }
    };

    PointerDragging.prototype.destroyScrollWatch = function () {
      if (this.shouldWatchScroll) {
        window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true
      }
    }; // Event Normalization
    // ----------------------------------------------------------------------------------------------------


    PointerDragging.prototype.createEventFromMouse = function (ev, isFirst) {
      var deltaX = 0;
      var deltaY = 0; // TODO: repeat code

      if (isFirst) {
        this.origPageX = ev.pageX;
        this.origPageY = ev.pageY;
      } else {
        deltaX = ev.pageX - this.origPageX;
        deltaY = ev.pageY - this.origPageY;
      }

      return {
        origEvent: ev,
        isTouch: false,
        subjectEl: this.subjectEl,
        pageX: ev.pageX,
        pageY: ev.pageY,
        deltaX: deltaX,
        deltaY: deltaY
      };
    };

    PointerDragging.prototype.createEventFromTouch = function (ev, isFirst) {
      var touches = ev.touches;
      var pageX;
      var pageY;
      var deltaX = 0;
      var deltaY = 0; // if touch coords available, prefer,
      // because FF would give bad ev.pageX ev.pageY

      if (touches && touches.length) {
        pageX = touches[0].pageX;
        pageY = touches[0].pageY;
      } else {
        pageX = ev.pageX;
        pageY = ev.pageY;
      } // TODO: repeat code


      if (isFirst) {
        this.origPageX = pageX;
        this.origPageY = pageY;
      } else {
        deltaX = pageX - this.origPageX;
        deltaY = pageY - this.origPageY;
      }

      return {
        origEvent: ev,
        isTouch: true,
        subjectEl: this.subjectEl,
        pageX: pageX,
        pageY: pageY,
        deltaX: deltaX,
        deltaY: deltaY
      };
    };

    return PointerDragging;
  }(); // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)


  function isPrimaryMouseButton(ev) {
    return ev.button === 0 && !ev.ctrlKey;
  } // Ignoring fake mouse events generated by touch
  // ----------------------------------------------------------------------------------------------------


  function startIgnoringMouse() {
    ignoreMouseDepth++;
    setTimeout(function () {
      ignoreMouseDepth--;
    }, core.config.touchMouseIgnoreWait);
  } // We want to attach touchmove as early as possible for Safari
  // ----------------------------------------------------------------------------------------------------


  function listenerCreated() {
    if (!listenerCnt++) {
      window.addEventListener('touchmove', onWindowTouchMove, {
        passive: false
      });
    }
  }

  function listenerDestroyed() {
    if (! --listenerCnt) {
      window.removeEventListener('touchmove', onWindowTouchMove, {
        passive: false
      });
    }
  }

  function onWindowTouchMove(ev) {
    if (isWindowTouchMoveCancelled) {
      ev.preventDefault();
    }
  }
  /*
  An effect in which an element follows the movement of a pointer across the screen.
  The moving element is a clone of some other element.
  Must call start + handleMove + stop.
  */


  var ElementMirror =
  /** @class */
  function () {
    function ElementMirror() {
      this.isVisible = false; // must be explicitly enabled

      this.sourceEl = null;
      this.mirrorEl = null;
      this.sourceElRect = null; // screen coords relative to viewport
      // options that can be set directly by caller

      this.parentNode = document.body;
      this.zIndex = 9999;
      this.revertDuration = 0;
    }

    ElementMirror.prototype.start = function (sourceEl, pageX, pageY) {
      this.sourceEl = sourceEl;
      this.sourceElRect = this.sourceEl.getBoundingClientRect();
      this.origScreenX = pageX - window.pageXOffset;
      this.origScreenY = pageY - window.pageYOffset;
      this.deltaX = 0;
      this.deltaY = 0;
      this.updateElPosition();
    };

    ElementMirror.prototype.handleMove = function (pageX, pageY) {
      this.deltaX = pageX - window.pageXOffset - this.origScreenX;
      this.deltaY = pageY - window.pageYOffset - this.origScreenY;
      this.updateElPosition();
    }; // can be called before start


    ElementMirror.prototype.setIsVisible = function (bool) {
      if (bool) {
        if (!this.isVisible) {
          if (this.mirrorEl) {
            this.mirrorEl.style.display = '';
          }

          this.isVisible = bool; // needs to happen before updateElPosition

          this.updateElPosition(); // because was not updating the position while invisible
        }
      } else {
        if (this.isVisible) {
          if (this.mirrorEl) {
            this.mirrorEl.style.display = 'none';
          }

          this.isVisible = bool;
        }
      }
    }; // always async


    ElementMirror.prototype.stop = function (needsRevertAnimation, callback) {
      var _this = this;

      var done = function done() {
        _this.cleanup();

        callback();
      };

      if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && ( // if 0, transition won't work
      this.deltaX || this.deltaY) // if same coords, transition won't work
      ) {
          this.doRevertAnimation(done, this.revertDuration);
        } else {
        setTimeout(done, 0);
      }
    };

    ElementMirror.prototype.doRevertAnimation = function (callback, revertDuration) {
      var mirrorEl = this.mirrorEl;
      var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened

      mirrorEl.style.transition = 'top ' + revertDuration + 'ms,' + 'left ' + revertDuration + 'ms';
      core.applyStyle(mirrorEl, {
        left: finalSourceElRect.left,
        top: finalSourceElRect.top
      });
      core.whenTransitionDone(mirrorEl, function () {
        mirrorEl.style.transition = '';
        callback();
      });
    };

    ElementMirror.prototype.cleanup = function () {
      if (this.mirrorEl) {
        core.removeElement(this.mirrorEl);
        this.mirrorEl = null;
      }

      this.sourceEl = null;
    };

    ElementMirror.prototype.updateElPosition = function () {
      if (this.sourceEl && this.isVisible) {
        core.applyStyle(this.getMirrorEl(), {
          left: this.sourceElRect.left + this.deltaX,
          top: this.sourceElRect.top + this.deltaY
        });
      }
    };

    ElementMirror.prototype.getMirrorEl = function () {
      var sourceElRect = this.sourceElRect;
      var mirrorEl = this.mirrorEl;

      if (!mirrorEl) {
        mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true
        // we don't want long taps or any mouse interaction causing selection/menus.
        // would use preventSelection(), but that prevents selectstart, causing problems.

        mirrorEl.classList.add('fc-unselectable');
        mirrorEl.classList.add('fc-dragging');
        core.applyStyle(mirrorEl, {
          position: 'fixed',
          zIndex: this.zIndex,
          visibility: '',
          boxSizing: 'border-box',
          width: sourceElRect.right - sourceElRect.left,
          height: sourceElRect.bottom - sourceElRect.top,
          right: 'auto',
          bottom: 'auto',
          margin: 0
        });
        this.parentNode.appendChild(mirrorEl);
      }

      return mirrorEl;
    };

    return ElementMirror;
  }();
  /*
  Is a cache for a given element's scroll information (all the info that ScrollController stores)
  in addition the "client rectangle" of the element.. the area within the scrollbars.
    The cache can be in one of two modes:
  - doesListening:false - ignores when the container is scrolled by someone else
  - doesListening:true - watch for scrolling and update the cache
  */


  var ScrollGeomCache =
  /** @class */
  function (_super) {
    __extends(ScrollGeomCache, _super);

    function ScrollGeomCache(scrollController, doesListening) {
      var _this = _super.call(this) || this;

      _this.handleScroll = function () {
        _this.scrollTop = _this.scrollController.getScrollTop();
        _this.scrollLeft = _this.scrollController.getScrollLeft();

        _this.handleScrollChange();
      };

      _this.scrollController = scrollController;
      _this.doesListening = doesListening;
      _this.scrollTop = _this.origScrollTop = scrollController.getScrollTop();
      _this.scrollLeft = _this.origScrollLeft = scrollController.getScrollLeft();
      _this.scrollWidth = scrollController.getScrollWidth();
      _this.scrollHeight = scrollController.getScrollHeight();
      _this.clientWidth = scrollController.getClientWidth();
      _this.clientHeight = scrollController.getClientHeight();
      _this.clientRect = _this.computeClientRect(); // do last in case it needs cached values

      if (_this.doesListening) {
        _this.getEventTarget().addEventListener('scroll', _this.handleScroll);
      }

      return _this;
    }

    ScrollGeomCache.prototype.destroy = function () {
      if (this.doesListening) {
        this.getEventTarget().removeEventListener('scroll', this.handleScroll);
      }
    };

    ScrollGeomCache.prototype.getScrollTop = function () {
      return this.scrollTop;
    };

    ScrollGeomCache.prototype.getScrollLeft = function () {
      return this.scrollLeft;
    };

    ScrollGeomCache.prototype.setScrollTop = function (top) {
      this.scrollController.setScrollTop(top);

      if (!this.doesListening) {
        // we are not relying on the element to normalize out-of-bounds scroll values
        // so we need to sanitize ourselves
        this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
        this.handleScrollChange();
      }
    };

    ScrollGeomCache.prototype.setScrollLeft = function (top) {
      this.scrollController.setScrollLeft(top);

      if (!this.doesListening) {
        // we are not relying on the element to normalize out-of-bounds scroll values
        // so we need to sanitize ourselves
        this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
        this.handleScrollChange();
      }
    };

    ScrollGeomCache.prototype.getClientWidth = function () {
      return this.clientWidth;
    };

    ScrollGeomCache.prototype.getClientHeight = function () {
      return this.clientHeight;
    };

    ScrollGeomCache.prototype.getScrollWidth = function () {
      return this.scrollWidth;
    };

    ScrollGeomCache.prototype.getScrollHeight = function () {
      return this.scrollHeight;
    };

    ScrollGeomCache.prototype.handleScrollChange = function () {};

    return ScrollGeomCache;
  }(core.ScrollController);

  var ElementScrollGeomCache =
  /** @class */
  function (_super) {
    __extends(ElementScrollGeomCache, _super);

    function ElementScrollGeomCache(el, doesListening) {
      return _super.call(this, new core.ElementScrollController(el), doesListening) || this;
    }

    ElementScrollGeomCache.prototype.getEventTarget = function () {
      return this.scrollController.el;
    };

    ElementScrollGeomCache.prototype.computeClientRect = function () {
      return core.computeInnerRect(this.scrollController.el);
    };

    return ElementScrollGeomCache;
  }(ScrollGeomCache);

  var WindowScrollGeomCache =
  /** @class */
  function (_super) {
    __extends(WindowScrollGeomCache, _super);

    function WindowScrollGeomCache(doesListening) {
      return _super.call(this, new core.WindowScrollController(), doesListening) || this;
    }

    WindowScrollGeomCache.prototype.getEventTarget = function () {
      return window;
    };

    WindowScrollGeomCache.prototype.computeClientRect = function () {
      return {
        left: this.scrollLeft,
        right: this.scrollLeft + this.clientWidth,
        top: this.scrollTop,
        bottom: this.scrollTop + this.clientHeight
      };
    }; // the window is the only scroll object that changes it's rectangle relative
    // to the document's topleft as it scrolls


    WindowScrollGeomCache.prototype.handleScrollChange = function () {
      this.clientRect = this.computeClientRect();
    };

    return WindowScrollGeomCache;
  }(ScrollGeomCache); // If available we are using native "performance" API instead of "Date"
  // Read more about it on MDN:
  // https://developer.mozilla.org/en-US/docs/Web/API/Performance


  var getTime = typeof performance === 'function' ? performance.now : Date.now;
  /*
  For a pointer interaction, automatically scrolls certain scroll containers when the pointer
  approaches the edge.
    The caller must call start + handleMove + stop.
  */

  var AutoScroller =
  /** @class */
  function () {
    function AutoScroller() {
      var _this = this; // options that can be set by caller


      this.isEnabled = true;
      this.scrollQuery = [window, '.fc-scroller'];
      this.edgeThreshold = 50; // pixels

      this.maxVelocity = 300; // pixels per second
      // internal state

      this.pointerScreenX = null;
      this.pointerScreenY = null;
      this.isAnimating = false;
      this.scrollCaches = null; // protect against the initial pointerdown being too close to an edge and starting the scroll

      this.everMovedUp = false;
      this.everMovedDown = false;
      this.everMovedLeft = false;
      this.everMovedRight = false;

      this.animate = function () {
        if (_this.isAnimating) {
          // wasn't cancelled between animation calls
          var edge = _this.computeBestEdge(_this.pointerScreenX + window.pageXOffset, _this.pointerScreenY + window.pageYOffset);

          if (edge) {
            var now = getTime();

            _this.handleSide(edge, (now - _this.msSinceRequest) / 1000);

            _this.requestAnimation(now);
          } else {
            _this.isAnimating = false; // will stop animation
          }
        }
      };
    }

    AutoScroller.prototype.start = function (pageX, pageY) {
      if (this.isEnabled) {
        this.scrollCaches = this.buildCaches();
        this.pointerScreenX = null;
        this.pointerScreenY = null;
        this.everMovedUp = false;
        this.everMovedDown = false;
        this.everMovedLeft = false;
        this.everMovedRight = false;
        this.handleMove(pageX, pageY);
      }
    };

    AutoScroller.prototype.handleMove = function (pageX, pageY) {
      if (this.isEnabled) {
        var pointerScreenX = pageX - window.pageXOffset;
        var pointerScreenY = pageY - window.pageYOffset;
        var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
        var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;

        if (yDelta < 0) {
          this.everMovedUp = true;
        } else if (yDelta > 0) {
          this.everMovedDown = true;
        }

        if (xDelta < 0) {
          this.everMovedLeft = true;
        } else if (xDelta > 0) {
          this.everMovedRight = true;
        }

        this.pointerScreenX = pointerScreenX;
        this.pointerScreenY = pointerScreenY;

        if (!this.isAnimating) {
          this.isAnimating = true;
          this.requestAnimation(getTime());
        }
      }
    };

    AutoScroller.prototype.stop = function () {
      if (this.isEnabled) {
        this.isAnimating = false; // will stop animation

        for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
          var scrollCache = _a[_i];
          scrollCache.destroy();
        }

        this.scrollCaches = null;
      }
    };

    AutoScroller.prototype.requestAnimation = function (now) {
      this.msSinceRequest = now;
      requestAnimationFrame(this.animate);
    };

    AutoScroller.prototype.handleSide = function (edge, seconds) {
      var scrollCache = edge.scrollCache;
      var edgeThreshold = this.edgeThreshold;
      var invDistance = edgeThreshold - edge.distance;
      var velocity = // the closer to the edge, the faster we scroll
      invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic
      this.maxVelocity * seconds;
      var sign = 1;

      switch (edge.name) {
        case 'left':
          sign = -1;
        // falls through

        case 'right':
          scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
          break;

        case 'top':
          sign = -1;
        // falls through

        case 'bottom':
          scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
          break;
      }
    }; // left/top are relative to document topleft


    AutoScroller.prototype.computeBestEdge = function (left, top) {
      var edgeThreshold = this.edgeThreshold;
      var bestSide = null;

      for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
        var scrollCache = _a[_i];
        var rect = scrollCache.clientRect;
        var leftDist = left - rect.left;
        var rightDist = rect.right - left;
        var topDist = top - rect.top;
        var bottomDist = rect.bottom - top; // completely within the rect?

        if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
          if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {
            bestSide = {
              scrollCache: scrollCache,
              name: 'top',
              distance: topDist
            };
          }

          if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {
            bestSide = {
              scrollCache: scrollCache,
              name: 'bottom',
              distance: bottomDist
            };
          }

          if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {
            bestSide = {
              scrollCache: scrollCache,
              name: 'left',
              distance: leftDist
            };
          }

          if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {
            bestSide = {
              scrollCache: scrollCache,
              name: 'right',
              distance: rightDist
            };
          }
        }
      }

      return bestSide;
    };

    AutoScroller.prototype.buildCaches = function () {
      return this.queryScrollEls().map(function (el) {
        if (el === window) {
          return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls
        } else {
          return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls
        }
      });
    };

    AutoScroller.prototype.queryScrollEls = function () {
      var els = [];

      for (var _i = 0, _a = this.scrollQuery; _i < _a.length; _i++) {
        var query = _a[_i];

        if (_typeof(query) === 'object') {
          els.push(query);
        } else {
          els.push.apply(els, Array.prototype.slice.call(document.querySelectorAll(query)));
        }
      }

      return els;
    };

    return AutoScroller;
  }();
  /*
  Monitors dragging on an element. Has a number of high-level features:
  - minimum distance required before dragging
  - minimum wait time ("delay") before dragging
  - a mirror element that follows the pointer
  */


  var FeaturefulElementDragging =
  /** @class */
  function (_super) {
    __extends(FeaturefulElementDragging, _super);

    function FeaturefulElementDragging(containerEl) {
      var _this = _super.call(this, containerEl) || this; // options that can be directly set by caller
      // the caller can also set the PointerDragging's options as well


      _this.delay = null;
      _this.minDistance = 0;
      _this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag

      _this.mirrorNeedsRevert = false;
      _this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup

      _this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation

      _this.isDelayEnded = false;
      _this.isDistanceSurpassed = false;
      _this.delayTimeoutId = null;

      _this.onPointerDown = function (ev) {
        if (!_this.isDragging) {
          // so new drag doesn't happen while revert animation is going
          _this.isInteracting = true;
          _this.isDelayEnded = false;
          _this.isDistanceSurpassed = false;
          core.preventSelection(document.body);
          core.preventContextMenu(document.body); // prevent links from being visited if there's an eventual drag.
          // also prevents selection in older browsers (maybe?).
          // not necessary for touch, besides, browser would complain about passiveness.

          if (!ev.isTouch) {
            ev.origEvent.preventDefault();
          }

          _this.emitter.trigger('pointerdown', ev);

          if (!_this.pointer.shouldIgnoreMove) {
            // actions related to initiating dragstart+dragmove+dragend...
            _this.mirror.setIsVisible(false); // reset. caller must set-visible


            _this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down


            _this.startDelay(ev);

            if (!_this.minDistance) {
              _this.handleDistanceSurpassed(ev);
            }
          }
        }
      };

      _this.onPointerMove = function (ev) {
        if (_this.isInteracting) {
          // if false, still waiting for previous drag's revert
          _this.emitter.trigger('pointermove', ev);

          if (!_this.isDistanceSurpassed) {
            var minDistance = _this.minDistance;
            var distanceSq = void 0; // current distance from the origin, squared

            var deltaX = ev.deltaX,
                deltaY = ev.deltaY;
            distanceSq = deltaX * deltaX + deltaY * deltaY;

            if (distanceSq >= minDistance * minDistance) {
              // use pythagorean theorem
              _this.handleDistanceSurpassed(ev);
            }
          }

          if (_this.isDragging) {
            // a real pointer move? (not one simulated by scrolling)
            if (ev.origEvent.type !== 'scroll') {
              _this.mirror.handleMove(ev.pageX, ev.pageY);

              _this.autoScroller.handleMove(ev.pageX, ev.pageY);
            }

            _this.emitter.trigger('dragmove', ev);
          }
        }
      };

      _this.onPointerUp = function (ev) {
        if (_this.isInteracting) {
          // if false, still waiting for previous drag's revert
          _this.isInteracting = false;
          core.allowSelection(document.body);
          core.allowContextMenu(document.body);

          _this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert


          if (_this.isDragging) {
            _this.autoScroller.stop();

            _this.tryStopDrag(ev); // which will stop the mirror

          }

          if (_this.delayTimeoutId) {
            clearTimeout(_this.delayTimeoutId);
            _this.delayTimeoutId = null;
          }
        }
      };

      var pointer = _this.pointer = new PointerDragging(containerEl);
      pointer.emitter.on('pointerdown', _this.onPointerDown);
      pointer.emitter.on('pointermove', _this.onPointerMove);
      pointer.emitter.on('pointerup', _this.onPointerUp);
      _this.mirror = new ElementMirror();
      _this.autoScroller = new AutoScroller();
      return _this;
    }

    FeaturefulElementDragging.prototype.destroy = function () {
      this.pointer.destroy();
    };

    FeaturefulElementDragging.prototype.startDelay = function (ev) {
      var _this = this;

      if (typeof this.delay === 'number') {
        this.delayTimeoutId = setTimeout(function () {
          _this.delayTimeoutId = null;

          _this.handleDelayEnd(ev);
        }, this.delay); // not assignable to number!
      } else {
        this.handleDelayEnd(ev);
      }
    };

    FeaturefulElementDragging.prototype.handleDelayEnd = function (ev) {
      this.isDelayEnded = true;
      this.tryStartDrag(ev);
    };

    FeaturefulElementDragging.prototype.handleDistanceSurpassed = function (ev) {
      this.isDistanceSurpassed = true;
      this.tryStartDrag(ev);
    };

    FeaturefulElementDragging.prototype.tryStartDrag = function (ev) {
      if (this.isDelayEnded && this.isDistanceSurpassed) {
        if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
          this.isDragging = true;
          this.mirrorNeedsRevert = false;
          this.autoScroller.start(ev.pageX, ev.pageY);
          this.emitter.trigger('dragstart', ev);

          if (this.touchScrollAllowed === false) {
            this.pointer.cancelTouchScroll();
          }
        }
      }
    };

    FeaturefulElementDragging.prototype.tryStopDrag = function (ev) {
      // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events
      // that come from the document to fire beforehand. much more convenient this way.
      this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev) // bound with args
      );
    };

    FeaturefulElementDragging.prototype.stopDrag = function (ev) {
      this.isDragging = false;
      this.emitter.trigger('dragend', ev);
    }; // fill in the implementations...


    FeaturefulElementDragging.prototype.setIgnoreMove = function (bool) {
      this.pointer.shouldIgnoreMove = bool;
    };

    FeaturefulElementDragging.prototype.setMirrorIsVisible = function (bool) {
      this.mirror.setIsVisible(bool);
    };

    FeaturefulElementDragging.prototype.setMirrorNeedsRevert = function (bool) {
      this.mirrorNeedsRevert = bool;
    };

    FeaturefulElementDragging.prototype.setAutoScrollEnabled = function (bool) {
      this.autoScroller.isEnabled = bool;
    };

    return FeaturefulElementDragging;
  }(core.ElementDragging);
  /*
  When this class is instantiated, it records the offset of an element (relative to the document topleft),
  and continues to monitor scrolling, updating the cached coordinates if it needs to.
  Does not access the DOM after instantiation, so highly performant.
    Also keeps track of all scrolling/overflow:hidden containers that are parents of the given element
  and an determine if a given point is inside the combined clipping rectangle.
  */


  var OffsetTracker =
  /** @class */
  function () {
    function OffsetTracker(el) {
      this.origRect = core.computeRect(el); // will work fine for divs that have overflow:hidden

      this.scrollCaches = core.getClippingParents(el).map(function (el) {
        return new ElementScrollGeomCache(el, true); // listen=true
      });
    }

    OffsetTracker.prototype.destroy = function () {
      for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
        var scrollCache = _a[_i];
        scrollCache.destroy();
      }
    };

    OffsetTracker.prototype.computeLeft = function () {
      var left = this.origRect.left;

      for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
        var scrollCache = _a[_i];
        left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
      }

      return left;
    };

    OffsetTracker.prototype.computeTop = function () {
      var top = this.origRect.top;

      for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
        var scrollCache = _a[_i];
        top += scrollCache.origScrollTop - scrollCache.getScrollTop();
      }

      return top;
    };

    OffsetTracker.prototype.isWithinClipping = function (pageX, pageY) {
      var point = {
        left: pageX,
        top: pageY
      };

      for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
        var scrollCache = _a[_i];

        if (!isIgnoredClipping(scrollCache.getEventTarget()) && !core.pointInsideRect(point, scrollCache.clientRect)) {
          return false;
        }
      }

      return true;
    };

    return OffsetTracker;
  }(); // certain clipping containers should never constrain interactions, like <html> and <body>
  // https://github.com/fullcalendar/fullcalendar/issues/3615


  function isIgnoredClipping(node) {
    var tagName = node.tagName;
    return tagName === 'HTML' || tagName === 'BODY';
  }
  /*
  Tracks movement over multiple droppable areas (aka "hits")
  that exist in one or more DateComponents.
  Relies on an existing draggable.
    emits:
  - pointerdown
  - dragstart
  - hitchange - fires initially, even if not over a hit
  - pointerup
  - (hitchange - again, to null, if ended over a hit)
  - dragend
  */


  var HitDragging =
  /** @class */
  function () {
    function HitDragging(dragging, droppableStore) {
      var _this = this; // options that can be set by caller


      this.useSubjectCenter = false;
      this.requireInitial = true; // if doesn't start out on a hit, won't emit any events

      this.initialHit = null;
      this.movingHit = null;
      this.finalHit = null; // won't ever be populated if shouldIgnoreMove

      this.handlePointerDown = function (ev) {
        var dragging = _this.dragging;
        _this.initialHit = null;
        _this.movingHit = null;
        _this.finalHit = null;

        _this.prepareHits();

        _this.processFirstCoord(ev);

        if (_this.initialHit || !_this.requireInitial) {
          dragging.setIgnoreMove(false);

          _this.emitter.trigger('pointerdown', ev); // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(

        } else {
          dragging.setIgnoreMove(true);
        }
      };

      this.handleDragStart = function (ev) {
        _this.emitter.trigger('dragstart', ev);

        _this.handleMove(ev, true); // force = fire even if initially null

      };

      this.handleDragMove = function (ev) {
        _this.emitter.trigger('dragmove', ev);

        _this.handleMove(ev);
      };

      this.handlePointerUp = function (ev) {
        _this.releaseHits();

        _this.emitter.trigger('pointerup', ev);
      };

      this.handleDragEnd = function (ev) {
        if (_this.movingHit) {
          _this.emitter.trigger('hitupdate', null, true, ev);
        }

        _this.finalHit = _this.movingHit;
        _this.movingHit = null;

        _this.emitter.trigger('dragend', ev);
      };

      this.droppableStore = droppableStore;
      dragging.emitter.on('pointerdown', this.handlePointerDown);
      dragging.emitter.on('dragstart', this.handleDragStart);
      dragging.emitter.on('dragmove', this.handleDragMove);
      dragging.emitter.on('pointerup', this.handlePointerUp);
      dragging.emitter.on('dragend', this.handleDragEnd);
      this.dragging = dragging;
      this.emitter = new core.EmitterMixin();
    } // sets initialHit
    // sets coordAdjust


    HitDragging.prototype.processFirstCoord = function (ev) {
      var origPoint = {
        left: ev.pageX,
        top: ev.pageY
      };
      var adjustedPoint = origPoint;
      var subjectEl = ev.subjectEl;
      var subjectRect;

      if (subjectEl !== document) {
        subjectRect = core.computeRect(subjectEl);
        adjustedPoint = core.constrainPoint(adjustedPoint, subjectRect);
      }

      var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);

      if (initialHit) {
        if (this.useSubjectCenter && subjectRect) {
          var slicedSubjectRect = core.intersectRects(subjectRect, initialHit.rect);

          if (slicedSubjectRect) {
            adjustedPoint = core.getRectCenter(slicedSubjectRect);
          }
        }

        this.coordAdjust = core.diffPoints(adjustedPoint, origPoint);
      } else {
        this.coordAdjust = {
          left: 0,
          top: 0
        };
      }
    };

    HitDragging.prototype.handleMove = function (ev, forceHandle) {
      var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);

      if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
        this.movingHit = hit;
        this.emitter.trigger('hitupdate', hit, false, ev);
      }
    };

    HitDragging.prototype.prepareHits = function () {
      this.offsetTrackers = core.mapHash(this.droppableStore, function (interactionSettings) {
        interactionSettings.component.buildPositionCaches();
        return new OffsetTracker(interactionSettings.el);
      });
    };

    HitDragging.prototype.releaseHits = function () {
      var offsetTrackers = this.offsetTrackers;

      for (var id in offsetTrackers) {
        offsetTrackers[id].destroy();
      }

      this.offsetTrackers = {};
    };

    HitDragging.prototype.queryHitForOffset = function (offsetLeft, offsetTop) {
      var _a = this,
          droppableStore = _a.droppableStore,
          offsetTrackers = _a.offsetTrackers;

      var bestHit = null;

      for (var id in droppableStore) {
        var component = droppableStore[id].component;
        var offsetTracker = offsetTrackers[id];

        if (offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
          var originLeft = offsetTracker.computeLeft();
          var originTop = offsetTracker.computeTop();
          var positionLeft = offsetLeft - originLeft;
          var positionTop = offsetTop - originTop;
          var origRect = offsetTracker.origRect;
          var width = origRect.right - origRect.left;
          var height = origRect.bottom - origRect.top;

          if ( // must be within the element's bounds
          positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {
            var hit = component.queryHit(positionLeft, positionTop, width, height);

            if (hit && ( // make sure the hit is within activeRange, meaning it's not a deal cell
            !component.props.dateProfile || // hack for DayTile
            core.rangeContainsRange(component.props.dateProfile.activeRange, hit.dateSpan.range)) && (!bestHit || hit.layer > bestHit.layer)) {
              // TODO: better way to re-orient rectangle
              hit.rect.left += originLeft;
              hit.rect.right += originLeft;
              hit.rect.top += originTop;
              hit.rect.bottom += originTop;
              bestHit = hit;
            }
          }
        }
      }

      return bestHit;
    };

    return HitDragging;
  }();

  function isHitsEqual(hit0, hit1) {
    if (!hit0 && !hit1) {
      return true;
    }

    if (Boolean(hit0) !== Boolean(hit1)) {
      return false;
    }

    return core.isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
  }
  /*
  Monitors when the user clicks on a specific date/time of a component.
  A pointerdown+pointerup on the same "hit" constitutes a click.
  */


  var DateClicking =
  /** @class */
  function (_super) {
    __extends(DateClicking, _super);

    function DateClicking(settings) {
      var _this = _super.call(this, settings) || this;

      _this.handlePointerDown = function (ev) {
        var dragging = _this.dragging; // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired

        dragging.setIgnoreMove(!_this.component.isValidDateDownEl(dragging.pointer.downEl));
      }; // won't even fire if moving was ignored


      _this.handleDragEnd = function (ev) {
        var component = _this.component;
        var pointer = _this.dragging.pointer;

        if (!pointer.wasTouchScroll) {
          var _a = _this.hitDragging,
              initialHit = _a.initialHit,
              finalHit = _a.finalHit;

          if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
            component.calendar.triggerDateClick(initialHit.dateSpan, initialHit.dayEl, component.view, ev.origEvent);
          }
        }
      };

      var component = settings.component; // we DO want to watch pointer moves because otherwise finalHit won't get populated

      _this.dragging = new FeaturefulElementDragging(component.el);
      _this.dragging.autoScroller.isEnabled = false;
      var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, core.interactionSettingsToStore(settings));
      hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
      hitDragging.emitter.on('dragend', _this.handleDragEnd);
      return _this;
    }

    DateClicking.prototype.destroy = function () {
      this.dragging.destroy();
    };

    return DateClicking;
  }(core.Interaction);
  /*
  Tracks when the user selects a portion of time of a component,
  constituted by a drag over date cells, with a possible delay at the beginning of the drag.
  */


  var DateSelecting =
  /** @class */
  function (_super) {
    __extends(DateSelecting, _super);

    function DateSelecting(settings) {
      var _this = _super.call(this, settings) || this;

      _this.dragSelection = null;

      _this.handlePointerDown = function (ev) {
        var _a = _this,
            component = _a.component,
            dragging = _a.dragging;
        var canSelect = component.opt('selectable') && component.isValidDateDownEl(ev.origEvent.target); // don't bother to watch expensive moves if component won't do selection

        dragging.setIgnoreMove(!canSelect); // if touch, require user to hold down

        dragging.delay = ev.isTouch ? getComponentTouchDelay(component) : null;
      };

      _this.handleDragStart = function (ev) {
        _this.component.calendar.unselect(ev); // unselect previous selections

      };

      _this.handleHitUpdate = function (hit, isFinal) {
        var calendar = _this.component.calendar;
        var dragSelection = null;
        var isInvalid = false;

        if (hit) {
          dragSelection = joinHitsIntoSelection(_this.hitDragging.initialHit, hit, calendar.pluginSystem.hooks.dateSelectionTransformers);

          if (!dragSelection || !_this.component.isDateSelectionValid(dragSelection)) {
            isInvalid = true;
            dragSelection = null;
          }
        }

        if (dragSelection) {
          calendar.dispatch({
            type: 'SELECT_DATES',
            selection: dragSelection
          });
        } else if (!isFinal) {
          // only unselect if moved away while dragging
          calendar.dispatch({
            type: 'UNSELECT_DATES'
          });
        }

        if (!isInvalid) {
          core.enableCursor();
        } else {
          core.disableCursor();
        }

        if (!isFinal) {
          _this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging
        }
      };

      _this.handlePointerUp = function (pev) {
        if (_this.dragSelection) {
          // selection is already rendered, so just need to report selection
          _this.component.calendar.triggerDateSelect(_this.dragSelection, pev);

          _this.dragSelection = null;
        }
      };

      var component = settings.component;
      var dragging = _this.dragging = new FeaturefulElementDragging(component.el);
      dragging.touchScrollAllowed = false;
      dragging.minDistance = component.opt('selectMinDistance') || 0;
      dragging.autoScroller.isEnabled = component.opt('dragScroll');
      var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, core.interactionSettingsToStore(settings));
      hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
      hitDragging.emitter.on('dragstart', _this.handleDragStart);
      hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
      hitDragging.emitter.on('pointerup', _this.handlePointerUp);
      return _this;
    }

    DateSelecting.prototype.destroy = function () {
      this.dragging.destroy();
    };

    return DateSelecting;
  }(core.Interaction);

  function getComponentTouchDelay(component) {
    var delay = component.opt('selectLongPressDelay');

    if (delay == null) {
      delay = component.opt('longPressDelay');
    }

    return delay;
  }

  function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
    var dateSpan0 = hit0.dateSpan;
    var dateSpan1 = hit1.dateSpan;
    var ms = [dateSpan0.range.start, dateSpan0.range.end, dateSpan1.range.start, dateSpan1.range.end];
    ms.sort(core.compareNumbers);
    var props = {};

    for (var _i = 0, dateSelectionTransformers_1 = dateSelectionTransformers; _i < dateSelectionTransformers_1.length; _i++) {
      var transformer = dateSelectionTransformers_1[_i];
      var res = transformer(hit0, hit1);

      if (res === false) {
        return null;
      } else if (res) {
        _assign(props, res);
      }
    }

    props.range = {
      start: ms[0],
      end: ms[3]
    };
    props.allDay = dateSpan0.allDay;
    return props;
  }

  var EventDragging =
  /** @class */
  function (_super) {
    __extends(EventDragging, _super);

    function EventDragging(settings) {
      var _this = _super.call(this, settings) || this; // internal state


      _this.subjectSeg = null; // the seg being selected/dragged

      _this.isDragging = false;
      _this.eventRange = null;
      _this.relevantEvents = null; // the events being dragged

      _this.receivingCalendar = null;
      _this.validMutation = null;
      _this.mutatedRelevantEvents = null;

      _this.handlePointerDown = function (ev) {
        var origTarget = ev.origEvent.target;
        var _a = _this,
            component = _a.component,
            dragging = _a.dragging;
        var mirror = dragging.mirror;
        var initialCalendar = component.calendar;
        var subjectSeg = _this.subjectSeg = core.getElSeg(ev.subjectEl);
        var eventRange = _this.eventRange = subjectSeg.eventRange;
        var eventInstanceId = eventRange.instance.instanceId;
        _this.relevantEvents = core.getRelevantEvents(initialCalendar.state.eventStore, eventInstanceId);
        dragging.minDistance = ev.isTouch ? 0 : component.opt('eventDragMinDistance');
        dragging.delay = // only do a touch delay if touch and this event hasn't been selected yet
        ev.isTouch && eventInstanceId !== component.props.eventSelection ? getComponentTouchDelay$1(component) : null;
        mirror.parentNode = initialCalendar.el;
        mirror.revertDuration = component.opt('dragRevertDuration');
        var isValid = component.isValidSegDownEl(origTarget) && !core.elementClosest(origTarget, '.fc-resizer'); // NOT on a resizer

        dragging.setIgnoreMove(!isValid); // disable dragging for elements that are resizable (ie, selectable)
        // but are not draggable

        _this.isDragging = isValid && ev.subjectEl.classList.contains('fc-draggable');
      };

      _this.handleDragStart = function (ev) {
        var initialCalendar = _this.component.calendar;
        var eventRange = _this.eventRange;
        var eventInstanceId = eventRange.instance.instanceId;

        if (ev.isTouch) {
          // need to select a different event?
          if (eventInstanceId !== _this.component.props.eventSelection) {
            initialCalendar.dispatch({
              type: 'SELECT_EVENT',
              eventInstanceId: eventInstanceId
            });
          }
        } else {
          // if now using mouse, but was previous touch interaction, clear selected event
          initialCalendar.dispatch({
            type: 'UNSELECT_EVENT'
          });
        }

        if (_this.isDragging) {
          initialCalendar.unselect(ev); // unselect *date* selection

          initialCalendar.publiclyTrigger('eventDragStart', [{
            el: _this.subjectSeg.el,
            event: new core.EventApi(initialCalendar, eventRange.def, eventRange.instance),
            jsEvent: ev.origEvent,
            view: _this.component.view
          }]);
        }
      };

      _this.handleHitUpdate = function (hit, isFinal) {
        if (!_this.isDragging) {
          return;
        }

        var relevantEvents = _this.relevantEvents;
        var initialHit = _this.hitDragging.initialHit;
        var initialCalendar = _this.component.calendar; // states based on new hit

        var receivingCalendar = null;
        var mutation = null;
        var mutatedRelevantEvents = null;
        var isInvalid = false;
        var interaction = {
          affectedEvents: relevantEvents,
          mutatedEvents: core.createEmptyEventStore(),
          isEvent: true,
          origSeg: _this.subjectSeg
        };

        if (hit) {
          var receivingComponent = hit.component;
          receivingCalendar = receivingComponent.calendar;

          if (initialCalendar === receivingCalendar || receivingComponent.opt('editable') && receivingComponent.opt('droppable')) {
            mutation = computeEventMutation(initialHit, hit, receivingCalendar.pluginSystem.hooks.eventDragMutationMassagers);

            if (mutation) {
              mutatedRelevantEvents = core.applyMutationToEventStore(relevantEvents, receivingCalendar.eventUiBases, mutation, receivingCalendar);
              interaction.mutatedEvents = mutatedRelevantEvents;

              if (!receivingComponent.isInteractionValid(interaction)) {
                isInvalid = true;
                mutation = null;
                mutatedRelevantEvents = null;
                interaction.mutatedEvents = core.createEmptyEventStore();
              }
            }
          } else {
            receivingCalendar = null;
          }
        }

        _this.displayDrag(receivingCalendar, interaction);

        if (!isInvalid) {
          core.enableCursor();
        } else {
          core.disableCursor();
        }

        if (!isFinal) {
          if (initialCalendar === receivingCalendar && // TODO: write test for this
          isHitsEqual(initialHit, hit)) {
            mutation = null;
          }

          _this.dragging.setMirrorNeedsRevert(!mutation); // render the mirror if no already-rendered mirror
          // TODO: wish we could somehow wait for dispatch to guarantee render


          _this.dragging.setMirrorIsVisible(!hit || !document.querySelector('.fc-mirror')); // assign states based on new hit


          _this.receivingCalendar = receivingCalendar;
          _this.validMutation = mutation;
          _this.mutatedRelevantEvents = mutatedRelevantEvents;
        }
      };

      _this.handlePointerUp = function () {
        if (!_this.isDragging) {
          _this.cleanup(); // because handleDragEnd won't fire

        }
      };

      _this.handleDragEnd = function (ev) {
        if (_this.isDragging) {
          var initialCalendar_1 = _this.component.calendar;
          var initialView = _this.component.view;
          var _a = _this,
              receivingCalendar = _a.receivingCalendar,
              validMutation = _a.validMutation;
          var eventDef = _this.eventRange.def;
          var eventInstance = _this.eventRange.instance;
          var eventApi = new core.EventApi(initialCalendar_1, eventDef, eventInstance);
          var relevantEvents_1 = _this.relevantEvents;
          var mutatedRelevantEvents = _this.mutatedRelevantEvents;
          var finalHit = _this.hitDragging.finalHit;

          _this.clearDrag(); // must happen after revert animation


          initialCalendar_1.publiclyTrigger('eventDragStop', [{
            el: _this.subjectSeg.el,
            event: eventApi,
            jsEvent: ev.origEvent,
            view: initialView
          }]);

          if (validMutation) {
            // dropped within same calendar
            if (receivingCalendar === initialCalendar_1) {
              initialCalendar_1.dispatch({
                type: 'MERGE_EVENTS',
                eventStore: mutatedRelevantEvents
              });
              var transformed = {};

              for (var _i = 0, _b = initialCalendar_1.pluginSystem.hooks.eventDropTransformers; _i < _b.length; _i++) {
                var transformer = _b[_i];

                _assign(transformed, transformer(validMutation, initialCalendar_1));
              }

              var eventDropArg = _assign({}, transformed, {
                el: ev.subjectEl,
                delta: validMutation.datesDelta,
                oldEvent: eventApi,
                event: new core.EventApi( // the data AFTER the mutation
                initialCalendar_1, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null),
                revert: function revert() {
                  initialCalendar_1.dispatch({
                    type: 'MERGE_EVENTS',
                    eventStore: relevantEvents_1
                  });
                },
                jsEvent: ev.origEvent,
                view: initialView
              });

              initialCalendar_1.publiclyTrigger('eventDrop', [eventDropArg]); // dropped in different calendar
            } else if (receivingCalendar) {
              initialCalendar_1.publiclyTrigger('eventLeave', [{
                draggedEl: ev.subjectEl,
                event: eventApi,
                view: initialView
              }]);
              initialCalendar_1.dispatch({
                type: 'REMOVE_EVENT_INSTANCES',
                instances: _this.mutatedRelevantEvents.instances
              });
              receivingCalendar.dispatch({
                type: 'MERGE_EVENTS',
                eventStore: _this.mutatedRelevantEvents
              });

              if (ev.isTouch) {
                receivingCalendar.dispatch({
                  type: 'SELECT_EVENT',
                  eventInstanceId: eventInstance.instanceId
                });
              }

              var dropArg = _assign({}, receivingCalendar.buildDatePointApi(finalHit.dateSpan), {
                draggedEl: ev.subjectEl,
                jsEvent: ev.origEvent,
                view: finalHit.component // should this be finalHit.component.view? See #4644

              });

              receivingCalendar.publiclyTrigger('drop', [dropArg]);
              receivingCalendar.publiclyTrigger('eventReceive', [{
                draggedEl: ev.subjectEl,
                event: new core.EventApi( // the data AFTER the mutation
                receivingCalendar, mutatedRelevantEvents.defs[eventDef.defId], mutatedRelevantEvents.instances[eventInstance.instanceId]),
                view: finalHit.component // should this be finalHit.component.view? See #4644

              }]);
            }
          } else {
            initialCalendar_1.publiclyTrigger('_noEventDrop');
          }
        }

        _this.cleanup();
      };

      var component = _this.component;
      var dragging = _this.dragging = new FeaturefulElementDragging(component.el);
      dragging.pointer.selector = EventDragging.SELECTOR;
      dragging.touchScrollAllowed = false;
      dragging.autoScroller.isEnabled = component.opt('dragScroll');
      var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, core.interactionSettingsStore);
      hitDragging.useSubjectCenter = settings.useEventCenter;
      hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
      hitDragging.emitter.on('dragstart', _this.handleDragStart);
      hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
      hitDragging.emitter.on('pointerup', _this.handlePointerUp);
      hitDragging.emitter.on('dragend', _this.handleDragEnd);
      return _this;
    }

    EventDragging.prototype.destroy = function () {
      this.dragging.destroy();
    }; // render a drag state on the next receivingCalendar


    EventDragging.prototype.displayDrag = function (nextCalendar, state) {
      var initialCalendar = this.component.calendar;
      var prevCalendar = this.receivingCalendar; // does the previous calendar need to be cleared?

      if (prevCalendar && prevCalendar !== nextCalendar) {
        // does the initial calendar need to be cleared?
        // if so, don't clear all the way. we still need to to hide the affectedEvents
        if (prevCalendar === initialCalendar) {
          prevCalendar.dispatch({
            type: 'SET_EVENT_DRAG',
            state: {
              affectedEvents: state.affectedEvents,
              mutatedEvents: core.createEmptyEventStore(),
              isEvent: true,
              origSeg: state.origSeg
            }
          }); // completely clear the old calendar if it wasn't the initial
        } else {
          prevCalendar.dispatch({
            type: 'UNSET_EVENT_DRAG'
          });
        }
      }

      if (nextCalendar) {
        nextCalendar.dispatch({
          type: 'SET_EVENT_DRAG',
          state: state
        });
      }
    };

    EventDragging.prototype.clearDrag = function () {
      var initialCalendar = this.component.calendar;
      var receivingCalendar = this.receivingCalendar;

      if (receivingCalendar) {
        receivingCalendar.dispatch({
          type: 'UNSET_EVENT_DRAG'
        });
      } // the initial calendar might have an dummy drag state from displayDrag


      if (initialCalendar !== receivingCalendar) {
        initialCalendar.dispatch({
          type: 'UNSET_EVENT_DRAG'
        });
      }
    };

    EventDragging.prototype.cleanup = function () {
      this.subjectSeg = null;
      this.isDragging = false;
      this.eventRange = null;
      this.relevantEvents = null;
      this.receivingCalendar = null;
      this.validMutation = null;
      this.mutatedRelevantEvents = null;
    };

    EventDragging.SELECTOR = '.fc-draggable, .fc-resizable'; // TODO: test this in IE11

    return EventDragging;
  }(core.Interaction);

  function computeEventMutation(hit0, hit1, massagers) {
    var dateSpan0 = hit0.dateSpan;
    var dateSpan1 = hit1.dateSpan;
    var date0 = dateSpan0.range.start;
    var date1 = dateSpan1.range.start;
    var standardProps = {};

    if (dateSpan0.allDay !== dateSpan1.allDay) {
      standardProps.allDay = dateSpan1.allDay;
      standardProps.hasEnd = hit1.component.opt('allDayMaintainDuration');

      if (dateSpan1.allDay) {
        // means date1 is already start-of-day,
        // but date0 needs to be converted
        date0 = core.startOfDay(date0);
      }
    }

    var delta = core.diffDates(date0, date1, hit0.component.dateEnv, hit0.component === hit1.component ? hit0.component.largeUnit : null);

    if (delta.milliseconds) {
      // has hours/minutes/seconds
      standardProps.allDay = false;
    }

    var mutation = {
      datesDelta: delta,
      standardProps: standardProps
    };

    for (var _i = 0, massagers_1 = massagers; _i < massagers_1.length; _i++) {
      var massager = massagers_1[_i];
      massager(mutation, hit0, hit1);
    }

    return mutation;
  }

  function getComponentTouchDelay$1(component) {
    var delay = component.opt('eventLongPressDelay');

    if (delay == null) {
      delay = component.opt('longPressDelay');
    }

    return delay;
  }

  var EventDragging$1 =
  /** @class */
  function (_super) {
    __extends(EventDragging, _super);

    function EventDragging(settings) {
      var _this = _super.call(this, settings) || this; // internal state


      _this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?

      _this.eventRange = null;
      _this.relevantEvents = null;
      _this.validMutation = null;
      _this.mutatedRelevantEvents = null;

      _this.handlePointerDown = function (ev) {
        var component = _this.component;

        var seg = _this.querySeg(ev);

        var eventRange = _this.eventRange = seg.eventRange;
        _this.dragging.minDistance = component.opt('eventDragMinDistance'); // if touch, need to be working with a selected event

        _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && _this.component.props.eventSelection !== eventRange.instance.instanceId);
      };

      _this.handleDragStart = function (ev) {
        var calendar = _this.component.calendar;
        var eventRange = _this.eventRange;
        _this.relevantEvents = core.getRelevantEvents(calendar.state.eventStore, _this.eventRange.instance.instanceId);
        _this.draggingSeg = _this.querySeg(ev);
        calendar.unselect();
        calendar.publiclyTrigger('eventResizeStart', [{
          el: _this.draggingSeg.el,
          event: new core.EventApi(calendar, eventRange.def, eventRange.instance),
          jsEvent: ev.origEvent,
          view: _this.component.view
        }]);
      };

      _this.handleHitUpdate = function (hit, isFinal, ev) {
        var calendar = _this.component.calendar;
        var relevantEvents = _this.relevantEvents;
        var initialHit = _this.hitDragging.initialHit;
        var eventInstance = _this.eventRange.instance;
        var mutation = null;
        var mutatedRelevantEvents = null;
        var isInvalid = false;
        var interaction = {
          affectedEvents: relevantEvents,
          mutatedEvents: core.createEmptyEventStore(),
          isEvent: true,
          origSeg: _this.draggingSeg
        };

        if (hit) {
          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-start-resizer'), eventInstance.range, calendar.pluginSystem.hooks.eventResizeJoinTransforms);
        }

        if (mutation) {
          mutatedRelevantEvents = core.applyMutationToEventStore(relevantEvents, calendar.eventUiBases, mutation, calendar);
          interaction.mutatedEvents = mutatedRelevantEvents;

          if (!_this.component.isInteractionValid(interaction)) {
            isInvalid = true;
            mutation = null;
            mutatedRelevantEvents = null;
            interaction.mutatedEvents = null;
          }
        }

        if (mutatedRelevantEvents) {
          calendar.dispatch({
            type: 'SET_EVENT_RESIZE',
            state: interaction
          });
        } else {
          calendar.dispatch({
            type: 'UNSET_EVENT_RESIZE'
          });
        }

        if (!isInvalid) {
          core.enableCursor();
        } else {
          core.disableCursor();
        }

        if (!isFinal) {
          if (mutation && isHitsEqual(initialHit, hit)) {
            mutation = null;
          }

          _this.validMutation = mutation;
          _this.mutatedRelevantEvents = mutatedRelevantEvents;
        }
      };

      _this.handleDragEnd = function (ev) {
        var calendar = _this.component.calendar;
        var view = _this.component.view;
        var eventDef = _this.eventRange.def;
        var eventInstance = _this.eventRange.instance;
        var eventApi = new core.EventApi(calendar, eventDef, eventInstance);
        var relevantEvents = _this.relevantEvents;
        var mutatedRelevantEvents = _this.mutatedRelevantEvents;
        calendar.publiclyTrigger('eventResizeStop', [{
          el: _this.draggingSeg.el,
          event: eventApi,
          jsEvent: ev.origEvent,
          view: view
        }]);

        if (_this.validMutation) {
          calendar.dispatch({
            type: 'MERGE_EVENTS',
            eventStore: mutatedRelevantEvents
          });
          calendar.publiclyTrigger('eventResize', [{
            el: _this.draggingSeg.el,
            startDelta: _this.validMutation.startDelta || core.createDuration(0),
            endDelta: _this.validMutation.endDelta || core.createDuration(0),
            prevEvent: eventApi,
            event: new core.EventApi( // the data AFTER the mutation
            calendar, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null),
            revert: function revert() {
              calendar.dispatch({
                type: 'MERGE_EVENTS',
                eventStore: relevantEvents
              });
            },
            jsEvent: ev.origEvent,
            view: view
          }]);
        } else {
          calendar.publiclyTrigger('_noEventResize');
        } // reset all internal state


        _this.draggingSeg = null;
        _this.relevantEvents = null;
        _this.validMutation = null; // okay to keep eventInstance around. useful to set it in handlePointerDown
      };

      var component = settings.component;
      var dragging = _this.dragging = new FeaturefulElementDragging(component.el);
      dragging.pointer.selector = '.fc-resizer';
      dragging.touchScrollAllowed = false;
      dragging.autoScroller.isEnabled = component.opt('dragScroll');
      var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, core.interactionSettingsToStore(settings));
      hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
      hitDragging.emitter.on('dragstart', _this.handleDragStart);
      hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
      hitDragging.emitter.on('dragend', _this.handleDragEnd);
      return _this;
    }

    EventDragging.prototype.destroy = function () {
      this.dragging.destroy();
    };

    EventDragging.prototype.querySeg = function (ev) {
      return core.getElSeg(core.elementClosest(ev.subjectEl, this.component.fgSegSelector));
    };

    return EventDragging;
  }(core.Interaction);

  function computeMutation(hit0, hit1, isFromStart, instanceRange, transforms) {
    var dateEnv = hit0.component.dateEnv;
    var date0 = hit0.dateSpan.range.start;
    var date1 = hit1.dateSpan.range.start;
    var delta = core.diffDates(date0, date1, dateEnv, hit0.component.largeUnit);
    var props = {};

    for (var _i = 0, transforms_1 = transforms; _i < transforms_1.length; _i++) {
      var transform = transforms_1[_i];
      var res = transform(hit0, hit1);

      if (res === false) {
        return null;
      } else if (res) {
        _assign(props, res);
      }
    }

    if (isFromStart) {
      if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
        props.startDelta = delta;
        return props;
      }
    } else {
      if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
        props.endDelta = delta;
        return props;
      }
    }

    return null;
  }

  var UnselectAuto =
  /** @class */
  function () {
    function UnselectAuto(calendar) {
      var _this = this;

      this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system

      this.onSelect = function (selectInfo) {
        if (selectInfo.jsEvent) {
          _this.isRecentPointerDateSelect = true;
        }
      };

      this.onDocumentPointerUp = function (pev) {
        var _a = _this,
            calendar = _a.calendar,
            documentPointer = _a.documentPointer;
        var state = calendar.state; // touch-scrolling should never unfocus any type of selection

        if (!documentPointer.wasTouchScroll) {
          if (state.dateSelection && // an existing date selection?
          !_this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?
          ) {
              var unselectAuto = calendar.viewOpt('unselectAuto');
              var unselectCancel = calendar.viewOpt('unselectCancel');

              if (unselectAuto && (!unselectAuto || !core.elementClosest(documentPointer.downEl, unselectCancel))) {
                calendar.unselect(pev);
              }
            }

          if (state.eventSelection && // an existing event selected?
          !core.elementClosest(documentPointer.downEl, EventDragging.SELECTOR) // interaction DIDN'T start on an event
          ) {
              calendar.dispatch({
                type: 'UNSELECT_EVENT'
              });
            }
        }

        _this.isRecentPointerDateSelect = false;
      };

      this.calendar = calendar;
      var documentPointer = this.documentPointer = new PointerDragging(document);
      documentPointer.shouldIgnoreMove = true;
      documentPointer.shouldWatchScroll = false;
      documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);
      /*
      TODO: better way to know about whether there was a selection with the pointer
      */

      calendar.on('select', this.onSelect);
    }

    UnselectAuto.prototype.destroy = function () {
      this.calendar.off('select', this.onSelect);
      this.documentPointer.destroy();
    };

    return UnselectAuto;
  }();
  /*
  Given an already instantiated draggable object for one-or-more elements,
  Interprets any dragging as an attempt to drag an events that lives outside
  of a calendar onto a calendar.
  */


  var ExternalElementDragging =
  /** @class */
  function () {
    function ExternalElementDragging(dragging, suppliedDragMeta) {
      var _this = this;

      this.receivingCalendar = null;
      this.droppableEvent = null; // will exist for all drags, even if create:false

      this.suppliedDragMeta = null;
      this.dragMeta = null;

      this.handleDragStart = function (ev) {
        _this.dragMeta = _this.buildDragMeta(ev.subjectEl);
      };

      this.handleHitUpdate = function (hit, isFinal, ev) {
        var dragging = _this.hitDragging.dragging;
        var receivingCalendar = null;
        var droppableEvent = null;
        var isInvalid = false;
        var interaction = {
          affectedEvents: core.createEmptyEventStore(),
          mutatedEvents: core.createEmptyEventStore(),
          isEvent: _this.dragMeta.create,
          origSeg: null
        };

        if (hit) {
          receivingCalendar = hit.component.calendar;

          if (_this.canDropElOnCalendar(ev.subjectEl, receivingCalendar)) {
            droppableEvent = computeEventForDateSpan(hit.dateSpan, _this.dragMeta, receivingCalendar);
            interaction.mutatedEvents = core.eventTupleToStore(droppableEvent);
            isInvalid = !core.isInteractionValid(interaction, receivingCalendar);

            if (isInvalid) {
              interaction.mutatedEvents = core.createEmptyEventStore();
              droppableEvent = null;
            }
          }
        }

        _this.displayDrag(receivingCalendar, interaction); // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)
        // TODO: wish we could somehow wait for dispatch to guarantee render


        dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-mirror'));

        if (!isInvalid) {
          core.enableCursor();
        } else {
          core.disableCursor();
        }

        if (!isFinal) {
          dragging.setMirrorNeedsRevert(!droppableEvent);
          _this.receivingCalendar = receivingCalendar;
          _this.droppableEvent = droppableEvent;
        }
      };

      this.handleDragEnd = function (pev) {
        var _a = _this,
            receivingCalendar = _a.receivingCalendar,
            droppableEvent = _a.droppableEvent;

        _this.clearDrag();

        if (receivingCalendar && droppableEvent) {
          var finalHit = _this.hitDragging.finalHit;
          var finalView = finalHit.component.view;
          var dragMeta = _this.dragMeta;

          var arg = _assign({}, receivingCalendar.buildDatePointApi(finalHit.dateSpan), {
            draggedEl: pev.subjectEl,
            jsEvent: pev.origEvent,
            view: finalView
          });

          receivingCalendar.publiclyTrigger('drop', [arg]);

          if (dragMeta.create) {
            receivingCalendar.dispatch({
              type: 'MERGE_EVENTS',
              eventStore: core.eventTupleToStore(droppableEvent)
            });

            if (pev.isTouch) {
              receivingCalendar.dispatch({
                type: 'SELECT_EVENT',
                eventInstanceId: droppableEvent.instance.instanceId
              });
            } // signal that an external event landed


            receivingCalendar.publiclyTrigger('eventReceive', [{
              draggedEl: pev.subjectEl,
              event: new core.EventApi(receivingCalendar, droppableEvent.def, droppableEvent.instance),
              view: finalView
            }]);
          }
        }

        _this.receivingCalendar = null;
        _this.droppableEvent = null;
      };

      var hitDragging = this.hitDragging = new HitDragging(dragging, core.interactionSettingsStore);
      hitDragging.requireInitial = false; // will start outside of a component

      hitDragging.emitter.on('dragstart', this.handleDragStart);
      hitDragging.emitter.on('hitupdate', this.handleHitUpdate);
      hitDragging.emitter.on('dragend', this.handleDragEnd);
      this.suppliedDragMeta = suppliedDragMeta;
    }

    ExternalElementDragging.prototype.buildDragMeta = function (subjectEl) {
      if (_typeof(this.suppliedDragMeta) === 'object') {
        return core.parseDragMeta(this.suppliedDragMeta);
      } else if (typeof this.suppliedDragMeta === 'function') {
        return core.parseDragMeta(this.suppliedDragMeta(subjectEl));
      } else {
        return getDragMetaFromEl(subjectEl);
      }
    };

    ExternalElementDragging.prototype.displayDrag = function (nextCalendar, state) {
      var prevCalendar = this.receivingCalendar;

      if (prevCalendar && prevCalendar !== nextCalendar) {
        prevCalendar.dispatch({
          type: 'UNSET_EVENT_DRAG'
        });
      }

      if (nextCalendar) {
        nextCalendar.dispatch({
          type: 'SET_EVENT_DRAG',
          state: state
        });
      }
    };

    ExternalElementDragging.prototype.clearDrag = function () {
      if (this.receivingCalendar) {
        this.receivingCalendar.dispatch({
          type: 'UNSET_EVENT_DRAG'
        });
      }
    };

    ExternalElementDragging.prototype.canDropElOnCalendar = function (el, receivingCalendar) {
      var dropAccept = receivingCalendar.opt('dropAccept');

      if (typeof dropAccept === 'function') {
        return dropAccept(el);
      } else if (typeof dropAccept === 'string' && dropAccept) {
        return Boolean(core.elementMatches(el, dropAccept));
      }

      return true;
    };

    return ExternalElementDragging;
  }(); // Utils for computing event store from the DragMeta
  // ----------------------------------------------------------------------------------------------------


  function computeEventForDateSpan(dateSpan, dragMeta, calendar) {
    var defProps = _assign({}, dragMeta.leftoverProps);

    for (var _i = 0, _a = calendar.pluginSystem.hooks.externalDefTransforms; _i < _a.length; _i++) {
      var transform = _a[_i];

      _assign(defProps, transform(dateSpan, dragMeta));
    }

    var def = core.parseEventDef(defProps, dragMeta.sourceId, dateSpan.allDay, calendar.opt('forceEventDuration') || Boolean(dragMeta.duration), // hasEnd
    calendar);
    var start = dateSpan.range.start; // only rely on time info if drop zone is all-day,
    // otherwise, we already know the time

    if (dateSpan.allDay && dragMeta.startTime) {
      start = calendar.dateEnv.add(start, dragMeta.startTime);
    }

    var end = dragMeta.duration ? calendar.dateEnv.add(start, dragMeta.duration) : calendar.getDefaultEventEnd(dateSpan.allDay, start);
    var instance = core.createEventInstance(def.defId, {
      start: start,
      end: end
    });
    return {
      def: def,
      instance: instance
    };
  } // Utils for extracting data from element
  // ----------------------------------------------------------------------------------------------------


  function getDragMetaFromEl(el) {
    var str = getEmbeddedElData(el, 'event');
    var obj = str ? JSON.parse(str) : {
      create: false
    }; // if no embedded data, assume no event creation

    return core.parseDragMeta(obj);
  }

  core.config.dataAttrPrefix = '';

  function getEmbeddedElData(el, name) {
    var prefix = core.config.dataAttrPrefix;
    var prefixedName = (prefix ? prefix + '-' : '') + name;
    return el.getAttribute('data-' + prefixedName) || '';
  }
  /*
  Makes an element (that is *external* to any calendar) draggable.
  Can pass in data that determines how an event will be created when dropped onto a calendar.
  Leverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.
  */


  var ExternalDraggable =
  /** @class */
  function () {
    function ExternalDraggable(el, settings) {
      var _this = this;

      if (settings === void 0) {
        settings = {};
      }

      this.handlePointerDown = function (ev) {
        var dragging = _this.dragging;
        var _a = _this.settings,
            minDistance = _a.minDistance,
            longPressDelay = _a.longPressDelay;
        dragging.minDistance = minDistance != null ? minDistance : ev.isTouch ? 0 : core.globalDefaults.eventDragMinDistance;
        dragging.delay = ev.isTouch ? // TODO: eventually read eventLongPressDelay instead vvv
        longPressDelay != null ? longPressDelay : core.globalDefaults.longPressDelay : 0;
      };

      this.handleDragStart = function (ev) {
        if (ev.isTouch && _this.dragging.delay && ev.subjectEl.classList.contains('fc-event')) {
          _this.dragging.mirror.getMirrorEl().classList.add('fc-selected');
        }
      };

      this.settings = settings;
      var dragging = this.dragging = new FeaturefulElementDragging(el);
      dragging.touchScrollAllowed = false;

      if (settings.itemSelector != null) {
        dragging.pointer.selector = settings.itemSelector;
      }

      if (settings.appendTo != null) {
        dragging.mirror.parentNode = settings.appendTo; // TODO: write tests
      }

      dragging.emitter.on('pointerdown', this.handlePointerDown);
      dragging.emitter.on('dragstart', this.handleDragStart);
      new ExternalElementDragging(dragging, settings.eventData);
    }

    ExternalDraggable.prototype.destroy = function () {
      this.dragging.destroy();
    };

    return ExternalDraggable;
  }();
  /*
  Detects when a *THIRD-PARTY* drag-n-drop system interacts with elements.
  The third-party system is responsible for drawing the visuals effects of the drag.
  This class simply monitors for pointer movements and fires events.
  It also has the ability to hide the moving element (the "mirror") during the drag.
  */


  var InferredElementDragging =
  /** @class */
  function (_super) {
    __extends(InferredElementDragging, _super);

    function InferredElementDragging(containerEl) {
      var _this = _super.call(this, containerEl) || this;

      _this.shouldIgnoreMove = false;
      _this.mirrorSelector = '';
      _this.currentMirrorEl = null;

      _this.handlePointerDown = function (ev) {
        _this.emitter.trigger('pointerdown', ev);

        if (!_this.shouldIgnoreMove) {
          // fire dragstart right away. does not support delay or min-distance
          _this.emitter.trigger('dragstart', ev);
        }
      };

      _this.handlePointerMove = function (ev) {
        if (!_this.shouldIgnoreMove) {
          _this.emitter.trigger('dragmove', ev);
        }
      };

      _this.handlePointerUp = function (ev) {
        _this.emitter.trigger('pointerup', ev);

        if (!_this.shouldIgnoreMove) {
          // fire dragend right away. does not support a revert animation
          _this.emitter.trigger('dragend', ev);
        }
      };

      var pointer = _this.pointer = new PointerDragging(containerEl);
      pointer.emitter.on('pointerdown', _this.handlePointerDown);
      pointer.emitter.on('pointermove', _this.handlePointerMove);
      pointer.emitter.on('pointerup', _this.handlePointerUp);
      return _this;
    }

    InferredElementDragging.prototype.destroy = function () {
      this.pointer.destroy();
    };

    InferredElementDragging.prototype.setIgnoreMove = function (bool) {
      this.shouldIgnoreMove = bool;
    };

    InferredElementDragging.prototype.setMirrorIsVisible = function (bool) {
      if (bool) {
        // restore a previously hidden element.
        // use the reference in case the selector class has already been removed.
        if (this.currentMirrorEl) {
          this.currentMirrorEl.style.visibility = '';
          this.currentMirrorEl = null;
        }
      } else {
        var mirrorEl = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null;

        if (mirrorEl) {
          this.currentMirrorEl = mirrorEl;
          mirrorEl.style.visibility = 'hidden';
        }
      }
    };

    return InferredElementDragging;
  }(core.ElementDragging);
  /*
  Bridges third-party drag-n-drop systems with FullCalendar.
  Must be instantiated and destroyed by caller.
  */


  var ThirdPartyDraggable =
  /** @class */
  function () {
    function ThirdPartyDraggable(containerOrSettings, settings) {
      var containerEl = document;

      if ( // wish we could just test instanceof EventTarget, but doesn't work in IE11
      containerOrSettings === document || containerOrSettings instanceof Element) {
        containerEl = containerOrSettings;
        settings = settings || {};
      } else {
        settings = containerOrSettings || {};
      }

      var dragging = this.dragging = new InferredElementDragging(containerEl);

      if (typeof settings.itemSelector === 'string') {
        dragging.pointer.selector = settings.itemSelector;
      } else if (containerEl === document) {
        dragging.pointer.selector = '[data-event]';
      }

      if (typeof settings.mirrorSelector === 'string') {
        dragging.mirrorSelector = settings.mirrorSelector;
      }

      new ExternalElementDragging(dragging, settings.eventData);
    }

    ThirdPartyDraggable.prototype.destroy = function () {
      this.dragging.destroy();
    };

    return ThirdPartyDraggable;
  }();

  var main = core.createPlugin({
    componentInteractions: [DateClicking, DateSelecting, EventDragging, EventDragging$1],
    calendarInteractions: [UnselectAuto],
    elementDraggingImpl: FeaturefulElementDragging
  });
  exports.Draggable = ExternalDraggable;
  exports.FeaturefulElementDragging = FeaturefulElementDragging;
  exports.PointerDragging = PointerDragging;
  exports.ThirdPartyDraggable = ThirdPartyDraggable;
  exports["default"] = main;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./assets/fullcalendar/list/main.css":
/*!*******************************************!*\
  !*** ./assets/fullcalendar/list/main.css ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./assets/fullcalendar/list/main.js":
/*!******************************************!*\
  !*** ./assets/fullcalendar/list/main.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__(/*! core-js/modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");

__webpack_require__(/*! core-js/modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");

__webpack_require__(/*! core-js/modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.concat */ "./node_modules/core-js/modules/es.array.concat.js");

__webpack_require__(/*! core-js/modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.join */ "./node_modules/core-js/modules/es.array.join.js");

__webpack_require__(/*! core-js/modules/es.function.bind */ "./node_modules/core-js/modules/es.function.bind.js");

__webpack_require__(/*! core-js/modules/es.object.create */ "./node_modules/core-js/modules/es.object.create.js");

__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.set-prototype-of */ "./node_modules/core-js/modules/es.object.set-prototype-of.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");

__webpack_require__(/*! core-js/modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");

__webpack_require__(/*! core-js/modules/es.string.split */ "./node_modules/core-js/modules/es.string.split.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
FullCalendar List View Plugin v4.3.0
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, __webpack_require__(/*! @fullcalendar/core */ "./node_modules/@fullcalendar/core/main.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! @fullcalendar/core */ "./node_modules/@fullcalendar/core/main.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(this, function (exports, core) {
  'use strict';
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
    See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */

  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var ListEventRenderer =
  /** @class */
  function (_super) {
    __extends(ListEventRenderer, _super);

    function ListEventRenderer(listView) {
      var _this = _super.call(this, listView.context) || this;

      _this.listView = listView;
      return _this;
    }

    ListEventRenderer.prototype.attachSegs = function (segs) {
      if (!segs.length) {
        this.listView.renderEmptyMessage();
      } else {
        this.listView.renderSegList(segs);
      }
    };

    ListEventRenderer.prototype.detachSegs = function () {}; // generates the HTML for a single event row


    ListEventRenderer.prototype.renderSegHtml = function (seg) {
      var _a = this.context,
          view = _a.view,
          theme = _a.theme;
      var eventRange = seg.eventRange;
      var eventDef = eventRange.def;
      var eventInstance = eventRange.instance;
      var eventUi = eventRange.ui;
      var url = eventDef.url;
      var classes = ['fc-list-item'].concat(eventUi.classNames);
      var bgColor = eventUi.backgroundColor;
      var timeHtml;

      if (eventDef.allDay) {
        timeHtml = core.getAllDayHtml(view);
      } else if (core.isMultiDayRange(eventRange.range)) {
        if (seg.isStart) {
          timeHtml = core.htmlEscape(this._getTimeText(eventInstance.range.start, seg.end, false // allDay
          ));
        } else if (seg.isEnd) {
          timeHtml = core.htmlEscape(this._getTimeText(seg.start, eventInstance.range.end, false // allDay
          ));
        } else {
          // inner segment that lasts the whole day
          timeHtml = core.getAllDayHtml(view);
        }
      } else {
        // Display the normal time text for the *event's* times
        timeHtml = core.htmlEscape(this.getTimeText(eventRange));
      }

      if (url) {
        classes.push('fc-has-url');
      }

      return '<tr class="' + classes.join(' ') + '">' + (this.displayEventTime ? '<td class="fc-list-item-time ' + theme.getClass('widgetContent') + '">' + (timeHtml || '') + '</td>' : '') + '<td class="fc-list-item-marker ' + theme.getClass('widgetContent') + '">' + '<span class="fc-event-dot"' + (bgColor ? ' style="background-color:' + bgColor + '"' : '') + '></span>' + '</td>' + '<td class="fc-list-item-title ' + theme.getClass('widgetContent') + '">' + '<a' + (url ? ' href="' + core.htmlEscape(url) + '"' : '') + '>' + core.htmlEscape(eventDef.title || '') + '</a>' + '</td>' + '</tr>';
    }; // like "4:00am"


    ListEventRenderer.prototype.computeEventTimeFormat = function () {
      return {
        hour: 'numeric',
        minute: '2-digit',
        meridiem: 'short'
      };
    };

    return ListEventRenderer;
  }(core.FgEventRenderer);
  /*
  Responsible for the scroller, and forwarding event-related actions into the "grid".
  */


  var ListView =
  /** @class */
  function (_super) {
    __extends(ListView, _super);

    function ListView(context, viewSpec, dateProfileGenerator, parentEl) {
      var _this = _super.call(this, context, viewSpec, dateProfileGenerator, parentEl) || this;

      _this.computeDateVars = core.memoize(computeDateVars);
      _this.eventStoreToSegs = core.memoize(_this._eventStoreToSegs);
      var eventRenderer = _this.eventRenderer = new ListEventRenderer(_this);
      _this.renderContent = core.memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer));

      _this.el.classList.add('fc-list-view');

      var listViewClassNames = (_this.theme.getClass('listView') || '').split(' '); // wish we didn't have to do this

      for (var _i = 0, listViewClassNames_1 = listViewClassNames; _i < listViewClassNames_1.length; _i++) {
        var listViewClassName = listViewClassNames_1[_i];

        if (listViewClassName) {
          // in case input was empty string
          _this.el.classList.add(listViewClassName);
        }
      }

      _this.scroller = new core.ScrollComponent('hidden', // overflow x
      'auto' // overflow y
      );

      _this.el.appendChild(_this.scroller.el);

      _this.contentEl = _this.scroller.el; // shortcut

      context.calendar.registerInteractiveComponent(_this, {
        el: _this.el // TODO: make aware that it doesn't do Hits

      });
      return _this;
    }

    ListView.prototype.render = function (props) {
      var _a = this.computeDateVars(props.dateProfile),
          dayDates = _a.dayDates,
          dayRanges = _a.dayRanges;

      this.dayDates = dayDates;
      this.renderContent(this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges));
    };

    ListView.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      this.renderContent.unrender();
      this.scroller.destroy(); // will remove the Grid too

      this.calendar.unregisterInteractiveComponent(this);
    };

    ListView.prototype.updateSize = function (isResize, viewHeight, isAuto) {
      _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto);

      this.eventRenderer.computeSizes(isResize);
      this.eventRenderer.assignSizes(isResize);
      this.scroller.clear(); // sets height to 'auto' and clears overflow

      if (!isAuto) {
        this.scroller.setHeight(this.computeScrollerHeight(viewHeight));
      }
    };

    ListView.prototype.computeScrollerHeight = function (viewHeight) {
      return viewHeight - core.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };

    ListView.prototype._eventStoreToSegs = function (eventStore, eventUiBases, dayRanges) {
      return this.eventRangesToSegs(core.sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.nextDayThreshold).fg, dayRanges);
    };

    ListView.prototype.eventRangesToSegs = function (eventRanges, dayRanges) {
      var segs = [];

      for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {
        var eventRange = eventRanges_1[_i];
        segs.push.apply(segs, this.eventRangeToSegs(eventRange, dayRanges));
      }

      return segs;
    };

    ListView.prototype.eventRangeToSegs = function (eventRange, dayRanges) {
      var _a = this,
          dateEnv = _a.dateEnv,
          nextDayThreshold = _a.nextDayThreshold;

      var range = eventRange.range;
      var allDay = eventRange.def.allDay;
      var dayIndex;
      var segRange;
      var seg;
      var segs = [];

      for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex++) {
        segRange = core.intersectRanges(range, dayRanges[dayIndex]);

        if (segRange) {
          seg = {
            component: this,
            eventRange: eventRange,
            start: segRange.start,
            end: segRange.end,
            isStart: eventRange.isStart && segRange.start.valueOf() === range.start.valueOf(),
            isEnd: eventRange.isEnd && segRange.end.valueOf() === range.end.valueOf(),
            dayIndex: dayIndex
          };
          segs.push(seg); // detect when range won't go fully into the next day,
          // and mutate the latest seg to the be the end.

          if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {
            seg.end = range.end;
            seg.isEnd = true;
            break;
          }
        }
      }

      return segs;
    };

    ListView.prototype.renderEmptyMessage = function () {
      this.contentEl.innerHTML = '<div class="fc-list-empty-wrap2">' + // TODO: try less wraps
      '<div class="fc-list-empty-wrap1">' + '<div class="fc-list-empty">' + core.htmlEscape(this.opt('noEventsMessage')) + '</div>' + '</div>' + '</div>';
    }; // called by ListEventRenderer


    ListView.prototype.renderSegList = function (allSegs) {
      var segsByDay = this.groupSegsByDay(allSegs); // sparse array

      var dayIndex;
      var daySegs;
      var i;
      var tableEl = core.htmlToElement('<table class="fc-list-table ' + this.calendar.theme.getClass('tableList') + '"><tbody></tbody></table>');
      var tbodyEl = tableEl.querySelector('tbody');

      for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
        daySegs = segsByDay[dayIndex];

        if (daySegs) {
          // sparse array, so might be undefined
          // append a day header
          tbodyEl.appendChild(this.buildDayHeaderRow(this.dayDates[dayIndex]));
          daySegs = this.eventRenderer.sortEventSegs(daySegs);

          for (i = 0; i < daySegs.length; i++) {
            tbodyEl.appendChild(daySegs[i].el); // append event row
          }
        }
      }

      this.contentEl.innerHTML = '';
      this.contentEl.appendChild(tableEl);
    }; // Returns a sparse array of arrays, segs grouped by their dayIndex


    ListView.prototype.groupSegsByDay = function (segs) {
      var segsByDay = []; // sparse array

      var i;
      var seg;

      for (i = 0; i < segs.length; i++) {
        seg = segs[i];
        (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);
      }

      return segsByDay;
    }; // generates the HTML for the day headers that live amongst the event rows


    ListView.prototype.buildDayHeaderRow = function (dayDate) {
      var dateEnv = this.dateEnv;
      var mainFormat = core.createFormatter(this.opt('listDayFormat')); // TODO: cache

      var altFormat = core.createFormatter(this.opt('listDayAltFormat')); // TODO: cache

      return core.createElement('tr', {
        className: 'fc-list-heading',
        'data-date': dateEnv.formatIso(dayDate, {
          omitTime: true
        })
      }, '<td class="' + (this.calendar.theme.getClass('tableListHeading') || this.calendar.theme.getClass('widgetHeader')) + '" colspan="3">' + (mainFormat ? core.buildGotoAnchorHtml(this, dayDate, {
        'class': 'fc-list-heading-main'
      }, core.htmlEscape(dateEnv.format(dayDate, mainFormat)) // inner HTML
      ) : '') + (altFormat ? core.buildGotoAnchorHtml(this, dayDate, {
        'class': 'fc-list-heading-alt'
      }, core.htmlEscape(dateEnv.format(dayDate, altFormat)) // inner HTML
      ) : '') + '</td>');
    };

    return ListView;
  }(core.View);

  ListView.prototype.fgSegSelector = '.fc-list-item'; // which elements accept event actions

  function computeDateVars(dateProfile) {
    var dayStart = core.startOfDay(dateProfile.renderRange.start);
    var viewEnd = dateProfile.renderRange.end;
    var dayDates = [];
    var dayRanges = [];

    while (dayStart < viewEnd) {
      dayDates.push(dayStart);
      dayRanges.push({
        start: dayStart,
        end: core.addDays(dayStart, 1)
      });
      dayStart = core.addDays(dayStart, 1);
    }

    return {
      dayDates: dayDates,
      dayRanges: dayRanges
    };
  }

  var main = core.createPlugin({
    views: {
      list: {
        "class": ListView,
        buttonTextKey: 'list',
        listDayFormat: {
          month: 'long',
          day: 'numeric',
          year: 'numeric'
        } // like "January 1, 2016"

      },
      listDay: {
        type: 'list',
        duration: {
          days: 1
        },
        listDayFormat: {
          weekday: 'long'
        } // day-of-week is all we need. full date is probably in header

      },
      listWeek: {
        type: 'list',
        duration: {
          weeks: 1
        },
        listDayFormat: {
          weekday: 'long'
        },
        listDayAltFormat: {
          month: 'long',
          day: 'numeric',
          year: 'numeric'
        }
      },
      listMonth: {
        type: 'list',
        duration: {
          month: 1
        },
        listDayAltFormat: {
          weekday: 'long'
        } // day-of-week is nice-to-have

      },
      listYear: {
        type: 'list',
        duration: {
          year: 1
        },
        listDayAltFormat: {
          weekday: 'long'
        } // day-of-week is nice-to-have

      }
    }
  });
  exports.ListView = ListView;
  exports["default"] = main;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./assets/fullcalendar/timegrid/main.css":
/*!***********************************************!*\
  !*** ./assets/fullcalendar/timegrid/main.css ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./assets/fullcalendar/timegrid/main.js":
/*!**********************************************!*\
  !*** ./assets/fullcalendar/timegrid/main.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__(/*! core-js/modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");

__webpack_require__(/*! core-js/modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");

__webpack_require__(/*! core-js/modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.concat */ "./node_modules/core-js/modules/es.array.concat.js");

__webpack_require__(/*! core-js/modules/es.array.filter */ "./node_modules/core-js/modules/es.array.filter.js");

__webpack_require__(/*! core-js/modules/es.array.for-each */ "./node_modules/core-js/modules/es.array.for-each.js");

__webpack_require__(/*! core-js/modules/es.array.is-array */ "./node_modules/core-js/modules/es.array.is-array.js");

__webpack_require__(/*! core-js/modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.join */ "./node_modules/core-js/modules/es.array.join.js");

__webpack_require__(/*! core-js/modules/es.array.map */ "./node_modules/core-js/modules/es.array.map.js");

__webpack_require__(/*! core-js/modules/es.array.reverse */ "./node_modules/core-js/modules/es.array.reverse.js");

__webpack_require__(/*! core-js/modules/es.array.sort */ "./node_modules/core-js/modules/es.array.sort.js");

__webpack_require__(/*! core-js/modules/es.function.bind */ "./node_modules/core-js/modules/es.function.bind.js");

__webpack_require__(/*! core-js/modules/es.object.assign */ "./node_modules/core-js/modules/es.object.assign.js");

__webpack_require__(/*! core-js/modules/es.object.create */ "./node_modules/core-js/modules/es.object.create.js");

__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.set-prototype-of */ "./node_modules/core-js/modules/es.object.set-prototype-of.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
FullCalendar Time Grid Plugin v4.3.0
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, __webpack_require__(/*! @fullcalendar/core */ "./node_modules/@fullcalendar/core/main.js"), __webpack_require__(/*! @fullcalendar/daygrid */ "./node_modules/@fullcalendar/daygrid/main.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! @fullcalendar/core */ "./node_modules/@fullcalendar/core/main.js"), __webpack_require__(/*! @fullcalendar/daygrid */ "./node_modules/@fullcalendar/daygrid/main.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(this, function (exports, core, daygrid) {
  'use strict';
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
    See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */

  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };
  /*
  Only handles foreground segs.
  Does not own rendering. Use for low-level util methods by TimeGrid.
  */


  var TimeGridEventRenderer =
  /** @class */
  function (_super) {
    __extends(TimeGridEventRenderer, _super);

    function TimeGridEventRenderer(timeGrid) {
      var _this = _super.call(this, timeGrid.context) || this;

      _this.timeGrid = timeGrid;
      _this.fullTimeFormat = core.createFormatter({
        hour: 'numeric',
        minute: '2-digit',
        separator: _this.context.options.defaultRangeSeparator
      });
      return _this;
    } // Given an array of foreground segments, render a DOM element for each, computes position,
    // and attaches to the column inner-container elements.


    TimeGridEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
      var segsByCol = this.timeGrid.groupSegsByCol(segs); // order the segs within each column
      // TODO: have groupSegsByCol do this?

      for (var col = 0; col < segsByCol.length; col++) {
        segsByCol[col] = this.sortEventSegs(segsByCol[col]);
      }

      this.segsByCol = segsByCol;
      this.timeGrid.attachSegsByCol(segsByCol, this.timeGrid.fgContainerEls);
    };

    TimeGridEventRenderer.prototype.detachSegs = function (segs) {
      segs.forEach(function (seg) {
        core.removeElement(seg.el);
      });
      this.segsByCol = null;
    };

    TimeGridEventRenderer.prototype.computeSegSizes = function (allSegs) {
      var _a = this,
          timeGrid = _a.timeGrid,
          segsByCol = _a.segsByCol;

      var colCnt = timeGrid.colCnt;
      timeGrid.computeSegVerticals(allSegs); // horizontals relies on this

      if (segsByCol) {
        for (var col = 0; col < colCnt; col++) {
          this.computeSegHorizontals(segsByCol[col]); // compute horizontal coordinates, z-index's, and reorder the array
        }
      }
    };

    TimeGridEventRenderer.prototype.assignSegSizes = function (allSegs) {
      var _a = this,
          timeGrid = _a.timeGrid,
          segsByCol = _a.segsByCol;

      var colCnt = timeGrid.colCnt;
      timeGrid.assignSegVerticals(allSegs); // horizontals relies on this

      if (segsByCol) {
        for (var col = 0; col < colCnt; col++) {
          this.assignSegCss(segsByCol[col]);
        }
      }
    }; // Computes a default event time formatting string if `eventTimeFormat` is not explicitly defined


    TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {
      return {
        hour: 'numeric',
        minute: '2-digit',
        meridiem: false
      };
    }; // Computes a default `displayEventEnd` value if one is not expliclty defined


    TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {
      return true;
    }; // Renders the HTML for a single event segment's default rendering


    TimeGridEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {
      var view = this.context.view;
      var eventRange = seg.eventRange;
      var eventDef = eventRange.def;
      var eventUi = eventRange.ui;
      var allDay = eventDef.allDay;
      var isDraggable = view.computeEventDraggable(eventDef, eventUi);
      var isResizableFromStart = seg.isStart && view.computeEventStartResizable(eventDef, eventUi);
      var isResizableFromEnd = seg.isEnd && view.computeEventEndResizable(eventDef, eventUi);
      var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);
      var skinCss = core.cssToStr(this.getSkinCss(eventUi));
      var timeText;
      var fullTimeText; // more verbose time text. for the print stylesheet

      var startTimeText; // just the start time text

      classes.unshift('fc-time-grid-event'); // if the event appears to span more than one day...

      if (core.isMultiDayRange(eventRange.range)) {
        // Don't display time text on segments that run entirely through a day.
        // That would appear as midnight-midnight and would look dumb.
        // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
        if (seg.isStart || seg.isEnd) {
          var unzonedStart = seg.start;
          var unzonedEnd = seg.end;
          timeText = this._getTimeText(unzonedStart, unzonedEnd, allDay); // TODO: give the timezones

          fullTimeText = this._getTimeText(unzonedStart, unzonedEnd, allDay, this.fullTimeFormat);
          startTimeText = this._getTimeText(unzonedStart, unzonedEnd, allDay, null, false); // displayEnd=false
        }
      } else {
        // Display the normal time text for the *event's* times
        timeText = this.getTimeText(eventRange);
        fullTimeText = this.getTimeText(eventRange, this.fullTimeFormat);
        startTimeText = this.getTimeText(eventRange, null, false); // displayEnd=false
      }

      return '<a class="' + classes.join(' ') + '"' + (eventDef.url ? ' href="' + core.htmlEscape(eventDef.url) + '"' : '') + (skinCss ? ' style="' + skinCss + '"' : '') + '>' + '<div class="fc-content">' + (timeText ? '<div class="fc-time"' + ' data-start="' + core.htmlEscape(startTimeText) + '"' + ' data-full="' + core.htmlEscape(fullTimeText) + '"' + '>' + '<span>' + core.htmlEscape(timeText) + '</span>' + '</div>' : '') + (eventDef.title ? '<div class="fc-title">' + core.htmlEscape(eventDef.title) + '</div>' : '') + '</div>' + (
      /* TODO: write CSS for this
      (isResizableFromStart ?
        '<div class="fc-resizer fc-start-resizer"></div>' :
        ''
        ) +
      */
      isResizableFromEnd ? '<div class="fc-resizer fc-end-resizer"></div>' : '') + '</a>';
    }; // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
    // Assumed the segs are already ordered.
    // NOTE: Also reorders the given array by date!


    TimeGridEventRenderer.prototype.computeSegHorizontals = function (segs) {
      var levels;
      var level0;
      var i;
      levels = buildSlotSegLevels(segs);
      computeForwardSlotSegs(levels);

      if (level0 = levels[0]) {
        for (i = 0; i < level0.length; i++) {
          computeSlotSegPressures(level0[i]);
        }

        for (i = 0; i < level0.length; i++) {
          this.computeSegForwardBack(level0[i], 0, 0);
        }
      }
    }; // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
    // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
    // seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
    //
    // The segment might be part of a "series", which means consecutive segments with the same pressure
    // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
    // segments behind this one in the current series, and `seriesBackwardCoord` is the starting
    // coordinate of the first segment in the series.


    TimeGridEventRenderer.prototype.computeSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {
      var forwardSegs = seg.forwardSegs;
      var i;

      if (seg.forwardCoord === undefined) {
        // not already computed
        if (!forwardSegs.length) {
          // if there are no forward segments, this segment should butt up against the edge
          seg.forwardCoord = 1;
        } else {
          // sort highest pressure first
          this.sortForwardSegs(forwardSegs); // this segment's forwardCoord will be calculated from the backwardCoord of the
          // highest-pressure forward segment.

          this.computeSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
          seg.forwardCoord = forwardSegs[0].backwardCoord;
        } // calculate the backwardCoord from the forwardCoord. consider the series


        seg.backwardCoord = seg.forwardCoord - (seg.forwardCoord - seriesBackwardCoord) / ( // available width for series
        seriesBackwardPressure + 1); // # of segments in the series
        // use this segment's coordinates to computed the coordinates of the less-pressurized
        // forward segments

        for (i = 0; i < forwardSegs.length; i++) {
          this.computeSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
        }
      }
    };

    TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {
      var objs = forwardSegs.map(buildTimeGridSegCompareObj);
      var specs = [// put higher-pressure first
      {
        field: 'forwardPressure',
        order: -1
      }, // put segments that are closer to initial edge first (and favor ones with no coords yet)
      {
        field: 'backwardCoord',
        order: 1
      }].concat(this.context.view.eventOrderSpecs);
      objs.sort(function (obj0, obj1) {
        return core.compareByFieldSpecs(obj0, obj1, specs);
      });
      return objs.map(function (c) {
        return c._seg;
      });
    }; // Given foreground event segments that have already had their position coordinates computed,
    // assigns position-related CSS values to their elements.


    TimeGridEventRenderer.prototype.assignSegCss = function (segs) {
      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
        var seg = segs_1[_i];
        core.applyStyle(seg.el, this.generateSegCss(seg));

        if (seg.level > 0) {
          seg.el.classList.add('fc-time-grid-event-inset');
        } // if the event is short that the title will be cut off,
        // attach a className that condenses the title into the time area.


        if (seg.eventRange.def.title && seg.bottom - seg.top < 30) {
          seg.el.classList.add('fc-short'); // TODO: "condensed" is a better name
        }
      }
    }; // Generates an object with CSS properties/values that should be applied to an event segment element.
    // Contains important positioning-related properties that should be applied to any event element, customized or not.


    TimeGridEventRenderer.prototype.generateSegCss = function (seg) {
      var shouldOverlap = this.context.options.slotEventOverlap;
      var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point

      var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point

      var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first

      var isRtl = this.timeGrid.isRtl;
      var left; // amount of space from left edge, a fraction of the total width

      var right; // amount of space from right edge, a fraction of the total width

      if (shouldOverlap) {
        // double the width, but don't go beyond the maximum forward coordinate (1.0)
        forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
      }

      if (isRtl) {
        left = 1 - forwardCoord;
        right = backwardCoord;
      } else {
        left = backwardCoord;
        right = 1 - forwardCoord;
      }

      props.zIndex = seg.level + 1; // convert from 0-base to 1-based

      props.left = left * 100 + '%';
      props.right = right * 100 + '%';

      if (shouldOverlap && seg.forwardPressure) {
        // add padding to the edge so that forward stacked events don't cover the resizer's icon
        props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
      }

      return props;
    };

    return TimeGridEventRenderer;
  }(core.FgEventRenderer); // Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
  // left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.


  function buildSlotSegLevels(segs) {
    var levels = [];
    var i;
    var seg;
    var j;

    for (i = 0; i < segs.length; i++) {
      seg = segs[i]; // go through all the levels and stop on the first level where there are no collisions

      for (j = 0; j < levels.length; j++) {
        if (!computeSlotSegCollisions(seg, levels[j]).length) {
          break;
        }
      }

      seg.level = j;
      (levels[j] || (levels[j] = [])).push(seg);
    }

    return levels;
  } // For every segment, figure out the other segments that are in subsequent
  // levels that also occupy the same vertical space. Accumulate in seg.forwardSegs


  function computeForwardSlotSegs(levels) {
    var i;
    var level;
    var j;
    var seg;
    var k;

    for (i = 0; i < levels.length; i++) {
      level = levels[i];

      for (j = 0; j < level.length; j++) {
        seg = level[j];
        seg.forwardSegs = [];

        for (k = i + 1; k < levels.length; k++) {
          computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
        }
      }
    }
  } // Figure out which path forward (via seg.forwardSegs) results in the longest path until
  // the furthest edge is reached. The number of segments in this path will be seg.forwardPressure


  function computeSlotSegPressures(seg) {
    var forwardSegs = seg.forwardSegs;
    var forwardPressure = 0;
    var i;
    var forwardSeg;

    if (seg.forwardPressure === undefined) {
      // not already computed
      for (i = 0; i < forwardSegs.length; i++) {
        forwardSeg = forwardSegs[i]; // figure out the child's maximum forward path

        computeSlotSegPressures(forwardSeg); // either use the existing maximum, or use the child's forward pressure
        // plus one (for the forwardSeg itself)

        forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);
      }

      seg.forwardPressure = forwardPressure;
    }
  } // Find all the segments in `otherSegs` that vertically collide with `seg`.
  // Append into an optionally-supplied `results` array and return.


  function computeSlotSegCollisions(seg, otherSegs, results) {
    if (results === void 0) {
      results = [];
    }

    for (var i = 0; i < otherSegs.length; i++) {
      if (isSlotSegCollision(seg, otherSegs[i])) {
        results.push(otherSegs[i]);
      }
    }

    return results;
  } // Do these segments occupy the same vertical space?


  function isSlotSegCollision(seg1, seg2) {
    return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
  }

  function buildTimeGridSegCompareObj(seg) {
    var obj = core.buildSegCompareObj(seg);
    obj.forwardPressure = seg.forwardPressure;
    obj.backwardCoord = seg.backwardCoord;
    return obj;
  }

  var TimeGridMirrorRenderer =
  /** @class */
  function (_super) {
    __extends(TimeGridMirrorRenderer, _super);

    function TimeGridMirrorRenderer() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    TimeGridMirrorRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
      this.segsByCol = this.timeGrid.groupSegsByCol(segs);
      this.timeGrid.attachSegsByCol(this.segsByCol, this.timeGrid.mirrorContainerEls);
      this.sourceSeg = mirrorInfo.sourceSeg;
    };

    TimeGridMirrorRenderer.prototype.generateSegCss = function (seg) {
      var props = _super.prototype.generateSegCss.call(this, seg);

      var sourceSeg = this.sourceSeg;

      if (sourceSeg && sourceSeg.col === seg.col) {
        var sourceSegProps = _super.prototype.generateSegCss.call(this, sourceSeg);

        props.left = sourceSegProps.left;
        props.right = sourceSegProps.right;
        props.marginLeft = sourceSegProps.marginLeft;
        props.marginRight = sourceSegProps.marginRight;
      }

      return props;
    };

    return TimeGridMirrorRenderer;
  }(TimeGridEventRenderer);

  var TimeGridFillRenderer =
  /** @class */
  function (_super) {
    __extends(TimeGridFillRenderer, _super);

    function TimeGridFillRenderer(timeGrid) {
      var _this = _super.call(this, timeGrid.context) || this;

      _this.timeGrid = timeGrid;
      return _this;
    }

    TimeGridFillRenderer.prototype.attachSegs = function (type, segs) {
      var timeGrid = this.timeGrid;
      var containerEls; // TODO: more efficient lookup

      if (type === 'bgEvent') {
        containerEls = timeGrid.bgContainerEls;
      } else if (type === 'businessHours') {
        containerEls = timeGrid.businessContainerEls;
      } else if (type === 'highlight') {
        containerEls = timeGrid.highlightContainerEls;
      }

      timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);
      return segs.map(function (seg) {
        return seg.el;
      });
    };

    TimeGridFillRenderer.prototype.computeSegSizes = function (segs) {
      this.timeGrid.computeSegVerticals(segs);
    };

    TimeGridFillRenderer.prototype.assignSegSizes = function (segs) {
      this.timeGrid.assignSegVerticals(segs);
    };

    return TimeGridFillRenderer;
  }(core.FillRenderer);
  /* A component that renders one or more columns of vertical time slots
  ----------------------------------------------------------------------------------------------------------------------*/
  // potential nice values for the slot-duration and interval-duration
  // from largest to smallest


  var AGENDA_STOCK_SUB_DURATIONS = [{
    hours: 1
  }, {
    minutes: 30
  }, {
    minutes: 15
  }, {
    seconds: 30
  }, {
    seconds: 15
  }];

  var TimeGrid =
  /** @class */
  function (_super) {
    __extends(TimeGrid, _super);

    function TimeGrid(context, el, renderProps) {
      var _this = _super.call(this, context, el) || this;

      _this.isSlatSizesDirty = false;
      _this.isColSizesDirty = false;
      _this.renderSlats = core.memoizeRendering(_this._renderSlats);
      var eventRenderer = _this.eventRenderer = new TimeGridEventRenderer(_this);
      var fillRenderer = _this.fillRenderer = new TimeGridFillRenderer(_this);
      _this.mirrorRenderer = new TimeGridMirrorRenderer(_this);
      var renderColumns = _this.renderColumns = core.memoizeRendering(_this._renderColumns, _this._unrenderColumns);
      _this.renderBusinessHours = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'), [renderColumns]);
      _this.renderDateSelection = core.memoizeRendering(_this._renderDateSelection, _this._unrenderDateSelection, [renderColumns]);
      _this.renderFgEvents = core.memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderColumns]);
      _this.renderBgEvents = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'), [renderColumns]);
      _this.renderEventSelection = core.memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);
      _this.renderEventDrag = core.memoizeRendering(_this._renderEventDrag, _this._unrenderEventDrag, [renderColumns]);
      _this.renderEventResize = core.memoizeRendering(_this._renderEventResize, _this._unrenderEventResize, [renderColumns]);

      _this.processOptions();

      el.innerHTML = '<div class="fc-bg"></div>' + '<div class="fc-slats"></div>' + '<hr class="fc-divider ' + _this.theme.getClass('widgetHeader') + '" style="display:none" />';
      _this.rootBgContainerEl = el.querySelector('.fc-bg');
      _this.slatContainerEl = el.querySelector('.fc-slats');
      _this.bottomRuleEl = el.querySelector('.fc-divider');
      _this.renderProps = renderProps;
      return _this;
    }
    /* Options
    ------------------------------------------------------------------------------------------------------------------*/
    // Parses various options into properties of this object


    TimeGrid.prototype.processOptions = function () {
      var slotDuration = this.opt('slotDuration');
      var snapDuration = this.opt('snapDuration');
      var snapsPerSlot;
      var input;
      slotDuration = core.createDuration(slotDuration);
      snapDuration = snapDuration ? core.createDuration(snapDuration) : slotDuration;
      snapsPerSlot = core.wholeDivideDurations(slotDuration, snapDuration);

      if (snapsPerSlot === null) {
        snapDuration = slotDuration;
        snapsPerSlot = 1; // TODO: say warning?
      }

      this.slotDuration = slotDuration;
      this.snapDuration = snapDuration;
      this.snapsPerSlot = snapsPerSlot; // might be an array value (for TimelineView).
      // if so, getting the most granular entry (the last one probably).

      input = this.opt('slotLabelFormat');

      if (Array.isArray(input)) {
        input = input[input.length - 1];
      }

      this.labelFormat = core.createFormatter(input || {
        hour: 'numeric',
        minute: '2-digit',
        omitZeroMinute: true,
        meridiem: 'short'
      });
      input = this.opt('slotLabelInterval');
      this.labelInterval = input ? core.createDuration(input) : this.computeLabelInterval(slotDuration);
    }; // Computes an automatic value for slotLabelInterval


    TimeGrid.prototype.computeLabelInterval = function (slotDuration) {
      var i;
      var labelInterval;
      var slotsPerLabel; // find the smallest stock label interval that results in more than one slots-per-label

      for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
        labelInterval = core.createDuration(AGENDA_STOCK_SUB_DURATIONS[i]);
        slotsPerLabel = core.wholeDivideDurations(labelInterval, slotDuration);

        if (slotsPerLabel !== null && slotsPerLabel > 1) {
          return labelInterval;
        }
      }

      return slotDuration; // fall back
    };
    /* Rendering
    ------------------------------------------------------------------------------------------------------------------*/


    TimeGrid.prototype.render = function (props) {
      var cells = props.cells;
      this.colCnt = cells.length;
      this.renderSlats(props.dateProfile);
      this.renderColumns(props.cells, props.dateProfile);
      this.renderBusinessHours(props.businessHourSegs);
      this.renderDateSelection(props.dateSelectionSegs);
      this.renderFgEvents(props.fgEventSegs);
      this.renderBgEvents(props.bgEventSegs);
      this.renderEventSelection(props.eventSelection);
      this.renderEventDrag(props.eventDrag);
      this.renderEventResize(props.eventResize);
    };

    TimeGrid.prototype.destroy = function () {
      _super.prototype.destroy.call(this); // should unrender everything else too


      this.renderSlats.unrender();
      this.renderColumns.unrender();
    };

    TimeGrid.prototype.updateSize = function (isResize) {
      var _a = this,
          fillRenderer = _a.fillRenderer,
          eventRenderer = _a.eventRenderer,
          mirrorRenderer = _a.mirrorRenderer;

      if (isResize || this.isSlatSizesDirty) {
        this.buildSlatPositions();
        this.isSlatSizesDirty = false;
      }

      if (isResize || this.isColSizesDirty) {
        this.buildColPositions();
        this.isColSizesDirty = false;
      }

      fillRenderer.computeSizes(isResize);
      eventRenderer.computeSizes(isResize);
      mirrorRenderer.computeSizes(isResize);
      fillRenderer.assignSizes(isResize);
      eventRenderer.assignSizes(isResize);
      mirrorRenderer.assignSizes(isResize);
    };

    TimeGrid.prototype._renderSlats = function (dateProfile) {
      var theme = this.theme;
      this.slatContainerEl.innerHTML = '<table class="' + theme.getClass('tableGrid') + '">' + this.renderSlatRowHtml(dateProfile) + '</table>';
      this.slatEls = core.findElements(this.slatContainerEl, 'tr');
      this.slatPositions = new core.PositionCache(this.el, this.slatEls, false, true // vertical
      );
      this.isSlatSizesDirty = true;
    }; // Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.


    TimeGrid.prototype.renderSlatRowHtml = function (dateProfile) {
      var _a = this,
          dateEnv = _a.dateEnv,
          theme = _a.theme,
          isRtl = _a.isRtl;

      var html = '';
      var dayStart = core.startOfDay(dateProfile.renderRange.start);
      var slotTime = dateProfile.minTime;
      var slotIterator = core.createDuration(0);
      var slotDate; // will be on the view's first day, but we only care about its time

      var isLabeled;
      var axisHtml; // Calculate the time for each slot

      while (core.asRoughMs(slotTime) < core.asRoughMs(dateProfile.maxTime)) {
        slotDate = dateEnv.add(dayStart, slotTime);
        isLabeled = core.wholeDivideDurations(slotIterator, this.labelInterval) !== null;
        axisHtml = '<td class="fc-axis fc-time ' + theme.getClass('widgetContent') + '">' + (isLabeled ? '<span>' + // for matchCellWidths
        core.htmlEscape(dateEnv.format(slotDate, this.labelFormat)) + '</span>' : '') + '</td>';
        html += '<tr data-time="' + core.formatIsoTimeString(slotDate) + '"' + (isLabeled ? '' : ' class="fc-minor"') + '>' + (!isRtl ? axisHtml : '') + '<td class="' + theme.getClass('widgetContent') + '"></td>' + (isRtl ? axisHtml : '') + '</tr>';
        slotTime = core.addDurations(slotTime, this.slotDuration);
        slotIterator = core.addDurations(slotIterator, this.slotDuration);
      }

      return html;
    };

    TimeGrid.prototype._renderColumns = function (cells, dateProfile) {
      var _a = this,
          theme = _a.theme,
          dateEnv = _a.dateEnv,
          view = _a.view;

      var bgRow = new daygrid.DayBgRow(this.context);
      this.rootBgContainerEl.innerHTML = '<table class="' + theme.getClass('tableGrid') + '">' + bgRow.renderHtml({
        cells: cells,
        dateProfile: dateProfile,
        renderIntroHtml: this.renderProps.renderBgIntroHtml
      }) + '</table>';
      this.colEls = core.findElements(this.el, '.fc-day, .fc-disabled-day');

      for (var col = 0; col < this.colCnt; col++) {
        this.publiclyTrigger('dayRender', [{
          date: dateEnv.toDate(cells[col].date),
          el: this.colEls[col],
          view: view
        }]);
      }

      if (this.isRtl) {
        this.colEls.reverse();
      }

      this.colPositions = new core.PositionCache(this.el, this.colEls, true, // horizontal
      false);
      this.renderContentSkeleton();
      this.isColSizesDirty = true;
    };

    TimeGrid.prototype._unrenderColumns = function () {
      this.unrenderContentSkeleton();
    };
    /* Content Skeleton
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders the DOM that the view's content will live in


    TimeGrid.prototype.renderContentSkeleton = function () {
      var parts = [];
      var skeletonEl;
      parts.push(this.renderProps.renderIntroHtml());

      for (var i = 0; i < this.colCnt; i++) {
        parts.push('<td>' + '<div class="fc-content-col">' + '<div class="fc-event-container fc-mirror-container"></div>' + '<div class="fc-event-container"></div>' + '<div class="fc-highlight-container"></div>' + '<div class="fc-bgevent-container"></div>' + '<div class="fc-business-container"></div>' + '</div>' + '</td>');
      }

      if (this.isRtl) {
        parts.reverse();
      }

      skeletonEl = this.contentSkeletonEl = core.htmlToElement('<div class="fc-content-skeleton">' + '<table>' + '<tr>' + parts.join('') + '</tr>' + '</table>' + '</div>');
      this.colContainerEls = core.findElements(skeletonEl, '.fc-content-col');
      this.mirrorContainerEls = core.findElements(skeletonEl, '.fc-mirror-container');
      this.fgContainerEls = core.findElements(skeletonEl, '.fc-event-container:not(.fc-mirror-container)');
      this.bgContainerEls = core.findElements(skeletonEl, '.fc-bgevent-container');
      this.highlightContainerEls = core.findElements(skeletonEl, '.fc-highlight-container');
      this.businessContainerEls = core.findElements(skeletonEl, '.fc-business-container');

      if (this.isRtl) {
        this.colContainerEls.reverse();
        this.mirrorContainerEls.reverse();
        this.fgContainerEls.reverse();
        this.bgContainerEls.reverse();
        this.highlightContainerEls.reverse();
        this.businessContainerEls.reverse();
      }

      this.el.appendChild(skeletonEl);
    };

    TimeGrid.prototype.unrenderContentSkeleton = function () {
      core.removeElement(this.contentSkeletonEl);
    }; // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col


    TimeGrid.prototype.groupSegsByCol = function (segs) {
      var segsByCol = [];
      var i;

      for (i = 0; i < this.colCnt; i++) {
        segsByCol.push([]);
      }

      for (i = 0; i < segs.length; i++) {
        segsByCol[segs[i].col].push(segs[i]);
      }

      return segsByCol;
    }; // Given segments grouped by column, insert the segments' elements into a parallel array of container
    // elements, each living within a column.


    TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {
      var col;
      var segs;
      var i;

      for (col = 0; col < this.colCnt; col++) {
        // iterate each column grouping
        segs = segsByCol[col];

        for (i = 0; i < segs.length; i++) {
          containerEls[col].appendChild(segs[i].el);
        }
      }
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/


    TimeGrid.prototype.getNowIndicatorUnit = function () {
      return 'minute'; // will refresh on the minute
    };

    TimeGrid.prototype.renderNowIndicator = function (segs, date) {
      // HACK: if date columns not ready for some reason (scheduler)
      if (!this.colContainerEls) {
        return;
      }

      var top = this.computeDateTop(date);
      var nodes = [];
      var i; // render lines within the columns

      for (i = 0; i < segs.length; i++) {
        var lineEl = core.createElement('div', {
          className: 'fc-now-indicator fc-now-indicator-line'
        });
        lineEl.style.top = top + 'px';
        this.colContainerEls[segs[i].col].appendChild(lineEl);
        nodes.push(lineEl);
      } // render an arrow over the axis


      if (segs.length > 0) {
        // is the current time in view?
        var arrowEl = core.createElement('div', {
          className: 'fc-now-indicator fc-now-indicator-arrow'
        });
        arrowEl.style.top = top + 'px';
        this.contentSkeletonEl.appendChild(arrowEl);
        nodes.push(arrowEl);
      }

      this.nowIndicatorEls = nodes;
    };

    TimeGrid.prototype.unrenderNowIndicator = function () {
      if (this.nowIndicatorEls) {
        this.nowIndicatorEls.forEach(core.removeElement);
        this.nowIndicatorEls = null;
      }
    };
    /* Coordinates
    ------------------------------------------------------------------------------------------------------------------*/


    TimeGrid.prototype.getTotalSlatHeight = function () {
      return this.slatContainerEl.getBoundingClientRect().height;
    }; // Computes the top coordinate, relative to the bounds of the grid, of the given date.
    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.


    TimeGrid.prototype.computeDateTop = function (when, startOfDayDate) {
      if (!startOfDayDate) {
        startOfDayDate = core.startOfDay(when);
      }

      return this.computeTimeTop(core.createDuration(when.valueOf() - startOfDayDate.valueOf()));
    }; // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).


    TimeGrid.prototype.computeTimeTop = function (duration) {
      var len = this.slatEls.length;
      var dateProfile = this.props.dateProfile;
      var slatCoverage = (duration.milliseconds - core.asRoughMs(dateProfile.minTime)) / core.asRoughMs(this.slotDuration); // floating-point value of # of slots covered

      var slatIndex;
      var slatRemainder; // compute a floating-point number for how many slats should be progressed through.
      // from 0 to number of slats (inclusive)
      // constrained because minTime/maxTime might be customized.

      slatCoverage = Math.max(0, slatCoverage);
      slatCoverage = Math.min(len, slatCoverage); // an integer index of the furthest whole slat
      // from 0 to number slats (*exclusive*, so len-1)

      slatIndex = Math.floor(slatCoverage);
      slatIndex = Math.min(slatIndex, len - 1); // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
      // could be 1.0 if slatCoverage is covering *all* the slots

      slatRemainder = slatCoverage - slatIndex;
      return this.slatPositions.tops[slatIndex] + this.slatPositions.getHeight(slatIndex) * slatRemainder;
    }; // For each segment in an array, computes and assigns its top and bottom properties


    TimeGrid.prototype.computeSegVerticals = function (segs) {
      var eventMinHeight = this.opt('timeGridEventMinHeight');
      var i;
      var seg;
      var dayDate;

      for (i = 0; i < segs.length; i++) {
        seg = segs[i];
        dayDate = this.props.cells[seg.col].date;
        seg.top = this.computeDateTop(seg.start, dayDate);
        seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.end, dayDate));
      }
    }; // Given segments that already have their top/bottom properties computed, applies those values to
    // the segments' elements.


    TimeGrid.prototype.assignSegVerticals = function (segs) {
      var i;
      var seg;

      for (i = 0; i < segs.length; i++) {
        seg = segs[i];
        core.applyStyle(seg.el, this.generateSegVerticalCss(seg));
      }
    }; // Generates an object with CSS properties for the top/bottom coordinates of a segment element


    TimeGrid.prototype.generateSegVerticalCss = function (seg) {
      return {
        top: seg.top,
        bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container

      };
    };
    /* Sizing
    ------------------------------------------------------------------------------------------------------------------*/


    TimeGrid.prototype.buildPositionCaches = function () {
      this.buildColPositions();
      this.buildSlatPositions();
    };

    TimeGrid.prototype.buildColPositions = function () {
      this.colPositions.build();
    };

    TimeGrid.prototype.buildSlatPositions = function () {
      this.slatPositions.build();
    };
    /* Hit System
    ------------------------------------------------------------------------------------------------------------------*/


    TimeGrid.prototype.positionToHit = function (positionLeft, positionTop) {
      var _a = this,
          dateEnv = _a.dateEnv,
          snapsPerSlot = _a.snapsPerSlot,
          slatPositions = _a.slatPositions,
          colPositions = _a.colPositions;

      var colIndex = colPositions.leftToIndex(positionLeft);
      var slatIndex = slatPositions.topToIndex(positionTop);

      if (colIndex != null && slatIndex != null) {
        var slatTop = slatPositions.tops[slatIndex];
        var slatHeight = slatPositions.getHeight(slatIndex);
        var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1

        var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat

        var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
        var dayDate = this.props.cells[colIndex].date;
        var time = core.addDurations(this.props.dateProfile.minTime, core.multiplyDuration(this.snapDuration, snapIndex));
        var start = dateEnv.add(dayDate, time);
        var end = dateEnv.add(start, this.snapDuration);
        return {
          col: colIndex,
          dateSpan: {
            range: {
              start: start,
              end: end
            },
            allDay: false
          },
          dayEl: this.colEls[colIndex],
          relativeRect: {
            left: colPositions.lefts[colIndex],
            right: colPositions.rights[colIndex],
            top: slatTop,
            bottom: slatTop + slatHeight
          }
        };
      }
    };
    /* Event Drag Visualization
    ------------------------------------------------------------------------------------------------------------------*/


    TimeGrid.prototype._renderEventDrag = function (state) {
      if (state) {
        this.eventRenderer.hideByHash(state.affectedInstances);

        if (state.isEvent) {
          this.mirrorRenderer.renderSegs(state.segs, {
            isDragging: true,
            sourceSeg: state.sourceSeg
          });
        } else {
          this.fillRenderer.renderSegs('highlight', state.segs);
        }
      }
    };

    TimeGrid.prototype._unrenderEventDrag = function (state) {
      if (state) {
        this.eventRenderer.showByHash(state.affectedInstances);
        this.mirrorRenderer.unrender(state.segs, {
          isDragging: true,
          sourceSeg: state.sourceSeg
        });
        this.fillRenderer.unrender('highlight');
      }
    };
    /* Event Resize Visualization
    ------------------------------------------------------------------------------------------------------------------*/


    TimeGrid.prototype._renderEventResize = function (state) {
      if (state) {
        this.eventRenderer.hideByHash(state.affectedInstances);
        this.mirrorRenderer.renderSegs(state.segs, {
          isResizing: true,
          sourceSeg: state.sourceSeg
        });
      }
    };

    TimeGrid.prototype._unrenderEventResize = function (state) {
      if (state) {
        this.eventRenderer.showByHash(state.affectedInstances);
        this.mirrorRenderer.unrender(state.segs, {
          isResizing: true,
          sourceSeg: state.sourceSeg
        });
      }
    };
    /* Selection
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.


    TimeGrid.prototype._renderDateSelection = function (segs) {
      if (segs) {
        if (this.opt('selectMirror')) {
          this.mirrorRenderer.renderSegs(segs, {
            isSelecting: true
          });
        } else {
          this.fillRenderer.renderSegs('highlight', segs);
        }
      }
    };

    TimeGrid.prototype._unrenderDateSelection = function (segs) {
      this.mirrorRenderer.unrender(segs, {
        isSelecting: true
      });
      this.fillRenderer.unrender('highlight');
    };

    return TimeGrid;
  }(core.DateComponent);

  var AllDaySplitter =
  /** @class */
  function (_super) {
    __extends(AllDaySplitter, _super);

    function AllDaySplitter() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    AllDaySplitter.prototype.getKeyInfo = function () {
      return {
        allDay: {},
        timed: {}
      };
    };

    AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {
      if (dateSpan.allDay) {
        return ['allDay'];
      } else {
        return ['timed'];
      }
    };

    AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {
      if (!eventDef.allDay) {
        return ['timed'];
      } else if (core.hasBgRendering(eventDef)) {
        return ['timed', 'allDay'];
      } else {
        return ['allDay'];
      }
    };

    return AllDaySplitter;
  }(core.Splitter);

  var TIMEGRID_ALL_DAY_EVENT_LIMIT = 5;
  var WEEK_HEADER_FORMAT = core.createFormatter({
    week: 'short'
  });
  /* An abstract class for all timegrid-related views. Displays one more columns with time slots running vertically.
  ----------------------------------------------------------------------------------------------------------------------*/
  // Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
  // Responsible for managing width/height.

  var TimeGridView =
  /** @class */
  function (_super) {
    __extends(TimeGridView, _super);

    function TimeGridView(context, viewSpec, dateProfileGenerator, parentEl) {
      var _this = _super.call(this, context, viewSpec, dateProfileGenerator, parentEl) || this;

      _this.splitter = new AllDaySplitter();
      /* Header Render Methods
      ------------------------------------------------------------------------------------------------------------------*/
      // Generates the HTML that will go before the day-of week header cells

      _this.renderHeadIntroHtml = function () {
        var _a = _this,
            theme = _a.theme,
            dateEnv = _a.dateEnv;
        var range = _this.props.dateProfile.renderRange;
        var dayCnt = core.diffDays(range.start, range.end);
        var weekText;

        if (_this.opt('weekNumbers')) {
          weekText = dateEnv.format(range.start, WEEK_HEADER_FORMAT);
          return '' + '<th class="fc-axis fc-week-number ' + theme.getClass('widgetHeader') + '" ' + _this.axisStyleAttr() + '>' + core.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
          _this, {
            date: range.start,
            type: 'week',
            forceOff: dayCnt > 1
          }, core.htmlEscape(weekText) // inner HTML
          ) + '</th>';
        } else {
          return '<th class="fc-axis ' + theme.getClass('widgetHeader') + '" ' + _this.axisStyleAttr() + '></th>';
        }
      };
      /* Time Grid Render Methods
      ------------------------------------------------------------------------------------------------------------------*/
      // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.


      _this.renderTimeGridBgIntroHtml = function () {
        var theme = _this.theme;
        return '<td class="fc-axis ' + theme.getClass('widgetContent') + '" ' + _this.axisStyleAttr() + '></td>';
      }; // Generates the HTML that goes before all other types of cells.
      // Affects content-skeleton, mirror-skeleton, highlight-skeleton for both the time-grid and day-grid.


      _this.renderTimeGridIntroHtml = function () {
        return '<td class="fc-axis" ' + _this.axisStyleAttr() + '></td>';
      };
      /* Day Grid Render Methods
      ------------------------------------------------------------------------------------------------------------------*/
      // Generates the HTML that goes before the all-day cells


      _this.renderDayGridBgIntroHtml = function () {
        var theme = _this.theme;
        return '' + '<td class="fc-axis ' + theme.getClass('widgetContent') + '" ' + _this.axisStyleAttr() + '>' + '<span>' + // needed for matchCellWidths
        core.getAllDayHtml(_this) + '</span>' + '</td>';
      }; // Generates the HTML that goes before all other types of cells.
      // Affects content-skeleton, mirror-skeleton, highlight-skeleton for both the time-grid and day-grid.


      _this.renderDayGridIntroHtml = function () {
        return '<td class="fc-axis" ' + _this.axisStyleAttr() + '></td>';
      };

      _this.el.classList.add('fc-timeGrid-view');

      _this.el.innerHTML = _this.renderSkeletonHtml();
      _this.scroller = new core.ScrollComponent('hidden', // overflow x
      'auto' // overflow y
      );
      var timeGridWrapEl = _this.scroller.el;

      _this.el.querySelector('.fc-body > tr > td').appendChild(timeGridWrapEl);

      timeGridWrapEl.classList.add('fc-time-grid-container');
      var timeGridEl = core.createElement('div', {
        className: 'fc-time-grid'
      });
      timeGridWrapEl.appendChild(timeGridEl);
      _this.timeGrid = new TimeGrid(_this.context, timeGridEl, {
        renderBgIntroHtml: _this.renderTimeGridBgIntroHtml,
        renderIntroHtml: _this.renderTimeGridIntroHtml
      });

      if (_this.opt('allDaySlot')) {
        // should we display the "all-day" area?
        _this.dayGrid = new daygrid.DayGrid( // the all-day subcomponent of this view
        _this.context, _this.el.querySelector('.fc-day-grid'), {
          renderNumberIntroHtml: _this.renderDayGridIntroHtml,
          renderBgIntroHtml: _this.renderDayGridBgIntroHtml,
          renderIntroHtml: _this.renderDayGridIntroHtml,
          colWeekNumbersVisible: false,
          cellWeekNumbersVisible: false
        }); // have the day-grid extend it's coordinate area over the <hr> dividing the two grids

        var dividerEl = _this.el.querySelector('.fc-divider');

        _this.dayGrid.bottomCoordPadding = dividerEl.getBoundingClientRect().height;
      }

      return _this;
    }

    TimeGridView.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      this.timeGrid.destroy();

      if (this.dayGrid) {
        this.dayGrid.destroy();
      }

      this.scroller.destroy();
    };
    /* Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    // Builds the HTML skeleton for the view.
    // The day-grid and time-grid components will render inside containers defined by this HTML.


    TimeGridView.prototype.renderSkeletonHtml = function () {
      var theme = this.theme;
      return '' + '<table class="' + theme.getClass('tableGrid') + '">' + (this.opt('columnHeader') ? '<thead class="fc-head">' + '<tr>' + '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' + '</tr>' + '</thead>' : '') + '<tbody class="fc-body">' + '<tr>' + '<td class="' + theme.getClass('widgetContent') + '">' + (this.opt('allDaySlot') ? '<div class="fc-day-grid"></div>' + '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '" />' : '') + '</td>' + '</tr>' + '</tbody>' + '</table>';
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/


    TimeGridView.prototype.getNowIndicatorUnit = function () {
      return this.timeGrid.getNowIndicatorUnit();
    }; // subclasses should implement
    // renderNowIndicator(date: DateMarker) {
    // }


    TimeGridView.prototype.unrenderNowIndicator = function () {
      this.timeGrid.unrenderNowIndicator();
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/


    TimeGridView.prototype.updateSize = function (isResize, viewHeight, isAuto) {
      _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto); // will call updateBaseSize. important that executes first


      this.timeGrid.updateSize(isResize);

      if (this.dayGrid) {
        this.dayGrid.updateSize(isResize);
      }
    }; // Adjusts the vertical dimensions of the view to the specified values


    TimeGridView.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {
      var _this = this;

      var eventLimit;
      var scrollerHeight;
      var scrollbarWidths; // make all axis cells line up

      this.axisWidth = core.matchCellWidths(core.findElements(this.el, '.fc-axis')); // hack to give the view some height prior to timeGrid's columns being rendered
      // TODO: separate setting height from scroller VS timeGrid.

      if (!this.timeGrid.colEls) {
        if (!isAuto) {
          scrollerHeight = this.computeScrollerHeight(viewHeight);
          this.scroller.setHeight(scrollerHeight);
        }

        return;
      } // set of fake row elements that must compensate when scroller has scrollbars


      var noScrollRowEls = core.findElements(this.el, '.fc-row').filter(function (node) {
        return !_this.scroller.el.contains(node);
      }); // reset all dimensions back to the original state

      this.timeGrid.bottomRuleEl.style.display = 'none'; // will be shown later if this <hr> is necessary

      this.scroller.clear(); // sets height to 'auto' and clears overflow

      noScrollRowEls.forEach(core.uncompensateScroll); // limit number of events in the all-day area

      if (this.dayGrid) {
        this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

        eventLimit = this.opt('eventLimit');

        if (eventLimit && typeof eventLimit !== 'number') {
          eventLimit = TIMEGRID_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
        }

        if (eventLimit) {
          this.dayGrid.limitRows(eventLimit);
        }
      }

      if (!isAuto) {
        // should we force dimensions of the scroll container?
        scrollerHeight = this.computeScrollerHeight(viewHeight);
        this.scroller.setHeight(scrollerHeight);
        scrollbarWidths = this.scroller.getScrollbarWidths();

        if (scrollbarWidths.left || scrollbarWidths.right) {
          // using scrollbars?
          // make the all-day and header rows lines up
          noScrollRowEls.forEach(function (rowEl) {
            core.compensateScroll(rowEl, scrollbarWidths);
          }); // the scrollbar compensation might have changed text flow, which might affect height, so recalculate
          // and reapply the desired height to the scroller.

          scrollerHeight = this.computeScrollerHeight(viewHeight);
          this.scroller.setHeight(scrollerHeight);
        } // guarantees the same scrollbar widths


        this.scroller.lockOverflow(scrollbarWidths); // if there's any space below the slats, show the horizontal rule.
        // this won't cause any new overflow, because lockOverflow already called.

        if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
          this.timeGrid.bottomRuleEl.style.display = '';
        }
      }
    }; // given a desired total height of the view, returns what the height of the scroller should be


    TimeGridView.prototype.computeScrollerHeight = function (viewHeight) {
      return viewHeight - core.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    /* Scroll
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes the initial pre-configured scroll state prior to allowing the user to change it


    TimeGridView.prototype.computeDateScroll = function (duration) {
      var top = this.timeGrid.computeTimeTop(duration); // zoom can give weird floating-point values. rather scroll a little bit further

      top = Math.ceil(top);

      if (top) {
        top++; // to overcome top border that slots beyond the first have. looks better
      }

      return {
        top: top
      };
    };

    TimeGridView.prototype.queryDateScroll = function () {
      return {
        top: this.scroller.getScrollTop()
      };
    };

    TimeGridView.prototype.applyDateScroll = function (scroll) {
      if (scroll.top !== undefined) {
        this.scroller.setScrollTop(scroll.top);
      }
    }; // Generates an HTML attribute string for setting the width of the axis, if it is known


    TimeGridView.prototype.axisStyleAttr = function () {
      if (this.axisWidth != null) {
        return 'style="width:' + this.axisWidth + 'px"';
      }

      return '';
    };

    return TimeGridView;
  }(core.View);

  TimeGridView.prototype.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering

  var SimpleTimeGrid =
  /** @class */
  function (_super) {
    __extends(SimpleTimeGrid, _super);

    function SimpleTimeGrid(context, timeGrid) {
      var _this = _super.call(this, context, timeGrid.el) || this;

      _this.buildDayRanges = core.memoize(buildDayRanges);
      _this.slicer = new TimeGridSlicer();
      _this.timeGrid = timeGrid;
      context.calendar.registerInteractiveComponent(_this, {
        el: _this.timeGrid.el
      });
      return _this;
    }

    SimpleTimeGrid.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      this.calendar.unregisterInteractiveComponent(this);
    };

    SimpleTimeGrid.prototype.render = function (props) {
      var dateProfile = props.dateProfile,
          dayTable = props.dayTable;
      var dayRanges = this.dayRanges = this.buildDayRanges(dayTable, dateProfile, this.dateEnv);
      this.timeGrid.receiveProps(_assign({}, this.slicer.sliceProps(props, dateProfile, null, this.timeGrid, dayRanges), {
        dateProfile: dateProfile,
        cells: dayTable.cells[0]
      }));
    };

    SimpleTimeGrid.prototype.renderNowIndicator = function (date) {
      this.timeGrid.renderNowIndicator(this.slicer.sliceNowDate(date, this.timeGrid, this.dayRanges), date);
    };

    SimpleTimeGrid.prototype.buildPositionCaches = function () {
      this.timeGrid.buildPositionCaches();
    };

    SimpleTimeGrid.prototype.queryHit = function (positionLeft, positionTop) {
      var rawHit = this.timeGrid.positionToHit(positionLeft, positionTop);

      if (rawHit) {
        return {
          component: this.timeGrid,
          dateSpan: rawHit.dateSpan,
          dayEl: rawHit.dayEl,
          rect: {
            left: rawHit.relativeRect.left,
            right: rawHit.relativeRect.right,
            top: rawHit.relativeRect.top,
            bottom: rawHit.relativeRect.bottom
          },
          layer: 0
        };
      }
    };

    return SimpleTimeGrid;
  }(core.DateComponent);

  function buildDayRanges(dayTable, dateProfile, dateEnv) {
    var ranges = [];

    for (var _i = 0, _a = dayTable.headerDates; _i < _a.length; _i++) {
      var date = _a[_i];
      ranges.push({
        start: dateEnv.add(date, dateProfile.minTime),
        end: dateEnv.add(date, dateProfile.maxTime)
      });
    }

    return ranges;
  }

  var TimeGridSlicer =
  /** @class */
  function (_super) {
    __extends(TimeGridSlicer, _super);

    function TimeGridSlicer() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    TimeGridSlicer.prototype.sliceRange = function (range, dayRanges) {
      var segs = [];

      for (var col = 0; col < dayRanges.length; col++) {
        var segRange = core.intersectRanges(range, dayRanges[col]);

        if (segRange) {
          segs.push({
            start: segRange.start,
            end: segRange.end,
            isStart: segRange.start.valueOf() === range.start.valueOf(),
            isEnd: segRange.end.valueOf() === range.end.valueOf(),
            col: col
          });
        }
      }

      return segs;
    };

    return TimeGridSlicer;
  }(core.Slicer);

  var TimeGridView$1 =
  /** @class */
  function (_super) {
    __extends(TimeGridView, _super);

    function TimeGridView(_context, viewSpec, dateProfileGenerator, parentEl) {
      var _this = _super.call(this, _context, viewSpec, dateProfileGenerator, parentEl) || this;

      _this.buildDayTable = core.memoize(buildDayTable);

      if (_this.opt('columnHeader')) {
        _this.header = new core.DayHeader(_this.context, _this.el.querySelector('.fc-head-container'));
      }

      _this.simpleTimeGrid = new SimpleTimeGrid(_this.context, _this.timeGrid);

      if (_this.dayGrid) {
        _this.simpleDayGrid = new daygrid.SimpleDayGrid(_this.context, _this.dayGrid);
      }

      return _this;
    }

    TimeGridView.prototype.destroy = function () {
      _super.prototype.destroy.call(this);

      if (this.header) {
        this.header.destroy();
      }

      this.simpleTimeGrid.destroy();

      if (this.simpleDayGrid) {
        this.simpleDayGrid.destroy();
      }
    };

    TimeGridView.prototype.render = function (props) {
      _super.prototype.render.call(this, props); // for flags for updateSize


      var dateProfile = this.props.dateProfile;
      var dayTable = this.buildDayTable(dateProfile, this.dateProfileGenerator);
      var splitProps = this.splitter.splitProps(props);

      if (this.header) {
        this.header.receiveProps({
          dateProfile: dateProfile,
          dates: dayTable.headerDates,
          datesRepDistinctDays: true,
          renderIntroHtml: this.renderHeadIntroHtml
        });
      }

      this.simpleTimeGrid.receiveProps(_assign({}, splitProps['timed'], {
        dateProfile: dateProfile,
        dayTable: dayTable
      }));

      if (this.simpleDayGrid) {
        this.simpleDayGrid.receiveProps(_assign({}, splitProps['allDay'], {
          dateProfile: dateProfile,
          dayTable: dayTable,
          nextDayThreshold: this.nextDayThreshold,
          isRigid: false
        }));
      }
    };

    TimeGridView.prototype.renderNowIndicator = function (date) {
      this.simpleTimeGrid.renderNowIndicator(date);
    };

    return TimeGridView;
  }(TimeGridView);

  function buildDayTable(dateProfile, dateProfileGenerator) {
    var daySeries = new core.DaySeries(dateProfile.renderRange, dateProfileGenerator);
    return new core.DayTable(daySeries, false);
  }

  var main = core.createPlugin({
    defaultView: 'timeGridWeek',
    views: {
      timeGrid: {
        "class": TimeGridView$1,
        allDaySlot: true,
        slotDuration: '00:30:00',
        slotEventOverlap: true // a bad name. confused with overlap/constraint system

      },
      timeGridDay: {
        type: 'timeGrid',
        duration: {
          days: 1
        }
      },
      timeGridWeek: {
        type: 'timeGrid',
        duration: {
          weeks: 1
        }
      }
    }
  });
  exports.AbstractTimeGridView = TimeGridView;
  exports.TimeGrid = TimeGrid;
  exports.TimeGridSlicer = TimeGridSlicer;
  exports.TimeGridView = TimeGridView$1;
  exports.buildDayRanges = buildDayRanges;
  exports.buildDayTable = buildDayTable;
  exports["default"] = main;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./assets/js/app.js":
/*!**************************!*\
  !*** ./assets/js/app.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css/app.css */ "./assets/css/app.css");
/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_app_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css/bootstrap.min.css */ "./assets/css/bootstrap.min.css");
/* harmony import */ var _css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_2__);
/*
 * Welcome to your app's main JavaScript file!
 *
 * We recommend including the built version of this JavaScript file
 * (and its CSS file) in your base layout (base.html.twig).
 */
// Need jQuery? Install it with "yarn add jquery", then uncomment to import it.
 // any CSS you import will output into a single css file (app.css in this case)




__webpack_require__(/*! ../fullcalendar/core/main.css */ "./assets/fullcalendar/core/main.css");

__webpack_require__(/*! ../fullcalendar/daygrid/main.css */ "./assets/fullcalendar/daygrid/main.css");

__webpack_require__(/*! ../fullcalendar/list/main.css */ "./assets/fullcalendar/list/main.css");

__webpack_require__(/*! ../fullcalendar/timegrid/main.css */ "./assets/fullcalendar/timegrid/main.css");

__webpack_require__(/*! ../fullcalendar/core/main.js */ "./assets/fullcalendar/core/main.js");

__webpack_require__(/*! ../fullcalendar/daygrid/main.js */ "./assets/fullcalendar/daygrid/main.js");

__webpack_require__(/*! ../fullcalendar/interaction/main.js */ "./assets/fullcalendar/interaction/main.js");

__webpack_require__(/*! ../fullcalendar/list/main.js */ "./assets/fullcalendar/list/main.js");

__webpack_require__(/*! ../fullcalendar/timegrid/main.js */ "./assets/fullcalendar/timegrid/main.js");

jquery__WEBPACK_IMPORTED_MODULE_0___default()(".datetimepicker").datetimepicker();
console.log('Hello Webpack Encore! Edit me in assets/js/app.js');

/***/ })

},[["./assets/js/app.js","runtime","vendors~app"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2FwcC5jc3MiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2Nzcy9ib290c3RyYXAubWluLmNzcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvZnVsbGNhbGVuZGFyL2NvcmUvbWFpbi5jc3MiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2Z1bGxjYWxlbmRhci9jb3JlL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2Z1bGxjYWxlbmRhci9kYXlncmlkL21haW4uY3NzIiwid2VicGFjazovLy8uL2Fzc2V0cy9mdWxsY2FsZW5kYXIvZGF5Z3JpZC9tYWluLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9mdWxsY2FsZW5kYXIvaW50ZXJhY3Rpb24vbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvZnVsbGNhbGVuZGFyL2xpc3QvbWFpbi5jc3MiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2Z1bGxjYWxlbmRhci9saXN0L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2Z1bGxjYWxlbmRhci90aW1lZ3JpZC9tYWluLmNzcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvZnVsbGNhbGVuZGFyL3RpbWVncmlkL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2FwcC5qcyJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImVsZW1lbnRQcm9wSGFzaCIsImNsYXNzTmFtZSIsImNvbFNwYW4iLCJyb3dTcGFuIiwiY29udGFpbmVyVGFnSGFzaCIsImNyZWF0ZUVsZW1lbnQiLCJ0YWdOYW1lIiwiYXR0cnMiLCJjb250ZW50IiwiZWwiLCJkb2N1bWVudCIsImF0dHJOYW1lIiwiYXBwbHlTdHlsZSIsInNldEF0dHJpYnV0ZSIsImlubmVySFRNTCIsImFwcGVuZFRvRWxlbWVudCIsImh0bWxUb0VsZW1lbnQiLCJodG1sIiwidHJpbSIsImNvbnRhaW5lciIsImNvbXB1dGVDb250YWluZXJUYWciLCJmaXJzdENoaWxkIiwiaHRtbFRvRWxlbWVudHMiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImh0bWxUb05vZGVMaXN0IiwiY2hpbGROb2RlcyIsInN1YnN0ciIsIm5vcm1hbGl6ZUNvbnRlbnQiLCJpIiwibGVuZ3RoIiwiYXBwZW5kQ2hpbGQiLCJwcmVwZW5kVG9FbGVtZW50IiwicGFyZW50IiwibmV3RWxzIiwiYWZ0ZXJFbCIsImluc2VydEJlZm9yZSIsImluc2VydEFmdGVyRWxlbWVudCIsInJlZkVsIiwibmV4dFNpYmxpbmciLCJwYXJlbnROb2RlIiwiZWxzIiwiTm9kZSIsInJlbW92ZUVsZW1lbnQiLCJyZW1vdmVDaGlsZCIsIm1hdGNoZXNNZXRob2QiLCJFbGVtZW50IiwibWF0Y2hlcyIsIm1hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiY2xvc2VzdE1ldGhvZCIsImNsb3Nlc3QiLCJzZWxlY3RvciIsImRvY3VtZW50RWxlbWVudCIsImNvbnRhaW5zIiwiZWxlbWVudE1hdGNoZXMiLCJwYXJlbnRFbGVtZW50Iiwibm9kZVR5cGUiLCJlbGVtZW50Q2xvc2VzdCIsImZpbmRFbGVtZW50cyIsImNvbnRhaW5lcnMiLCJIVE1MRWxlbWVudCIsImFsbE1hdGNoZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaiIsInB1c2giLCJmaW5kQ2hpbGRyZW4iLCJwYXJlbnRzIiwiY2hpbGRyZW4iLCJjaGlsZE5vZGUiLCJmb3JjZUNsYXNzTmFtZSIsImJvb2wiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJQSVhFTF9QUk9QX1JFIiwicHJvcHMiLCJwcm9wTmFtZSIsImFwcGx5U3R5bGVQcm9wIiwibmFtZSIsInZhbCIsInN0eWxlIiwidGVzdCIsInBvaW50SW5zaWRlUmVjdCIsInBvaW50IiwicmVjdCIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImludGVyc2VjdFJlY3RzIiwicmVjdDEiLCJyZWN0MiIsInJlcyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJ0cmFuc2xhdGVSZWN0IiwiZGVsdGFYIiwiZGVsdGFZIiwiY29uc3RyYWluUG9pbnQiLCJnZXRSZWN0Q2VudGVyIiwiZGlmZlBvaW50cyIsInBvaW50MSIsInBvaW50MiIsImlzUnRsU2Nyb2xsYmFyT25MZWZ0IiwiZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJvdXRlckVsIiwicG9zaXRpb24iLCJib3JkZXIiLCJwYWRkaW5nIiwib3ZlcmZsb3ciLCJkaXJlY3Rpb24iLCJib2R5IiwiaW5uZXJFbCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNhbml0aXplU2Nyb2xsYmFyV2lkdGgiLCJ3aWR0aCIsInJvdW5kIiwiY29tcHV0ZUVkZ2VzIiwiZ2V0UGFkZGluZyIsImNvbXB1dGVkU3R5bGUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiYm9yZGVyTGVmdCIsInBhcnNlSW50IiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyUmlnaHQiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyVG9wIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b20iLCJib3JkZXJCb3R0b21XaWR0aCIsInNjcm9sbGJhckxlZnRSaWdodCIsIm9mZnNldFdpZHRoIiwiY2xpZW50V2lkdGgiLCJzY3JvbGxiYXJCb3R0b20iLCJvZmZzZXRIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxiYXJMZWZ0Iiwic2Nyb2xsYmFyUmlnaHQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiY29tcHV0ZUlubmVyUmVjdCIsImdvV2l0aGluUGFkZGluZyIsIm91dGVyUmVjdCIsImNvbXB1dGVSZWN0IiwiZWRnZXMiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiY29tcHV0ZVZpZXdwb3J0UmVjdCIsImNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zIiwiaGVpZ2h0IiwiY29tcHV0ZVZNYXJnaW5zIiwiY29tcHV0ZWQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5Cb3R0b20iLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJjb21wdXRlQ2xpcHBpbmdSZWN0IiwibWFwIiwiY29uY2F0IiwicmVkdWNlIiwicmVjdDAiLCJwcmV2ZW50RGVmYXVsdCIsImV2IiwibGlzdGVuQnlTZWxlY3RvciIsImV2ZW50VHlwZSIsImhhbmRsZXIiLCJyZWFsSGFuZGxlciIsIm1hdGNoZWRDaGlsZCIsInRhcmdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJjdXJyZW50TWF0Y2hlZENoaWxkIiwicmVhbE9uTW91c2VMZWF2ZV8xIiwidHJhbnNpdGlvbkV2ZW50TmFtZXMiLCJ3aGVuVHJhbnNpdGlvbkRvbmUiLCJjYWxsYmFjayIsInJlYWxDYWxsYmFjayIsImZvckVhY2giLCJldmVudE5hbWUiLCJEQVlfSURTIiwiYWRkV2Vla3MiLCJtIiwibiIsImEiLCJkYXRlVG9VdGNBcnJheSIsImFycmF5VG9VdGNEYXRlIiwiYWRkRGF5cyIsImFkZE1zIiwiZGlmZldlZWtzIiwibTAiLCJtMSIsImRpZmZEYXlzIiwidmFsdWVPZiIsImRpZmZIb3VycyIsImRpZmZNaW51dGVzIiwiZGlmZlNlY29uZHMiLCJkaWZmRGF5QW5kVGltZSIsIm0wZGF5Iiwic3RhcnRPZkRheSIsIm0xZGF5IiwieWVhcnMiLCJtb250aHMiLCJkYXlzIiwibWlsbGlzZWNvbmRzIiwiZGlmZldob2xlV2Vla3MiLCJkIiwiZGlmZldob2xlRGF5cyIsInRpbWVBc01zIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJzdGFydE9mSG91ciIsImdldFVUQ0hvdXJzIiwic3RhcnRPZk1pbnV0ZSIsImdldFVUQ01pbnV0ZXMiLCJzdGFydE9mU2Vjb25kIiwiZ2V0VVRDU2Vjb25kcyIsIndlZWtPZlllYXIiLCJtYXJrZXIiLCJkb3ciLCJkb3kiLCJ5IiwidyIsIndlZWtPZkdpdmVuWWVhciIsIm5leHRXIiwieWVhciIsImZpcnN0V2Vla1N0YXJ0IiwiZmlyc3RXZWVrT2Zmc2V0IiwiZGF5U3RhcnQiLCJmbG9vciIsImZ3ZCIsImZ3ZGx3IiwiZ2V0VVRDRGF5IiwiZGF0ZVRvTG9jYWxBcnJheSIsImRhdGUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJhcnJheVRvTG9jYWxEYXRlIiwiRGF0ZSIsImdldFVUQ01pbGxpc2Vjb25kcyIsIlVUQyIsImFwcGx5IiwiaXNWYWxpZERhdGUiLCJpc05hTiIsIklOVEVSTkFMX1VOSVRTIiwiUEFSU0VfUkUiLCJjcmVhdGVEdXJhdGlvbiIsImlucHV0IiwidW5pdCIsIl9hIiwicGFyc2VTdHJpbmciLCJub3JtYWxpemVPYmplY3QiLCJzIiwiZXhlYyIsInNpZ24iLCJvYmoiLCJtb250aCIsImRheSIsImdldFdlZWtzRnJvbUlucHV0IiwiaG91cnMiLCJob3VyIiwibWludXRlcyIsIm1pbnV0ZSIsInNlY29uZHMiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsIm1zIiwid2Vla3MiLCJ3ZWVrIiwiZHVyYXRpb25zRXF1YWwiLCJkMCIsImQxIiwiaXNTaW5nbGVEYXkiLCJkdXIiLCJhZGREdXJhdGlvbnMiLCJzdWJ0cmFjdER1cmF0aW9ucyIsIm11bHRpcGx5RHVyYXRpb24iLCJhc1JvdWdoWWVhcnMiLCJhc1JvdWdoRGF5cyIsImFzUm91Z2hNb250aHMiLCJhc1JvdWdoTXMiLCJhc1JvdWdoTWludXRlcyIsImFzUm91Z2hTZWNvbmRzIiwid2hvbGVEaXZpZGVEdXJhdGlvbnMiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImxvY2FsUmVzIiwiaXNJbnQiLCJncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IiLCJkb250UmV0dXJuV2Vla3MiLCJ2YWx1ZSIsImNvbXBlbnNhdGVTY3JvbGwiLCJyb3dFbCIsInNjcm9sbGJhcldpZHRocyIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsInVuY29tcGVuc2F0ZVNjcm9sbCIsImRpc2FibGVDdXJzb3IiLCJlbmFibGVDdXJzb3IiLCJkaXN0cmlidXRlSGVpZ2h0IiwiYXZhaWxhYmxlSGVpZ2h0Iiwic2hvdWxkUmVkaXN0cmlidXRlIiwibWluT2Zmc2V0MSIsIm1pbk9mZnNldDIiLCJmbGV4RWxzIiwiZmxleE9mZnNldHMiLCJmbGV4SGVpZ2h0cyIsInVzZWRIZWlnaHQiLCJ1bmRpc3RyaWJ1dGVIZWlnaHQiLCJtaW5PZmZzZXQiLCJuYXR1cmFsSGVpZ2h0IiwibmF0dXJhbE9mZnNldCIsIm5ld0hlaWdodCIsIm1hdGNoQ2VsbFdpZHRocyIsIm1heElubmVyV2lkdGgiLCJpbm5lcldpZHRoXzEiLCJzdWJ0cmFjdElubmVyRWxIZWlnaHQiLCJyZWZsb3dTdHlsZVByb3BzIiwiZGlmZiIsInJlc2V0U3R5bGVQcm9wcyIsInByZXZlbnRTZWxlY3Rpb24iLCJhbGxvd1NlbGVjdGlvbiIsInByZXZlbnRDb250ZXh0TWVudSIsImFsbG93Q29udGV4dE1lbnUiLCJwYXJzZUZpZWxkU3BlY3MiLCJzcGVjcyIsInRva2VucyIsInRva2VuIiwic3BsaXQiLCJpc0FycmF5IiwiY2hhckF0IiwiZmllbGQiLCJzdWJzdHJpbmciLCJvcmRlciIsImZ1bmMiLCJjb21wYXJlQnlGaWVsZFNwZWNzIiwib2JqMCIsIm9iajEiLCJmaWVsZFNwZWNzIiwiY21wIiwiY29tcGFyZUJ5RmllbGRTcGVjIiwiZmllbGRTcGVjIiwiZmxleGlibGVDb21wYXJlIiwiYiIsIlN0cmluZyIsImxvY2FsZUNvbXBhcmUiLCJjYXBpdGFsaXNlRmlyc3RMZXR0ZXIiLCJzdHIiLCJ0b1VwcGVyQ2FzZSIsInBhZFN0YXJ0IiwibGVuIiwiY29tcGFyZU51bWJlcnMiLCJhcHBseUFsbCIsImZ1bmN0aW9ucyIsInRoaXNPYmoiLCJhcmdzIiwicmV0IiwiZmlyc3REZWZpbmVkIiwiX2kiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJkZWJvdW5jZSIsIndhaXQiLCJ0aW1lb3V0IiwiY29udGV4dCIsInRpbWVzdGFtcCIsInJlc3VsdCIsImxhdGVyIiwibGFzdCIsInNldFRpbWVvdXQiLCJyZWZpbmVQcm9wcyIsInJhd1Byb3BzIiwicHJvY2Vzc29ycyIsImRlZmF1bHRzIiwibGVmdG92ZXJQcm9wcyIsInJlZmluZWQiLCJrZXkiLCJwcm9jZXNzb3IiLCJGdW5jdGlvbiIsIk51bWJlciIsIkJvb2xlYW4iLCJjb21wdXRlQWxpZ25lZERheVJhbmdlIiwidGltZWRSYW5nZSIsImRheUNudCIsInN0YXJ0IiwiZW5kIiwiY29tcHV0ZVZpc2libGVEYXlSYW5nZSIsIm5leHREYXlUaHJlc2hvbGQiLCJzdGFydERheSIsImVuZERheSIsImVuZFRpbWVNUyIsImlzTXVsdGlEYXlSYW5nZSIsInJhbmdlIiwidmlzaWJsZVJhbmdlIiwiZGlmZkRhdGVzIiwiZGF0ZTAiLCJkYXRlMSIsImRhdGVFbnYiLCJsYXJnZVVuaXQiLCJkaWZmV2hvbGVZZWFycyIsImRpZmZXaG9sZU1vbnRocyIsImV4dGVuZFN0YXRpY3MiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fZXh0ZW5kcyIsIl9fIiwiY29uc3RydWN0b3IiLCJjcmVhdGUiLCJfX2Fzc2lnbiIsImFzc2lnbiIsInQiLCJwYXJzZVJlY3VycmluZyIsImV2ZW50SW5wdXQiLCJhbGxEYXlEZWZhdWx0IiwicmVjdXJyaW5nVHlwZXMiLCJsZWZ0b3ZlcnMiLCJsb2NhbExlZnRvdmVycyIsInBhcnNlZCIsInBhcnNlIiwiYWxsRGF5IiwiYWxsRGF5R3Vlc3MiLCJkdXJhdGlvbiIsInR5cGVEYXRhIiwidHlwZUlkIiwiZXhwYW5kUmVjdXJyaW5nUmFuZ2VzIiwiZXZlbnREZWYiLCJmcmFtaW5nUmFuZ2UiLCJ0eXBlRGVmIiwicmVjdXJyaW5nRGVmIiwibWFya2VycyIsImV4cGFuZCIsInN1YnRyYWN0IiwibWVyZ2VQcm9wcyIsInByb3BPYmpzIiwiY29tcGxleFByb3BzIiwiZGVzdCIsImNvbXBsZXhPYmpzIiwidW5zaGlmdCIsImZpbHRlckhhc2giLCJoYXNoIiwiZmlsdGVyZWQiLCJtYXBIYXNoIiwibmV3SGFzaCIsImFycmF5VG9IYXNoIiwiYV8xIiwiaXRlbSIsImhhc2hWYWx1ZXNUb0FycmF5IiwiaXNQcm9wc0VxdWFsIiwicGFyc2VFdmVudHMiLCJyYXdFdmVudHMiLCJzb3VyY2VJZCIsImNhbGVuZGFyIiwiYWxsb3dPcGVuUmFuZ2UiLCJldmVudFN0b3JlIiwiY3JlYXRlRW1wdHlFdmVudFN0b3JlIiwicmF3RXZlbnRzXzEiLCJyYXdFdmVudCIsInR1cGxlIiwicGFyc2VFdmVudCIsImV2ZW50VHVwbGVUb1N0b3JlIiwiZGVmcyIsImRlZiIsImRlZklkIiwiaW5zdGFuY2UiLCJpbnN0YW5jZXMiLCJpbnN0YW5jZUlkIiwiZXhwYW5kUmVjdXJyaW5nIiwiZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24iLCJkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uIiwic3RhcnRzIiwicGx1Z2luU3lzdGVtIiwiaG9va3MiLCJzdGFydHNfMSIsImNyZWF0ZUV2ZW50SW5zdGFuY2UiLCJnZXRSZWxldmFudEV2ZW50cyIsImRlZl8xIiwibmV3U3RvcmUiLCJmaWx0ZXJFdmVudFN0b3JlRGVmcyIsImxvb2tEZWYiLCJpc0V2ZW50RGVmc0dyb3VwZWQiLCJkZWYwIiwiZGVmMSIsImdyb3VwSWQiLCJ0cmFuc2Zvcm1SYXdFdmVudHMiLCJldmVudFNvdXJjZSIsImNhbEVhY2hUcmFuc2Zvcm0iLCJvcHQiLCJzb3VyY2VFYWNoVHJhbnNmb3JtIiwiZXZlbnREYXRhVHJhbnNmb3JtIiwidHJhbnNmb3JtRWFjaFJhd0V2ZW50IiwicmVmaW5lZEV2ZW50cyIsInJhd0V2ZW50c18yIiwicmVmaW5lZEV2ZW50IiwibWVyZ2VFdmVudFN0b3JlcyIsInN0b3JlMCIsInN0b3JlMSIsImZpbHRlckZ1bmMiLCJwYXJzZVJhbmdlIiwiY3JlYXRlTWFya2VyIiwiaW52ZXJ0UmFuZ2VzIiwicmFuZ2VzIiwiY29uc3RyYWludFJhbmdlIiwiaW52ZXJ0ZWRSYW5nZXMiLCJkYXRlUmFuZ2UiLCJzb3J0IiwiY29tcGFyZVJhbmdlcyIsInJhbmdlMCIsInJhbmdlMSIsImludGVyc2VjdFJhbmdlcyIsIm5ld1JhbmdlIiwicmFuZ2VzRXF1YWwiLCJyYW5nZXNJbnRlcnNlY3QiLCJyYW5nZUNvbnRhaW5zUmFuZ2UiLCJvdXRlclJhbmdlIiwiaW5uZXJSYW5nZSIsInJhbmdlQ29udGFpbnNNYXJrZXIiLCJjb25zdHJhaW5NYXJrZXJUb1JhbmdlIiwicmVtb3ZlRXhhY3QiLCJhcnJheSIsImV4YWN0VmFsIiwicmVtb3ZlQ250Iiwic3BsaWNlIiwiaXNBcnJheXNFcXVhbCIsImEwIiwiYTEiLCJtZW1vaXplIiwid29ya2VyRnVuYyIsIm1lbW9pemVPdXRwdXQiLCJlcXVhbGl0eUZ1bmMiLCJjYWNoZWRSZXMiLCJuZXdSZXMiLCJFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyIsInNlcGFyYXRvciIsIm9taXRaZXJvTWludXRlIiwibWVyaWRpZW0iLCJvbWl0Q29tbWFzIiwiU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMiLCJ0aW1lWm9uZU5hbWUiLCJlcmEiLCJ3ZWVrZGF5IiwiTUVSSURJRU1fUkUiLCJDT01NQV9SRSIsIk1VTFRJX1NQQUNFX1JFIiwiTFRSX1JFIiwiVVRDX1JFIiwiTmF0aXZlRm9ybWF0dGVyIiwiZm9ybWF0U2V0dGluZ3MiLCJzdGFuZGFyZERhdGVQcm9wcyIsImV4dGVuZGVkU2V0dGluZ3MiLCJzZXZlcml0eSIsIm5hbWVfMSIsImJ1aWxkRm9ybWF0dGluZ0Z1bmMiLCJmb3JtYXQiLCJmb3JtYXRSYW5nZSIsImRpZmZTZXZlcml0eSIsImNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkiLCJjYWxlbmRhclN5c3RlbSIsImJpZ2dlc3RVbml0Rm9yUGFydGlhbCIsImZ1bGwwIiwiZnVsbDEiLCJwYXJ0aWFsRGF0ZVByb3BzIiwiY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyIsInBhcnRpYWxGb3JtYXR0aW5nRnVuYyIsInBhcnRpYWwwIiwicGFydGlhbDEiLCJpbnNlcnRpb24iLCJmaW5kQ29tbW9uSW5zZXJ0aW9uIiwiYmVmb3JlIiwiYWZ0ZXIiLCJnZXRMYXJnZXN0VW5pdCIsInN0YW5kYXJkRGF0ZVByb3BDbnQiLCJrZXlzIiwiZm9ybWF0VGltZVpvbmVPZmZzZXQiLCJ0aW1lWm9uZU9mZnNldCIsImZvcm1hdFdlZWtOdW1iZXIiLCJjb21wdXRlV2Vla051bWJlciIsIndlZWtMYWJlbCIsImxvY2FsZSIsImJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMiLCJzYW5pdGl6ZVNldHRpbmdzIiwidGltZVpvbmUiLCJub3JtYWxGb3JtYXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJjb2RlcyIsInplcm9Gb3JtYXQiLCJ6ZXJvUHJvcHMiLCJwb3N0UHJvY2VzcyIsInJlcGxhY2UiLCJpbmplY3RUem9TdHIiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsInR6b1N0ciIsInJlcGxhY2VkIiwibnVtIiwiZGlzcGxheSIsInBhcnRzIiwic2ltcGxlTnVtYmVyRm9ybWF0Iiwib3B0aW9ucyIsImlzUnRsIiwicmV2ZXJzZSIsImpvaW4iLCJjYSIsImdldE1hcmtlclllYXIiLCJnZXRNYXJrZXJNb250aCIsImdldE1hcmtlckRheSIsImJpZ2dlc3RVbml0IiwicGFydGlhbE9wdGlvbnMiLCJuYW1lXzIiLCJpMCIsImZvdW5kMCIsImluZGV4T2YiLCJiZWZvcmUwIiwiYWZ0ZXIwIiwiaTEiLCJmb3VuZDEiLCJiZWZvcmUxIiwiYWZ0ZXIxIiwiQ21kRm9ybWF0dGVyIiwiY21kU3RyIiwiY21kRm9ybWF0dGVyIiwiY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmciLCJGdW5jRm9ybWF0dGVyIiwiY3JlYXRlRm9ybWF0dGVyIiwiZGVmYXVsdFNlcGFyYXRvciIsImJ1aWxkSXNvU3RyaW5nIiwic3RyaXBaZXJvVGltZSIsInRvSVNPU3RyaW5nIiwiZm9ybWF0SXNvVGltZVN0cmluZyIsImRvSXNvIiwiYWJzIiwibWlucyIsInN0YXJ0SW5mbyIsImV4cGFuZFpvbmVkTWFya2VyIiwiZW5kSW5mbyIsImxvY2FsZUNvZGVzIiwiZGF0ZUluZm8iLCJtYXJrZXJUb0FycmF5IiwiRXZlbnRTb3VyY2VBcGkiLCJpbnRlcm5hbEV2ZW50U291cmNlIiwiZGlzcGF0Y2giLCJ0eXBlIiwicmVmZXRjaCIsInNvdXJjZUlkcyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwicHVibGljSWQiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwibWV0YSIsInVybCIsIkV2ZW50QXBpIiwiX2NhbGVuZGFyIiwiX2RlZiIsIl9pbnN0YW5jZSIsInNldFByb3AiLCJfYiIsIkRBVEVfUFJPUFMiLCJOT05fREFURV9QUk9QUyIsIm11dGF0ZSIsInN0YW5kYXJkUHJvcHMiLCJVTlNDT1BFRF9FVkVOVF9VSV9QUk9QUyIsInVpIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyQ29sb3IiLCJzdGFydEVkaXRhYmxlIiwiZHVyYXRpb25FZGl0YWJsZSIsInNldEV4dGVuZGVkUHJvcCIsImV4dGVuZGVkUHJvcHMiLCJzZXRTdGFydCIsInN0YXJ0SW5wdXQiLCJpbnN0YW5jZVJhbmdlIiwic3RhcnREZWx0YSIsImdyYW51bGFyaXR5IiwibWFpbnRhaW5EdXJhdGlvbiIsImRhdGVzRGVsdGEiLCJzZXRFbmQiLCJlbmRJbnB1dCIsImVuZERlbHRhIiwiaGFzRW5kIiwic2V0RGF0ZXMiLCJtb3ZlU3RhcnQiLCJkZWx0YUlucHV0IiwiZGVsdGEiLCJtb3ZlRW5kIiwibW92ZURhdGVzIiwic2V0QWxsRGF5IiwiZm9ybWF0SW5wdXQiLCJmb3JtYXR0ZXIiLCJmb3JjZWRTdGFydFR6byIsImZvcmNlZEVuZFR6byIsImZvcmNlZFR6byIsIm11dGF0aW9uIiwiZnJvbUFwaSIsInN0YXRlIiwiZXZlbnRTb3VyY2VzIiwidG9EYXRlIiwidGl0bGUiLCJyZW5kZXJpbmciLCJjb25zdHJhaW50cyIsIm92ZXJsYXAiLCJhbGxvd3MiLCJ0ZXh0Q29sb3IiLCJjbGFzc05hbWVzIiwic2xpY2VFdmVudFN0b3JlIiwiZXZlbnRVaUJhc2VzIiwiaW52ZXJzZUJnQnlHcm91cElkIiwiaW52ZXJzZUJnQnlEZWZJZCIsImRlZkJ5R3JvdXBJZCIsImJnUmFuZ2VzIiwiZmdSYW5nZXMiLCJldmVudFVpcyIsImNvbXBpbGVFdmVudFVpcyIsIm9yaWdSYW5nZSIsIm5vcm1hbFJhbmdlIiwic2xpY2VkUmFuZ2UiLCJpc1N0YXJ0IiwiaXNFbmQiLCJpbnZlcnRlZFJhbmdlc18xIiwiaW52ZXJ0ZWRSYW5nZSIsImludmVydGVkUmFuZ2VzXzIiLCJiZyIsImZnIiwiaGFzQmdSZW5kZXJpbmciLCJmaWx0ZXJTZWdzVmlhRWxzIiwidmlldyIsInNlZ3MiLCJpc01pcnJvciIsImhhc1B1YmxpY0hhbmRsZXJzIiwiZmlsdGVyIiwic2VnIiwiY3VzdG9tIiwicHVibGljbHlUcmlnZ2VyIiwiZXZlbnQiLCJldmVudFJhbmdlIiwic2Vnc18xIiwic2V0RWxTZWciLCJmY1NlZyIsImdldEVsU2VnIiwiZXZlbnREZWZzIiwiY29tcGlsZUV2ZW50VWkiLCJ1aXMiLCJjb21iaW5lRXZlbnRVaXMiLCJhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlIiwiZXZlbnRDb25maWdCYXNlIiwiZXZlbnRDb25maWdzIiwiYXBwbHlNdXRhdGlvblRvRXZlbnREZWYiLCJldmVudERlZk11dGF0aW9uQXBwbGllcnMiLCJhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlIiwiZXZlbnRDb25maWciLCJhcHBsaWVycyIsImNvcHkiLCJhcHBsaWVyc18xIiwiYXBwbGllciIsImV2ZW50SW5zdGFuY2UiLCJmb3JjZUFsbERheSIsImNsZWFyRW5kIiwiZ2V0RGVmYXVsdEV2ZW50RW5kIiwicmVkdWNlRXZlbnRTdG9yZSIsImFjdGlvbiIsImRhdGVQcm9maWxlIiwicmVjZWl2ZVJhd0V2ZW50cyIsImZldGNoSWQiLCJmZXRjaFJhbmdlIiwiYWRkRXZlbnQiLCJhY3RpdmVSYW5nZSIsInJlem9uZURhdGVzIiwib2xkRGF0ZUVudiIsImFwcGx5TXV0YXRpb25Ub1JlbGF0ZWQiLCJleGNsdWRlSW5zdGFuY2VzIiwiZXhjbHVkZUV2ZW50c0J5U291cmNlSWQiLCJsYXRlc3RGZXRjaElkIiwic3Vic2V0IiwiZXhwYW5kUmFuZ2UiLCJuZXdEYXRlRW52IiwiY2FuQ29tcHV0ZU9mZnNldCIsInJlbGV2YW50IiwicmVtb3ZhbHMiLCJpc0ludGVyYWN0aW9uVmFsaWQiLCJpbnRlcmFjdGlvbiIsImlzTmV3UHJvcHNWYWxpZCIsImV2ZW50RHJhZyIsImlzRGF0ZVNlbGVjdGlvblZhbGlkIiwiZGF0ZVNlbGVjdGlvbiIsIm5ld1Byb3BzIiwiYnVzaW5lc3NIb3VycyIsImV2ZW50U2VsZWN0aW9uIiwiZXZlbnRSZXNpemUiLCJpc1Byb3BzVmFsaWQiLCJkYXRlU3Bhbk1ldGEiLCJmaWx0ZXJDb25maWciLCJpc0ludGVyYWN0aW9uUHJvcHNWYWxpZCIsImlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQiLCJzdWJqZWN0RXZlbnRTdG9yZSIsIm11dGF0ZWRFdmVudHMiLCJzdWJqZWN0RGVmcyIsInN1YmplY3RJbnN0YW5jZXMiLCJzdWJqZWN0Q29uZmlncyIsImlzRXZlbnQiLCJzZWxlY3Rpb25Db25maWciLCJvdGhlckV2ZW50U3RvcmUiLCJhZmZlY3RlZEV2ZW50cyIsIm90aGVyRGVmcyIsIm90aGVySW5zdGFuY2VzIiwib3RoZXJDb25maWdzIiwic3ViamVjdEluc3RhbmNlSWQiLCJzdWJqZWN0SW5zdGFuY2UiLCJzdWJqZWN0UmFuZ2UiLCJzdWJqZWN0Q29uZmlnIiwic3ViamVjdERlZiIsImFsbENvbnN0cmFpbnRzUGFzcyIsIm92ZXJsYXBGdW5jIiwib3RoZXJJbnN0YW5jZUlkIiwib3RoZXJJbnN0YW5jZSIsIm90aGVyT3ZlcmxhcCIsImNhbGVuZGFyRXZlbnRTdG9yZSIsInN1YmplY3RBbGxvdyIsInN1YmplY3REYXRlU3BhbiIsIm9yaWdEZWYiLCJvcmlnSW5zdGFuY2UiLCJldmVudEFwaSIsImJ1aWxkRGF0ZVNwYW5BcGkiLCJyZWxldmFudEV2ZW50U3RvcmUiLCJyZWxldmFudERlZnMiLCJyZWxldmFudEluc3RhbmNlcyIsInNlbGVjdGlvbiIsInNlbGVjdGlvblJhbmdlIiwicmVsZXZhbnRJbnN0YW5jZUlkIiwicmVsZXZhbnRJbnN0YW5jZSIsInNlbGVjdGlvbkFsbG93IiwiZnVsbERhdGVTcGFuIiwiYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQiLCJjb25zdHJhaW50c18xIiwiY29uc3RyYWludCIsImFueVJhbmdlc0NvbnRhaW5SYW5nZSIsImNvbnN0cmFpbnRUb1JhbmdlcyIsImV2ZW50U3RvcmVUb1JhbmdlcyIsIm91dGVyUmFuZ2VzIiwib3V0ZXJSYW5nZXNfMSIsIm5vcm1hbGl6ZUNvbnN0cmFpbnQiLCJodG1sRXNjYXBlIiwiY3NzVG9TdHIiLCJjc3NQcm9wcyIsInN0YXRlbWVudHMiLCJhdHRyc1RvU3RyIiwicGFyc2VDbGFzc05hbWUiLCJyYXciLCJlZGl0YWJsZSIsImFsbG93IiwiY29sb3IiLCJwcm9jZXNzVW5zY29wZWRVaVByb3BzIiwicHJvY2Vzc1Njb3BlZFVpUHJvcHMiLCJwcmVmaXgiLCJyYXdTY29wZWQiLCJyYXdVbnNjb3BlZCIsIndhc0ZvdW5kIiwic2NvcGVkS2V5IiwiRU1QVFlfRVZFTlRfVUkiLCJjb21iaW5lVHdvRXZlbnRVaXMiLCJpdGVtMCIsIml0ZW0xIiwiaWQiLCJ1aWQiLCJjb21wdXRlSXNBbGxEYXlEZWZhdWx0IiwibGVmdG92ZXJzMCIsInJlY3VycmluZ1JlcyIsInBhcnNlRXZlbnREZWYiLCJsZWZ0b3ZlcnMxIiwic2luZ2xlUmVzIiwicGFyc2VTaW5nbGUiLCJwbHVja05vbkRhdGVQcm9wcyIsImV2ZW50RGVmUGFyc2VycyIsImV2ZW50RGVmUGFyc2VyIiwibmV3TGVmdG92ZXJzIiwiZnJlZXplIiwicGx1Y2tEYXRlUHJvcHMiLCJzdGFydE1ldGEiLCJzdGFydE1hcmtlciIsImVuZE1ldGEiLCJlbmRNYXJrZXIiLCJjcmVhdGVNYXJrZXJNZXRhIiwiaXNUaW1lVW5zcGVjaWZpZWQiLCJwcmVMZWZ0b3ZlcnMiLCJzb3VyY2UiLCJERUZfREVGQVVMVFMiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZGF5c09mV2VlayIsInBhcnNlQnVzaW5lc3NIb3VycyIsInJlZmluZUlucHV0cyIsInJhd0RlZnMiLCJyYXdEZWYiLCJtZW1vaXplUmVuZGVyaW5nIiwicmVuZGVyRnVuYyIsInVucmVuZGVyRnVuYyIsImRlcGVuZGVuY2llcyIsImRlcGVuZGVudHMiLCJ0aGlzQ29udGV4dCIsInByZXZBcmdzIiwidW5yZW5kZXIiLCJkZXBlbmRlbnRzXzEiLCJkZXBlbmRlbnQiLCJkZXBlbmRlbmNpZXNfMSIsImRlcGVuZGVuY3kiLCJFTVBUWV9FVkVOVF9TVE9SRSIsIlNwbGl0dGVyIiwiZ2V0S2V5c0ZvckV2ZW50RGVmcyIsIl9nZXRLZXlzRm9yRXZlbnREZWZzIiwic3BsaXREYXRlU2VsZWN0aW9uIiwiX3NwbGl0RGF0ZVNwYW4iLCJzcGxpdEV2ZW50U3RvcmUiLCJfc3BsaXRFdmVudFN0b3JlIiwic3BsaXRJbmRpdmlkdWFsVWkiLCJfc3BsaXRJbmRpdmlkdWFsVWkiLCJzcGxpdEV2ZW50RHJhZyIsIl9zcGxpdEludGVyYWN0aW9uIiwic3BsaXRFdmVudFJlc2l6ZSIsImV2ZW50VWlCdWlsZGVycyIsInNwbGl0UHJvcHMiLCJfdGhpcyIsImtleUluZm9zIiwiZ2V0S2V5SW5mbyIsImRlZktleXMiLCJkYXRlU2VsZWN0aW9ucyIsImluZGl2aWR1YWxVaSIsImV2ZW50U3RvcmVzIiwiZXZlbnREcmFncyIsImV2ZW50UmVzaXplcyIsImluZm8iLCJidWlsZEV2ZW50VWlGb3JLZXkiLCJrZXlJbmZvIiwiYnVpbGRFdmVudFVpIiwiZGF0ZVNwYW4iLCJkYXRlU3BhbnMiLCJnZXRLZXlzRm9yRGF0ZVNwYW4iLCJrZXlzXzEiLCJnZXRLZXlzRm9yRXZlbnREZWYiLCJzcGxpdFN0b3JlcyIsIl9jIiwic3BsaXRIYXNoZXMiLCJzcGxpdFN0YXRlcyIsImFmZmVjdGVkU3RvcmVzXzEiLCJtdXRhdGVkS2V5c0J5RGVmSWQiLCJtdXRhdGVkU3RvcmVzXzEiLCJwb3B1bGF0ZSIsIm9yaWdTZWciLCJhbGxVaSIsImV2ZW50VWlGb3JLZXkiLCJiYXNlUGFydHMiLCJzdHVmZiIsImJ1aWxkR290b0FuY2hvckh0bWwiLCJjb21wb25lbnQiLCJnb3RvT3B0aW9ucyIsImlubmVySHRtbCIsImZvcmNlT2ZmIiwiZmluYWxPcHRpb25zIiwiZm9ybWF0SXNvIiwib21pdFRpbWUiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0QWxsRGF5SHRtbCIsImdldERheUNsYXNzZXMiLCJub1RoZW1lSGlnaGxpZ2h0IiwidGhlbWUiLCJjbGFzc2VzIiwidG9kYXlTdGFydCIsInRvZGF5RW5kIiwiY3VycmVudFJhbmdlIiwiZ2V0Tm93IiwiZ2V0Q2xhc3MiLCJ1bnByb21pc2lmeSIsInN1Y2Nlc3MiLCJmYWlsdXJlIiwiaXNSZXNvbHZlZCIsIndyYXBwZWRTdWNjZXNzIiwid3JhcHBlZEZhaWx1cmUiLCJ0aGVuIiwiTWl4aW4iLCJtaXhJbnRvIiwiZGVzdENsYXNzIiwibWl4SW50b09iaiIsImRlc3RPYmoiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwibWl4T3ZlciIsIkVtaXR0ZXJNaXhpbiIsIl9zdXBlciIsIm9uIiwiYWRkVG9IYXNoIiwiX2hhbmRsZXJzIiwib25lIiwiX29uZUhhbmRsZXJzIiwib2ZmIiwicmVtb3ZlRnJvbUhhc2giLCJ0cmlnZ2VyIiwidHJpZ2dlcldpdGgiLCJoYXNIYW5kbGVycyIsIlBvc2l0aW9uQ2FjaGUiLCJvcmlnaW5FbCIsImlzSG9yaXpvbnRhbCIsImlzVmVydGljYWwiLCJidWlsZCIsIm9yaWdpbkNsaWVudFJlY3QiLCJidWlsZEVsSG9yaXpvbnRhbHMiLCJidWlsZEVsVmVydGljYWxzIiwib3JpZ2luQ2xpZW50TGVmdCIsImxlZnRzIiwicmlnaHRzIiwib3JpZ2luQ2xpZW50VG9wIiwidG9wcyIsImJvdHRvbXMiLCJsZWZ0VG9JbmRleCIsImxlZnRQb3NpdGlvbiIsInRvcFRvSW5kZXgiLCJ0b3BQb3NpdGlvbiIsImdldFdpZHRoIiwibGVmdEluZGV4IiwiZ2V0SGVpZ2h0IiwidG9wSW5kZXgiLCJTY3JvbGxDb250cm9sbGVyIiwiZ2V0TWF4U2Nyb2xsVG9wIiwiZ2V0U2Nyb2xsSGVpZ2h0IiwiZ2V0Q2xpZW50SGVpZ2h0IiwiZ2V0TWF4U2Nyb2xsTGVmdCIsImdldFNjcm9sbFdpZHRoIiwiZ2V0Q2xpZW50V2lkdGgiLCJjYW5TY3JvbGxWZXJ0aWNhbGx5IiwiY2FuU2Nyb2xsSG9yaXpvbnRhbGx5IiwiY2FuU2Nyb2xsVXAiLCJnZXRTY3JvbGxUb3AiLCJjYW5TY3JvbGxEb3duIiwiY2FuU2Nyb2xsTGVmdCIsImdldFNjcm9sbExlZnQiLCJjYW5TY3JvbGxSaWdodCIsIkVsZW1lbnRTY3JvbGxDb250cm9sbGVyIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsInNldFNjcm9sbFRvcCIsInNldFNjcm9sbExlZnQiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsIldpbmRvd1Njcm9sbENvbnRyb2xsZXIiLCJzY3JvbGwiLCJTY3JvbGxDb21wb25lbnQiLCJhcHBseU92ZXJmbG93IiwiY2xlYXIiLCJzZXRIZWlnaHQiLCJkZXN0cm95IiwibG9ja092ZXJmbG93IiwiZ2V0U2Nyb2xsYmFyV2lkdGhzIiwiVGhlbWUiLCJjYWxlbmRhck9wdGlvbnMiLCJwcm9jZXNzSWNvbk92ZXJyaWRlIiwiaWNvbk92ZXJyaWRlT3B0aW9uIiwic2V0SWNvbk92ZXJyaWRlIiwiaWNvbk92ZXJyaWRlSGFzaCIsImljb25DbGFzc2VzQ29weSIsImJ1dHRvbk5hbWUiLCJpY29uQ2xhc3NlcyIsImFwcGx5SWNvbk92ZXJyaWRlUHJlZml4IiwiaWNvbk92ZXJyaWRlUHJlZml4IiwiZ2V0SWNvbkNsYXNzIiwiYmFzZUljb25DbGFzcyIsImdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyIsImN1c3RvbUJ1dHRvblByb3BzIiwiaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uIiwiZ3VpZCIsIkNvbXBvbmVudCIsImlzVmlldyIsImFkZEVxdWFsaXR5RnVuY3MiLCJuZXdGdW5jcyIsImVxdWFsaXR5RnVuY3MiLCJyZWNlaXZlUHJvcHMiLCJyZWN5Y2xlUHJvcHMiLCJhbnlDaGFuZ2VzIiwiY29tYm9Qcm9wcyIsInJlbmRlciIsIm9sZFByb3BzIiwiRGF0ZUNvbXBvbmVudCIsImJ1aWxkUG9zaXRpb25DYWNoZXMiLCJxdWVyeUhpdCIsInBvc2l0aW9uTGVmdCIsInBvc2l0aW9uVG9wIiwiZWxXaWR0aCIsImVsSGVpZ2h0IiwidmFsaWRSYW5nZSIsInB1YmxpY2x5VHJpZ2dlckFmdGVyU2l6aW5nIiwidHJpZ2dlclJlbmRlcmVkU2VncyIsImlzTWlycm9ycyIsImxvYWRpbmdMZXZlbCIsImFmdGVyU2l6aW5nVHJpZ2dlcnMiLCJfZXZlbnRzUG9zaXRpb25lZCIsInRyaWdnZXJXaWxsUmVtb3ZlU2VncyIsInNlZ3NfMiIsInNlZ3NfMyIsImlzVmFsaWRTZWdEb3duRWwiLCJpc1BvcG92ZXIiLCJpc0luUG9wb3ZlciIsImlzVmFsaWREYXRlRG93bkVsIiwic2VnRWwiLCJmZ1NlZ1NlbGVjdG9yIiwiYmdTZWdTZWxlY3RvciIsInVpZCQxIiwiY3JlYXRlUGx1Z2luIiwiZGVwcyIsInJlZHVjZXJzIiwiaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMiLCJldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyIsImRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMiLCJkYXRlUG9pbnRUcmFuc2Zvcm1zIiwiZGF0ZVNwYW5UcmFuc2Zvcm1zIiwidmlld3MiLCJ2aWV3UHJvcHNUcmFuc2Zvcm1lcnMiLCJleHRlcm5hbERlZlRyYW5zZm9ybXMiLCJldmVudFJlc2l6ZUpvaW5UcmFuc2Zvcm1zIiwidmlld0NvbnRhaW5lck1vZGlmaWVycyIsImV2ZW50RHJvcFRyYW5zZm9ybWVycyIsImNvbXBvbmVudEludGVyYWN0aW9ucyIsImNhbGVuZGFySW50ZXJhY3Rpb25zIiwidGhlbWVDbGFzc2VzIiwiZXZlbnRTb3VyY2VEZWZzIiwibmFtZWRUaW1lWm9uZWRJbXBsIiwiZGVmYXVsdFZpZXciLCJlbGVtZW50RHJhZ2dpbmdJbXBsIiwib3B0aW9uQ2hhbmdlSGFuZGxlcnMiLCJQbHVnaW5TeXN0ZW0iLCJhZGRlZEhhc2giLCJwbHVnaW4iLCJkZXAiLCJjb21iaW5lSG9va3MiLCJob29rczAiLCJob29rczEiLCJldmVudFNvdXJjZURlZiIsImlnbm9yZVJhbmdlIiwicGFyc2VNZXRhIiwiZXZlbnRzIiwiZmV0Y2giLCJhcmciLCJBcnJheUV2ZW50U291cmNlUGx1Z2luIiwiZXZlbnRTb3VyY2VEZWYkMSIsImJpbmQiLCJzdGFydFN0ciIsImVuZFN0ciIsIkZ1bmNFdmVudFNvdXJjZVBsdWdpbiIsInJlcXVlc3RKc29uIiwibWV0aG9kIiwicGFyYW1zIiwic3VjY2Vzc0NhbGxiYWNrIiwiZmFpbHVyZUNhbGxiYWNrIiwiaW5qZWN0UXVlcnlTdHJpbmdQYXJhbXMiLCJlbmNvZGVQYXJhbXMiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25sb2FkIiwic3RhdHVzIiwicmVzcG9uc2VUZXh0IiwiZXJyIiwib25lcnJvciIsInNlbmQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJldmVudFNvdXJjZURlZiQyIiwiZXh0cmFQYXJhbXMiLCJzdGFydFBhcmFtIiwiZW5kUGFyYW0iLCJ0aW1lWm9uZVBhcmFtIiwicmVxdWVzdFBhcmFtcyIsImJ1aWxkUmVxdWVzdFBhcmFtcyIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJKc29uRmVlZEV2ZW50U291cmNlUGx1Z2luIiwiY3VzdG9tUmVxdWVzdFBhcmFtcyIsInJlY3VycmluZyIsInN0YXJ0UmVjdXIiLCJlbmRSZWN1ciIsImFueVZhbGlkIiwiY2xpcHBlZEZyYW1pbmdSYW5nZSIsImV4cGFuZFJhbmdlcyIsIlNpbXBsZVJlY3VycmVuY2VQbHVnaW4iLCJkb3dIYXNoIiwiZGF5TWFya2VyIiwiaW5zdGFuY2VTdGFydHMiLCJpbnN0YW5jZVN0YXJ0IiwiRGVmYXVsdE9wdGlvbkNoYW5nZUhhbmRsZXJzIiwiZGVlcEVxdWFsIiwiaGFuZGxlRXZlbnRTb3VyY2VzIiwicGx1Z2lucyIsImhhbmRsZVBsdWdpbnMiLCJpbnB1dHMiLCJ1bmZvdW5kU291cmNlcyIsIm5ld0lucHV0cyIsImlucHV0c18xIiwiaW5wdXRGb3VuZCIsIl9yYXciLCJ1bmZvdW5kU291cmNlc18xIiwidW5mb3VuZFNvdXJjZSIsIm5ld0lucHV0c18xIiwibmV3SW5wdXQiLCJhZGRFdmVudFNvdXJjZSIsImFkZFBsdWdpbklucHV0cyIsImNvbmZpZyIsImdsb2JhbERlZmF1bHRzIiwiZGVmYXVsdFJhbmdlU2VwYXJhdG9yIiwidGl0bGVSYW5nZVNlcGFyYXRvciIsImZvcmNlRXZlbnREdXJhdGlvbiIsImNvbHVtbkhlYWRlciIsImFzcGVjdFJhdGlvIiwiaGVhZGVyIiwiY2VudGVyIiwid2Vla2VuZHMiLCJ3ZWVrTnVtYmVycyIsIndlZWtOdW1iZXJDYWxjdWxhdGlvbiIsInNjcm9sbFRpbWUiLCJtaW5UaW1lIiwibWF4VGltZSIsInNob3dOb25DdXJyZW50RGF0ZXMiLCJsYXp5RmV0Y2hpbmciLCJsb2NhbGVzIiwidGltZUdyaWRFdmVudE1pbkhlaWdodCIsInRoZW1lU3lzdGVtIiwiZHJhZ1JldmVydER1cmF0aW9uIiwiZHJhZ1Njcm9sbCIsImFsbERheU1haW50YWluRHVyYXRpb24iLCJ1bnNlbGVjdEF1dG8iLCJkcm9wQWNjZXB0IiwiZXZlbnRPcmRlciIsImV2ZW50TGltaXQiLCJldmVudExpbWl0Q2xpY2siLCJkYXlQb3BvdmVyRm9ybWF0IiwiaGFuZGxlV2luZG93UmVzaXplIiwid2luZG93UmVzaXplRGVsYXkiLCJsb25nUHJlc3NEZWxheSIsImV2ZW50RHJhZ01pbkRpc3RhbmNlIiwicnRsRGVmYXVsdHMiLCJidXR0b25JY29ucyIsInByZXYiLCJuZXh0IiwicHJldlllYXIiLCJuZXh0WWVhciIsImNvbXBsZXhPcHRpb25zIiwibWVyZ2VPcHRpb25zIiwib3B0aW9uT2JqcyIsIklOVEVSTkFMX1BMVUdJTlMiLCJyZWZpbmVQbHVnaW5EZWZzIiwicGx1Z2luSW5wdXRzIiwicGx1Z2luSW5wdXRzXzEiLCJwbHVnaW5JbnB1dCIsImdsb2JhbE5hbWUiLCJjb25zb2xlIiwid2FybiIsIlJBV19FTl9MT0NBTEUiLCJjb2RlIiwiZGlyIiwiYnV0dG9uVGV4dCIsInRvZGF5IiwibGlzdCIsImFsbERheVRleHQiLCJldmVudExpbWl0VGV4dCIsIm5vRXZlbnRzTWVzc2FnZSIsInBhcnNlUmF3TG9jYWxlcyIsImV4cGxpY2l0UmF3TG9jYWxlcyIsImRlZmF1bHRDb2RlIiwiZ2xvYmFsQXJyYXkiLCJnbG9iYWxPYmplY3QiLCJhbGxSYXdMb2NhbGVzIiwicmF3TG9jYWxlTWFwIiwiZW4iLCJhbGxSYXdMb2NhbGVzXzEiLCJyYXdMb2NhbGUiLCJidWlsZExvY2FsZSIsImlucHV0U2luZ3VsYXIiLCJhdmFpbGFibGUiLCJwYXJzZUxvY2FsZSIsInF1ZXJ5TG9jYWxlIiwiY29kZUFyZyIsInF1ZXJ5UmF3TG9jYWxlIiwic2ltcGxlSWQiLCJtZXJnZWQiLCJOdW1iZXJGb3JtYXQiLCJPcHRpb25zTWFuYWdlciIsIm92ZXJyaWRlcyIsImR5bmFtaWNPdmVycmlkZXMiLCJjb21wdXRlIiwidXBkYXRlcyIsImlzRHluYW1pYyIsIm92ZXJyaWRlSGFzaCIsInJlbW92YWxzXzEiLCJsb2NhbGVEZWZhdWx0cyIsImRpckRlZmF1bHRzIiwiY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCIsInJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0iLCJ0aGVDbGFzcyIsImNyZWF0ZUNhbGVuZGFyU3lzdGVtIiwiR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0iLCJhcnJheVRvTWFya2VyIiwiYXJyIiwiSVNPX1JFIiwiRGF0ZUVudiIsInNldHRpbmdzIiwiaXNOYW1lZFRpbWVab25lIiwibmFtZWRUaW1lWm9uZUltcGwiLCJ3ZWVrRG93Iiwid2Vla0RveSIsImZpcnN0RGF5Iiwid2Vla051bWJlckZ1bmMiLCJjcmVhdGVOb3dNYXJrZXIiLCJ0aW1lc3RhbXBUb01hcmtlciIsImdldFllYXIiLCJhZGRZZWFycyIsImFkZE1vbnRocyIsImdyZWF0ZXN0V2hvbGVVbml0IiwiY291bnREdXJhdGlvbnNCZXR3ZWVuIiwic3RhcnRPZiIsInN0YXJ0T2ZZZWFyIiwic3RhcnRPZk1vbnRoIiwic3RhcnRPZldlZWsiLCJkYXRlT3B0aW9ucyIsIm9mZnNldEZvck1hcmtlciIsImlzRW5kRXhjbHVzaXZlIiwiZXh0cmFPcHRpb25zIiwib21pdFRpbWVab25lT2Zmc2V0IiwidGltZXN0YW1wVG9BcnJheSIsImdldFRpbWV6b25lT2Zmc2V0Iiwib2Zmc2V0Rm9yQXJyYXkiLCJTSU1QTEVfU09VUkNFX1BST1BTIiwidWlkJDIiLCJkb2VzU291cmNlTmVlZFJhbmdlIiwic291cmNlRGVmSWQiLCJwYXJzZUV2ZW50U291cmNlIiwicGFyc2VFdmVudFNvdXJjZVByb3BzIiwiaXNGZXRjaGluZyIsInJlZHVjZUV2ZW50U291cmNlcyIsImFkZFNvdXJjZXMiLCJzb3VyY2VzIiwicmVtb3ZlU291cmNlIiwiZmV0Y2hEaXJ0eVNvdXJjZXMiLCJmZXRjaFNvdXJjZXNCeUlkcyIsImV4Y2x1ZGVTdGF0aWNTb3VyY2VzIiwicmVjZWl2ZVJlc3BvbnNlIiwidWlkJDMiLCJldmVudFNvdXJjZUhhc2giLCJzb3VyY2VzXzEiLCJzb3VyY2VIYXNoIiwiaXNTb3VyY2VEaXJ0eSIsInByZXZTb3VyY2VzIiwic291cmNlSWRIYXNoIiwibmV4dFNvdXJjZXMiLCJmZXRjaFNvdXJjZSIsInNvdXJjZURlZiIsImNhbFN1Y2Nlc3MiLCJjYWxTdWNjZXNzUmVzIiwic291cmNlU3VjY2Vzc1JlcyIsImVycm9yIiwiY2FsbEZhaWx1cmUiLCJEYXRlUHJvZmlsZUdlbmVyYXRvciIsInZpZXdTcGVjIiwiaW5pdEhpZGRlbkRheXMiLCJidWlsZFByZXYiLCJjdXJyZW50RGF0ZVByb2ZpbGUiLCJjdXJyZW50RGF0ZSIsInByZXZEYXRlIiwiY3VycmVudFJhbmdlVW5pdCIsImRhdGVJbmNyZW1lbnQiLCJidWlsZE5leHQiLCJuZXh0RGF0ZSIsImZvcmNlVG9WYWxpZCIsImN1cnJlbnRJbmZvIiwiaXNSYW5nZUFsbERheSIsInJlbmRlclJhbmdlIiwiaXNWYWxpZCIsImJ1aWxkVmFsaWRSYW5nZSIsInRyaW1IaWRkZW5EYXlzIiwiYnVpbGRDdXJyZW50UmFuZ2VJbmZvIiwiYnVpbGRSZW5kZXJSYW5nZSIsImFkanVzdEFjdGl2ZVJhbmdlIiwiYnVpbGREYXRlSW5jcmVtZW50IiwiZ2V0UmFuZ2VPcHRpb24iLCJkYXlDb3VudCIsImR1cmF0aW9uVW5pdCIsImJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24iLCJidWlsZFJhbmdlRnJvbURheUNvdW50IiwiYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UiLCJnZXRGYWxsYmFja0R1cmF0aW9uIiwidXNlc01pbk1heFRpbWUiLCJhbGlnbm1lbnQiLCJkYXRlQWxpZ25tZW50IiwiZGF0ZUluY3JlbWVudElucHV0IiwiZGF0ZUluY3JlbWVudER1cmF0aW9uIiwiaXNIaWRkZW5EYXkiLCJza2lwSGlkZGVuRGF5cyIsImNvbXB1dGVSZXMiLCJjdXN0b21BbGlnbm1lbnQiLCJydW5uaW5nQ291bnQiLCJmYWxsYmFjayIsIm90aGVyQXJncyIsImhpZGRlbkRheXMiLCJpc0hpZGRlbkRheUhhc2giLCJFcnJvciIsImluYyIsImlzRXhjbHVzaXZlIiwiaXNEYXRlUHJvZmlsZXNFcXVhbCIsInAwIiwicDEiLCJ2aWV3VHlwZSIsInJlZHVjZVZpZXdUeXBlIiwicmVkdWNlRGF0ZVByb2ZpbGUiLCJuZXh0U3RhdGUiLCJyZWR1Y2VDdXJyZW50RGF0ZSIsInJlZHVjZURhdGVTZWxlY3Rpb24iLCJyZWR1Y2VTZWxlY3RlZEV2ZW50IiwicmVkdWNlRXZlbnREcmFnIiwicmVkdWNlRXZlbnRSZXNpemUiLCJldmVudFNvdXJjZUxvYWRpbmdMZXZlbCIsImNvbXB1dGVMb2FkaW5nTGV2ZWwiLCJyZWR1Y2VyRnVuYyIsImN1cnJlbnRWaWV3VHlwZSIsIm5ld0RhdGVQcm9maWxlIiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JzIiwiZGF0ZU1hcmtlciIsImdlbmVyYXRvciIsIm5ld0RhdGUiLCJjdXJyZW50U2VsZWN0aW9uIiwiY3VycmVudEluc3RhbmNlSWQiLCJldmVudEluc3RhbmNlSWQiLCJjdXJyZW50RHJhZyIsIm5ld0RyYWciLCJjdXJyZW50UmVzaXplIiwibmV3UmVzaXplIiwiY250IiwiU1RBTkRBUkRfUFJPUFMiLCJwYXJzZURhdGVTcGFuIiwiZGVmYXVsdER1cmF0aW9uIiwic3BhbiIsInBhcnNlT3BlbkRhdGVTcGFuIiwiaXNEYXRlU3BhbnNFcXVhbCIsInNwYW4wIiwic3BhbjEiLCJpc1NwYW5Qcm9wc0VxdWFsIiwiYnVpbGREYXRlUG9pbnRBcGkiLCJkYXRlU3RyIiwiZmFicmljYXRlRXZlbnRSYW5nZSIsImNvbXBpbGVWaWV3RGVmcyIsImRlZmF1bHRDb25maWdzIiwib3ZlcnJpZGVDb25maWdzIiwiZW5zdXJlVmlld0RlZiIsInZpZXdEZWYiLCJidWlsZFZpZXdEZWYiLCJkZWZhdWx0Q29uZmlnIiwib3ZlcnJpZGVDb25maWciLCJxdWVyeVByb3AiLCJzdXBlclR5cGUiLCJmaW5kVmlld05hbWVCeVN1YmNsYXNzIiwic3VwZXJEZWYiLCJ2aWV3U3ViY2xhc3MiLCJjb25maWdzIiwic3VwZXJQcm90byIsImdldFByb3RvdHlwZU9mIiwicGFyc2VWaWV3Q29uZmlncyIsInBhcnNlVmlld0NvbmZpZyIsIlZJRVdfREVGX1BST1BTIiwiYnVpbGRWaWV3U3BlY3MiLCJkZWZhdWx0SW5wdXRzIiwib3B0aW9uc01hbmFnZXIiLCJ2aWV3RGVmcyIsImJ1aWxkVmlld1NwZWMiLCJkdXJhdGlvbklucHV0Iiwic2luZ2xlVW5pdCIsInNpbmdsZVVuaXRPdmVycmlkZXMiLCJkZW5vbSIsInF1ZXJ5QnV0dG9uVGV4dCIsImJ1dHRvblRleHRNYXAiLCJidXR0b25UZXh0S2V5IiwiYnV0dG9uVGV4dE92ZXJyaWRlIiwiYnV0dG9uVGV4dERlZmF1bHQiLCJUb29sYmFyIiwiZXh0cmFDbGFzc05hbWUiLCJfcmVuZGVyTGF5b3V0IiwicmVuZGVyTGF5b3V0IiwidW5yZW5kZXJMYXlvdXQiLCJfdXBkYXRlVGl0bGUiLCJ1cGRhdGVUaXRsZSIsIl91cGRhdGVBY3RpdmVCdXR0b24iLCJ1cGRhdGVBY3RpdmVCdXR0b24iLCJfdXBkYXRlVG9kYXkiLCJ1cGRhdGVUb2RheSIsIl91cGRhdGVQcmV2IiwidXBkYXRlUHJldiIsIl91cGRhdGVOZXh0IiwidXBkYXRlTmV4dCIsImxheW91dCIsImFjdGl2ZUJ1dHRvbiIsImlzVG9kYXlFbmFibGVkIiwiaXNQcmV2RW5hYmxlZCIsImlzTmV4dEVuYWJsZWQiLCJ2aWV3c1dpdGhCdXR0b25zIiwicmVuZGVyU2VjdGlvbiIsImJ1dHRvblN0ciIsInZpZXdTcGVjcyIsInNlY3Rpb25FbCIsImNhbGVuZGFyQ3VzdG9tQnV0dG9ucyIsImN1c3RvbUJ1dHRvbnMiLCJjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXMiLCJjYWxlbmRhckJ1dHRvblRleHQiLCJidXR0b25Hcm91cFN0ciIsImdyb3VwQ2hpbGRyZW4iLCJpc09ubHlCdXR0b25zIiwiZ3JvdXBFbCIsImJ1dHRvbkNsaWNrIiwiYnV0dG9uSWNvbiIsImJ1dHRvbklubmVySHRtbCIsImJ1dHRvbkNsYXNzZXMiLCJidXR0b25FbCIsImJ1dHRvbkFyaWFBdHRyIiwiY2xpY2siLCJ0ZXh0IiwiY2hhbmdlVmlldyIsImJ1dHRvbkdyb3VwQ2xhc3NOYW1lIiwidG9nZ2xlQnV0dG9uRW5hYmxlZCIsInRpdGxlRWwiLCJpbm5lclRleHQiLCJkaXNhYmxlZCIsIkNhbGVuZGFyQ29tcG9uZW50IiwiX3JlbmRlclRvb2xiYXJzIiwicmVuZGVyVG9vbGJhcnMiLCJidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzIiwiY29udGVudEVsIiwibW9kaWZ5Vmlld0NvbnRhaW5lciIsInRvZ2dsZUVsQ2xhc3NOYW1lcyIsImNvbXB1dGVUaXRsZSIsImZvb3RlciIsImRpckNsYXNzTmFtZSIsInRoZW1lQ2xhc3NOYW1lIiwiZnJlZXplSGVpZ2h0IiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJyZW5kZXJWaWV3IiwidXBkYXRlU2l6ZSIsInRoYXdIZWlnaHQiLCJoZWFkZXJMYXlvdXQiLCJmb290ZXJMYXlvdXQiLCJub3ciLCJ0b2RheUluZm8iLCJwcmV2SW5mbyIsIm5leHRJbmZvIiwidG9vbGJhclByb3BzIiwiYWRkU2Nyb2xsIiwicXVlcnlTY3JvbGwiLCJ2aWV3UHJvcHMiLCJ0cmFuc2Zvcm1lcnMiLCJ0cmFuc2Zvcm1lcnNfMSIsInRyYW5zZm9ybWVyIiwidHJhbnNmb3JtIiwiaXNSZXNpemUiLCJpc0hlaWdodEF1dG8iLCJjb21wdXRlSGVpZ2h0VmFycyIsInZpZXdIZWlnaHQiLCJ1cGRhdGVOb3dJbmRpY2F0b3IiLCJwb3BTY3JvbGwiLCJoZWlnaHRJbnB1dCIsImNvbnRlbnRIZWlnaHRJbnB1dCIsInF1ZXJ5VG9vbGJhcnNIZWlnaHQiLCJwYXJlbnRFbCIsInZpZXdPcHRpb25zIiwidGl0bGVGb3JtYXQiLCJjb21wdXRlVGl0bGVGb3JtYXQiLCJ0aGVDbGFzc2VzIiwiSW50ZXJhY3Rpb24iLCJwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MiLCJ1c2VFdmVudENlbnRlciIsImludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlIiwiaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIiwiRXZlbnRDbGlja2luZyIsImhhbmRsZVNlZ0NsaWNrIiwiaGFzVXJsQ29udGFpbmVyIiwicXVlcnlTZWxlY3RvciIsImhyZWYiLCJqc0V2ZW50IiwiZGVmYXVsdFByZXZlbnRlZCIsImxvY2F0aW9uIiwiRXZlbnRIb3ZlcmluZyIsImhhbmRsZUV2ZW50RWxSZW1vdmUiLCJjdXJyZW50U2VnRWwiLCJoYW5kbGVTZWdMZWF2ZSIsImhhbmRsZVNlZ0VudGVyIiwidHJpZ2dlckV2ZW50IiwicmVtb3ZlSG92ZXJMaXN0ZW5lcnMiLCJwdWJsaWNFdk5hbWUiLCJTdGFuZGFyZFRoZW1lIiwid2lkZ2V0Iiwid2lkZ2V0SGVhZGVyIiwid2lkZ2V0Q29udGVudCIsImJ1dHRvbkdyb3VwIiwiYnV0dG9uIiwiYnV0dG9uQWN0aXZlIiwicG9wb3ZlckhlYWRlciIsInBvcG92ZXJDb250ZW50IiwiaGVhZGVyUm93IiwiZGF5Um93IiwibGlzdFZpZXciLCJjbG9zZSIsIkNhbGVuZGFyIiwiYnVpbGREYXRlRW52IiwiYnVpbGRUaGVtZSIsImJ1aWxkRXZlbnRVaVNpbmdsZUJhc2UiLCJfYnVpbGRFdmVudFVpU2luZ2xlQmFzZSIsImJ1aWxkU2VsZWN0aW9uQ29uZmlnIiwiX2J1aWxkU2VsZWN0aW9uQ29uZmlnIiwiYnVpbGRFdmVudFVpQnlTb3VyY2UiLCJidWlsZEV2ZW50VWlCYXNlcyIsImludGVyYWN0aW9uc1N0b3JlIiwiYWN0aW9uUXVldWUiLCJpc1JlZHVjaW5nIiwibmVlZHNSZXJlbmRlciIsIm5lZWRzRnVsbFJlcmVuZGVyIiwiaXNSZW5kZXJpbmciLCJyZW5kZXJpbmdQYXVzZURlcHRoIiwiYnVpbGREZWxheWVkUmVyZW5kZXIiLCJpc1ZpZXdVcGRhdGVkIiwiaXNEYXRlc1VwZGF0ZWQiLCJpc0V2ZW50c1VwZGF0ZWQiLCJoYW5kbGVPcHRpb25zIiwiaHlkcmF0ZSIsImNhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyIsInBsdWdpbkRlZnMiLCJwbHVnaW5EZWZzXzEiLCJwbHVnaW5EZWYiLCJyZW5kZXJhYmxlRXZlbnRTdG9yZSIsImJpbmRIYW5kbGVycyIsImV4ZWN1dGVSZW5kZXIiLCJyZXF1ZXN0UmVyZW5kZXIiLCJ1bmJpbmRIYW5kbGVycyIsInJlbW92ZU5hdkxpbmtMaXN0ZW5lciIsImFuY2hvckVsIiwiZ2V0QXR0cmlidXRlIiwiY3VzdG9tQWN0aW9uIiwidmlld09wdCIsInpvb21UbyIsIndpbmRvd1Jlc2l6ZVByb3h5Iiwid2luZG93UmVzaXplIiwiYnVpbGRJbml0aWFsU3RhdGUiLCJyYXdTb3VyY2VzIiwic2luZ2xlUmF3U291cmNlIiwicmF3U291cmNlc18xIiwicmF3U291cmNlIiwiYmF0Y2hSZW5kZXJpbmciLCJnZXRJbml0aWFsRGF0ZSIsIm9sZFN0YXRlIiwic2hpZnQiLCJuZXdTdGF0ZSIsIm5lZWRzRnVsbCIsImRlbGF5ZWRSZXJlbmRlciIsInRyeVJlcmVuZGVyIiwicmVuZGVyQ29tcG9uZW50Iiwic2F2ZWRTY3JvbGwiLCJldmVudFVpU2luZ2xlQmFzZSIsImV2ZW50VWlCeVNvdXJjZSIsImFwcGx5U2Nyb2xsIiwicmVsZWFzZUFmdGVyU2l6aW5nVHJpZ2dlcnMiLCJzZXRPcHRpb24iLCJtdXRhdGVPcHRpb25zIiwiZ2V0T3B0aW9uIiwidmlld09wdHMiLCJjaGFuZ2VIYW5kbGVycyIsIm5vcm1hbFVwZGF0ZXMiLCJzcGVjaWFsVXBkYXRlcyIsImlzVGltZVpvbmVEaXJ0eSIsImlzU2l6ZURpcnR5IiwiYW55RGlmZmljdWx0T3B0aW9ucyIsIm5hbWVfMyIsInBsdWdpbkhvb2tzIiwicmVyZW5kZXJEZWxheSIsImF2YWlsYWJsZVJhd0xvY2FsZXMiLCJkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIiwiZ2V0QXZhaWxhYmxlTG9jYWxlQ29kZXMiLCJyYXdPcHRzIiwiZXZlbnRFZGl0YWJsZSIsIm9wdEhhbmRsZXIiLCJuYW1lXzQiLCJpc1ZhbGlkVmlld1R5cGUiLCJkYXRlT3JSYW5nZSIsInVuc2VsZWN0Iiwic3BlYyIsImdldFVuaXRWaWV3U3BlYyIsInZpZXdUeXBlcyIsImRlZmF1bHREYXRlSW5wdXQiLCJnb3RvRGF0ZSIsInpvbmVkRGF0ZUlucHV0IiwiaW5jcmVtZW50RGF0ZSIsImZvcm1hdERhdGUiLCJpc0hhbmRsaW5nV2luZG93UmVzaXplIiwicmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsInNldHRpbmdzSW5wdXQiLCJERUZBVUxUX0lOVEVSQUNUSU9OUyIsImludGVyYWN0aW9uQ2xhc3NlcyIsImludGVyYWN0aW9ucyIsImludGVyYWN0aW9uQ2xhc3MiLCJ1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJsaXN0ZW5lciIsInNlbGVjdCIsImRhdGVPck9iaiIsImVuZERhdGUiLCJzZWxlY3Rpb25JbnB1dCIsInRyaWdnZXJEYXRlU2VsZWN0IiwicGV2IiwidHJpZ2dlckRhdGVVbnNlbGVjdCIsIm9yaWdFdmVudCIsInRyaWdnZXJEYXRlQ2xpY2siLCJkYXlFbCIsInNvdXJjZUlucHV0Iiwic291cmNlQXBpIiwiZ2V0RXZlbnRTb3VyY2VCeUlkIiwiZ2V0RXZlbnRCeUlkIiwiZ2V0RXZlbnRzIiwiZXZlbnRBcGlzIiwicmVtb3ZlQWxsRXZlbnRzIiwicmVyZW5kZXJFdmVudHMiLCJnZXRFdmVudFNvdXJjZXMiLCJzb3VyY2VBcGlzIiwiaW50ZXJuYWxJZCIsInJlbW92ZUFsbEV2ZW50U291cmNlcyIsInJlZmV0Y2hFdmVudHMiLCJzY3JvbGxUb1RpbWUiLCJ0aW1lSW5wdXQiLCJzY3JvbGxUb0R1cmF0aW9uIiwidGhlbWVDbGFzcyIsIlZpZXciLCJyZW5kZXJEYXRlc01lbSIsInJlbmRlckRhdGVzV3JhcCIsInVucmVuZGVyRGF0ZXNXcmFwIiwicmVuZGVyQnVzaW5lc3NIb3Vyc01lbSIsInJlbmRlckJ1c2luZXNzSG91cnMiLCJ1bnJlbmRlckJ1c2luZXNzSG91cnMiLCJyZW5kZXJEYXRlU2VsZWN0aW9uTWVtIiwicmVuZGVyRGF0ZVNlbGVjdGlvbldyYXAiLCJ1bnJlbmRlckRhdGVTZWxlY3Rpb25XcmFwIiwicmVuZGVyRXZlbnRzTWVtIiwicmVuZGVyRXZlbnRzIiwidW5yZW5kZXJFdmVudHMiLCJyZW5kZXJFdmVudFNlbGVjdGlvbk1lbSIsInJlbmRlckV2ZW50U2VsZWN0aW9uV3JhcCIsInVucmVuZGVyRXZlbnRTZWxlY3Rpb25XcmFwIiwicmVuZGVyRXZlbnREcmFnTWVtIiwicmVuZGVyRXZlbnREcmFnV3JhcCIsInVucmVuZGVyRXZlbnREcmFnV3JhcCIsInJlbmRlckV2ZW50UmVzaXplTWVtIiwicmVuZGVyRXZlbnRSZXNpemVXcmFwIiwidW5yZW5kZXJFdmVudFJlc2l6ZVdyYXAiLCJldmVudE9yZGVyU3BlY3MiLCJpbml0aWFsaXplIiwiaXNBdXRvIiwidXBkYXRlQmFzZVNpemUiLCJyZW5kZXJEYXRlcyIsInN0YXJ0Tm93SW5kaWNhdG9yIiwic3RvcE5vd0luZGljYXRvciIsInVucmVuZGVyRGF0ZXMiLCJyZW5kZXJEYXRlU2VsZWN0aW9uIiwidW5yZW5kZXJEYXRlU2VsZWN0aW9uIiwic2xpY2VFdmVudHMiLCJjb21wdXRlRXZlbnREcmFnZ2FibGUiLCJldmVudFVpIiwiY29tcHV0ZUV2ZW50U3RhcnRSZXNpemFibGUiLCJjb21wdXRlRXZlbnRFbmRSZXNpemFibGUiLCJyZW5kZXJFdmVudFNlbGVjdGlvbiIsInVucmVuZGVyRXZlbnRTZWxlY3Rpb24iLCJyZW5kZXJFdmVudERyYWciLCJ1bnJlbmRlckV2ZW50RHJhZyIsInJlbmRlckV2ZW50UmVzaXplIiwidW5yZW5kZXJFdmVudFJlc2l6ZSIsInVwZGF0ZSIsImRlbGF5IiwiZ2V0Tm93SW5kaWNhdG9yVW5pdCIsImluaXRpYWxOb3dEYXRlIiwiaW5pdGlhbE5vd1F1ZXJpZWRNcyIsIm5vd0luZGljYXRvclRpbWVvdXRJRCIsIm5vd0luZGljYXRvckludGVydmFsSUQiLCJzZXRJbnRlcnZhbCIsInVucmVuZGVyTm93SW5kaWNhdG9yIiwicmVuZGVyTm93SW5kaWNhdG9yIiwiaXNOb3dJbmRpY2F0b3JSZW5kZXJlZCIsImNsZWFyVGltZW91dCIsImNsZWFySW50ZXJ2YWwiLCJxdWV1ZWRTY3JvbGwiLCJhcHBseVF1ZXVlZFNjcm9sbCIsInF1ZXJ5RGF0ZVNjcm9sbCIsImNvbXB1dGVEYXRlU2Nyb2xsIiwiYXBwbHlEYXRlU2Nyb2xsIiwiRmdFdmVudFJlbmRlcmVyIiwicmVuZGVyU2VncyIsIm1pcnJvckluZm8iLCJyYW5nZVVwZGF0ZWQiLCJyZW5kZXJTZWdFbHMiLCJhdHRhY2hTZWdzIiwiX3NlZ3MiLCJkZXRhY2hTZWdzIiwiZGlzcGxheUV2ZW50VGltZSIsImRpc3BsYXlFdmVudEVuZCIsImV2ZW50VGltZUZvcm1hdCIsImNvbXB1dGVFdmVudFRpbWVGb3JtYXQiLCJjb21wdXRlRGlzcGxheUV2ZW50VGltZSIsImNvbXB1dGVEaXNwbGF5RXZlbnRFbmQiLCJyZW5kZXJTZWdIdG1sIiwiZ2V0U2VnQ2xhc3NlcyIsImlzRHJhZ2dhYmxlIiwiaXNSZXNpemFibGUiLCJpc0RyYWdnaW5nIiwiaXNSZXNpemluZyIsImdldFRpbWVUZXh0IiwiZGlzcGxheUVuZCIsIl9nZXRUaW1lVGV4dCIsImdldFNraW5Dc3MiLCJzb3J0RXZlbnRTZWdzIiwib2JqcyIsImJ1aWxkU2VnQ29tcGFyZU9iaiIsImMiLCJfc2VnIiwiY29tcHV0ZVNpemVzIiwiZm9yY2UiLCJjb21wdXRlU2VnU2l6ZXMiLCJhc3NpZ25TaXplcyIsImFzc2lnblNlZ1NpemVzIiwiaGlkZUJ5SGFzaCIsInZpc2liaWxpdHkiLCJzaG93QnlIYXNoIiwic2VsZWN0QnlJbnN0YW5jZUlkIiwidW5zZWxlY3RCeUluc3RhbmNlSWQiLCJGaWxsUmVuZGVyZXIiLCJmaWxsU2VnVGFnIiwiZGlydHlTaXplRmxhZ3MiLCJjb250YWluZXJFbHNCeVR5cGUiLCJzZWdzQnlUeXBlIiwiZ2V0U2Vnc0J5VHlwZSIsInJlbmRlcmVkU2VncyIsImNvbnRhaW5lckVscyIsImNzcyIsInRvTG93ZXJDYXNlIiwiTmFtZWRUaW1lWm9uZUltcGwiLCJFbGVtZW50RHJhZ2dpbmciLCJlbWl0dGVyIiwic2V0TWlycm9ySXNWaXNpYmxlIiwic2V0TWlycm9yTmVlZHNSZXZlcnQiLCJzZXRBdXRvU2Nyb2xsRW5hYmxlZCIsImRhdGVJbnB1dCIsImJ1aWxkRGF0ZUVudiQxIiwiZGF0ZU1ldGEiLCJEUkFHX01FVEFfUFJPUFMiLCJEUkFHX01FVEFfREVGQVVMVFMiLCJwYXJzZURyYWdNZXRhIiwiY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0IiwiZGF0ZXNSZXBEaXN0aW5jdERheXMiLCJyZW5kZXJEYXRlQ2VsbCIsImNvbENudCIsImNvbEhlYWRGb3JtYXQiLCJjb2xzcGFuIiwib3RoZXJBdHRycyIsImlzRGF0ZVZhbGlkIiwiY29sdW1uSGVhZGVySHRtbCIsImNvbHVtbkhlYWRlclRleHQiLCJEYXlIZWFkZXIiLCJ0aGVhZCIsImRhdGVzIiwicmVuZGVySW50cm9IdG1sIiwiZGF0ZXNfMSIsIkRheVNlcmllcyIsImluZGljZXMiLCJkYXlJbmRleCIsInNsaWNlUmFuZ2UiLCJmaXJzdEluZGV4IiwiZ2V0RGF0ZURheUluZGV4IiwibGFzdEluZGV4IiwiY2xpcHBlZEZpcnN0SW5kZXgiLCJjbGlwcGVkTGFzdEluZGV4IiwiY2VpbCIsImRheU9mZnNldCIsIkRheVRhYmxlIiwiZGF5U2VyaWVzIiwiYnJlYWtPbldlZWtzIiwiZGF5c1BlclJvdyIsInJvd0NudCIsImNlbGxzIiwiYnVpbGRDZWxscyIsImhlYWRlckRhdGVzIiwiYnVpbGRIZWFkZXJEYXRlcyIsInJvd3MiLCJyb3ciLCJjb2wiLCJidWlsZENlbGwiLCJzZXJpZXNTZWciLCJpbmRleCIsIm5leHRJbmRleCIsImZpcnN0Q29sIiwibGFzdENvbCIsIlNsaWNlciIsInNsaWNlQnVzaW5lc3NIb3VycyIsIl9zbGljZUJ1c2luZXNzSG91cnMiLCJzbGljZURhdGVTZWxlY3Rpb24iLCJfc2xpY2VEYXRlU3BhbiIsIl9zbGljZUV2ZW50U3RvcmUiLCJzbGljZUV2ZW50RHJhZyIsIl9zbGljZUludGVyYWN0aW9uIiwic2xpY2VFdmVudFJlc2l6ZSIsInNsaWNlUHJvcHMiLCJleHRyYUFyZ3MiLCJldmVudFNlZ3MiLCJkYXRlU2VsZWN0aW9uU2VncyIsImJ1c2luZXNzSG91clNlZ3MiLCJmZ0V2ZW50U2VncyIsImJnRXZlbnRTZWdzIiwic2xpY2VOb3dEYXRlIiwiY29tcHV0ZUFjdGl2ZVJhbmdlIiwicmFuZ2VSZXMiLCJzbGljZUV2ZW50UmFuZ2VzIiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJzb3VyY2VTZWciLCJldmVudFJhbmdlcyIsImV2ZW50UmFuZ2VzXzEiLCJzbGljZUV2ZW50UmFuZ2UiLCJpc0NvbXBvbmVudEFsbERheSIsInZlcnNpb24iLCJwYXJzZU1hcmtlciIsInJlcXVpcmUiLCJjb3JlIiwiRGF5R3JpZERhdGVQcm9maWxlR2VuZXJhdG9yIiwiZW5kT2ZXZWVrIiwibW9udGhNb2RlIiwiZml4ZWRXZWVrQ291bnQiLCJQb3BvdmVyIiwiaXNIaWRkZW4iLCJtYXJnaW4iLCJkb2N1bWVudE1vdXNlZG93biIsImhpZGUiLCJzaG93IiwiYXV0b0hpZGUiLCJlbERpbXMiLCJvcmlnaW4iLCJvZmZzZXRQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJTaW1wbGVEYXlHcmlkRXZlbnRSZW5kZXJlciIsImlzUmVzaXphYmxlRnJvbVN0YXJ0IiwiaXNSZXNpemFibGVGcm9tRW5kIiwic2tpbkNzcyIsInRpbWVIdG1sIiwidGltZVRleHQiLCJ0aXRsZUh0bWwiLCJEYXlHcmlkRXZlbnRSZW5kZXJlciIsImRheUdyaWQiLCJyb3dTdHJ1Y3RzIiwicmVuZGVyU2VnUm93cyIsInJvd0VscyIsInJvd05vZGUiLCJ0Ym9keUVsIiwicmVtb3ZlU2VnUG9wb3ZlciIsInJvd1N0cnVjdCIsInBvcCIsInNlZ1Jvd3MiLCJncm91cFNlZ1Jvd3MiLCJyZW5kZXJTZWdSb3ciLCJyb3dTZWdzIiwic2VnTGV2ZWxzIiwiYnVpbGRTZWdMZXZlbHMiLCJsZXZlbENudCIsInRib2R5Iiwic2VnTWF0cml4IiwiY2VsbE1hdHJpeCIsImxvbmVDZWxsTWF0cml4IiwibGV2ZWxTZWdzIiwidHIiLCJ0ZCIsImVtcHR5Q2VsbHNVbnRpbCIsImVuZENvbCIsImxlZnRDb2wiLCJyaWdodENvbCIsImludHJvSHRtbCIsInJlbmRlclByb3BzIiwibGV2ZWxzIiwiaXNEYXlTZWdDb2xsaXNpb24iLCJsZXZlbCIsImNvbXBhcmVEYXlTZWdDb2xzIiwib3RoZXJTZWdzIiwib3RoZXJTZWciLCJEYXlHcmlkTWlycm9yUmVuZGVyZXIiLCJza2VsZXRvbkVsIiwic2tlbGV0b25Ub3BFbCIsInNrZWxldG9uVG9wIiwiRU1QVFlfQ0VMTF9IVE1MIiwiRGF5R3JpZEZpbGxSZW5kZXJlciIsInJlbmRlckZpbGxSb3ciLCJzdGFydENvbCIsInRyRWwiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIkRheVRpbGUiLCJldmVudFJlbmRlcmVyIiwiRGF5VGlsZUV2ZW50UmVuZGVyZXIiLCJyZW5kZXJGcmFtZSIsIl9yZW5kZXJGcmFtZSIsInJlbmRlckZnRXZlbnRzIiwiZmdTZWdzIiwiZXZlbnREcmFnSW5zdGFuY2VzIiwiZXZlbnRSZXNpemVJbnN0YW5jZXMiLCJzZWdDb250YWluZXJFbCIsImxheWVyIiwiZGF5VGlsZSIsIkRheUJnUm93IiwicmVuZGVySHRtbCIsImNlbGwiLCJyZW5kZXJDZWxsSHRtbCIsImh0bWxBdHRycyIsIkRBWV9OVU1fRk9STUFUIiwiV0VFS19OVU1fRk9STUFUIiwiRGF5R3JpZCIsImJvdHRvbUNvb3JkUGFkZGluZyIsImlzQ2VsbFNpemVzRGlydHkiLCJmaWxsUmVuZGVyZXIiLCJtaXJyb3JSZW5kZXJlciIsInJlbmRlckNlbGxzIiwiX3JlbmRlckNlbGxzIiwiX3VucmVuZGVyQ2VsbHMiLCJyZW5kZXJCZ0V2ZW50cyIsIl9yZW5kZXJFdmVudERyYWciLCJfdW5yZW5kZXJFdmVudERyYWciLCJfcmVuZGVyRXZlbnRSZXNpemUiLCJfdW5yZW5kZXJFdmVudFJlc2l6ZSIsImlzUmlnaWQiLCJzZWdQb3BvdmVyVGlsZSIsInVwZGF0ZVNlZ1BvcG92ZXJUaWxlIiwiZ2V0Q2VsbFJhbmdlIiwib3duUHJvcHMiLCJyZW5kZXJEYXlSb3dIdG1sIiwiY2VsbEVscyIsInJvd1Bvc2l0aW9ucyIsImNvbFBvc2l0aW9ucyIsImdldENlbGxFbCIsImJnUm93IiwicmVuZGVyQmdJbnRyb0h0bWwiLCJnZXRJc051bWJlcnNWaXNpYmxlIiwicmVuZGVyTnVtYmVyVHJIdG1sIiwiZ2V0SXNEYXlOdW1iZXJzVmlzaWJsZSIsImNlbGxXZWVrTnVtYmVyc1Zpc2libGUiLCJjb2xXZWVrTnVtYmVyc1Zpc2libGUiLCJpbnRybyIsInJlbmRlck51bWJlckludHJvSHRtbCIsInJlbmRlck51bWJlckNlbGxzSHRtbCIsImh0bWxzIiwicmVuZGVyTnVtYmVyQ2VsbEh0bWwiLCJpc0RheU51bWJlclZpc2libGUiLCJ3ZWVrQ2FsY0ZpcnN0RG93IiwiYnVpbGRDb2xQb3NpdGlvbnMiLCJidWlsZFJvd1Bvc2l0aW9ucyIsInBvc2l0aW9uVG9IaXQiLCJyZWxhdGl2ZVJlY3QiLCJzZWdQb3BvdmVyIiwibGltaXRSb3dzIiwibGV2ZWxMaW1pdCIsInJvd0xldmVsTGltaXQiLCJ1bmxpbWl0Um93IiwiY29tcHV0ZVJvd0xldmVsTGltaXQiLCJsaW1pdFJvdyIsInJvd0JvdHRvbSIsInRyRWxzIiwibW9yZU5vZGVzIiwibGltaXRlZE5vZGVzIiwic2Vnc0JlbG93IiwidG90YWxTZWdzQmVsb3ciLCJjb2xTZWdzQmVsb3ciLCJzZWdNb3JlTm9kZXMiLCJtb3JlVGQiLCJtb3JlV3JhcCIsIm1vcmVMaW5rIiwiZ2V0Q2VsbFNlZ3MiLCJyZW5kZXJNb3JlTGluayIsIm5vZGUiLCJtb3JlRWxzIiwibGltaXRlZEVscyIsImxpbWl0ZWRFbCIsImhpZGRlblNlZ3MiLCJnZXRNb3JlTGlua1RleHQiLCJjbGlja09wdGlvbiIsIl9jb2wiLCJtb3JlRWwiLCJjdXJyZW50VGFyZ2V0IiwiYWxsU2VncyIsInJlc2xpY2VkQWxsU2VncyIsInJlc2xpY2VEYXlTZWdzIiwicmVzbGljZWRIaWRkZW5TZWdzIiwic2hvd1NlZ1BvcG92ZXIiLCJ0b3BFbCIsImRheURhdGUiLCJkYXlFbmQiLCJkYXlSYW5nZSIsIm5ld1NlZ3MiLCJzdGFydExldmVsIiwiV0VFS19OVU1fRk9STUFUJDEiLCJEYXlHcmlkVmlldyIsInJlbmRlckhlYWRJbnRyb0h0bWwiLCJ3ZWVrTnVtYmVyU3R5bGVBdHRyIiwicmVuZGVyRGF5R3JpZE51bWJlckludHJvSHRtbCIsIndlZWtTdGFydCIsInJlbmRlckRheUdyaWRCZ0ludHJvSHRtbCIsInJlbmRlckRheUdyaWRJbnRyb0h0bWwiLCJyZW5kZXJTa2VsZXRvbkh0bWwiLCJzY3JvbGxlciIsImRheUdyaWRDb250YWluZXJFbCIsImRheUdyaWRFbCIsIndlZWtOdW1iZXJXaWR0aCIsImhhc1JpZ2lkUm93cyIsImhlYWRSb3dFbCIsInNjcm9sbGVySGVpZ2h0IiwiY29tcHV0ZVNjcm9sbGVySGVpZ2h0Iiwic2V0R3JpZEhlaWdodCIsIlNpbXBsZURheUdyaWQiLCJzbGljZXIiLCJEYXlHcmlkU2xpY2VyIiwiZGF5VGFibGUiLCJyYXdIaXQiLCJEYXlHcmlkVmlldyQxIiwiX2NvbnRleHQiLCJidWlsZERheVRhYmxlIiwic2ltcGxlRGF5R3JpZCIsIm1haW4iLCJkYXlHcmlkRGF5IiwiZGF5R3JpZFdlZWsiLCJkYXlHcmlkTW9udGgiLCJBYnN0cmFjdERheUdyaWRWaWV3IiwiYnVpbGRCYXNpY0RheVRhYmxlIiwidG91Y2hNb3VzZUlnbm9yZVdhaXQiLCJpZ25vcmVNb3VzZURlcHRoIiwibGlzdGVuZXJDbnQiLCJpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCIsIlBvaW50ZXJEcmFnZ2luZyIsImNvbnRhaW5lckVsIiwic3ViamVjdEVsIiwiZG93bkVsIiwiaGFuZGxlU2VsZWN0b3IiLCJzaG91bGRJZ25vcmVNb3ZlIiwic2hvdWxkV2F0Y2hTY3JvbGwiLCJpc1RvdWNoRHJhZ2dpbmciLCJ3YXNUb3VjaFNjcm9sbCIsImhhbmRsZU1vdXNlRG93biIsInNob3VsZElnbm9yZU1vdXNlIiwiaXNQcmltYXJ5TW91c2VCdXR0b24iLCJ0cnlTdGFydCIsImNyZWF0ZUV2ZW50RnJvbU1vdXNlIiwiaW5pdFNjcm9sbFdhdGNoIiwiaGFuZGxlTW91c2VNb3ZlIiwiaGFuZGxlTW91c2VVcCIsInJlY29yZENvb3JkcyIsImNsZWFudXAiLCJoYW5kbGVUb3VjaFN0YXJ0IiwiY3JlYXRlRXZlbnRGcm9tVG91Y2giLCJoYW5kbGVUb3VjaE1vdmUiLCJoYW5kbGVUb3VjaEVuZCIsImhhbmRsZVRvdWNoU2Nyb2xsIiwic3RhcnRJZ25vcmluZ01vdXNlIiwiaGFuZGxlU2Nyb2xsIiwicGFnZVgiLCJwcmV2U2Nyb2xsWCIsInByZXZQYWdlWCIsInBhZ2VZIiwicHJldlNjcm9sbFkiLCJwcmV2UGFnZVkiLCJpc1RvdWNoIiwib3JpZ1BhZ2VYIiwib3JpZ1BhZ2VZIiwicGFzc2l2ZSIsImxpc3RlbmVyQ3JlYXRlZCIsImxpc3RlbmVyRGVzdHJveWVkIiwicXVlcnlTdWJqZWN0RWwiLCJkZXN0cm95U2Nyb2xsV2F0Y2giLCJjYW5jZWxUb3VjaFNjcm9sbCIsImlzRmlyc3QiLCJ0b3VjaGVzIiwiY3RybEtleSIsIm9uV2luZG93VG91Y2hNb3ZlIiwiRWxlbWVudE1pcnJvciIsImlzVmlzaWJsZSIsInNvdXJjZUVsIiwibWlycm9yRWwiLCJzb3VyY2VFbFJlY3QiLCJ6SW5kZXgiLCJyZXZlcnREdXJhdGlvbiIsIm9yaWdTY3JlZW5YIiwib3JpZ1NjcmVlblkiLCJ1cGRhdGVFbFBvc2l0aW9uIiwiaGFuZGxlTW92ZSIsInNldElzVmlzaWJsZSIsInN0b3AiLCJuZWVkc1JldmVydEFuaW1hdGlvbiIsImRvbmUiLCJkb1JldmVydEFuaW1hdGlvbiIsImZpbmFsU291cmNlRWxSZWN0IiwidHJhbnNpdGlvbiIsImdldE1pcnJvckVsIiwiY2xvbmVOb2RlIiwiYm94U2l6aW5nIiwiU2Nyb2xsR2VvbUNhY2hlIiwic2Nyb2xsQ29udHJvbGxlciIsImRvZXNMaXN0ZW5pbmciLCJoYW5kbGVTY3JvbGxDaGFuZ2UiLCJvcmlnU2Nyb2xsVG9wIiwib3JpZ1Njcm9sbExlZnQiLCJjbGllbnRSZWN0IiwiY29tcHV0ZUNsaWVudFJlY3QiLCJnZXRFdmVudFRhcmdldCIsIkVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUiLCJXaW5kb3dTY3JvbGxHZW9tQ2FjaGUiLCJnZXRUaW1lIiwicGVyZm9ybWFuY2UiLCJBdXRvU2Nyb2xsZXIiLCJpc0VuYWJsZWQiLCJzY3JvbGxRdWVyeSIsImVkZ2VUaHJlc2hvbGQiLCJtYXhWZWxvY2l0eSIsInBvaW50ZXJTY3JlZW5YIiwicG9pbnRlclNjcmVlblkiLCJpc0FuaW1hdGluZyIsInNjcm9sbENhY2hlcyIsImV2ZXJNb3ZlZFVwIiwiZXZlck1vdmVkRG93biIsImV2ZXJNb3ZlZExlZnQiLCJldmVyTW92ZWRSaWdodCIsImFuaW1hdGUiLCJlZGdlIiwiY29tcHV0ZUJlc3RFZGdlIiwiaGFuZGxlU2lkZSIsIm1zU2luY2VSZXF1ZXN0IiwicmVxdWVzdEFuaW1hdGlvbiIsImJ1aWxkQ2FjaGVzIiwieURlbHRhIiwieERlbHRhIiwic2Nyb2xsQ2FjaGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJpbnZEaXN0YW5jZSIsImRpc3RhbmNlIiwidmVsb2NpdHkiLCJiZXN0U2lkZSIsImxlZnREaXN0IiwicmlnaHREaXN0IiwidG9wRGlzdCIsImJvdHRvbURpc3QiLCJxdWVyeVNjcm9sbEVscyIsInF1ZXJ5IiwiRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyIsIm1pbkRpc3RhbmNlIiwidG91Y2hTY3JvbGxBbGxvd2VkIiwibWlycm9yTmVlZHNSZXZlcnQiLCJpc0ludGVyYWN0aW5nIiwiaXNEZWxheUVuZGVkIiwiaXNEaXN0YW5jZVN1cnBhc3NlZCIsImRlbGF5VGltZW91dElkIiwib25Qb2ludGVyRG93biIsInBvaW50ZXIiLCJtaXJyb3IiLCJzdGFydERlbGF5IiwiaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQiLCJvblBvaW50ZXJNb3ZlIiwiZGlzdGFuY2VTcSIsImF1dG9TY3JvbGxlciIsIm9uUG9pbnRlclVwIiwidHJ5U3RvcERyYWciLCJoYW5kbGVEZWxheUVuZCIsInRyeVN0YXJ0RHJhZyIsInN0b3BEcmFnIiwic2V0SWdub3JlTW92ZSIsIk9mZnNldFRyYWNrZXIiLCJvcmlnUmVjdCIsImNvbXB1dGVMZWZ0IiwiY29tcHV0ZVRvcCIsImlzV2l0aGluQ2xpcHBpbmciLCJpc0lnbm9yZWRDbGlwcGluZyIsIkhpdERyYWdnaW5nIiwiZHJhZ2dpbmciLCJkcm9wcGFibGVTdG9yZSIsInVzZVN1YmplY3RDZW50ZXIiLCJyZXF1aXJlSW5pdGlhbCIsImluaXRpYWxIaXQiLCJtb3ZpbmdIaXQiLCJmaW5hbEhpdCIsImhhbmRsZVBvaW50ZXJEb3duIiwicHJlcGFyZUhpdHMiLCJwcm9jZXNzRmlyc3RDb29yZCIsImhhbmRsZURyYWdTdGFydCIsImhhbmRsZURyYWdNb3ZlIiwiaGFuZGxlUG9pbnRlclVwIiwicmVsZWFzZUhpdHMiLCJoYW5kbGVEcmFnRW5kIiwib3JpZ1BvaW50IiwiYWRqdXN0ZWRQb2ludCIsInN1YmplY3RSZWN0IiwicXVlcnlIaXRGb3JPZmZzZXQiLCJzbGljZWRTdWJqZWN0UmVjdCIsImNvb3JkQWRqdXN0IiwiZm9yY2VIYW5kbGUiLCJoaXQiLCJpc0hpdHNFcXVhbCIsIm9mZnNldFRyYWNrZXJzIiwiaW50ZXJhY3Rpb25TZXR0aW5ncyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJiZXN0SGl0Iiwib2Zmc2V0VHJhY2tlciIsIm9yaWdpbkxlZnQiLCJvcmlnaW5Ub3AiLCJoaXQwIiwiaGl0MSIsIkRhdGVDbGlja2luZyIsImhpdERyYWdnaW5nIiwiRGF0ZVNlbGVjdGluZyIsImRyYWdTZWxlY3Rpb24iLCJjYW5TZWxlY3QiLCJnZXRDb21wb25lbnRUb3VjaERlbGF5IiwiaGFuZGxlSGl0VXBkYXRlIiwiaXNGaW5hbCIsImlzSW52YWxpZCIsImpvaW5IaXRzSW50b1NlbGVjdGlvbiIsImRhdGVTcGFuMCIsImRhdGVTcGFuMSIsImRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnNfMSIsIkV2ZW50RHJhZ2dpbmciLCJzdWJqZWN0U2VnIiwicmVsZXZhbnRFdmVudHMiLCJyZWNlaXZpbmdDYWxlbmRhciIsInZhbGlkTXV0YXRpb24iLCJtdXRhdGVkUmVsZXZhbnRFdmVudHMiLCJvcmlnVGFyZ2V0IiwiaW5pdGlhbENhbGVuZGFyIiwiZ2V0Q29tcG9uZW50VG91Y2hEZWxheSQxIiwicmVjZWl2aW5nQ29tcG9uZW50IiwiY29tcHV0ZUV2ZW50TXV0YXRpb24iLCJkaXNwbGF5RHJhZyIsImluaXRpYWxDYWxlbmRhcl8xIiwiaW5pdGlhbFZpZXciLCJyZWxldmFudEV2ZW50c18xIiwiY2xlYXJEcmFnIiwidHJhbnNmb3JtZWQiLCJldmVudERyb3BBcmciLCJvbGRFdmVudCIsInJldmVydCIsImRyYWdnZWRFbCIsImRyb3BBcmciLCJTRUxFQ1RPUiIsIm5leHRDYWxlbmRhciIsInByZXZDYWxlbmRhciIsIm1hc3NhZ2VycyIsIm1hc3NhZ2Vyc18xIiwibWFzc2FnZXIiLCJFdmVudERyYWdnaW5nJDEiLCJkcmFnZ2luZ1NlZyIsInF1ZXJ5U2VnIiwiY29tcHV0ZU11dGF0aW9uIiwicHJldkV2ZW50IiwiaXNGcm9tU3RhcnQiLCJ0cmFuc2Zvcm1zIiwidHJhbnNmb3Jtc18xIiwiVW5zZWxlY3RBdXRvIiwiaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCIsIm9uU2VsZWN0Iiwic2VsZWN0SW5mbyIsIm9uRG9jdW1lbnRQb2ludGVyVXAiLCJkb2N1bWVudFBvaW50ZXIiLCJ1bnNlbGVjdENhbmNlbCIsIkV4dGVybmFsRWxlbWVudERyYWdnaW5nIiwic3VwcGxpZWREcmFnTWV0YSIsImRyb3BwYWJsZUV2ZW50IiwiZHJhZ01ldGEiLCJidWlsZERyYWdNZXRhIiwiY2FuRHJvcEVsT25DYWxlbmRhciIsImNvbXB1dGVFdmVudEZvckRhdGVTcGFuIiwiZmluYWxWaWV3IiwiZ2V0RHJhZ01ldGFGcm9tRWwiLCJkZWZQcm9wcyIsImdldEVtYmVkZGVkRWxEYXRhIiwiZGF0YUF0dHJQcmVmaXgiLCJwcmVmaXhlZE5hbWUiLCJFeHRlcm5hbERyYWdnYWJsZSIsIml0ZW1TZWxlY3RvciIsImFwcGVuZFRvIiwiZXZlbnREYXRhIiwiSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmciLCJtaXJyb3JTZWxlY3RvciIsImN1cnJlbnRNaXJyb3JFbCIsImhhbmRsZVBvaW50ZXJNb3ZlIiwiVGhpcmRQYXJ0eURyYWdnYWJsZSIsImNvbnRhaW5lck9yU2V0dGluZ3MiLCJEcmFnZ2FibGUiLCJMaXN0RXZlbnRSZW5kZXJlciIsInJlbmRlckVtcHR5TWVzc2FnZSIsInJlbmRlclNlZ0xpc3QiLCJiZ0NvbG9yIiwiTGlzdFZpZXciLCJjb21wdXRlRGF0ZVZhcnMiLCJldmVudFN0b3JlVG9TZWdzIiwiX2V2ZW50U3RvcmVUb1NlZ3MiLCJyZW5kZXJDb250ZW50IiwibGlzdFZpZXdDbGFzc05hbWVzIiwibGlzdFZpZXdDbGFzc05hbWVzXzEiLCJsaXN0Vmlld0NsYXNzTmFtZSIsImRheURhdGVzIiwiZGF5UmFuZ2VzIiwiZXZlbnRSYW5nZXNUb1NlZ3MiLCJldmVudFJhbmdlVG9TZWdzIiwic2VnUmFuZ2UiLCJzZWdzQnlEYXkiLCJncm91cFNlZ3NCeURheSIsImRheVNlZ3MiLCJ0YWJsZUVsIiwiYnVpbGREYXlIZWFkZXJSb3ciLCJtYWluRm9ybWF0IiwiYWx0Rm9ybWF0Iiwidmlld0VuZCIsImxpc3REYXlGb3JtYXQiLCJsaXN0RGF5IiwibGlzdFdlZWsiLCJsaXN0RGF5QWx0Rm9ybWF0IiwibGlzdE1vbnRoIiwibGlzdFllYXIiLCJkYXlncmlkIiwiVGltZUdyaWRFdmVudFJlbmRlcmVyIiwidGltZUdyaWQiLCJmdWxsVGltZUZvcm1hdCIsInNlZ3NCeUNvbCIsImdyb3VwU2Vnc0J5Q29sIiwiYXR0YWNoU2Vnc0J5Q29sIiwiZmdDb250YWluZXJFbHMiLCJjb21wdXRlU2VnVmVydGljYWxzIiwiY29tcHV0ZVNlZ0hvcml6b250YWxzIiwiYXNzaWduU2VnVmVydGljYWxzIiwiYXNzaWduU2VnQ3NzIiwiZnVsbFRpbWVUZXh0Iiwic3RhcnRUaW1lVGV4dCIsInVuem9uZWRTdGFydCIsInVuem9uZWRFbmQiLCJsZXZlbDAiLCJidWlsZFNsb3RTZWdMZXZlbHMiLCJjb21wdXRlRm9yd2FyZFNsb3RTZWdzIiwiY29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMiLCJjb21wdXRlU2VnRm9yd2FyZEJhY2siLCJzZXJpZXNCYWNrd2FyZFByZXNzdXJlIiwic2VyaWVzQmFja3dhcmRDb29yZCIsImZvcndhcmRTZWdzIiwiZm9yd2FyZENvb3JkIiwic29ydEZvcndhcmRTZWdzIiwiYmFja3dhcmRDb29yZCIsImJ1aWxkVGltZUdyaWRTZWdDb21wYXJlT2JqIiwiZ2VuZXJhdGVTZWdDc3MiLCJzaG91bGRPdmVybGFwIiwic2xvdEV2ZW50T3ZlcmxhcCIsImdlbmVyYXRlU2VnVmVydGljYWxDc3MiLCJmb3J3YXJkUHJlc3N1cmUiLCJjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMiLCJrIiwiZm9yd2FyZFNlZyIsInJlc3VsdHMiLCJpc1Nsb3RTZWdDb2xsaXNpb24iLCJzZWcxIiwic2VnMiIsIlRpbWVHcmlkTWlycm9yUmVuZGVyZXIiLCJtaXJyb3JDb250YWluZXJFbHMiLCJzb3VyY2VTZWdQcm9wcyIsIlRpbWVHcmlkRmlsbFJlbmRlcmVyIiwiYmdDb250YWluZXJFbHMiLCJidXNpbmVzc0NvbnRhaW5lckVscyIsImhpZ2hsaWdodENvbnRhaW5lckVscyIsIkFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TIiwiVGltZUdyaWQiLCJpc1NsYXRTaXplc0RpcnR5IiwiaXNDb2xTaXplc0RpcnR5IiwicmVuZGVyU2xhdHMiLCJfcmVuZGVyU2xhdHMiLCJyZW5kZXJDb2x1bW5zIiwiX3JlbmRlckNvbHVtbnMiLCJfdW5yZW5kZXJDb2x1bW5zIiwiX3JlbmRlckRhdGVTZWxlY3Rpb24iLCJfdW5yZW5kZXJEYXRlU2VsZWN0aW9uIiwicHJvY2Vzc09wdGlvbnMiLCJyb290QmdDb250YWluZXJFbCIsInNsYXRDb250YWluZXJFbCIsImJvdHRvbVJ1bGVFbCIsInNsb3REdXJhdGlvbiIsInNuYXBEdXJhdGlvbiIsInNuYXBzUGVyU2xvdCIsImxhYmVsRm9ybWF0IiwibGFiZWxJbnRlcnZhbCIsImNvbXB1dGVMYWJlbEludGVydmFsIiwic2xvdHNQZXJMYWJlbCIsImJ1aWxkU2xhdFBvc2l0aW9ucyIsInJlbmRlclNsYXRSb3dIdG1sIiwic2xhdEVscyIsInNsYXRQb3NpdGlvbnMiLCJzbG90VGltZSIsInNsb3RJdGVyYXRvciIsInNsb3REYXRlIiwiaXNMYWJlbGVkIiwiYXhpc0h0bWwiLCJjb2xFbHMiLCJyZW5kZXJDb250ZW50U2tlbGV0b24iLCJ1bnJlbmRlckNvbnRlbnRTa2VsZXRvbiIsImNvbnRlbnRTa2VsZXRvbkVsIiwiY29sQ29udGFpbmVyRWxzIiwiY29tcHV0ZURhdGVUb3AiLCJub2RlcyIsImxpbmVFbCIsImFycm93RWwiLCJub3dJbmRpY2F0b3JFbHMiLCJnZXRUb3RhbFNsYXRIZWlnaHQiLCJ3aGVuIiwic3RhcnRPZkRheURhdGUiLCJjb21wdXRlVGltZVRvcCIsInNsYXRDb3ZlcmFnZSIsInNsYXRJbmRleCIsInNsYXRSZW1haW5kZXIiLCJldmVudE1pbkhlaWdodCIsImNvbEluZGV4Iiwic2xhdFRvcCIsInNsYXRIZWlnaHQiLCJwYXJ0aWFsIiwibG9jYWxTbmFwSW5kZXgiLCJzbmFwSW5kZXgiLCJ0aW1lIiwiaXNTZWxlY3RpbmciLCJBbGxEYXlTcGxpdHRlciIsInRpbWVkIiwiVElNRUdSSURfQUxMX0RBWV9FVkVOVF9MSU1JVCIsIldFRUtfSEVBREVSX0ZPUk1BVCIsIlRpbWVHcmlkVmlldyIsInNwbGl0dGVyIiwid2Vla1RleHQiLCJheGlzU3R5bGVBdHRyIiwicmVuZGVyVGltZUdyaWRCZ0ludHJvSHRtbCIsInJlbmRlclRpbWVHcmlkSW50cm9IdG1sIiwidGltZUdyaWRXcmFwRWwiLCJ0aW1lR3JpZEVsIiwiZGl2aWRlckVsIiwiYXhpc1dpZHRoIiwibm9TY3JvbGxSb3dFbHMiLCJTaW1wbGVUaW1lR3JpZCIsImJ1aWxkRGF5UmFuZ2VzIiwiVGltZUdyaWRTbGljZXIiLCJUaW1lR3JpZFZpZXckMSIsInNpbXBsZVRpbWVHcmlkIiwiYWxsRGF5U2xvdCIsInRpbWVHcmlkRGF5IiwidGltZUdyaWRXZWVrIiwiQWJzdHJhY3RUaW1lR3JpZFZpZXciLCIkIiwiZGF0ZXRpbWVwaWNrZXIiLCJsb2ciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLHVDOzs7Ozs7Ozs7OztBQ0FBLHVDOzs7Ozs7Ozs7OztBQ0FBLHVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7O0FBTUMsV0FBVUEsTUFB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QkEvUixTQUFPLENBQUNrZ0Ysb0JBQVIsR0FBK0JuQixZQUEvQjtBQUNBLytFLFNBQU8sQ0FBQ203RSxRQUFSLEdBQW1CQSxRQUFuQjtBQUNBbjdFLFNBQU8sQ0FBQzQvRSxjQUFSLEdBQXlCQSxjQUF6QjtBQUNBNS9FLFNBQU8sQ0FBQysrRSxZQUFSLEdBQXVCYyxjQUF2QjtBQUNBNy9FLFNBQU8sQ0FBQzIvRSxjQUFSLEdBQXlCQSxjQUF6QjtBQUNBMy9FLFNBQU8sQ0FBQ3dsRSxhQUFSLEdBQXdCQSxhQUF4QjtBQUNBeGxFLFNBQU8sV0FBUCxHQUFrQjBsRSxJQUFsQjtBQUVBcHJELFFBQU0sQ0FBQ29QLGNBQVAsQ0FBc0IxcEIsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRXNULFNBQUssRUFBRTtBQUFULEdBQTdDO0FBRUgsQ0F0MENBLENBQUQsQzs7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7O0FBT0E7Q0FHQTs7QUFDQTtBQUNBOztBQUNBOGxELG1CQUFPLENBQUUsMEVBQUYsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBRSxnRkFBRixDQUFQOztBQUNBQSxtQkFBTyxDQUFFLDBFQUFGLENBQVA7O0FBQ0FBLG1CQUFPLENBQUUsa0ZBQUYsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBRSx3RUFBRixDQUFQOztBQUNBQSxtQkFBTyxDQUFFLDhFQUFGLENBQVA7O0FBQ0FBLG1CQUFPLENBQUUsc0ZBQUYsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBRSx3RUFBRixDQUFQOztBQUNBQSxtQkFBTyxDQUFFLGdGQUFGLENBQVA7O0FBRUErbUIsNkNBQUMsQ0FBQyxpQkFBRCxDQUFELENBQXFCQyxjQUFyQjtBQUVBOXdDLE9BQU8sQ0FBQyt3QyxHQUFSLENBQVksbURBQVosRSIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCIvKiFcclxuRnVsbENhbGVuZGFyIENvcmUgUGFja2FnZSB2NC4zLjFcclxuRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xyXG4oYykgMjAxOSBBZGFtIFNoYXdcclxuKi9cclxuXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcclxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxyXG4gICAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5GdWxsQ2FsZW5kYXIgPSB7fSkpO1xyXG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvLyBDcmVhdGluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdmFyIGVsZW1lbnRQcm9wSGFzaCA9IHtcclxuICAgICAgICBjbGFzc05hbWU6IHRydWUsXHJcbiAgICAgICAgY29sU3BhbjogdHJ1ZSxcclxuICAgICAgICByb3dTcGFuOiB0cnVlXHJcbiAgICB9O1xyXG4gICAgdmFyIGNvbnRhaW5lclRhZ0hhc2ggPSB7XHJcbiAgICAgICAgJzx0cic6ICd0Ym9keScsXHJcbiAgICAgICAgJzx0ZCc6ICd0cidcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUsIGF0dHJzLCBjb250ZW50KSB7XHJcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuICAgICAgICBpZiAoYXR0cnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gYXR0cnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGx5U3R5bGUoZWwsIGF0dHJzW2F0dHJOYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50UHJvcEhhc2hbYXR0ck5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxbYXR0ck5hbWVdID0gYXR0cnNbYXR0ck5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyc1thdHRyTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gY29udGVudDsgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gcHJvY2VzcyBIVE1MIGluIGFueSB3YXlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29udGVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFwcGVuZFRvRWxlbWVudChlbCwgY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGh0bWxUb0VsZW1lbnQoaHRtbCkge1xyXG4gICAgICAgIGh0bWwgPSBodG1sLnRyaW0oKTtcclxuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjb21wdXRlQ29udGFpbmVyVGFnKGh0bWwpKTtcclxuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcclxuICAgICAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBodG1sVG9FbGVtZW50cyhodG1sKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGh0bWxUb05vZGVMaXN0KGh0bWwpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGh0bWxUb05vZGVMaXN0KGh0bWwpIHtcclxuICAgICAgICBodG1sID0gaHRtbC50cmltKCk7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY29tcHV0ZUNvbnRhaW5lclRhZyhodG1sKSk7XHJcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZE5vZGVzO1xyXG4gICAgfVxyXG4gICAgLy8gYXNzdW1lcyBodG1sIGFscmVhZHkgdHJpbW1lZCBhbmQgdGFnIG5hbWVzIGFyZSBsb3dlcmNhc2VcclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVDb250YWluZXJUYWcoaHRtbCkge1xyXG4gICAgICAgIHJldHVybiBjb250YWluZXJUYWdIYXNoW2h0bWwuc3Vic3RyKDAsIDMpIC8vIGZhc3RlciB0aGFuIHVzaW5nIHJlZ2V4XHJcbiAgICAgICAgXSB8fCAnZGl2JztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFwcGVuZFRvRWxlbWVudChlbCwgY29udGVudCkge1xyXG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gbm9ybWFsaXplQ29udGVudChjb250ZW50KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoY2hpbGROb2Rlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHJlcGVuZFRvRWxlbWVudChwYXJlbnQsIGNvbnRlbnQpIHtcclxuICAgICAgICB2YXIgbmV3RWxzID0gbm9ybWFsaXplQ29udGVudChjb250ZW50KTtcclxuICAgICAgICB2YXIgYWZ0ZXJFbCA9IHBhcmVudC5maXJzdENoaWxkIHx8IG51bGw7IC8vIGlmIG5vIGZpcnN0Q2hpbGQsIHdpbGwgYXBwZW5kIHRvIGVuZCwgYnV0IHRoYXQncyBva2F5LCBiL2MgdGhlcmUgd2VyZSBubyBjaGlsZHJlblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobmV3RWxzW2ldLCBhZnRlckVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnNlcnRBZnRlckVsZW1lbnQocmVmRWwsIGNvbnRlbnQpIHtcclxuICAgICAgICB2YXIgbmV3RWxzID0gbm9ybWFsaXplQ29udGVudChjb250ZW50KTtcclxuICAgICAgICB2YXIgYWZ0ZXJFbCA9IHJlZkVsLm5leHRTaWJsaW5nIHx8IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdFbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVmRWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3RWxzW2ldLCBhZnRlckVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBub3JtYWxpemVDb250ZW50KGNvbnRlbnQpIHtcclxuICAgICAgICB2YXIgZWxzO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZWxzID0gaHRtbFRvRWxlbWVudHMoY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBOb2RlKSB7XHJcbiAgICAgICAgICAgIGVscyA9IFtjb250ZW50XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7IC8vIE5vZGVbXSBvciBOb2RlTGlzdFxyXG4gICAgICAgICAgICBlbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVscztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcclxuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBRdWVyeWluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0XHJcbiAgICB2YXIgbWF0Y2hlc01ldGhvZCA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHxcclxuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHxcclxuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvcjtcclxuICAgIHZhciBjbG9zZXN0TWV0aG9kID0gRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCB8fCBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAvLyBwb2x5ZmlsbFxyXG4gICAgICAgIHZhciBlbCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGU7XHJcbiAgICAgICAgfSB3aGlsZSAoZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGVsZW1lbnRDbG9zZXN0KGVsLCBzZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBjbG9zZXN0TWV0aG9kLmNhbGwoZWwsIHNlbGVjdG9yKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzKGVsLCBzZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVzTWV0aG9kLmNhbGwoZWwsIHNlbGVjdG9yKTtcclxuICAgIH1cclxuICAgIC8vIGFjY2VwdHMgbXVsdGlwbGUgc3ViamVjdCBlbHNcclxuICAgIC8vIHJldHVybnMgYSByZWFsIGFycmF5LiBnb29kIGZvciBtZXRob2RzIGxpa2UgZm9yRWFjaFxyXG4gICAgZnVuY3Rpb24gZmluZEVsZW1lbnRzKGNvbnRhaW5lciwgc2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgY29udGFpbmVycyA9IGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gW2NvbnRhaW5lcl0gOiBjb250YWluZXI7XHJcbiAgICAgICAgdmFyIGFsbE1hdGNoZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRhaW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBjb250YWluZXJzW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hdGNoZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChtYXRjaGVzW2pdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWxsTWF0Y2hlcztcclxuICAgIH1cclxuICAgIC8vIGFjY2VwdHMgbXVsdGlwbGUgc3ViamVjdCBlbHNcclxuICAgIC8vIG9ubHkgcXVlcmllcyBkaXJlY3QgY2hpbGQgZWxlbWVudHNcclxuICAgIGZ1bmN0aW9uIGZpbmRDaGlsZHJlbihwYXJlbnQsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudHMgPSBwYXJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtwYXJlbnRdIDogcGFyZW50O1xyXG4gICAgICAgIHZhciBhbGxNYXRjaGVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gcGFyZW50c1tpXS5jaGlsZHJlbjsgLy8gb25seSBldmVyIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbal07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IGVsZW1lbnRNYXRjaGVzKGNoaWxkTm9kZSwgc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsTWF0Y2hlcy5wdXNoKGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFsbE1hdGNoZXM7XHJcbiAgICB9XHJcbiAgICAvLyBBdHRyaWJ1dGVzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBmb3JjZUNsYXNzTmFtZShlbCwgY2xhc3NOYW1lLCBib29sKSB7XHJcbiAgICAgICAgaWYgKGJvb2wpIHtcclxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFN0eWxlXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB2YXIgUElYRUxfUFJPUF9SRSA9IC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tfHdpZHRofGhlaWdodCkkL2k7XHJcbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlKGVsLCBwcm9wcykge1xyXG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgIGFwcGx5U3R5bGVQcm9wKGVsLCBwcm9wTmFtZSwgcHJvcHNbcHJvcE5hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlUHJvcChlbCwgbmFtZSwgdmFsKSB7XHJcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlW25hbWVdID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIFBJWEVMX1BST1BfUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbCArICdweCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcG9pbnRJbnNpZGVSZWN0KHBvaW50LCByZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50LmxlZnQgPj0gcmVjdC5sZWZ0ICYmXHJcbiAgICAgICAgICAgIHBvaW50LmxlZnQgPCByZWN0LnJpZ2h0ICYmXHJcbiAgICAgICAgICAgIHBvaW50LnRvcCA+PSByZWN0LnRvcCAmJlxyXG4gICAgICAgICAgICBwb2ludC50b3AgPCByZWN0LmJvdHRvbTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXHJcbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RSZWN0cyhyZWN0MSwgcmVjdDIpIHtcclxuICAgICAgICB2YXIgcmVzID0ge1xyXG4gICAgICAgICAgICBsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcclxuICAgICAgICAgICAgcmlnaHQ6IE1hdGgubWluKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCksXHJcbiAgICAgICAgICAgIHRvcDogTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApLFxyXG4gICAgICAgICAgICBib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHJlcy5sZWZ0IDwgcmVzLnJpZ2h0ICYmIHJlcy50b3AgPCByZXMuYm90dG9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlY3QocmVjdCwgZGVsdGFYLCBkZWx0YVkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyBkZWx0YVgsXHJcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgZGVsdGFYLFxyXG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgZGVsdGFZLFxyXG4gICAgICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgZGVsdGFZXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcclxuICAgIGZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXHJcbiAgICAgICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcclxuICAgIGZ1bmN0aW9uIGdldFJlY3RDZW50ZXIocmVjdCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsXHJcbiAgICAgICAgICAgIHRvcDogKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBTdWJ0cmFjdHMgcG9pbnQyJ3MgY29vcmRpbmF0ZXMgZnJvbSBwb2ludDEncyBjb29yZGluYXRlcywgcmV0dXJuaW5nIGEgZGVsdGFcclxuICAgIGZ1bmN0aW9uIGRpZmZQb2ludHMocG9pbnQxLCBwb2ludDIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiBwb2ludDEubGVmdCAtIHBvaW50Mi5sZWZ0LFxyXG4gICAgICAgICAgICB0b3A6IHBvaW50MS50b3AgLSBwb2ludDIudG9wXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMb2dpYyBmb3IgZGV0ZXJtaW5pbmcgaWYsIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmlnaHQtdG8tbGVmdCwgdGhlIHNjcm9sbGJhciBhcHBlYXJzIG9uIHRoZSBsZWZ0IHNpZGVcclxuICAgIHZhciBpc1J0bFNjcm9sbGJhck9uTGVmdCA9IG51bGw7XHJcbiAgICBmdW5jdGlvbiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcclxuICAgICAgICBpZiAoaXNSdGxTY3JvbGxiYXJPbkxlZnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzUnRsU2Nyb2xsYmFyT25MZWZ0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KCkge1xyXG4gICAgICAgIHZhciBvdXRlckVsID0gY3JlYXRlRWxlbWVudCgnZGl2Jywge1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgICB0b3A6IC0xMDAwLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogMCxcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdydGwnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAnPGRpdj48L2Rpdj4nKTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyRWwpO1xyXG4gICAgICAgIHZhciBpbm5lckVsID0gb3V0ZXJFbC5maXJzdENoaWxkO1xyXG4gICAgICAgIHZhciByZXMgPSBpbm5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgPiBvdXRlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XHJcbiAgICAgICAgcmVtb3ZlRWxlbWVudChvdXRlckVsKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlIHNjcm9sbGJhciB3aWR0aCBjb21wdXRhdGlvbnMgaW4gY29tcHV0ZUVkZ2VzIGFyZSBzb21ldGltZXMgZmxhd2VkIHdoZW4gaXQgY29tZXMgdG9cclxuICAgIC8vIHJldGluYSBkaXNwbGF5cywgcm91bmRpbmcsIGFuZCBJRTExLiBNYXNzYWdlIHRoZW0gaW50byBhIHVzYWJsZSB2YWx1ZS5cclxuICAgIGZ1bmN0aW9uIHNhbml0aXplU2Nyb2xsYmFyV2lkdGgod2lkdGgpIHtcclxuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoKTsgLy8gbm8gbmVnYXRpdmVzXHJcbiAgICAgICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcclxuICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUVkZ2VzKGVsLCBnZXRQYWRkaW5nKSB7XHJcbiAgICAgICAgaWYgKGdldFBhZGRpbmcgPT09IHZvaWQgMCkgeyBnZXRQYWRkaW5nID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgICAgICB2YXIgYm9yZGVyTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoLCAxMCkgfHwgMDtcclxuICAgICAgICB2YXIgYm9yZGVyUmlnaHQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgsIDEwKSB8fCAwO1xyXG4gICAgICAgIHZhciBib3JkZXJUb3AgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlclRvcFdpZHRoLCAxMCkgfHwgMDtcclxuICAgICAgICB2YXIgYm9yZGVyQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCwgMTApIHx8IDA7XHJcbiAgICAgICAgLy8gbXVzdCB1c2Ugb2Zmc2V0KFdpZHRofEhlaWdodCkgYmVjYXVzZSBjb21wYXRpYmxlIHdpdGggY2xpZW50KFdpZHRofEhlaWdodClcclxuICAgICAgICB2YXIgc2Nyb2xsYmFyTGVmdFJpZ2h0ID0gc2FuaXRpemVTY3JvbGxiYXJXaWR0aChlbC5vZmZzZXRXaWR0aCAtIGVsLmNsaWVudFdpZHRoIC0gYm9yZGVyTGVmdCAtIGJvcmRlclJpZ2h0KTtcclxuICAgICAgICB2YXIgc2Nyb2xsYmFyQm90dG9tID0gc2FuaXRpemVTY3JvbGxiYXJXaWR0aChlbC5vZmZzZXRIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQgLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b20pO1xyXG4gICAgICAgIHZhciByZXMgPSB7XHJcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IGJvcmRlckxlZnQsXHJcbiAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBib3JkZXJSaWdodCxcclxuICAgICAgICAgICAgYm9yZGVyVG9wOiBib3JkZXJUb3AsXHJcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYm9yZGVyQm90dG9tLFxyXG4gICAgICAgICAgICBzY3JvbGxiYXJCb3R0b206IHNjcm9sbGJhckJvdHRvbSxcclxuICAgICAgICAgICAgc2Nyb2xsYmFyTGVmdDogMCxcclxuICAgICAgICAgICAgc2Nyb2xsYmFyUmlnaHQ6IDBcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpICYmIGNvbXB1dGVkU3R5bGUuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBpcyB0aGUgc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0IHNpZGU/XHJcbiAgICAgICAgICAgIHJlcy5zY3JvbGxiYXJMZWZ0ID0gc2Nyb2xsYmFyTGVmdFJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzLnNjcm9sbGJhclJpZ2h0ID0gc2Nyb2xsYmFyTGVmdFJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ2V0UGFkZGluZykge1xyXG4gICAgICAgICAgICByZXMucGFkZGluZ0xlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0LCAxMCkgfHwgMDtcclxuICAgICAgICAgICAgcmVzLnBhZGRpbmdSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0LCAxMCkgfHwgMDtcclxuICAgICAgICAgICAgcmVzLnBhZGRpbmdUb3AgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3AsIDEwKSB8fCAwO1xyXG4gICAgICAgICAgICByZXMucGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSwgMTApIHx8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlSW5uZXJSZWN0KGVsLCBnb1dpdGhpblBhZGRpbmcpIHtcclxuICAgICAgICBpZiAoZ29XaXRoaW5QYWRkaW5nID09PSB2b2lkIDApIHsgZ29XaXRoaW5QYWRkaW5nID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgb3V0ZXJSZWN0ID0gY29tcHV0ZVJlY3QoZWwpO1xyXG4gICAgICAgIHZhciBlZGdlcyA9IGNvbXB1dGVFZGdlcyhlbCwgZ29XaXRoaW5QYWRkaW5nKTtcclxuICAgICAgICB2YXIgcmVzID0ge1xyXG4gICAgICAgICAgICBsZWZ0OiBvdXRlclJlY3QubGVmdCArIGVkZ2VzLmJvcmRlckxlZnQgKyBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxyXG4gICAgICAgICAgICByaWdodDogb3V0ZXJSZWN0LnJpZ2h0IC0gZWRnZXMuYm9yZGVyUmlnaHQgLSBlZGdlcy5zY3JvbGxiYXJSaWdodCxcclxuICAgICAgICAgICAgdG9wOiBvdXRlclJlY3QudG9wICsgZWRnZXMuYm9yZGVyVG9wLFxyXG4gICAgICAgICAgICBib3R0b206IG91dGVyUmVjdC5ib3R0b20gLSBlZGdlcy5ib3JkZXJCb3R0b20gLSBlZGdlcy5zY3JvbGxiYXJCb3R0b21cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChnb1dpdGhpblBhZGRpbmcpIHtcclxuICAgICAgICAgICAgcmVzLmxlZnQgKz0gZWRnZXMucGFkZGluZ0xlZnQ7XHJcbiAgICAgICAgICAgIHJlcy5yaWdodCAtPSBlZGdlcy5wYWRkaW5nUmlnaHQ7XHJcbiAgICAgICAgICAgIHJlcy50b3AgKz0gZWRnZXMucGFkZGluZ1RvcDtcclxuICAgICAgICAgICAgcmVzLmJvdHRvbSAtPSBlZGdlcy5wYWRkaW5nQm90dG9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVJlY3QoZWwpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcclxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCxcclxuICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXHJcbiAgICAgICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVZpZXdwb3J0UmVjdCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiB3aW5kb3cucGFnZVhPZmZzZXQsXHJcbiAgICAgICAgICAgIHJpZ2h0OiB3aW5kb3cucGFnZVhPZmZzZXQgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICAgIHRvcDogd2luZG93LnBhZ2VZT2Zmc2V0LFxyXG4gICAgICAgICAgICBib3R0b206IHdpbmRvdy5wYWdlWU9mZnNldCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUhlaWdodEFuZE1hcmdpbnMoZWwpIHtcclxuICAgICAgICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ICsgY29tcHV0ZVZNYXJnaW5zKGVsKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVWTWFyZ2lucyhlbCkge1xyXG4gICAgICAgIHZhciBjb21wdXRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoY29tcHV0ZWQubWFyZ2luVG9wLCAxMCkgK1xyXG4gICAgICAgICAgICBwYXJzZUludChjb21wdXRlZC5tYXJnaW5Cb3R0b20sIDEwKTtcclxuICAgIH1cclxuICAgIC8vIGRvZXMgbm90IHJldHVybiB3aW5kb3dcclxuICAgIGZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbCkge1xyXG4gICAgICAgIHZhciBwYXJlbnRzID0gW107XHJcbiAgICAgICAgd2hpbGUgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHsgLy8gd2lsbCBzdG9wIHdoZW4gZ2V0cyB0byBkb2N1bWVudCBvciBudWxsXHJcbiAgICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xyXG4gICAgICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoY29tcHV0ZWRTdHlsZS5vdmVyZmxvdyArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dZICsgY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2goZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudHM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlQ2xpcHBpbmdSZWN0KGVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldENsaXBwaW5nUGFyZW50cyhlbClcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVJbm5lclJlY3QoZWwpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jb25jYXQoY29tcHV0ZVZpZXdwb3J0UmVjdCgpKVxyXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChyZWN0MCwgcmVjdDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdFJlY3RzKHJlY3QwLCByZWN0MSkgfHwgcmVjdDE7IC8vIHNob3VsZCBhbHdheXMgaW50ZXJzZWN0XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RvcHMgYSBtb3VzZS90b3VjaCBldmVudCBmcm9tIGRvaW5nIGl0J3MgbmF0aXZlIGJyb3dzZXIgYWN0aW9uXHJcbiAgICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xyXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICAvLyBFdmVudCBEZWxlZ2F0aW9uXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBsaXN0ZW5CeVNlbGVjdG9yKGNvbnRhaW5lciwgZXZlbnRUeXBlLCBzZWxlY3RvciwgaGFuZGxlcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWxIYW5kbGVyKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGVkQ2hpbGQgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZWRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKG1hdGNoZWRDaGlsZCwgZXYsIG1hdGNoZWRDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCByZWFsSGFuZGxlcik7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCByZWFsSGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKGNvbnRhaW5lciwgc2VsZWN0b3IsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRNYXRjaGVkQ2hpbGQ7XHJcbiAgICAgICAgcmV0dXJuIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCAnbW91c2VvdmVyJywgc2VsZWN0b3IsIGZ1bmN0aW9uIChldiwgbWF0Y2hlZENoaWxkKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaGVkQ2hpbGQgIT09IGN1cnJlbnRNYXRjaGVkQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBtYXRjaGVkQ2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXIoZXYsIG1hdGNoZWRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVhbE9uTW91c2VMZWF2ZV8xID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE1hdGNoZWRDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlKGV2LCBtYXRjaGVkQ2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZV8xKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZV8xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gQW5pbWF0aW9uXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB2YXIgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSBbXHJcbiAgICAgICAgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxyXG4gICAgICAgICdvdHJhbnNpdGlvbmVuZCcsXHJcbiAgICAgICAgJ29UcmFuc2l0aW9uRW5kJyxcclxuICAgICAgICAnbXNUcmFuc2l0aW9uRW5kJyxcclxuICAgICAgICAndHJhbnNpdGlvbmVuZCdcclxuICAgIF07XHJcbiAgICAvLyB0cmlnZ2VyZWQgb25seSB3aGVuIHRoZSBuZXh0IHNpbmdsZSBzdWJzZXF1ZW50IHRyYW5zaXRpb24gZmluaXNoZXNcclxuICAgIGZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRG9uZShlbCwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgcmVhbENhbGxiYWNrID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGV2KTtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcmVhbENhbGxiYWNrKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cmFuc2l0aW9uRXZlbnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7IC8vIGNyb3NzLWJyb3dzZXIgd2F5IHRvIGRldGVybWluZSB3aGVuIHRoZSB0cmFuc2l0aW9uIGZpbmlzaGVzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIERBWV9JRFMgPSBbJ3N1bicsICdtb24nLCAndHVlJywgJ3dlZCcsICd0aHUnLCAnZnJpJywgJ3NhdCddO1xyXG4gICAgLy8gQWRkaW5nXHJcbiAgICBmdW5jdGlvbiBhZGRXZWVrcyhtLCBuKSB7XHJcbiAgICAgICAgdmFyIGEgPSBkYXRlVG9VdGNBcnJheShtKTtcclxuICAgICAgICBhWzJdICs9IG4gKiA3O1xyXG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFkZERheXMobSwgbikge1xyXG4gICAgICAgIHZhciBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XHJcbiAgICAgICAgYVsyXSArPSBuO1xyXG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFkZE1zKG0sIG4pIHtcclxuICAgICAgICB2YXIgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xyXG4gICAgICAgIGFbNl0gKz0gbjtcclxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XHJcbiAgICB9XHJcbiAgICAvLyBEaWZmaW5nIChhbGwgcmV0dXJuIGZsb2F0cylcclxuICAgIGZ1bmN0aW9uIGRpZmZXZWVrcyhtMCwgbTEpIHtcclxuICAgICAgICByZXR1cm4gZGlmZkRheXMobTAsIG0xKSAvIDc7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkaWZmRGF5cyhtMCwgbTEpIHtcclxuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkaWZmSG91cnMobTAsIG0xKSB7XHJcbiAgICAgICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCAqIDYwKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRpZmZNaW51dGVzKG0wLCBtMSkge1xyXG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGlmZlNlY29uZHMobTAsIG0xKSB7XHJcbiAgICAgICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gMTAwMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRpZmZEYXlBbmRUaW1lKG0wLCBtMSkge1xyXG4gICAgICAgIHZhciBtMGRheSA9IHN0YXJ0T2ZEYXkobTApO1xyXG4gICAgICAgIHZhciBtMWRheSA9IHN0YXJ0T2ZEYXkobTEpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHllYXJzOiAwLFxyXG4gICAgICAgICAgICBtb250aHM6IDAsXHJcbiAgICAgICAgICAgIGRheXM6IE1hdGgucm91bmQoZGlmZkRheXMobTBkYXksIG0xZGF5KSksXHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogKG0xLnZhbHVlT2YoKSAtIG0xZGF5LnZhbHVlT2YoKSkgLSAobTAudmFsdWVPZigpIC0gbTBkYXkudmFsdWVPZigpKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBEaWZmaW5nIFdob2xlIFVuaXRzXHJcbiAgICBmdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpIHtcclxuICAgICAgICB2YXIgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcclxuICAgICAgICBpZiAoZCAhPT0gbnVsbCAmJiBkICUgNyA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZCAvIDc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMCwgbTEpIHtcclxuICAgICAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGlmZkRheXMobTAsIG0xKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gU3RhcnQtT2ZcclxuICAgIGZ1bmN0aW9uIHN0YXJ0T2ZEYXkobSkge1xyXG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENNb250aCgpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ0RhdGUoKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RhcnRPZkhvdXIobSkge1xyXG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENNb250aCgpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ0RhdGUoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENIb3VycygpXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzdGFydE9mTWludXRlKG0pIHtcclxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xyXG4gICAgICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENEYXRlKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDSG91cnMoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENNaW51dGVzKClcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobSkge1xyXG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENNb250aCgpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ0RhdGUoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENIb3VycygpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENTZWNvbmRzKClcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIC8vIFdlZWsgQ29tcHV0YXRpb25cclxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobWFya2VyLCBkb3csIGRveSkge1xyXG4gICAgICAgIHZhciB5ID0gbWFya2VyLmdldFVUQ0Z1bGxZZWFyKCk7XHJcbiAgICAgICAgdmFyIHcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5LCBkb3csIGRveSk7XHJcbiAgICAgICAgaWYgKHcgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5IC0gMSwgZG93LCBkb3kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dFcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5ICsgMSwgZG93LCBkb3kpO1xyXG4gICAgICAgIGlmIChuZXh0VyA+PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih3LCBuZXh0Vyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeWVhciwgZG93LCBkb3kpIHtcclxuICAgICAgICB2YXIgZmlyc3RXZWVrU3RhcnQgPSBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgMSArIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSldKTtcclxuICAgICAgICB2YXIgZGF5U3RhcnQgPSBzdGFydE9mRGF5KG1hcmtlcik7XHJcbiAgICAgICAgdmFyIGRheXMgPSBNYXRoLnJvdW5kKGRpZmZEYXlzKGZpcnN0V2Vla1N0YXJ0LCBkYXlTdGFydCkpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGRheXMgLyA3KSArIDE7IC8vIHplcm8taW5kZXhlZFxyXG4gICAgfVxyXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xyXG4gICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxyXG4gICAgICAgIHZhciBmd2QgPSA3ICsgZG93IC0gZG95O1xyXG4gICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcclxuICAgICAgICB2YXIgZndkbHcgPSAoNyArIGFycmF5VG9VdGNEYXRlKFt5ZWFyLCAwLCBmd2RdKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xyXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xyXG4gICAgfVxyXG4gICAgLy8gQXJyYXkgQ29udmVyc2lvblxyXG4gICAgZnVuY3Rpb24gZGF0ZVRvTG9jYWxBcnJheShkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICBkYXRlLmdldE1vbnRoKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0RGF0ZSgpLFxyXG4gICAgICAgICAgICBkYXRlLmdldEhvdXJzKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0TWludXRlcygpLFxyXG4gICAgICAgICAgICBkYXRlLmdldFNlY29uZHMoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcnJheVRvTG9jYWxEYXRlKGEpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUoYVswXSwgYVsxXSB8fCAwLCBhWzJdID09IG51bGwgPyAxIDogYVsyXSwgLy8gZGF5IG9mIG1vbnRoXHJcbiAgICAgICAgYVszXSB8fCAwLCBhWzRdIHx8IDAsIGFbNV0gfHwgMCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkYXRlVG9VdGNBcnJheShkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgZGF0ZS5nZXRVVENGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICBkYXRlLmdldFVUQ01vbnRoKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDRGF0ZSgpLFxyXG4gICAgICAgICAgICBkYXRlLmdldFVUQ0hvdXJzKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDTWludXRlcygpLFxyXG4gICAgICAgICAgICBkYXRlLmdldFVUQ1NlY29uZHMoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XHJcbiAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxyXG4gICAgICAgIC8vIG1hc3NhZ2UgaWYgb25seSBnaXZlbiBhIHllYXIuXHJcbiAgICAgICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGEgPSBhLmNvbmNhdChbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkoRGF0ZSwgYSkpO1xyXG4gICAgfVxyXG4gICAgLy8gT3RoZXIgVXRpbHNcclxuICAgIGZ1bmN0aW9uIGlzVmFsaWREYXRlKG0pIHtcclxuICAgICAgICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRpbWVBc01zKG0pIHtcclxuICAgICAgICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xyXG4gICAgICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSAqIDEwMDAgKiA2MCArXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDU2Vjb25kcygpICogMTAwMCArXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIElOVEVSTkFMX1VOSVRTID0gWyd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdtaWxsaXNlY29uZHMnXTtcclxuICAgIHZhciBQQVJTRV9SRSA9IC9eKC0/KSg/OihcXGQrKVxcLik/KFxcZCspOihcXGRcXGQpKD86OihcXGRcXGQpKD86XFwuKFxcZFxcZFxcZCkpPyk/LztcclxuICAgIC8vIFBhcnNpbmcgYW5kIENyZWF0aW9uXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdW5pdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplT2JqZWN0KGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplT2JqZWN0KChfYSA9IHt9LCBfYVt1bml0IHx8ICdtaWxsaXNlY29uZHMnXSA9IGlucHV0LCBfYSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xyXG4gICAgICAgIHZhciBtID0gUEFSU0VfUkUuZXhlYyhzKTtcclxuICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB5ZWFyczogMCxcclxuICAgICAgICAgICAgICAgIG1vbnRoczogMCxcclxuICAgICAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxyXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXHJcbiAgICAgICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcclxuICAgICAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcclxuICAgICAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0KG9iaikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHllYXJzOiBvYmoueWVhcnMgfHwgb2JqLnllYXIgfHwgMCxcclxuICAgICAgICAgICAgbW9udGhzOiBvYmoubW9udGhzIHx8IG9iai5tb250aCB8fCAwLFxyXG4gICAgICAgICAgICBkYXlzOiAob2JqLmRheXMgfHwgb2JqLmRheSB8fCAwKSArXHJcbiAgICAgICAgICAgICAgICBnZXRXZWVrc0Zyb21JbnB1dChvYmopICogNyxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xyXG4gICAgICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXHJcbiAgICAgICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXHJcbiAgICAgICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApIC8vIG1zXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFdlZWtzRnJvbUlucHV0KG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmoud2Vla3MgfHwgb2JqLndlZWsgfHwgMDtcclxuICAgIH1cclxuICAgIC8vIEVxdWFsaXR5XHJcbiAgICBmdW5jdGlvbiBkdXJhdGlvbnNFcXVhbChkMCwgZDEpIHtcclxuICAgICAgICByZXR1cm4gZDAueWVhcnMgPT09IGQxLnllYXJzICYmXHJcbiAgICAgICAgICAgIGQwLm1vbnRocyA9PT0gZDEubW9udGhzICYmXHJcbiAgICAgICAgICAgIGQwLmRheXMgPT09IGQxLmRheXMgJiZcclxuICAgICAgICAgICAgZDAubWlsbGlzZWNvbmRzID09PSBkMS5taWxsaXNlY29uZHM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1NpbmdsZURheShkdXIpIHtcclxuICAgICAgICByZXR1cm4gZHVyLnllYXJzID09PSAwICYmIGR1ci5tb250aHMgPT09IDAgJiYgZHVyLmRheXMgPT09IDEgJiYgZHVyLm1pbGxpc2Vjb25kcyA9PT0gMDtcclxuICAgIH1cclxuICAgIC8vIFNpbXBsZSBNYXRoXHJcbiAgICBmdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXHJcbiAgICAgICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxyXG4gICAgICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3REdXJhdGlvbnMoZDEsIGQwKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeWVhcnM6IGQxLnllYXJzIC0gZDAueWVhcnMsXHJcbiAgICAgICAgICAgIG1vbnRoczogZDEubW9udGhzIC0gZDAubW9udGhzLFxyXG4gICAgICAgICAgICBkYXlzOiBkMS5kYXlzIC0gZDAuZGF5cyxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBkMS5taWxsaXNlY29uZHMgLSBkMC5taWxsaXNlY29uZHNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlEdXJhdGlvbihkLCBuKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeWVhcnM6IGQueWVhcnMgKiBuLFxyXG4gICAgICAgICAgICBtb250aHM6IGQubW9udGhzICogbixcclxuICAgICAgICAgICAgZGF5czogZC5kYXlzICogbixcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBkLm1pbGxpc2Vjb25kcyAqIG5cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gQ29udmVyc2lvbnNcclxuICAgIC8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXHJcbiAgICBmdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xyXG4gICAgICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcclxuICAgICAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xyXG4gICAgICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcclxuICAgICAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXHJcbiAgICAgICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xyXG4gICAgICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcclxuICAgICAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcclxuICAgIH1cclxuICAgIC8vIEFkdmFuY2VkIE1hdGhcclxuICAgIGZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcclxuICAgICAgICB2YXIgcmVzID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XHJcbiAgICAgICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIsIGRvbnRSZXR1cm5XZWVrcykge1xyXG4gICAgICAgIHZhciBtcyA9IGR1ci5taWxsaXNlY29uZHM7XHJcbiAgICAgICAgaWYgKG1zKSB7XHJcbiAgICAgICAgICAgIGlmIChtcyAlIDEwMDAgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiBtcyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtcyAlICgxMDAwICogNjApICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnc2Vjb25kJywgdmFsdWU6IG1zIC8gMTAwMCB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtcyAlICgxMDAwICogNjAgKiA2MCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbXMgLyAoMTAwMCAqIDYwKSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2hvdXInLCB2YWx1ZTogbXMgLyAoMTAwMCAqIDYwICogNjApIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGR1ci5kYXlzKSB7XHJcbiAgICAgICAgICAgIGlmICghZG9udFJldHVybldlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZHVyLm1vbnRocykge1xyXG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZHVyLnllYXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEdpdmVuIHRoZSBzY3JvbGxiYXIgd2lkdGhzIG9mIHNvbWUgb3RoZXIgY29udGFpbmVyLCBjcmVhdGUgYm9yZGVycy9tYXJnaW5zIG9uIHJvd0VscyBpbiBvcmRlciB0byBtYXRjaCB0aGUgbGVmdFxyXG4gICAgLy8gYW5kIHJpZ2h0IHNwYWNlIHRoYXQgd2FzIG9mZnNldCBieSB0aGUgc2Nyb2xsYmFycy4gQSAxLXBpeGVsIGJvcmRlciBmaXJzdCwgdGhlbiBtYXJnaW4gYmV5b25kIHRoYXQuXHJcbiAgICBmdW5jdGlvbiBjb21wZW5zYXRlU2Nyb2xsKHJvd0VsLCBzY3JvbGxiYXJXaWR0aHMpIHtcclxuICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQpIHtcclxuICAgICAgICAgICAgYXBwbHlTdHlsZShyb3dFbCwge1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyTGVmdFdpZHRoOiAxLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogc2Nyb2xsYmFyV2lkdGhzLmxlZnQgLSAxXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIGFwcGx5U3R5bGUocm93RWwsIHtcclxuICAgICAgICAgICAgICAgIGJvcmRlclJpZ2h0V2lkdGg6IDEsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0IC0gMVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBVbmRvZXMgY29tcGVuc2F0ZVNjcm9sbCBhbmQgcmVzdG9yZXMgYWxsIGJvcmRlcnMvbWFyZ2luc1xyXG4gICAgZnVuY3Rpb24gdW5jb21wZW5zYXRlU2Nyb2xsKHJvd0VsKSB7XHJcbiAgICAgICAgYXBwbHlTdHlsZShyb3dFbCwge1xyXG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiAnJyxcclxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICcnLFxyXG4gICAgICAgICAgICBib3JkZXJMZWZ0V2lkdGg6ICcnLFxyXG4gICAgICAgICAgICBib3JkZXJSaWdodFdpZHRoOiAnJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gTWFrZSB0aGUgbW91c2UgY3Vyc29yIGV4cHJlc3MgdGhhdCBhbiBldmVudCBpcyBub3QgYWxsb3dlZCBpbiB0aGUgY3VycmVudCBhcmVhXHJcbiAgICBmdW5jdGlvbiBkaXNhYmxlQ3Vyc29yKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnZmMtbm90LWFsbG93ZWQnKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1vdXNlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgbG9va1xyXG4gICAgZnVuY3Rpb24gZW5hYmxlQ3Vyc29yKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnZmMtbm90LWFsbG93ZWQnKTtcclxuICAgIH1cclxuICAgIC8vIEdpdmVuIGEgdG90YWwgYXZhaWxhYmxlIGhlaWdodCB0byBmaWxsLCBoYXZlIGBlbHNgIChlc3NlbnRpYWxseSBjaGlsZCByb3dzKSBleHBhbmQgdG8gYWNjb21vZGF0ZS5cclxuICAgIC8vIEJ5IGRlZmF1bHQsIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBzaG9ydGVyIHRoYW4gdGhlIHJlY29tbWVuZGVkIGhlaWdodCBhcmUgZXhwYW5kZWQgdW5pZm9ybWx5LCBub3QgY29uc2lkZXJpbmdcclxuICAgIC8vIGFueSBvdGhlciBlbHMgdGhhdCBhcmUgYWxyZWFkeSB0b28gdGFsbC4gaWYgYHNob3VsZFJlZGlzdHJpYnV0ZWAgaXMgb24sIGl0IGNvbnNpZGVycyB0aGVzZSB0YWxsIHJvd3MgYW5kXHJcbiAgICAvLyByZWR1Y2VzIHRoZSBhdmFpbGFibGUgaGVpZ2h0LlxyXG4gICAgZnVuY3Rpb24gZGlzdHJpYnV0ZUhlaWdodChlbHMsIGF2YWlsYWJsZUhlaWdodCwgc2hvdWxkUmVkaXN0cmlidXRlKSB7XHJcbiAgICAgICAgLy8gKkZMT09SSU5HIE5PVEUqOiB3ZSBmbG9vciBpbiBjZXJ0YWluIHBsYWNlcyBiZWNhdXNlIHpvb20gY2FuIGdpdmUgaW5hY2N1cmF0ZSBmbG9hdGluZy1wb2ludCBkaW1lbnNpb25zLFxyXG4gICAgICAgIC8vIGFuZCBpdCBpcyBiZXR0ZXIgdG8gYmUgc2hvcnRlciB0aGFuIHRhbGxlciwgdG8gYXZvaWQgY3JlYXRpbmcgdW5uZWNlc3Nhcnkgc2Nyb2xsYmFycy5cclxuICAgICAgICB2YXIgbWluT2Zmc2V0MSA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC8gZWxzLmxlbmd0aCk7IC8vIGZvciBub24tbGFzdCBlbGVtZW50XHJcbiAgICAgICAgdmFyIG1pbk9mZnNldDIgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAtIG1pbk9mZnNldDEgKiAoZWxzLmxlbmd0aCAtIDEpKTsgLy8gZm9yIGxhc3QgZWxlbWVudCAqRkxPT1JJTkcgTk9URSpcclxuICAgICAgICB2YXIgZmxleEVscyA9IFtdOyAvLyBlbGVtZW50cyB0aGF0IGFyZSBhbGxvd2VkIHRvIGV4cGFuZC4gYXJyYXkgb2YgRE9NIG5vZGVzXHJcbiAgICAgICAgdmFyIGZsZXhPZmZzZXRzID0gW107IC8vIGFtb3VudCBvZiB2ZXJ0aWNhbCBzcGFjZSBpdCB0YWtlcyB1cFxyXG4gICAgICAgIHZhciBmbGV4SGVpZ2h0cyA9IFtdOyAvLyBhY3R1YWwgY3NzIGhlaWdodFxyXG4gICAgICAgIHZhciB1c2VkSGVpZ2h0ID0gMDtcclxuICAgICAgICB1bmRpc3RyaWJ1dGVIZWlnaHQoZWxzKTsgLy8gZ2l2ZSBhbGwgZWxlbWVudHMgdGhlaXIgbmF0dXJhbCBoZWlnaHRcclxuICAgICAgICAvLyBmaW5kIGVsZW1lbnRzIHRoYXQgYXJlIGJlbG93IHRoZSByZWNvbW1lbmRlZCBoZWlnaHQgKGV4cGFuZGFibGUpLlxyXG4gICAgICAgIC8vIGltcG9ydGFudCB0byBxdWVyeSBmb3IgaGVpZ2h0cyBpbiBhIHNpbmdsZSBmaXJzdCBwYXNzICh0byBhdm9pZCByZWZsb3cgb3NjaWxsYXRpb24pLlxyXG4gICAgICAgIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaSkge1xyXG4gICAgICAgICAgICB2YXIgbWluT2Zmc2V0ID0gaSA9PT0gZWxzLmxlbmd0aCAtIDEgPyBtaW5PZmZzZXQyIDogbWluT2Zmc2V0MTtcclxuICAgICAgICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBuYXR1cmFsT2Zmc2V0ID0gbmF0dXJhbEhlaWdodCArIGNvbXB1dGVWTWFyZ2lucyhlbCk7XHJcbiAgICAgICAgICAgIGlmIChuYXR1cmFsT2Zmc2V0IDwgbWluT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBmbGV4RWxzLnB1c2goZWwpO1xyXG4gICAgICAgICAgICAgICAgZmxleE9mZnNldHMucHVzaChuYXR1cmFsT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGZsZXhIZWlnaHRzLnB1c2gobmF0dXJhbEhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGVsZW1lbnQgc3RyZXRjaGVzIHBhc3QgcmVjb21tZW5kZWQgaGVpZ2h0IChub24tZXhwYW5kYWJsZSkuIG1hcmsgdGhlIHNwYWNlIGFzIG9jY3VwaWVkLlxyXG4gICAgICAgICAgICAgICAgdXNlZEhlaWdodCArPSBuYXR1cmFsT2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gcmVhZGp1c3QgdGhlIHJlY29tbWVuZGVkIGhlaWdodCB0byBvbmx5IGNvbnNpZGVyIHRoZSBoZWlnaHQgYXZhaWxhYmxlIHRvIG5vbi1tYXhlZC1vdXQgcm93cy5cclxuICAgICAgICBpZiAoc2hvdWxkUmVkaXN0cmlidXRlKSB7XHJcbiAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCAtPSB1c2VkSGVpZ2h0O1xyXG4gICAgICAgICAgICBtaW5PZmZzZXQxID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLyBmbGV4RWxzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIG1pbk9mZnNldDIgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAtIG1pbk9mZnNldDEgKiAoZmxleEVscy5sZW5ndGggLSAxKSk7IC8vICpGTE9PUklORyBOT1RFKlxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhc3NpZ24gaGVpZ2h0cyB0byBhbGwgZXhwYW5kYWJsZSBlbGVtZW50c1xyXG4gICAgICAgIGZsZXhFbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGkpIHtcclxuICAgICAgICAgICAgdmFyIG1pbk9mZnNldCA9IGkgPT09IGZsZXhFbHMubGVuZ3RoIC0gMSA/IG1pbk9mZnNldDIgOiBtaW5PZmZzZXQxO1xyXG4gICAgICAgICAgICB2YXIgbmF0dXJhbE9mZnNldCA9IGZsZXhPZmZzZXRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IGZsZXhIZWlnaHRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gbWluT2Zmc2V0IC0gKG5hdHVyYWxPZmZzZXQgLSBuYXR1cmFsSGVpZ2h0KTsgLy8gc3VidHJhY3QgdGhlIG1hcmdpbi9wYWRkaW5nXHJcbiAgICAgICAgICAgIGlmIChuYXR1cmFsT2Zmc2V0IDwgbWluT2Zmc2V0KSB7IC8vIHdlIGNoZWNrIHRoaXMgYWdhaW4gYmVjYXVzZSByZWRpc3RyaWJ1dGlvbiBtaWdodCBoYXZlIGNoYW5nZWQgdGhpbmdzXHJcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyAncHgnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBVbmRvZXMgZGlzdHJ1YnV0ZUhlaWdodCwgcmVzdG9yaW5nIGFsbCBlbHMgdG8gdGhlaXIgbmF0dXJhbCBoZWlnaHRcclxuICAgIGZ1bmN0aW9uIHVuZGlzdHJpYnV0ZUhlaWdodChlbHMpIHtcclxuICAgICAgICBlbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJyc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBHaXZlbiBgZWxzYCwgYSBzZXQgb2YgPHRkPiBjZWxscywgZmluZCB0aGUgY2VsbCB3aXRoIHRoZSBsYXJnZXN0IG5hdHVyYWwgd2lkdGggYW5kIHNldCB0aGUgd2lkdGhzIG9mIGFsbCB0aGVcclxuICAgIC8vIGNlbGxzIHRvIGJlIHRoYXQgd2lkdGguXHJcbiAgICAvLyBQUkVSRVFVSVNJVEU6IGlmIHlvdSB3YW50IGEgY2VsbCB0byB0YWtlIHVwIHdpZHRoLCBpdCBuZWVkcyB0byBoYXZlIGEgc2luZ2xlIGlubmVyIGVsZW1lbnQgdy8gZGlzcGxheTppbmxpbmVcclxuICAgIGZ1bmN0aW9uIG1hdGNoQ2VsbFdpZHRocyhlbHMpIHtcclxuICAgICAgICB2YXIgbWF4SW5uZXJXaWR0aCA9IDA7XHJcbiAgICAgICAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBpbm5lckVsID0gZWwuZmlyc3RDaGlsZDsgLy8gaG9wZWZ1bGx5IGFuIGVsZW1lbnRcclxuICAgICAgICAgICAgaWYgKGlubmVyRWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlubmVyV2lkdGhfMSA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJXaWR0aF8xID4gbWF4SW5uZXJXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heElubmVyV2lkdGggPSBpbm5lcldpZHRoXzE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBtYXhJbm5lcldpZHRoKys7IC8vIHNvbWV0aW1lcyBub3QgYWNjdXJhdGUgb2Ygd2lkdGggdGhlIHRleHQgbmVlZHMgdG8gc3RheSBvbiBvbmUgbGluZS4gaW5zdXJhbmNlXHJcbiAgICAgICAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gbWF4SW5uZXJXaWR0aCArICdweCc7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1heElubmVyV2lkdGg7XHJcbiAgICB9XHJcbiAgICAvLyBHaXZlbiBvbmUgZWxlbWVudCB0aGF0IHJlc2lkZXMgaW5zaWRlIGFub3RoZXIsXHJcbiAgICAvLyBTdWJ0cmFjdHMgdGhlIGhlaWdodCBvZiB0aGUgaW5uZXIgZWxlbWVudCBmcm9tIHRoZSBvdXRlciBlbGVtZW50LlxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3RJbm5lckVsSGVpZ2h0KG91dGVyRWwsIGlubmVyRWwpIHtcclxuICAgICAgICAvLyBlZmZpbicgSUU4LzkvMTAvMTEgc29tZXRpbWVzIHJldHVybnMgMCBmb3IgZGltZW5zaW9ucy4gdGhpcyB3ZWlyZCBoYWNrIHdhcyB0aGUgb25seSB0aGluZyB0aGF0IHdvcmtlZFxyXG4gICAgICAgIHZhciByZWZsb3dTdHlsZVByb3BzID0ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICAgICAgbGVmdDogLTEgLy8gZW5zdXJlIHJlZmxvdyBpbiBjYXNlIHRoZSBlbCB3YXMgYWxyZWFkeSByZWxhdGl2ZS4gbmVnYXRpdmUgaXMgbGVzcyBsaWtlbHkgdG8gY2F1c2UgbmV3IHNjcm9sbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYXBwbHlTdHlsZShvdXRlckVsLCByZWZsb3dTdHlsZVByb3BzKTtcclxuICAgICAgICBhcHBseVN0eWxlKGlubmVyRWwsIHJlZmxvd1N0eWxlUHJvcHMpO1xyXG4gICAgICAgIHZhciBkaWZmID0gLy8gZ3JhYiB0aGUgZGltZW5zaW9uc1xyXG4gICAgICAgICBvdXRlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAtXHJcbiAgICAgICAgICAgIGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xyXG4gICAgICAgIC8vIHVuZG8gaGFja1xyXG4gICAgICAgIHZhciByZXNldFN0eWxlUHJvcHMgPSB7IHBvc2l0aW9uOiAnJywgbGVmdDogJycgfTtcclxuICAgICAgICBhcHBseVN0eWxlKG91dGVyRWwsIHJlc2V0U3R5bGVQcm9wcyk7XHJcbiAgICAgICAgYXBwbHlTdHlsZShpbm5lckVsLCByZXNldFN0eWxlUHJvcHMpO1xyXG4gICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgfVxyXG4gICAgLyogU2VsZWN0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIGZ1bmN0aW9uIHByZXZlbnRTZWxlY3Rpb24oZWwpIHtcclxuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdmYy11bnNlbGVjdGFibGUnKTtcclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFsbG93U2VsZWN0aW9uKGVsKSB7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZmMtdW5zZWxlY3RhYmxlJyk7XHJcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgICB9XHJcbiAgICAvKiBDb250ZXh0IE1lbnVcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgZnVuY3Rpb24gcHJldmVudENvbnRleHRNZW51KGVsKSB7XHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhbGxvd0NvbnRleHRNZW51KGVsKSB7XHJcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgICB9XHJcbiAgICAvKiBPYmplY3QgT3JkZXJpbmcgYnkgRmllbGRcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgZnVuY3Rpb24gcGFyc2VGaWVsZFNwZWNzKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIHNwZWNzID0gW107XHJcbiAgICAgICAgdmFyIHRva2VucyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB0b2tlbjtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0b2tlbnMgPSBpbnB1dC5zcGxpdCgvXFxzKixcXHMqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0b2tlbnMgPSBbaW5wdXRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICB0b2tlbnMgPSBpbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHNwZWNzLnB1c2godG9rZW4uY2hhckF0KDApID09PSAnLScgP1xyXG4gICAgICAgICAgICAgICAgICAgIHsgZmllbGQ6IHRva2VuLnN1YnN0cmluZygxKSwgb3JkZXI6IC0xIH0gOlxyXG4gICAgICAgICAgICAgICAgICAgIHsgZmllbGQ6IHRva2VuLCBvcmRlcjogMSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHNwZWNzLnB1c2goeyBmdW5jOiB0b2tlbiB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3BlY3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIGZpZWxkU3BlY3MpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgY21wO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWVsZFNwZWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmVCeUZpZWxkU3BlYyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzW2ldKTtcclxuICAgICAgICAgICAgaWYgKGNtcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlYyhvYmowLCBvYmoxLCBmaWVsZFNwZWMpIHtcclxuICAgICAgICBpZiAoZmllbGRTcGVjLmZ1bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkU3BlYy5mdW5jKG9iajAsIG9iajEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmxleGlibGVDb21wYXJlKG9iajBbZmllbGRTcGVjLmZpZWxkXSwgb2JqMVtmaWVsZFNwZWMuZmllbGRdKVxyXG4gICAgICAgICAgICAqIChmaWVsZFNwZWMub3JkZXIgfHwgMSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmbGV4aWJsZUNvbXBhcmUoYSwgYikge1xyXG4gICAgICAgIGlmICghYSAmJiAhYikge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICB9XHJcbiAgICAvKiBTdHJpbmcgVXRpbGl0aWVzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIGZ1bmN0aW9uIGNhcGl0YWxpc2VGaXJzdExldHRlcihzdHIpIHtcclxuICAgICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFkU3RhcnQodmFsLCBsZW4pIHtcclxuICAgICAgICB2YXIgcyA9IFN0cmluZyh2YWwpO1xyXG4gICAgICAgIHJldHVybiAnMDAwJy5zdWJzdHIoMCwgbGVuIC0gcy5sZW5ndGgpICsgcztcclxuICAgIH1cclxuICAgIC8qIE51bWJlciBVdGlsaXRpZXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhIC0gYjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzSW50KG4pIHtcclxuICAgICAgICByZXR1cm4gbiAlIDEgPT09IDA7XHJcbiAgICB9XHJcbiAgICAvKiBXZWlyZCBVdGlsaXRpZXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgZnVuY3Rpb24gYXBwbHlBbGwoZnVuY3Rpb25zLCB0aGlzT2JqLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbnMgPT09ICdmdW5jdGlvbicpIHsgLy8gc3VwcGxpZWQgYSBzaW5nbGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgZnVuY3Rpb25zID0gW2Z1bmN0aW9uc107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmdW5jdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJldCA9IGZ1bmN0aW9uc1tpXS5hcHBseSh0aGlzT2JqLCBhcmdzKSB8fCByZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaXJzdERlZmluZWQoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXJnc1tpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcclxuICAgIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcclxuICAgIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxyXG4gICAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9ibG9iLzEuNi4wL3VuZGVyc2NvcmUuanMjTDcxNFxyXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCkge1xyXG4gICAgICAgIHZhciB0aW1lb3V0O1xyXG4gICAgICAgIHZhciBhcmdzO1xyXG4gICAgICAgIHZhciBjb250ZXh0O1xyXG4gICAgICAgIHZhciB0aW1lc3RhbXA7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0ID0gbmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aW1lc3RhbXA7XHJcbiAgICAgICAgICAgIGlmIChsYXN0IDwgd2FpdCkge1xyXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29udGV4dCA9IHRoaXM7XHJcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xyXG4gICAgICAgICAgICBpZiAoIXRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBOdW1iZXIgYW5kIEJvb2xlYW4gYXJlIG9ubHkgdHlwZXMgdGhhdCBkZWZhdWx0cyBvciBub3QgY29tcHV0ZWQgZm9yXHJcbiAgICAvLyBUT0RPOiB3cml0ZSBtb3JlIGNvbW1lbnRzXHJcbiAgICBmdW5jdGlvbiByZWZpbmVQcm9wcyhyYXdQcm9wcywgcHJvY2Vzc29ycywgZGVmYXVsdHMsIGxlZnRvdmVyUHJvcHMpIHtcclxuICAgICAgICBpZiAoZGVmYXVsdHMgPT09IHZvaWQgMCkgeyBkZWZhdWx0cyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIHJlZmluZWQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvY2Vzc29ycykge1xyXG4gICAgICAgICAgICB2YXIgcHJvY2Vzc29yID0gcHJvY2Vzc29yc1trZXldO1xyXG4gICAgICAgICAgICBpZiAocmF3UHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3VuZFxyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NvciA9PT0gRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW2tleV0gPSB0eXBlb2YgcmF3UHJvcHNba2V5XSA9PT0gJ2Z1bmN0aW9uJyA/IHJhd1Byb3BzW2tleV0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvY2Vzc29yKSB7IC8vIGEgcmVmaW5pbmcgZnVuY3Rpb24/XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtrZXldID0gcHJvY2Vzc29yKHJhd1Byb3BzW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtrZXldID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkZWZhdWx0c1trZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW4gZXhwbGljaXQgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgcmVmaW5lZFtrZXldID0gZGVmYXVsdHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG11c3QgY29tcHV0ZSBhIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzb3IgPT09IFN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRba2V5XSA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgaXMgZGVmYXVsdCBmb3IgU3RyaW5nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcHJvY2Vzc29yIHx8IHByb2Nlc3NvciA9PT0gTnVtYmVyIHx8IHByb2Nlc3NvciA9PT0gQm9vbGVhbiB8fCBwcm9jZXNzb3IgPT09IEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtrZXldID0gbnVsbDsgLy8gYXNzaWduIG51bGwgZm9yIG90aGVyIG5vbi1jdXN0b20gcHJvY2Vzc29yIGZ1bmNzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW2tleV0gPSBwcm9jZXNzb3IobnVsbCk7IC8vIHJ1biB0aGUgY3VzdG9tIHByb2Nlc3NvciBmdW5jXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlZnRvdmVyUHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yc1trZXldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0b3ZlclByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyogRGF0ZSBzdHVmZiB0aGF0IGRvZXNuJ3QgYmVsb25nIGluIGRhdGVsaWIgY29yZVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIHRoYXQgaGFzIHRoZSBzYW1lIGV4YWN0IGR1cmF0aW9uLFxyXG4gICAgLy8gYnV0IHdob3NlIHN0YXJ0IHRpbWUgaXMgYWxpZ25lZCB3aXRoIHRoZSBzdGFydCBvZiB0aGUgZGF5LlxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUFsaWduZWREYXlSYW5nZSh0aW1lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGRheUNudCA9IE1hdGguZmxvb3IoZGlmZkRheXModGltZWRSYW5nZS5zdGFydCwgdGltZWRSYW5nZS5lbmQpKSB8fCAxO1xyXG4gICAgICAgIHZhciBzdGFydCA9IHN0YXJ0T2ZEYXkodGltZWRSYW5nZS5zdGFydCk7XHJcbiAgICAgICAgdmFyIGVuZCA9IGFkZERheXMoc3RhcnQsIGRheUNudCk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xyXG4gICAgfVxyXG4gICAgLy8gZ2l2ZW4gYSB0aW1lZCByYW5nZSwgY29tcHV0ZXMgYW4gYWxsLWRheSByYW5nZSBiYXNlZCBvbiBob3cgZm9yIHRoZSBlbmQgZGF0ZSBibGVlZHMgaW50byB0aGUgbmV4dCBkYXlcclxuICAgIC8vIFRPRE86IGdpdmUgbmV4dERheVRocmVzaG9sZCBhIGRlZmF1bHQgYXJnXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlVmlzaWJsZURheVJhbmdlKHRpbWVkUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIHtcclxuICAgICAgICBpZiAobmV4dERheVRocmVzaG9sZCA9PT0gdm9pZCAwKSB7IG5leHREYXlUaHJlc2hvbGQgPSBjcmVhdGVEdXJhdGlvbigwKTsgfVxyXG4gICAgICAgIHZhciBzdGFydERheSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGVuZERheSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRpbWVkUmFuZ2UuZW5kKSB7XHJcbiAgICAgICAgICAgIGVuZERheSA9IHN0YXJ0T2ZEYXkodGltZWRSYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICB2YXIgZW5kVGltZU1TID0gdGltZWRSYW5nZS5lbmQudmFsdWVPZigpIC0gZW5kRGF5LnZhbHVlT2YoKTsgLy8gIyBvZiBtaWxsaXNlY29uZHMgaW50byBgZW5kRGF5YFxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZW5kIHRpbWUgaXMgYWN0dWFsbHkgaW5jbHVzaXZlbHkgcGFydCBvZiB0aGUgbmV4dCBkYXkgYW5kIGlzIGVxdWFsIHRvIG9yXHJcbiAgICAgICAgICAgIC8vIGJleW9uZCB0aGUgbmV4dCBkYXkgdGhyZXNob2xkLCBhZGp1c3QgdGhlIGVuZCB0byBiZSB0aGUgZXhjbHVzaXZlIGVuZCBvZiBgZW5kRGF5YC5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBsZWF2aW5nIGl0IGFzIGluY2x1c2l2ZSB3aWxsIGNhdXNlIGl0IHRvIGV4Y2x1ZGUgYGVuZERheWAuXHJcbiAgICAgICAgICAgIGlmIChlbmRUaW1lTVMgJiYgZW5kVGltZU1TID49IGFzUm91Z2hNcyhuZXh0RGF5VGhyZXNob2xkKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhlbmREYXksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aW1lZFJhbmdlLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0RGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KTsgLy8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF5IHRoZSByYW5nZSBzdGFydHNcclxuICAgICAgICAgICAgLy8gSWYgZW5kIGlzIHdpdGhpbiBgc3RhcnREYXlgIGJ1dCBub3QgcGFzdCBuZXh0RGF5VGhyZXNob2xkLCBhc3NpZ24gdGhlIGRlZmF1bHQgZHVyYXRpb24gb2Ygb25lIGRheS5cclxuICAgICAgICAgICAgaWYgKGVuZERheSAmJiBlbmREYXkgPD0gc3RhcnREYXkpIHtcclxuICAgICAgICAgICAgICAgIGVuZERheSA9IGFkZERheXMoc3RhcnREYXksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydERheSwgZW5kOiBlbmREYXkgfTtcclxuICAgIH1cclxuICAgIC8vIHNwYW5zIGZyb20gb25lIGRheSBpbnRvIGFub3RoZXI/XHJcbiAgICBmdW5jdGlvbiBpc011bHRpRGF5UmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICB2YXIgdmlzaWJsZVJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZShyYW5nZSk7XHJcbiAgICAgICAgcmV0dXJuIGRpZmZEYXlzKHZpc2libGVSYW5nZS5zdGFydCwgdmlzaWJsZVJhbmdlLmVuZCkgPiAxO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGlmZkRhdGVzKGRhdGUwLCBkYXRlMSwgZGF0ZUVudiwgbGFyZ2VVbml0KSB7XHJcbiAgICAgICAgaWYgKGxhcmdlVW5pdCA9PT0gJ3llYXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihkYXRlRW52LmRpZmZXaG9sZVllYXJzKGRhdGUwLCBkYXRlMSksICd5ZWFyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlmZkRheUFuZFRpbWUoZGF0ZTAsIGRhdGUxKTsgLy8gcmV0dXJucyBhIGR1cmF0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxuICAgIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbiAgICBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuICAgIFRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICAgIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuICAgIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbiAgICBNRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuICAgIFNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG4gICAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuICAgIC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VSZWN1cnJpbmcoZXZlbnRJbnB1dCwgYWxsRGF5RGVmYXVsdCwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMsIGxlZnRvdmVycykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdXJyaW5nVHlwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FsTGVmdG92ZXJzID0ge307XHJcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSByZWN1cnJpbmdUeXBlc1tpXS5wYXJzZShldmVudElucHV0LCBsb2NhbExlZnRvdmVycywgZGF0ZUVudik7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbGxEYXkgPSBsb2NhbExlZnRvdmVycy5hbGxEYXk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxMZWZ0b3ZlcnMuYWxsRGF5OyAvLyByZW1vdmUgZnJvbSBsZWZ0b3ZlcnNcclxuICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbERheSA9IGFsbERheURlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERheSA9IHBhcnNlZC5hbGxEYXlHdWVzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxEYXkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9fYXNzaWduKGxlZnRvdmVycywgbG9jYWxMZWZ0b3ZlcnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxEYXk6IGFsbERheSxcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogcGFyc2VkLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVEYXRhOiBwYXJzZWQudHlwZURhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZUlkOiBpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIEV2ZW50IE1VU1QgaGF2ZSBhIHJlY3VycmluZ0RlZlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIGV4cGFuZFJlY3VycmluZ1JhbmdlcyhldmVudERlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcclxuICAgICAgICB2YXIgdHlwZURlZiA9IHJlY3VycmluZ1R5cGVzW2V2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlSWRdO1xyXG4gICAgICAgIHZhciBtYXJrZXJzID0gdHlwZURlZi5leHBhbmQoZXZlbnREZWYucmVjdXJyaW5nRGVmLnR5cGVEYXRhLCB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LnN1YnRyYWN0KGZyYW1pbmdSYW5nZS5zdGFydCwgZHVyYXRpb24pLFxyXG4gICAgICAgICAgICBlbmQ6IGZyYW1pbmdSYW5nZS5lbmRcclxuICAgICAgICB9LCBkYXRlRW52KTtcclxuICAgICAgICAvLyB0aGUgcmVjdXJyZW5jZSBwbHVnaW5zIGRvbid0IGd1YXJhbnRlZSB0aGF0IGFsbC1kYXkgZXZlbnRzIGFyZSBzdGFydC1vZi1kYXksIHNvIHdlIGhhdmUgdG9cclxuICAgICAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XHJcbiAgICAgICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzLm1hcChzdGFydE9mRGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuICAgIC8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxyXG4gICAgLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXHJcbiAgICBmdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHMpIHtcclxuICAgICAgICB2YXIgZGVzdCA9IHt9O1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgIHZhciBjb21wbGV4T2JqcztcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgIHZhciBwcm9wcztcclxuICAgICAgICBpZiAoY29tcGxleFByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV4UHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBjb21wbGV4UHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBjb21wbGV4T2JqcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwcm9wT2Jqc1tqXVtuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsKSB7IC8vIG5vbi1udWxsIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV4T2Jqcy51bnNoaWZ0KHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSB2YWw7IC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRyYWlsaW5nIHZhbHVlcyB3ZXJlIG9iamVjdHMsIHVzZSB0aGUgbWVyZ2VkIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IG1lcmdlUHJvcHMoY29tcGxleE9ianMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gdGhlIGRlc3RpbmF0aW9uLCBnb2luZyBmcm9tIGxhc3QgdG8gZmlyc3RcclxuICAgICAgICBmb3IgKGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBwcm9wcyA9IHByb3BPYmpzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghKG5hbWUgaW4gZGVzdCkpIHsgLy8gaWYgYWxyZWFkeSBhc3NpZ25lZCBieSBwcmV2aW91cyBwcm9wcyBvciBjb21wbGV4IHByb3BzLCBkb24ndCByZWFzc2lnblxyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBwcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZpbHRlckhhc2goaGFzaCwgZnVuYykge1xyXG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBoYXNoKSB7XHJcbiAgICAgICAgICAgIGlmIChmdW5jKGhhc2hba2V5XSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRba2V5XSA9IGhhc2hba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtYXBIYXNoKGhhc2gsIGZ1bmMpIHtcclxuICAgICAgICB2YXIgbmV3SGFzaCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBoYXNoKSB7XHJcbiAgICAgICAgICAgIG5ld0hhc2hba2V5XSA9IGZ1bmMoaGFzaFtrZXldLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3SGFzaDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFycmF5VG9IYXNoKGEpIHtcclxuICAgICAgICB2YXIgaGFzaCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYV8xID0gYTsgX2kgPCBhXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gYV8xW19pXTtcclxuICAgICAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFzaFZhbHVlc1RvQXJyYXkob2JqKSB7XHJcbiAgICAgICAgdmFyIGEgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIGEucHVzaChvYmpba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNQcm9wc0VxdWFsKG9iajAsIG9iajEpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqMCkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iajEpIHtcclxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlRXZlbnRzKHJhd0V2ZW50cywgc291cmNlSWQsIGNhbGVuZGFyLCBhbGxvd09wZW5SYW5nZSkge1xyXG4gICAgICAgIHZhciBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByYXdFdmVudHNfMSA9IHJhd0V2ZW50czsgX2kgPCByYXdFdmVudHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHJhd0V2ZW50ID0gcmF3RXZlbnRzXzFbX2ldO1xyXG4gICAgICAgICAgICB2YXIgdHVwbGUgPSBwYXJzZUV2ZW50KHJhd0V2ZW50LCBzb3VyY2VJZCwgY2FsZW5kYXIsIGFsbG93T3BlblJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKHR1cGxlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSkge1xyXG4gICAgICAgIGlmIChldmVudFN0b3JlID09PSB2b2lkIDApIHsgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpOyB9XHJcbiAgICAgICAgZXZlbnRTdG9yZS5kZWZzW3R1cGxlLmRlZi5kZWZJZF0gPSB0dXBsZS5kZWY7XHJcbiAgICAgICAgaWYgKHR1cGxlLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U3RvcmUuaW5zdGFuY2VzW3R1cGxlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gdHVwbGUuaW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudFN0b3JlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGZyYW1pbmdSYW5nZSwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgZGF0ZUVudiA9IGNhbGVuZGFyLmRhdGVFbnY7XHJcbiAgICAgICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xyXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXHJcbiAgICAgICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzW2RlZklkXTtcclxuICAgICAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGRlZi5yZWN1cnJpbmdEZWYuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBkZWYuYWxsRGF5ID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXIuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhci5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0cyA9IGV4cGFuZFJlY3VycmluZ1JhbmdlcyhkZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGNhbGVuZGFyLmRhdGVFbnYsIGNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy5yZWN1cnJpbmdUeXBlcyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN0YXJ0c18xID0gc3RhcnRzOyBfaSA8IHN0YXJ0c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHN0YXJ0c18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZklkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChzdGFydCwgZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgZGVmczogZGVmcywgaW5zdGFuY2VzOiBpbnN0YW5jZXMgfTtcclxuICAgIH1cclxuICAgIC8vIHJldHJpZXZlcyBldmVudHMgdGhhdCBoYXZlIHRoZSBzYW1lIGdyb3VwSWQgYXMgdGhlIGluc3RhbmNlIHNwZWNpZmllZCBieSBgaW5zdGFuY2VJZGBcclxuICAgIC8vIG9yIHRoZXkgYXJlIHRoZSBzYW1lIGFzIHRoZSBpbnN0YW5jZS5cclxuICAgIC8vIHdoeSBtaWdodCBpbnN0YW5jZUlkIG5vdCBiZSBpbiB0aGUgc3RvcmU/IGFuIGV2ZW50IGZyb20gYW5vdGhlciBjYWxlbmRhcj9cclxuICAgIGZ1bmN0aW9uIGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlSWQpIHtcclxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcclxuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdmFyIGRlZl8xID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXTtcclxuICAgICAgICAgICAgLy8gZ2V0IGV2ZW50cy9pbnN0YW5jZXMgd2l0aCBzYW1lIGdyb3VwXHJcbiAgICAgICAgICAgIHZhciBuZXdTdG9yZSA9IGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZ1bmN0aW9uIChsb29rRGVmKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNFdmVudERlZnNHcm91cGVkKGRlZl8xLCBsb29rRGVmKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCB1c2UgZXZlbnRUdXBsZVRvU3RvcmUgb3Igc29tZXRoaW5nIGxpa2UgaXRcclxuICAgICAgICAgICAgbmV3U3RvcmUuZGVmc1tkZWZfMS5kZWZJZF0gPSBkZWZfMTtcclxuICAgICAgICAgICAgbmV3U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdTdG9yZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNFdmVudERlZnNHcm91cGVkKGRlZjAsIGRlZjEpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbihkZWYwLmdyb3VwSWQgJiYgZGVmMC5ncm91cElkID09PSBkZWYxLmdyb3VwSWQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUmF3RXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIGNhbEVhY2hUcmFuc2Zvcm0gPSBjYWxlbmRhci5vcHQoJ2V2ZW50RGF0YVRyYW5zZm9ybScpO1xyXG4gICAgICAgIHZhciBzb3VyY2VFYWNoVHJhbnNmb3JtID0gZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0gOiBudWxsO1xyXG4gICAgICAgIGlmIChzb3VyY2VFYWNoVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIHNvdXJjZUVhY2hUcmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsRWFjaFRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBjYWxFYWNoVHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJhd0V2ZW50cztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGZ1bmMpIHtcclxuICAgICAgICB2YXIgcmVmaW5lZEV2ZW50cztcclxuICAgICAgICBpZiAoIWZ1bmMpIHtcclxuICAgICAgICAgICAgcmVmaW5lZEV2ZW50cyA9IHJhd0V2ZW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlZmluZWRFdmVudHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByYXdFdmVudHNfMiA9IHJhd0V2ZW50czsgX2kgPCByYXdFdmVudHNfMi5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciByYXdFdmVudCA9IHJhd0V2ZW50c18yW19pXTtcclxuICAgICAgICAgICAgICAgIHZhciByZWZpbmVkRXZlbnQgPSBmdW5jKHJhd0V2ZW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWZpbmVkRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWZpbmVkRXZlbnRzLnB1c2gocmVmaW5lZEV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZWRFdmVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJhd0V2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0gLy8gaWYgYSBkaWZmZXJlbnQgZmFsc3kgdmFsdWUsIGRvIG5vdGhpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVmaW5lZEV2ZW50cztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpIHtcclxuICAgICAgICByZXR1cm4geyBkZWZzOiB7fSwgaW5zdGFuY2VzOiB7fSB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWVyZ2VFdmVudFN0b3JlcyhzdG9yZTAsIHN0b3JlMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRlZnM6IF9fYXNzaWduKHt9LCBzdG9yZTAuZGVmcywgc3RvcmUxLmRlZnMpLFxyXG4gICAgICAgICAgICBpbnN0YW5jZXM6IF9fYXNzaWduKHt9LCBzdG9yZTAuaW5zdGFuY2VzLCBzdG9yZTEuaW5zdGFuY2VzKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmaWx0ZXJGdW5jKSB7XHJcbiAgICAgICAgdmFyIGRlZnMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuZGVmcywgZmlsdGVyRnVuYyk7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmc1tpbnN0YW5jZS5kZWZJZF07IC8vIHN0aWxsIGV4aXN0cz9cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4geyBkZWZzOiBkZWZzLCBpbnN0YW5jZXM6IGluc3RhbmNlcyB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlUmFuZ2UoaW5wdXQsIGRhdGVFbnYpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBudWxsO1xyXG4gICAgICAgIHZhciBlbmQgPSBudWxsO1xyXG4gICAgICAgIGlmIChpbnB1dC5zdGFydCkge1xyXG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGlucHV0LnN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlucHV0LmVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5lbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN0YXJ0ICYmICFlbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydCAmJiBlbmQgJiYgZW5kIDwgc3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcclxuICAgIH1cclxuICAgIC8vIFNJREUtRUZGRUNUOiB3aWxsIG11dGF0ZSByYW5nZXMuXHJcbiAgICAvLyBXaWxsIHJldHVybiBhIG5ldyBhcnJheSByZXN1bHQuXHJcbiAgICBmdW5jdGlvbiBpbnZlcnRSYW5nZXMocmFuZ2VzLCBjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICB2YXIgaW52ZXJ0ZWRSYW5nZXMgPSBbXTtcclxuICAgICAgICB2YXIgc3RhcnQgPSBjb25zdHJhaW50UmFuZ2Uuc3RhcnQ7IC8vIHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIHJhbmdlLiB0aGUgc3RhcnQgb2YgdGhlIG5ldyByYW5nZVxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBkYXRlUmFuZ2U7XHJcbiAgICAgICAgLy8gcmFuZ2VzIG5lZWQgdG8gYmUgaW4gb3JkZXIuIHJlcXVpcmVkIGZvciBvdXIgZGF0ZS13YWxraW5nIGFsZ29yaXRobVxyXG4gICAgICAgIHJhbmdlcy5zb3J0KGNvbXBhcmVSYW5nZXMpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGF0ZVJhbmdlID0gcmFuZ2VzW2ldO1xyXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBiZWZvcmUgdGhlIGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXHJcbiAgICAgICAgICAgIGlmIChkYXRlUmFuZ2Uuc3RhcnQgPiBzdGFydCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxyXG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaCh7IHN0YXJ0OiBzdGFydCwgZW5kOiBkYXRlUmFuZ2Uuc3RhcnQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5lbmQgPiBzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkYXRlUmFuZ2UuZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGFmdGVyIHRoZSBsYXN0IGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgY29uc3RyYWludFJhbmdlLmVuZCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxyXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGNvbnN0cmFpbnRSYW5nZS5lbmQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnZlcnRlZFJhbmdlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcclxuICAgICAgICByZXR1cm4gcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSAtIHJhbmdlMS5zdGFydC52YWx1ZU9mKCk7IC8vIGVhcmxpZXIgcmFuZ2VzIGdvIGZpcnN0XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZTAuc3RhcnQ7XHJcbiAgICAgICAgdmFyIGVuZCA9IHJhbmdlMC5lbmQ7XHJcbiAgICAgICAgdmFyIG5ld1JhbmdlID0gbnVsbDtcclxuICAgICAgICBpZiAocmFuZ2UxLnN0YXJ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSByYW5nZTEuc3RhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKE1hdGgubWF4KHN0YXJ0LnZhbHVlT2YoKSwgcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYW5nZTEuZW5kICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gcmFuZ2UxLmVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKE1hdGgubWluKGVuZC52YWx1ZU9mKCksIHJhbmdlMS5lbmQudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xyXG4gICAgICAgICAgICBuZXdSYW5nZSA9IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3UmFuZ2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByYW5nZXNFcXVhbChyYW5nZTAsIHJhbmdlMSkge1xyXG4gICAgICAgIHJldHVybiAocmFuZ2UwLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5zdGFydC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpICYmXHJcbiAgICAgICAgICAgIChyYW5nZTAuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5lbmQudmFsdWVPZigpKSA9PT0gKHJhbmdlMS5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLmVuZC52YWx1ZU9mKCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmFuZ2VzSW50ZXJzZWN0KHJhbmdlMCwgcmFuZ2UxKSB7XHJcbiAgICAgICAgcmV0dXJuIChyYW5nZTAuZW5kID09PSBudWxsIHx8IHJhbmdlMS5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTAuZW5kID4gcmFuZ2UxLnN0YXJ0KSAmJlxyXG4gICAgICAgICAgICAocmFuZ2UwLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMS5lbmQgPT09IG51bGwgfHwgcmFuZ2UwLnN0YXJ0IDwgcmFuZ2UxLmVuZCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiAob3V0ZXJSYW5nZS5zdGFydCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5zdGFydCAhPT0gbnVsbCAmJiBpbm5lclJhbmdlLnN0YXJ0ID49IG91dGVyUmFuZ2Uuc3RhcnQpKSAmJlxyXG4gICAgICAgICAgICAob3V0ZXJSYW5nZS5lbmQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kICE9PSBudWxsICYmIGlubmVyUmFuZ2UuZW5kIDw9IG91dGVyUmFuZ2UuZW5kKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByYW5nZUNvbnRhaW5zTWFya2VyKHJhbmdlLCBkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIChyYW5nZS5zdGFydCA9PT0gbnVsbCB8fCBkYXRlID49IHJhbmdlLnN0YXJ0KSAmJlxyXG4gICAgICAgICAgICAocmFuZ2UuZW5kID09PSBudWxsIHx8IGRhdGUgPCByYW5nZS5lbmQpO1xyXG4gICAgfVxyXG4gICAgLy8gSWYgdGhlIGdpdmVuIGRhdGUgaXMgbm90IHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UsIG1vdmUgaXQgaW5zaWRlLlxyXG4gICAgLy8gKElmIGl0J3MgcGFzdCB0aGUgZW5kLCBtYWtlIGl0IG9uZSBtaWxsaXNlY29uZCBiZWZvcmUgdGhlIGVuZCkuXHJcbiAgICBmdW5jdGlvbiBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGRhdGUsIHJhbmdlKSB7XHJcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwgJiYgZGF0ZSA8IHJhbmdlLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5zdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsICYmIGRhdGUgPj0gcmFuZ2UuZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShyYW5nZS5lbmQudmFsdWVPZigpIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xyXG4gICAgICAgIHZhciByZW1vdmVDbnQgPSAwO1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGV4YWN0VmFsKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVtb3ZlQ250O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEpIHtcclxuICAgICAgICB2YXIgbGVuID0gYTAubGVuZ3RoO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmIChsZW4gIT09IGExLmxlbmd0aCkgeyAvLyBub3QgYXJyYXk/IG9yIG5vdCBzYW1lIGxlbmd0aD9cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGEwW2ldICE9PSBhMVtpXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1lbW9pemUod29ya2VyRnVuYykge1xyXG4gICAgICAgIHZhciBhcmdzO1xyXG4gICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmdzIHx8ICFpc0FycmF5c0VxdWFsKGFyZ3MsIGFyZ3VtZW50cykpIHtcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgICAgICByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIGFsd2F5cyBleGVjdXRlcyB0aGUgd29ya2VyRnVuYywgYnV0IGlmIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gdGhlIHByZXZpb3VzIHJlc3VsdCxcclxuICAgIHJldHVybiB0aGUgcHJldmlvdXMgcmVzdWx0IGluc3RlYWQuXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWVtb2l6ZU91dHB1dCh3b3JrZXJGdW5jLCBlcXVhbGl0eUZ1bmMpIHtcclxuICAgICAgICB2YXIgY2FjaGVkUmVzID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3UmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkUmVzID09PSBudWxsIHx8ICEoY2FjaGVkUmVzID09PSBuZXdSZXMgfHwgZXF1YWxpdHlGdW5jKGNhY2hlZFJlcywgbmV3UmVzKSkpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZFJlcyA9IG5ld1JlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTID0ge1xyXG4gICAgICAgIHdlZWs6IDMsXHJcbiAgICAgICAgc2VwYXJhdG9yOiAwLFxyXG4gICAgICAgIG9taXRaZXJvTWludXRlOiAwLFxyXG4gICAgICAgIG1lcmlkaWVtOiAwLFxyXG4gICAgICAgIG9taXRDb21tYXM6IDBcclxuICAgIH07XHJcbiAgICB2YXIgU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMgPSB7XHJcbiAgICAgICAgdGltZVpvbmVOYW1lOiA3LFxyXG4gICAgICAgIGVyYTogNixcclxuICAgICAgICB5ZWFyOiA1LFxyXG4gICAgICAgIG1vbnRoOiA0LFxyXG4gICAgICAgIGRheTogMixcclxuICAgICAgICB3ZWVrZGF5OiAyLFxyXG4gICAgICAgIGhvdXI6IDEsXHJcbiAgICAgICAgbWludXRlOiAxLFxyXG4gICAgICAgIHNlY29uZDogMVxyXG4gICAgfTtcclxuICAgIHZhciBNRVJJRElFTV9SRSA9IC9cXHMqKFthcF0pXFwuP21cXC4/L2k7IC8vIGVhdHMgdXAgbGVhZGluZyBzcGFjZXMgdG9vXHJcbiAgICB2YXIgQ09NTUFfUkUgPSAvLC9nOyAvLyB3ZSBuZWVkIHJlIGZvciBnbG9iYWxuZXNzXHJcbiAgICB2YXIgTVVMVElfU1BBQ0VfUkUgPSAvXFxzKy9nO1xyXG4gICAgdmFyIExUUl9SRSA9IC9cXHUyMDBlL2c7IC8vIGNvbnRyb2wgY2hhcmFjdGVyXHJcbiAgICB2YXIgVVRDX1JFID0gL1VUQ3xHTVQvO1xyXG4gICAgdmFyIE5hdGl2ZUZvcm1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBOYXRpdmVGb3JtYXR0ZXIoZm9ybWF0U2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyIHN0YW5kYXJkRGF0ZVByb3BzID0ge307XHJcbiAgICAgICAgICAgIHZhciBleHRlbmRlZFNldHRpbmdzID0ge307XHJcbiAgICAgICAgICAgIHZhciBzZXZlcml0eSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBmb3JtYXRTZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWVfMSBpbiBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUykge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkU2V0dGluZ3NbbmFtZV8xXSA9IGZvcm1hdFNldHRpbmdzW25hbWVfMV07XHJcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFU1tuYW1lXzFdLCBzZXZlcml0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wc1tuYW1lXzFdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV8xXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZV8xIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldmVyaXR5ID0gTWF0aC5tYXgoU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVNbbmFtZV8xXSwgc2V2ZXJpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YW5kYXJkRGF0ZVByb3BzID0gc3RhbmRhcmREYXRlUHJvcHM7XHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncyA9IGV4dGVuZGVkU2V0dGluZ3M7XHJcbiAgICAgICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBzZXZlcml0eTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jID0gbWVtb2l6ZShidWlsZEZvcm1hdHRpbmdGdW5jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTmF0aXZlRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jKHRoaXMuc3RhbmRhcmREYXRlUHJvcHMsIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkoZGF0ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYXRpdmVGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgc3RhbmRhcmREYXRlUHJvcHMgPSBfYS5zdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyA9IF9hLmV4dGVuZGVkU2V0dGluZ3M7XHJcbiAgICAgICAgICAgIHZhciBkaWZmU2V2ZXJpdHkgPSBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KHN0YXJ0Lm1hcmtlciwgZW5kLm1hcmtlciwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XHJcbiAgICAgICAgICAgIGlmICghZGlmZlNldmVyaXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSBkaWZmU2V2ZXJpdHk7XHJcbiAgICAgICAgICAgIGlmIChiaWdnZXN0VW5pdEZvclBhcnRpYWwgPiAxICYmIC8vIHRoZSB0d28gZGF0ZXMgYXJlIGRpZmZlcmVudCBpbiBhIHdheSB0aGF0J3MgbGFyZ2VyIHNjYWxlIHRoYW4gdGltZVxyXG4gICAgICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnMi1kaWdpdCcpICYmXHJcbiAgICAgICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJzItZGlnaXQnKSAmJlxyXG4gICAgICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJzItZGlnaXQnKSkge1xyXG4gICAgICAgICAgICAgICAgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gMTsgLy8gbWFrZSBpdCBsb29rIGxpa2UgdGhlIGRhdGVzIGFyZSBvbmx5IGRpZmZlcmVudCBpbiB0ZXJtcyBvZiB0aW1lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZ1bGwwID0gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB2YXIgZnVsbDEgPSB0aGlzLmZvcm1hdChlbmQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoZnVsbDAgPT09IGZ1bGwxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBhcnRpYWxEYXRlUHJvcHMgPSBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKHN0YW5kYXJkRGF0ZVByb3BzLCBiaWdnZXN0VW5pdEZvclBhcnRpYWwpO1xyXG4gICAgICAgICAgICB2YXIgcGFydGlhbEZvcm1hdHRpbmdGdW5jID0gYnVpbGRGb3JtYXR0aW5nRnVuYyhwYXJ0aWFsRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgdmFyIHBhcnRpYWwwID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKHN0YXJ0KTtcclxuICAgICAgICAgICAgdmFyIHBhcnRpYWwxID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKGVuZCk7XHJcbiAgICAgICAgICAgIHZhciBpbnNlcnRpb24gPSBmaW5kQ29tbW9uSW5zZXJ0aW9uKGZ1bGwwLCBwYXJ0aWFsMCwgZnVsbDEsIHBhcnRpYWwxKTtcclxuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IGV4dGVuZGVkU2V0dGluZ3Muc2VwYXJhdG9yIHx8ICcnO1xyXG4gICAgICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0aW9uLmJlZm9yZSArIHBhcnRpYWwwICsgc2VwYXJhdG9yICsgcGFydGlhbDEgKyBpbnNlcnRpb24uYWZ0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bGwwICsgc2VwYXJhdG9yICsgZnVsbDE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYXRpdmVGb3JtYXR0ZXIucHJvdG90eXBlLmdldExhcmdlc3RVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V2ZXJpdHkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3llYXInO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbW9udGgnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnd2Vlayc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZGF5JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE5hdGl2ZUZvcm1hdHRlcjtcclxuICAgIH0oKSk7XHJcbiAgICBmdW5jdGlvbiBidWlsZEZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHN0YW5kYXJkRGF0ZVByb3BDbnQgPSBPYmplY3Qua2V5cyhzdGFuZGFyZERhdGVQcm9wcykubGVuZ3RoO1xyXG4gICAgICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAxICYmIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BDbnQgPT09IDAgJiYgZXh0ZW5kZWRTZXR0aW5ncy53ZWVrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFdlZWtOdW1iZXIoY29udGV4dC5jb21wdXRlV2Vla051bWJlcihkYXRlLm1hcmtlciksIGNvbnRleHQud2Vla0xhYmVsLCBjb250ZXh0LmxvY2FsZSwgZXh0ZW5kZWRTZXR0aW5ncy53ZWVrKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xyXG4gICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzID0gX19hc3NpZ24oe30sIHN0YW5kYXJkRGF0ZVByb3BzKTsgLy8gY29weVxyXG4gICAgICAgIGV4dGVuZGVkU2V0dGluZ3MgPSBfX2Fzc2lnbih7fSwgZXh0ZW5kZWRTZXR0aW5ncyk7IC8vIGNvcHlcclxuICAgICAgICBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKTtcclxuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZSA9ICdVVEMnOyAvLyB3ZSBsZXZlcmFnZSB0aGUgb25seSBndWFyYW50ZWVkIHRpbWVab25lIGZvciBvdXIgVVRDIG1hcmtlcnNcclxuICAgICAgICB2YXIgbm9ybWFsRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHN0YW5kYXJkRGF0ZVByb3BzKTtcclxuICAgICAgICB2YXIgemVyb0Zvcm1hdDsgLy8gbmVlZGVkP1xyXG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XHJcbiAgICAgICAgICAgIHZhciB6ZXJvUHJvcHMgPSBfX2Fzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpO1xyXG4gICAgICAgICAgICBkZWxldGUgemVyb1Byb3BzLm1pbnV0ZTsgLy8gc2Vjb25kcyBhbmQgbXMgd2VyZSBhbHJlYWR5IGNvbnNpZGVyZWQgaW4gc2FuaXRpemVTZXR0aW5nc1xyXG4gICAgICAgICAgICB6ZXJvRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHplcm9Qcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgbWFya2VyID0gZGF0ZS5tYXJrZXI7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXQ7XHJcbiAgICAgICAgICAgIGlmICh6ZXJvRm9ybWF0ICYmICFtYXJrZXIuZ2V0VVRDTWludXRlcygpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gbm9ybWFsRm9ybWF0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzID0gZm9ybWF0LmZvcm1hdChtYXJrZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKSB7XHJcbiAgICAgICAgLy8gZGVhbCB3aXRoIGEgYnJvd3NlciBpbmNvbnNpc3RlbmN5IHdoZXJlIGZvcm1hdHRpbmcgdGhlIHRpbWV6b25lXHJcbiAgICAgICAgLy8gcmVxdWlyZXMgdGhhdCB0aGUgaG91ci9taW51dGUgYmUgcHJlc2VudC5cclxuICAgICAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMuaG91cikge1xyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMuaG91ciA9ICcyLWRpZ2l0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMubWludXRlID0gJzItZGlnaXQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9ubHkgc3VwcG9ydCBzaG9ydCB0aW1lem9uZSBuYW1lc1xyXG4gICAgICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdsb25nJykge1xyXG4gICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPSAnc2hvcnQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiByZXF1ZXN0aW5nIHRvIGRpc3BsYXkgc2Vjb25kcywgTVVTVCBkaXNwbGF5IG1pbnV0ZXNcclxuICAgICAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSAmJiAoc3RhbmRhcmREYXRlUHJvcHMuc2Vjb25kIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1pbGxpc2Vjb25kKSkge1xyXG4gICAgICAgICAgICBkZWxldGUgZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xyXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTFRSX1JFLCAnJyk7IC8vIHJlbW92ZSBsZWZ0LXRvLXJpZ2h0IGNvbnRyb2wgY2hhcnMuIGRvIGZpcnN0LiBnb29kIGZvciBvdGhlciByZWdleGVzXHJcbiAgICAgICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xyXG4gICAgICAgICAgICBzID0gaW5qZWN0VHpvU3RyKHMsIChjb250ZXh0LnRpbWVab25lID09PSAnVVRDJyB8fCBkYXRlLnRpbWVab25lT2Zmc2V0ID09IG51bGwpID9cclxuICAgICAgICAgICAgICAgICdVVEMnIDogLy8gaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSBmb3IgSUUsIHdoaWNoIGRvZXMgXCJHTVRcIlxyXG4gICAgICAgICAgICAgICAgZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoQ09NTUFfUkUsICcnKS50cmltKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJzowMCcsICcnKTsgLy8gemVyb0Zvcm1hdCBkb2Vzbid0IGFsd2F5cyBhY2hpZXZlIHRoaXNcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gXiBkbyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNyZWF0ZSBhZGphY2VudCBzcGFjZXMgYmVmb3JlIHRoaXMgcG9pbnQsXHJcbiAgICAgICAgLy8gYmVjYXVzZSBNRVJJRElFTV9SRSBsaWtlcyB0byBlYXQgdXAgbG9hZGluZyBzcGFjZXNcclxuICAgICAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgJycpLnRyaW0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ25hcnJvdycpIHsgLy8gYS9wXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIGZ1bmN0aW9uIChtMCwgbTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtMS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ3Nob3J0JykgeyAvLyBhbS9wbVxyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCBmdW5jdGlvbiAobTAsIG0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbTEudG9Mb2NhbGVMb3dlckNhc2UoKSArICdtJztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdsb3dlcmNhc2UnKSB7IC8vIG90aGVyIG1lcmlkaWVtIHRyYW5zZm9ybWVycyBhbHJlYWR5IGNvbnZlcnRlZCB0byBsb3dlcmNhc2VcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgZnVuY3Rpb24gKG0wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbTAudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTVVMVElfU1BBQ0VfUkUsICcgJyk7XHJcbiAgICAgICAgcyA9IHMudHJpbSgpO1xyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5qZWN0VHpvU3RyKHMsIHR6b1N0cikge1xyXG4gICAgICAgIHZhciByZXBsYWNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoVVRDX1JFLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHR6b1N0cjtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBJRTExIGRvZXNuJ3QgaW5jbHVkZSBVVEMvR01UIGluIHRoZSBvcmlnaW5hbCBzdHJpbmcsIHNvIGFwcGVuZCB0byBlbmRcclxuICAgICAgICBpZiAoIXJlcGxhY2VkKSB7XHJcbiAgICAgICAgICAgIHMgKz0gJyAnICsgdHpvU3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIobnVtLCB3ZWVrTGFiZWwsIGxvY2FsZSwgZGlzcGxheSkge1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgICAgIGlmIChkaXNwbGF5ID09PSAnbmFycm93Jykge1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHdlZWtMYWJlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRpc3BsYXkgPT09ICdzaG9ydCcpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaCh3ZWVrTGFiZWwsICcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG90aGVyd2lzZSwgY29uc2lkZXJlZCAnbnVtZXJpYydcclxuICAgICAgICBwYXJ0cy5wdXNoKGxvY2FsZS5zaW1wbGVOdW1iZXJGb3JtYXQuZm9ybWF0KG51bSkpO1xyXG4gICAgICAgIGlmIChsb2NhbGUub3B0aW9ucy5pc1J0bCkgeyAvLyBUT0RPOiB1c2UgY29udHJvbCBjaGFyYWN0ZXJzIGluc3RlYWQ/XHJcbiAgICAgICAgICAgIHBhcnRzLnJldmVyc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xyXG4gICAgfVxyXG4gICAgLy8gUmFuZ2UgRm9ybWF0dGluZyBVdGlsc1xyXG4gICAgLy8gMCA9IGV4YWN0bHkgdGhlIHNhbWVcclxuICAgIC8vIDEgPSBkaWZmZXJlbnQgYnkgdGltZVxyXG4gICAgLy8gYW5kIGJpZ2dlclxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShkMCwgZDEsIGNhKSB7XHJcbiAgICAgICAgaWYgKGNhLmdldE1hcmtlclllYXIoZDApICE9PSBjYS5nZXRNYXJrZXJZZWFyKGQxKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhLmdldE1hcmtlck1vbnRoKGQwKSAhPT0gY2EuZ2V0TWFya2VyTW9udGgoZDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2EuZ2V0TWFya2VyRGF5KGQwKSAhPT0gY2EuZ2V0TWFya2VyRGF5KGQxKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRpbWVBc01zKGQwKSAhPT0gdGltZUFzTXMoZDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMob3B0aW9ucywgYmlnZ2VzdFVuaXQpIHtcclxuICAgICAgICB2YXIgcGFydGlhbE9wdGlvbnMgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBuYW1lXzIgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIShuYW1lXzIgaW4gU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMpIHx8IC8vIG5vdCBhIGRhdGUgcGFydCBwcm9wIChsaWtlIHRpbWVab25lKVxyXG4gICAgICAgICAgICAgICAgU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVNbbmFtZV8yXSA8PSBiaWdnZXN0VW5pdCkge1xyXG4gICAgICAgICAgICAgICAgcGFydGlhbE9wdGlvbnNbbmFtZV8yXSA9IG9wdGlvbnNbbmFtZV8yXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFydGlhbE9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaW5kQ29tbW9uSW5zZXJ0aW9uKGZ1bGwwLCBwYXJ0aWFsMCwgZnVsbDEsIHBhcnRpYWwxKSB7XHJcbiAgICAgICAgdmFyIGkwID0gMDtcclxuICAgICAgICB3aGlsZSAoaTAgPCBmdWxsMC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGZvdW5kMCA9IGZ1bGwwLmluZGV4T2YocGFydGlhbDAsIGkwKTtcclxuICAgICAgICAgICAgaWYgKGZvdW5kMCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBiZWZvcmUwID0gZnVsbDAuc3Vic3RyKDAsIGZvdW5kMCk7XHJcbiAgICAgICAgICAgIGkwID0gZm91bmQwICsgcGFydGlhbDAubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgYWZ0ZXIwID0gZnVsbDAuc3Vic3RyKGkwKTtcclxuICAgICAgICAgICAgdmFyIGkxID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKGkxIDwgZnVsbDEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm91bmQxID0gZnVsbDEuaW5kZXhPZihwYXJ0aWFsMSwgaTEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kMSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBiZWZvcmUxID0gZnVsbDEuc3Vic3RyKDAsIGZvdW5kMSk7XHJcbiAgICAgICAgICAgICAgICBpMSA9IGZvdW5kMSArIHBhcnRpYWwxLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBhZnRlcjEgPSBmdWxsMS5zdWJzdHIoaTEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZTAgPT09IGJlZm9yZTEgJiYgYWZ0ZXIwID09PSBhZnRlcjEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmU6IGJlZm9yZTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyOiBhZnRlcjBcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBUT0RPOiBmaXggdGhlIHRlcm1pbm9sb2d5IG9mIFwiZm9ybWF0dGVyXCIgdnMgXCJmb3JtYXR0aW5nIGZ1bmNcIlxyXG4gICAgKi9cclxuICAgIC8qXHJcbiAgICBBdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cclxuICAgIEl0IHJlY2VpdmVzIHRoaXMgYXQgdGhlIHRpbWUgb2YgZm9ybWF0dGluZywgYXMgYSBzZXR0aW5nLlxyXG4gICAgKi9cclxuICAgIHZhciBDbWRGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ21kRm9ybWF0dGVyKGNtZFN0ciwgc2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY21kU3RyID0gY21kU3RyO1xyXG4gICAgICAgICAgICB0aGlzLnNlcGFyYXRvciA9IHNlcGFyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ21kRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIHRoaXMuc2VwYXJhdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDbWRGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY21kRm9ybWF0dGVyKHRoaXMuY21kU3RyLCBjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCB0aGlzLnNlcGFyYXRvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENtZEZvcm1hdHRlcjtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgdmFyIEZ1bmNGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRnVuY0Zvcm1hdHRlcihmdW5jKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEZ1bmNGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmMoY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRnVuY0Zvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jKGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBGdW5jRm9ybWF0dGVyO1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICAvLyBGb3JtYXR0ZXIgT2JqZWN0IENyZWF0aW9uXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQsIGRlZmF1bHRTZXBhcmF0b3IpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0U2VwYXJhdG9yID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBfX2Fzc2lnbih7IHNlcGFyYXRvcjogZGVmYXVsdFNlcGFyYXRvciB9LCBpbnB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ21kRm9ybWF0dGVyKGlucHV0LCBkZWZhdWx0U2VwYXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY0Zvcm1hdHRlcihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gU3RyaW5nIFV0aWxzXHJcbiAgICAvLyB0aW1lWm9uZU9mZnNldCBpcyBpbiBtaW51dGVzXHJcbiAgICBmdW5jdGlvbiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBzdHJpcFplcm9UaW1lKSB7XHJcbiAgICAgICAgaWYgKHN0cmlwWmVyb1RpbWUgPT09IHZvaWQgMCkgeyBzdHJpcFplcm9UaW1lID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgcyA9IG1hcmtlci50b0lTT1N0cmluZygpO1xyXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJy4wMDAnLCAnJyk7XHJcbiAgICAgICAgaWYgKHN0cmlwWmVyb1RpbWUpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnVDAwOjAwOjAwWicsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHMubGVuZ3RoID4gMTApIHsgLy8gdGltZSBwYXJ0IHdhc24ndCBzdHJpcHBlZCwgY2FuIGFkZCB0aW1lem9uZSBpbmZvXHJcbiAgICAgICAgICAgIGlmICh0aW1lWm9uZU9mZnNldCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVab25lT2Zmc2V0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgZm9ybWF0VGltZVpvbmVPZmZzZXQodGltZVpvbmVPZmZzZXQsIHRydWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIGl0cyBVVEMtMCBhbmQgd2Ugd2FudCB0byBrZWVwIHRoZSBaXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZm9ybWF0SXNvVGltZVN0cmluZyhtYXJrZXIpIHtcclxuICAgICAgICByZXR1cm4gcGFkU3RhcnQobWFya2VyLmdldFVUQ0hvdXJzKCksIDIpICsgJzonICtcclxuICAgICAgICAgICAgcGFkU3RhcnQobWFya2VyLmdldFVUQ01pbnV0ZXMoKSwgMikgKyAnOicgK1xyXG4gICAgICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDU2Vjb25kcygpLCAyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvcm1hdFRpbWVab25lT2Zmc2V0KG1pbnV0ZXMsIGRvSXNvKSB7XHJcbiAgICAgICAgaWYgKGRvSXNvID09PSB2b2lkIDApIHsgZG9Jc28gPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKyc7XHJcbiAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xyXG4gICAgICAgIHZhciBob3VycyA9IE1hdGguZmxvb3IoYWJzIC8gNjApO1xyXG4gICAgICAgIHZhciBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MCk7XHJcbiAgICAgICAgaWYgKGRvSXNvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpICsgJzonICsgcGFkU3RhcnQobWlucywgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ0dNVCcgKyBzaWduICsgaG91cnMgKyAobWlucyA/ICc6JyArIHBhZFN0YXJ0KG1pbnMsIDIpIDogJycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEFyZyBVdGlsc1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgc2VwYXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0SW5mbyA9IGV4cGFuZFpvbmVkTWFya2VyKHN0YXJ0LCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKTtcclxuICAgICAgICB2YXIgZW5kSW5mbyA9IGVuZCA/IGV4cGFuZFpvbmVkTWFya2VyKGVuZCwgY29udGV4dC5jYWxlbmRhclN5c3RlbSkgOiBudWxsO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGU6IHN0YXJ0SW5mbyxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mbyxcclxuICAgICAgICAgICAgZW5kOiBlbmRJbmZvLFxyXG4gICAgICAgICAgICB0aW1lWm9uZTogY29udGV4dC50aW1lWm9uZSxcclxuICAgICAgICAgICAgbG9jYWxlQ29kZXM6IGNvbnRleHQubG9jYWxlLmNvZGVzLFxyXG4gICAgICAgICAgICBzZXBhcmF0b3I6IHNlcGFyYXRvclxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHBhbmRab25lZE1hcmtlcihkYXRlSW5mbywgY2FsZW5kYXJTeXN0ZW0pIHtcclxuICAgICAgICB2YXIgYSA9IGNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkoZGF0ZUluZm8ubWFya2VyKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtYXJrZXI6IGRhdGVJbmZvLm1hcmtlcixcclxuICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVJbmZvLnRpbWVab25lT2Zmc2V0LFxyXG4gICAgICAgICAgICBhcnJheTogYSxcclxuICAgICAgICAgICAgeWVhcjogYVswXSxcclxuICAgICAgICAgICAgbW9udGg6IGFbMV0sXHJcbiAgICAgICAgICAgIGRheTogYVsyXSxcclxuICAgICAgICAgICAgaG91cjogYVszXSxcclxuICAgICAgICAgICAgbWludXRlOiBhWzRdLFxyXG4gICAgICAgICAgICBzZWNvbmQ6IGFbNV0sXHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kOiBhWzZdXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgRXZlbnRTb3VyY2VBcGkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRTb3VyY2VBcGkoY2FsZW5kYXIsIGludGVybmFsRXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgICAgICB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UgPSBpbnRlcm5hbEV2ZW50U291cmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcclxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUucmVmZXRjaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhci5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VJZHM6IFt0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50U291cmNlQXBpLnByb3RvdHlwZSwgXCJpZFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5wdWJsaWNJZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50U291cmNlQXBpLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xyXG4gICAgICAgICAgICAvLyBvbmx5IHJlbGV2YW50IHRvIGpzb24tZmVlZCBldmVudCBzb3VyY2VzXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5tZXRhLnVybDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIEV2ZW50U291cmNlQXBpO1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICB2YXIgRXZlbnRBcGkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRBcGkoY2FsZW5kYXIsIGRlZiwgaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FsZW5kYXIgPSBjYWxlbmRhcjtcclxuICAgICAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgVE9ETzogbWFrZSBldmVudCBzdHJ1Y3QgbW9yZSByZXNwb25zaWJsZSBmb3IgdGhpc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgRXZlbnRBcGkucHJvdG90eXBlLnNldFByb3AgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIGlmIChuYW1lIGluIERBVEVfUFJPUFMpIDtcclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBOT05fREFURV9QUk9QUykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBOT05fREFURV9QUk9QU1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IE5PTl9EQVRFX1BST1BTW25hbWVdKHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogKF9hID0ge30sIF9hW25hbWVdID0gdmFsLCBfYSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gVU5TQ09QRURfRVZFTlRfVUlfUFJPUFMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1aSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVU5TQ09QRURfRVZFTlRfVUlfUFJPUFNbbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBVTlNDT1BFRF9FVkVOVF9VSV9QUk9QU1tuYW1lXSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdjb2xvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICB1aSA9IHsgYmFja2dyb3VuZENvbG9yOiB2YWwsIGJvcmRlckNvbG9yOiB2YWwgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdlZGl0YWJsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICB1aSA9IHsgc3RhcnRFZGl0YWJsZTogdmFsLCBkdXJhdGlvbkVkaXRhYmxlOiB2YWwgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHVpID0gKF9iID0ge30sIF9iW25hbWVdID0gdmFsLCBfYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyB1aTogdWkgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRFeHRlbmRlZFByb3AgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogKF9hID0ge30sIF9hW25hbWVdID0gdmFsLCBfYSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFdmVudEFwaS5wcm90b3R5cGUuc2V0U3RhcnQgPSBmdW5jdGlvbiAoc3RhcnRJbnB1dCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuX2NhbGVuZGFyLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5faW5zdGFuY2UpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogc3RhcnREZWx0YSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXZlbnRBcGkucHJvdG90eXBlLnNldEVuZCA9IGZ1bmN0aW9uIChlbmRJbnB1dCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuX2NhbGVuZGFyLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgICAgIGlmIChlbmRJbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihlbmRJbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZERlbHRhID0gZGlmZkRhdGVzKHRoaXMuX2luc3RhbmNlLnJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBlbmREZWx0YSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXREYXRlcyA9IGZ1bmN0aW9uIChzdGFydElucHV0LCBlbmRJbnB1dCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuX2NhbGVuZGFyLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZFByb3BzID0geyBhbGxEYXk6IG9wdGlvbnMuYWxsRGF5IH07XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xyXG4gICAgICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmRJbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihlbmRJbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVuZCkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjb21wdXRpbmcgdGhlIGRpZmYgZm9yIGFuIGV2ZW50IGJlaW5nIGNvbnZlcnRlZCB0byBhbGwtZGF5LFxyXG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBkaWZmIG9mZiBvZiB0aGUgYWxsLWRheSB2YWx1ZXMgdGhlIHdheSBldmVudC1tdXRhdGlvbiBkb2VzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsRGF5ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VSYW5nZSA9IGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UoaW5zdGFuY2VSYW5nZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLnN0YXJ0LCBzdGFydCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2UuZW5kLCBlbmQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbnNFcXVhbChzdGFydERlbHRhLCBlbmREZWx0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBzdGFydERlbHRhLCBzdGFuZGFyZFByb3BzOiBzdGFuZGFyZFByb3BzIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhOiBzdGFydERlbHRhLCBlbmREZWx0YTogZW5kRGVsdGEsIHN0YW5kYXJkUHJvcHM6IHN0YW5kYXJkUHJvcHMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIG1lYW5zIFwiY2xlYXIgdGhlIGVuZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHM6IHN0YW5kYXJkUHJvcHMgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEV2ZW50QXBpLnByb3RvdHlwZS5tb3ZlU3RhcnQgPSBmdW5jdGlvbiAoZGVsdGFJbnB1dCkge1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcclxuICAgICAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhOiBkZWx0YSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXZlbnRBcGkucHJvdG90eXBlLm1vdmVFbmQgPSBmdW5jdGlvbiAoZGVsdGFJbnB1dCkge1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcclxuICAgICAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBlbmREZWx0YTogZGVsdGEgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEV2ZW50QXBpLnByb3RvdHlwZS5tb3ZlRGF0ZXMgPSBmdW5jdGlvbiAoZGVsdGFJbnB1dCkge1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcclxuICAgICAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBkZWx0YSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXZlbnRBcGkucHJvdG90eXBlLnNldEFsbERheSA9IGZ1bmN0aW9uIChhbGxEYXksIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICAgICAgdmFyIHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheTogYWxsRGF5IH07XHJcbiAgICAgICAgICAgIHZhciBtYWludGFpbkR1cmF0aW9uID0gb3B0aW9ucy5tYWludGFpbkR1cmF0aW9uO1xyXG4gICAgICAgICAgICBpZiAobWFpbnRhaW5EdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBtYWludGFpbkR1cmF0aW9uID0gdGhpcy5fY2FsZW5kYXIub3B0KCdhbGxEYXlNYWludGFpbkR1cmF0aW9uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RlZi5hbGxEYXkgIT09IGFsbERheSkge1xyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBtYWludGFpbkR1cmF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogc3RhbmRhcmRQcm9wcyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEV2ZW50QXBpLnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChmb3JtYXRJbnB1dCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuX2NhbGVuZGFyLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKGZvcm1hdElucHV0LCB0aGlzLl9jYWxlbmRhci5vcHQoJ2RlZmF1bHRSYW5nZVNlcGFyYXRvcicpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RlZi5oYXNFbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBpbnN0YW5jZS5yYW5nZS5lbmQsIGZvcm1hdHRlciwge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcclxuICAgICAgICAgICAgICAgICAgICBmb3JjZWRFbmRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6b1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGZvcm1hdHRlciwge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem9cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFdmVudEFwaS5wcm90b3R5cGUubXV0YXRlID0gZnVuY3Rpb24gKG11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWYgPSB0aGlzLl9kZWY7XHJcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFyLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTVVUQVRFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZDogaW5zdGFuY2UuaW5zdGFuY2VJZCxcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbjogbXV0YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbUFwaTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRTdG9yZSA9IHRoaXMuX2NhbGVuZGFyLnN0YXRlLmV2ZW50U3RvcmU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmLmRlZklkXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEV2ZW50QXBpLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFyLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfREVGJyxcclxuICAgICAgICAgICAgICAgIGRlZklkOiB0aGlzLl9kZWYuZGVmSWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gdGhpcy5fZGVmLnNvdXJjZUlkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUFwaSh0aGlzLl9jYWxlbmRhciwgdGhpcy5fY2FsZW5kYXIuc3RhdGUuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJzdGFydFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlID9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxlbmRhci5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5zdGFydCkgOlxyXG4gICAgICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZW5kXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2RlZi5oYXNFbmQpID9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxlbmRhci5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcclxuICAgICAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImlkXCIsIHtcclxuICAgICAgICAgICAgLy8gY29tcHV0YWJsZSBwcm9wcyB0aGF0IGFsbCBhY2Nlc3MgdGhlIGRlZlxyXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kIGEgVHlwZVNjcmlwdC1jb21wYXRpYmxlIHdheSB0byBkbyB0aGlzIGF0IHNjYWxlXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnB1YmxpY0lkOyB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImdyb3VwSWRcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5ncm91cElkOyB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImFsbERheVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLmFsbERheTsgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnRpdGxlOyB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInVybFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVybDsgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJyZW5kZXJpbmdcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5yZW5kZXJpbmc7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwic3RhcnRFZGl0YWJsZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLnN0YXJ0RWRpdGFibGU7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZHVyYXRpb25FZGl0YWJsZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmR1cmF0aW9uRWRpdGFibGU7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiY29uc3RyYWludFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNvbnN0cmFpbnRzWzBdIHx8IG51bGw7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwib3ZlcmxhcFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLm92ZXJsYXA7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiYWxsb3dcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5hbGxvd3NbMF0gfHwgbnVsbDsgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5iYWNrZ3JvdW5kQ29sb3I7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiYm9yZGVyQ29sb3JcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5ib3JkZXJDb2xvcjsgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJ0ZXh0Q29sb3JcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS50ZXh0Q29sb3I7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IHVzZXIgY2FuJ3QgbW9kaWZ5IHRoZXNlIGJlY2F1c2UgT2JqZWN0LmZyZWV6ZSB3YXMgY2FsbGVkIGluIGV2ZW50LWRlZiBwYXJzaW5nXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXM7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZXh0ZW5kZWRQcm9wc1wiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLmV4dGVuZGVkUHJvcHM7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBFdmVudEFwaTtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgLypcclxuICAgIFNwZWNpZnlpbmcgbmV4dERheVRocmVzaG9sZCBzaWduYWxzIHRoYXQgYWxsLWRheSByYW5nZXMgc2hvdWxkIGJlIHNsaWNlZC5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBmcmFtaW5nUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIHtcclxuICAgICAgICB2YXIgaW52ZXJzZUJnQnlHcm91cElkID0ge307XHJcbiAgICAgICAgdmFyIGludmVyc2VCZ0J5RGVmSWQgPSB7fTtcclxuICAgICAgICB2YXIgZGVmQnlHcm91cElkID0ge307XHJcbiAgICAgICAgdmFyIGJnUmFuZ2VzID0gW107XHJcbiAgICAgICAgdmFyIGZnUmFuZ2VzID0gW107XHJcbiAgICAgICAgdmFyIGV2ZW50VWlzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaUJhc2VzKTtcclxuICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcclxuICAgICAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XHJcbiAgICAgICAgICAgIGlmIChkZWYucmVuZGVyaW5nID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xyXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XHJcbiAgICAgICAgICAgIHZhciB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XHJcbiAgICAgICAgICAgIHZhciBvcmlnUmFuZ2UgPSBpbnN0YW5jZS5yYW5nZTtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbFJhbmdlID0gKCFkZWYuYWxsRGF5ICYmIG5leHREYXlUaHJlc2hvbGQpID9cclxuICAgICAgICAgICAgICAgIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2Uob3JpZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSA6XHJcbiAgICAgICAgICAgICAgICBvcmlnUmFuZ2U7XHJcbiAgICAgICAgICAgIHZhciBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhub3JtYWxSYW5nZSwgZnJhbWluZ1JhbmdlKTtcclxuICAgICAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmLnJlbmRlcmluZyA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXS5wdXNoKHNsaWNlZFJhbmdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbaW5zdGFuY2UuZGVmSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIChkZWYucmVuZGVyaW5nID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBkZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpOiB1aSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogc2xpY2VkUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IG5vcm1hbFJhbmdlLnN0YXJ0ICYmIG5vcm1hbFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogbm9ybWFsUmFuZ2UuZW5kICYmIG5vcm1hbFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKClcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBncm91cElkIGluIGludmVyc2VCZ0J5R3JvdXBJZCkgeyAvLyBCWSBHUk9VUFxyXG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gaW52ZXJzZUJnQnlHcm91cElkW2dyb3VwSWRdO1xyXG4gICAgICAgICAgICB2YXIgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGludmVydGVkUmFuZ2VzXzEgPSBpbnZlcnRlZFJhbmdlczsgX2kgPCBpbnZlcnRlZFJhbmdlc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGludmVydGVkUmFuZ2UgPSBpbnZlcnRlZFJhbmdlc18xW19pXTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBkZWZCeUdyb3VwSWRbZ3JvdXBJZF07XHJcbiAgICAgICAgICAgICAgICB2YXIgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdO1xyXG4gICAgICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmOiBkZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgdWk6IHVpLFxyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBpbnZlcnRlZFJhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgZGVmSWQgaW4gaW52ZXJzZUJnQnlEZWZJZCkge1xyXG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gaW52ZXJzZUJnQnlEZWZJZFtkZWZJZF07XHJcbiAgICAgICAgICAgIHZhciBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgaW52ZXJ0ZWRSYW5nZXNfMiA9IGludmVydGVkUmFuZ2VzOyBfYSA8IGludmVydGVkUmFuZ2VzXzIubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW52ZXJ0ZWRSYW5nZSA9IGludmVydGVkUmFuZ2VzXzJbX2FdO1xyXG4gICAgICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmOiBldmVudFN0b3JlLmRlZnNbZGVmSWRdLFxyXG4gICAgICAgICAgICAgICAgICAgIHVpOiBldmVudFVpc1tkZWZJZF0sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBiZzogYmdSYW5nZXMsIGZnOiBmZ1JhbmdlcyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFzQmdSZW5kZXJpbmcoZGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZi5yZW5kZXJpbmcgPT09ICdiYWNrZ3JvdW5kJyB8fCBkZWYucmVuZGVyaW5nID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZpbHRlclNlZ3NWaWFFbHModmlldywgc2VncywgaXNNaXJyb3IpIHtcclxuICAgICAgICBpZiAodmlldy5oYXNQdWJsaWNIYW5kbGVycygnZXZlbnRSZW5kZXInKSkge1xyXG4gICAgICAgICAgICBzZWdzID0gc2Vncy5maWx0ZXIoZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbSA9IHZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudFJlbmRlcicsIFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkodmlldy5jYWxlbmRhciwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTWlycm9yOiBpc01pcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnLmlzU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWcuaXNFbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGluY2x1ZGUgc2VnLnJhbmdlIG9uY2UgYWxsIGNvbXBvbmVudHMgY29uc2lzdGVudGx5IGdlbmVyYXRlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBzZWcuZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b20gPT09IGZhbHNlKSB7IC8vIG1lYW5zIGRvbid0IHJlbmRlciBhdCBhbGxcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXN0b20gJiYgY3VzdG9tICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVsID0gY3VzdG9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ3NfMSA9IHNlZ3M7IF9pIDwgc2Vnc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18xW19pXTtcclxuICAgICAgICAgICAgc2V0RWxTZWcoc2VnLmVsLCBzZWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldEVsU2VnKGVsLCBzZWcpIHtcclxuICAgICAgICBlbC5mY1NlZyA9IHNlZztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldEVsU2VnKGVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsLmZjU2VnIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBldmVudCB1aSBjb21wdXRhdGlvblxyXG4gICAgZnVuY3Rpb24gY29tcGlsZUV2ZW50VWlzKGV2ZW50RGVmcywgZXZlbnRVaUJhc2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcEhhc2goZXZlbnREZWZzLCBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykge1xyXG4gICAgICAgIHZhciB1aXMgPSBbXTtcclxuICAgICAgICBpZiAoZXZlbnRVaUJhc2VzWycnXSkge1xyXG4gICAgICAgICAgICB1aXMucHVzaChldmVudFVpQmFzZXNbJyddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pIHtcclxuICAgICAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzW2V2ZW50RGVmLmRlZklkXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVpcy5wdXNoKGV2ZW50RGVmLnVpKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZUV2ZW50VWlzKHVpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXBwbGllcyB0aGUgbXV0YXRpb24gdG8gQUxMIGRlZnMvaW5zdGFuY2VzIHdpdGhpbiB0aGUgZXZlbnQgc3RvcmVcclxuICAgIGZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgZXZlbnRDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRDb25maWdCYXNlKTtcclxuICAgICAgICB2YXIgZGVzdCA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGRlZklkIGluIGV2ZW50U3RvcmUuZGVmcykge1xyXG4gICAgICAgICAgICB2YXIgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2RlZklkXTtcclxuICAgICAgICAgICAgZGVzdC5kZWZzW2RlZklkXSA9IGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmKGRlZiwgZXZlbnRDb25maWdzW2RlZklkXSwgbXV0YXRpb24sIGNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy5ldmVudERlZk11dGF0aW9uQXBwbGllcnMsIGNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xyXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgdmFyIGRlZiA9IGRlc3QuZGVmc1tpbnN0YW5jZS5kZWZJZF07IC8vIGltcG9ydGFudCB0byBncmFiIHRoZSBuZXdseSBtb2RpZmllZCBkZWZcclxuICAgICAgICAgICAgZGVzdC5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGluc3RhbmNlLCBkZWYsIGV2ZW50Q29uZmlnc1tpbnN0YW5jZS5kZWZJZF0sIG11dGF0aW9uLCBjYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZXZlbnREZWYsIGV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgYXBwbGllcnMsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHN0YW5kYXJkUHJvcHMgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzIHx8IHt9O1xyXG4gICAgICAgIC8vIGlmIGhhc0VuZCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkLCBndWVzcyBhIGdvb2QgdmFsdWUgYmFzZWQgb24gZGVsdGFzLlxyXG4gICAgICAgIC8vIGlmIGR1cmF0aW9uIHdpbGwgY2hhbmdlLCB0aGVyZSdzIG5vIHdheSB0aGUgZGVmYXVsdCBkdXJhdGlvbiB3aWxsIHBlcnNpc3QsXHJcbiAgICAgICAgLy8gYW5kIHRodXMsIHdlIG5lZWQgdG8gbWFyayB0aGUgZXZlbnQgYXMgaGF2aW5nIGEgcmVhbCBlbmRcclxuICAgICAgICBpZiAoc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlICYmXHJcbiAgICAgICAgICAgIChtdXRhdGlvbi5zdGFydERlbHRhIHx8IG11dGF0aW9uLmVuZERlbHRhKSkge1xyXG4gICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IHRydWU7IC8vIFRPRE86IGlzIHRoaXMgbXV0YXRpb24gb2theT9cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvcHkgPSBfX2Fzc2lnbih7fSwgZXZlbnREZWYsIHN0YW5kYXJkUHJvcHMsIHsgdWk6IF9fYXNzaWduKHt9LCBldmVudERlZi51aSwgc3RhbmRhcmRQcm9wcy51aSkgfSk7XHJcbiAgICAgICAgaWYgKG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpIHtcclxuICAgICAgICAgICAgY29weS5leHRlbmRlZFByb3BzID0gX19hc3NpZ24oe30sIGNvcHkuZXh0ZW5kZWRQcm9wcywgbXV0YXRpb24uZXh0ZW5kZWRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYXBwbGllcnNfMSA9IGFwcGxpZXJzOyBfaSA8IGFwcGxpZXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhcHBsaWVyID0gYXBwbGllcnNfMVtfaV07XHJcbiAgICAgICAgICAgIGFwcGxpZXIoY29weSwgbXV0YXRpb24sIGNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjb3B5Lmhhc0VuZCAmJiBjYWxlbmRhci5vcHQoJ2ZvcmNlRXZlbnREdXJhdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvcHkuaGFzRW5kID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2UsIGV2ZW50RGVmLCAvLyBtdXN0IGZpcnN0IGJlIG1vZGlmaWVkIGJ5IGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmXHJcbiAgICBldmVudENvbmZpZywgbXV0YXRpb24sIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIGRhdGVFbnYgPSBjYWxlbmRhci5kYXRlRW52O1xyXG4gICAgICAgIHZhciBmb3JjZUFsbERheSA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgJiYgbXV0YXRpb24uc3RhbmRhcmRQcm9wcy5hbGxEYXkgPT09IHRydWU7XHJcbiAgICAgICAgdmFyIGNsZWFyRW5kID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmhhc0VuZCA9PT0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGNvcHkgPSBfX2Fzc2lnbih7fSwgZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgaWYgKGZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGNvcHkucmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobXV0YXRpb24uZGF0ZXNEZWx0YSAmJiBldmVudENvbmZpZy5zdGFydEVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5zdGFydCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2UuZW5kLCBtdXRhdGlvbi5kYXRlc0RlbHRhKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobXV0YXRpb24uc3RhcnREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5zdGFydCwgbXV0YXRpb24uc3RhcnREZWx0YSksXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGNvcHkucmFuZ2UuZW5kXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtdXRhdGlvbi5lbmREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmVuZERlbHRhKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xlYXJFbmQpIHtcclxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBjb3B5LnJhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZW5kOiBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbiBjYXNlIGV2ZW50IHdhcyBhbGwtZGF5IGJ1dCB0aGUgc3VwcGxpZWQgZGVsdGFzIHdlcmUgbm90XHJcbiAgICAgICAgLy8gYmV0dGVyIHV0aWwgZm9yIHRoaXM/XHJcbiAgICAgICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xyXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0T2ZEYXkoY29weS5yYW5nZS5zdGFydCksXHJcbiAgICAgICAgICAgICAgICBlbmQ6IHN0YXJ0T2ZEYXkoY29weS5yYW5nZS5lbmQpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGR1cmF0aW9uc1xyXG4gICAgICAgIGlmIChjb3B5LnJhbmdlLmVuZCA8IGNvcHkucmFuZ2Uuc3RhcnQpIHtcclxuICAgICAgICAgICAgY29weS5yYW5nZS5lbmQgPSBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVkdWNlRXZlbnRTdG9yZSAoZXZlbnRTdG9yZSwgYWN0aW9uLCBldmVudFNvdXJjZXMsIGRhdGVQcm9maWxlLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOiAvLyByYXdcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlc1thY3Rpb24uc291cmNlSWRdLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UsIGFjdGlvbi5yYXdFdmVudHMsIGNhbGVuZGFyKTtcclxuICAgICAgICAgICAgY2FzZSAnQUREX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkLCBidXQgbm90IGV4cGFuZGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkRXZlbnQoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUsIC8vIG5ldyBvbmVzXHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbCwgY2FsZW5kYXIpO1xyXG4gICAgICAgICAgICBjYXNlICdNRVJHRV9FVkVOVFMnOiAvLyBhbHJlYWR5IHBhcnNlZCBhbmQgZXhwYW5kZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV2ZW50U3RvcmUsIGFjdGlvbi5ldmVudFN0b3JlKTtcclxuICAgICAgICAgICAgY2FzZSAnUFJFVic6IC8vIFRPRE86IGhvdyBkbyB3ZSB0cmFjayBhbGwgYWN0aW9ucyB0aGF0IGFmZmVjdCBkYXRlUHJvZmlsZSA6KFxyXG4gICAgICAgICAgICBjYXNlICdORVhUJzpcclxuICAgICAgICAgICAgY2FzZSAnU0VUX0RBVEUnOlxyXG4gICAgICAgICAgICBjYXNlICdTRVRfVklFV19UWVBFJzpcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZSwgZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNhbGVuZGFyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlICdDSEFOR0VfVElNRVpPTkUnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlem9uZURhdGVzKGV2ZW50U3RvcmUsIGFjdGlvbi5vbGREYXRlRW52LCBjYWxlbmRhci5kYXRlRW52KTtcclxuICAgICAgICAgICAgY2FzZSAnTVVUQVRFX0VWRU5UUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlNdXRhdGlvblRvUmVsYXRlZChldmVudFN0b3JlLCBhY3Rpb24uaW5zdGFuY2VJZCwgYWN0aW9uLm11dGF0aW9uLCBhY3Rpb24uZnJvbUFwaSwgY2FsZW5kYXIpO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfSU5TVEFOQ0VTJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBleGNsdWRlSW5zdGFuY2VzKGV2ZW50U3RvcmUsIGFjdGlvbi5pbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfREVGJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnREZWYuZGVmSWQgIT09IGFjdGlvbi5kZWZJZDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBhY3Rpb24uc291cmNlSWQpO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZXZlbnREZWYuc291cmNlSWQ7IC8vIG9ubHkga2VlcCBldmVudHMgd2l0aCBubyBzb3VyY2UgaWRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFU0VUX0VWRU5UUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZnM6IGV2ZW50U3RvcmUuZGVmcyxcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IGV2ZW50U3RvcmUuaW5zdGFuY2VzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZSwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSwgcmF3RXZlbnRzLCBjYWxlbmRhcikge1xyXG4gICAgICAgIGlmIChldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXHJcbiAgICAgICAgICAgIGZldGNoSWQgPT09IGV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQgLy8gVE9ETzogd2lzaCB0aGlzIGxvZ2ljIHdhcyBhbHdheXMgaW4gZXZlbnQtc291cmNlc1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB2YXIgc3Vic2V0ID0gcGFyc2VFdmVudHModHJhbnNmb3JtUmF3RXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNhbGVuZGFyKSwgZXZlbnRTb3VyY2Uuc291cmNlSWQsIGNhbGVuZGFyKTtcclxuICAgICAgICAgICAgaWYgKGZldGNoUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGZldGNoUmFuZ2UsIGNhbGVuZGFyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBldmVudFNvdXJjZS5zb3VyY2VJZCksIHN1YnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudFN0b3JlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkRXZlbnQoZXZlbnRTdG9yZSwgc3Vic2V0LCBleHBhbmRSYW5nZSwgY2FsZW5kYXIpIHtcclxuICAgICAgICBpZiAoZXhwYW5kUmFuZ2UpIHtcclxuICAgICAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZXhwYW5kUmFuZ2UsIGNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgc3Vic2V0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlem9uZURhdGVzKGV2ZW50U3RvcmUsIG9sZERhdGVFbnYsIG5ld0RhdGVFbnYpIHtcclxuICAgICAgICB2YXIgZGVmcyA9IGV2ZW50U3RvcmUuZGVmcztcclxuICAgICAgICB2YXIgaW5zdGFuY2VzID0gbWFwSGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcclxuICAgICAgICAgICAgaWYgKGRlZi5hbGxEYXkgfHwgZGVmLnJlY3VycmluZ0RlZikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlOyAvLyBpc24ndCBkZXBlbmRlbnQgb24gdGltZXpvbmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7fSwgaW5zdGFuY2UsIHsgcmFuZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBpbnN0YW5jZS5mb3JjZWRTdGFydFR6bykpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLmVuZCwgaW5zdGFuY2UuZm9yY2VkRW5kVHpvKSlcclxuICAgICAgICAgICAgICAgICAgICB9LCBmb3JjZWRTdGFydFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4geyBkZWZzOiBkZWZzLCBpbnN0YW5jZXM6IGluc3RhbmNlcyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvUmVsYXRlZChldmVudFN0b3JlLCBpbnN0YW5jZUlkLCBtdXRhdGlvbiwgZnJvbUFwaSwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgcmVsZXZhbnQgPSBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlLCBpbnN0YW5jZUlkKTtcclxuICAgICAgICB2YXIgZXZlbnRDb25maWdCYXNlID0gZnJvbUFwaSA/XHJcbiAgICAgICAgICAgIHsgJyc6IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydEVkaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdXHJcbiAgICAgICAgICAgICAgICB9IH0gOlxyXG4gICAgICAgICAgICBjYWxlbmRhci5ldmVudFVpQmFzZXM7XHJcbiAgICAgICAgcmVsZXZhbnQgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50LCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjYWxlbmRhcik7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgcmVsZXZhbnQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgc291cmNlSWQpIHtcclxuICAgICAgICByZXR1cm4gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudERlZi5zb3VyY2VJZCAhPT0gc291cmNlSWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBRVUVTVElPTjogd2h5IG5vdCBqdXN0IHJldHVybiBpbnN0YW5jZXM/IGRvIGEgZ2VuZXJhbCBvYmplY3QtcHJvcGVydHktZXhjbHVzaW9uIHV0aWxcclxuICAgIGZ1bmN0aW9uIGV4Y2x1ZGVJbnN0YW5jZXMoZXZlbnRTdG9yZSwgcmVtb3ZhbHMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkZWZzOiBldmVudFN0b3JlLmRlZnMsXHJcbiAgICAgICAgICAgIGluc3RhbmNlczogZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIXJlbW92YWxzW2luc3RhbmNlLmluc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaGlnaC1sZXZlbCBzZWdtZW50aW5nLWF3YXJlIHRlc3RlciBmdW5jdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBldmVudERyYWc6IGludGVyYWN0aW9uIH0sIGNhbGVuZGFyKTsgLy8gSEFDSzogdGhlIGV2ZW50RHJhZyBwcm9wcyBpcyB1c2VkIGZvciBBTEwgaW50ZXJhY3Rpb25zXHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25WYWxpZChkYXRlU2VsZWN0aW9uLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBkYXRlU2VsZWN0aW9uOiBkYXRlU2VsZWN0aW9uIH0sIGNhbGVuZGFyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzTmV3UHJvcHNWYWxpZChuZXdQcm9wcywgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgdmlldyA9IGNhbGVuZGFyLnZpZXc7XHJcbiAgICAgICAgdmFyIHByb3BzID0gX19hc3NpZ24oeyBidXNpbmVzc0hvdXJzOiB2aWV3ID8gdmlldy5wcm9wcy5idXNpbmVzc0hvdXJzIDogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksIGRhdGVTZWxlY3Rpb246ICcnLCBldmVudFN0b3JlOiBjYWxlbmRhci5zdGF0ZS5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IGNhbGVuZGFyLmV2ZW50VWlCYXNlcywgZXZlbnRTZWxlY3Rpb246ICcnLCBldmVudERyYWc6IG51bGwsIGV2ZW50UmVzaXplOiBudWxsIH0sIG5ld1Byb3BzKTtcclxuICAgICAgICByZXR1cm4gKGNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy5pc1Byb3BzVmFsaWQgfHwgaXNQcm9wc1ZhbGlkKShwcm9wcywgY2FsZW5kYXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNQcm9wc1ZhbGlkKHN0YXRlLCBjYWxlbmRhciwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpIHtcclxuICAgICAgICBpZiAoZGF0ZVNwYW5NZXRhID09PSB2b2lkIDApIHsgZGF0ZVNwYW5NZXRhID0ge307IH1cclxuICAgICAgICBpZiAoc3RhdGUuZXZlbnREcmFnICYmICFpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY2FsZW5kYXIsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5kYXRlU2VsZWN0aW9uICYmICFpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjYWxlbmRhciwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBNb3ZpbmcgRXZlbnQgVmFsaWRhdGlvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY2FsZW5kYXIsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGludGVyYWN0aW9uID0gc3RhdGUuZXZlbnREcmFnOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcclxuICAgICAgICB2YXIgc3ViamVjdEV2ZW50U3RvcmUgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzO1xyXG4gICAgICAgIHZhciBzdWJqZWN0RGVmcyA9IHN1YmplY3RFdmVudFN0b3JlLmRlZnM7XHJcbiAgICAgICAgdmFyIHN1YmplY3RJbnN0YW5jZXMgPSBzdWJqZWN0RXZlbnRTdG9yZS5pbnN0YW5jZXM7XHJcbiAgICAgICAgdmFyIHN1YmplY3RDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKHN1YmplY3REZWZzLCBpbnRlcmFjdGlvbi5pc0V2ZW50ID9cclxuICAgICAgICAgICAgc3RhdGUuZXZlbnRVaUJhc2VzIDpcclxuICAgICAgICAgICAgeyAnJzogY2FsZW5kYXIuc2VsZWN0aW9uQ29uZmlnIH0gLy8gaWYgbm90IGEgcmVhbCBldmVudCwgdmFsaWRhdGUgYXMgYSBzZWxlY3Rpb25cclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChmaWx0ZXJDb25maWcpIHtcclxuICAgICAgICAgICAgc3ViamVjdENvbmZpZ3MgPSBtYXBIYXNoKHN1YmplY3RDb25maWdzLCBmaWx0ZXJDb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3RoZXJFdmVudFN0b3JlID0gZXhjbHVkZUluc3RhbmNlcyhzdGF0ZS5ldmVudFN0b3JlLCBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMpOyAvLyBleGNsdWRlIHRoZSBzdWJqZWN0IGV2ZW50cy4gVE9ETzogZXhjbHVkZSBkZWZzIHRvbz9cclxuICAgICAgICB2YXIgb3RoZXJEZWZzID0gb3RoZXJFdmVudFN0b3JlLmRlZnM7XHJcbiAgICAgICAgdmFyIG90aGVySW5zdGFuY2VzID0gb3RoZXJFdmVudFN0b3JlLmluc3RhbmNlcztcclxuICAgICAgICB2YXIgb3RoZXJDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKG90aGVyRGVmcywgc3RhdGUuZXZlbnRVaUJhc2VzKTtcclxuICAgICAgICBmb3IgKHZhciBzdWJqZWN0SW5zdGFuY2VJZCBpbiBzdWJqZWN0SW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWJqZWN0SW5zdGFuY2UgPSBzdWJqZWN0SW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgdmFyIHN1YmplY3RSYW5nZSA9IHN1YmplY3RJbnN0YW5jZS5yYW5nZTtcclxuICAgICAgICAgICAgdmFyIHN1YmplY3RDb25maWcgPSBzdWJqZWN0Q29uZmlnc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdO1xyXG4gICAgICAgICAgICB2YXIgc3ViamVjdERlZiA9IHN1YmplY3REZWZzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XHJcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc3ViamVjdENvbmZpZy5jb25zdHJhaW50cywgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNhbGVuZGFyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG92ZXJsYXBcclxuICAgICAgICAgICAgdmFyIG92ZXJsYXBGdW5jID0gY2FsZW5kYXIub3B0KCdldmVudE92ZXJsYXAnKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvdmVybGFwRnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcEZ1bmMgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIG90aGVySW5zdGFuY2VJZCBpbiBvdGhlckluc3RhbmNlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG90aGVySW5zdGFuY2UgPSBvdGhlckluc3RhbmNlc1tvdGhlckluc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICAgICAgLy8gaW50ZXJzZWN0ISBldmFsdWF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlc0ludGVyc2VjdChzdWJqZWN0UmFuZ2UsIG90aGVySW5zdGFuY2UucmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyT3ZlcmxhcCA9IG90aGVyQ29uZmlnc1tvdGhlckluc3RhbmNlLmRlZklkXS5vdmVybGFwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBvdGhlciBldmVudCdzIG92ZXJsYXAuIG9ubHkgZG8gdGhpcyBpZiB0aGUgc3ViamVjdCBldmVudCBpcyBhIFwicmVhbFwiIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyT3ZlcmxhcCA9PT0gZmFsc2UgJiYgaW50ZXJhY3Rpb24uaXNFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJqZWN0Q29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBGdW5jICYmICFvdmVybGFwRnVuYyhuZXcgRXZlbnRBcGkoY2FsZW5kYXIsIG90aGVyRGVmc1tvdGhlckluc3RhbmNlLmRlZklkXSwgb3RoZXJJbnN0YW5jZSksIC8vIHN0aWxsIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEV2ZW50QXBpKGNhbGVuZGFyLCBzdWJqZWN0RGVmLCBzdWJqZWN0SW5zdGFuY2UpIC8vIG1vdmluZyBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbGxvdyAoYSBmdW5jdGlvbilcclxuICAgICAgICAgICAgdmFyIGNhbGVuZGFyRXZlbnRTdG9yZSA9IGNhbGVuZGFyLnN0YXRlLmV2ZW50U3RvcmU7IC8vIG5lZWQgZ2xvYmFsLXRvLWNhbGVuZGFyLCBub3QgbG9jYWwgdG8gY29tcG9uZW50IChzcGxpdHRhYmxlKXN0YXRlXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdWJqZWN0Q29uZmlnLmFsbG93czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdWJqZWN0QWxsb3cgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ViamVjdERhdGVTcGFuID0gX19hc3NpZ24oe30sIGRhdGVTcGFuTWV0YSwgeyByYW5nZTogc3ViamVjdEluc3RhbmNlLnJhbmdlLCBhbGxEYXk6IHN1YmplY3REZWYuYWxsRGF5IH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdEZWYgPSBjYWxlbmRhckV2ZW50U3RvcmUuZGVmc1tzdWJqZWN0RGVmLmRlZklkXTtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnSW5zdGFuY2UgPSBjYWxlbmRhckV2ZW50U3RvcmUuaW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudEFwaSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnRGVmKSB7IC8vIHdhcyBwcmV2aW91c2x5IGluIHRoZSBjYWxlbmRhclxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNhbGVuZGFyLCBvcmlnRGVmLCBvcmlnSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIHdhcyBhbiBleHRlcm5hbCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNhbGVuZGFyLCBzdWJqZWN0RGVmKTsgLy8gbm8gaW5zdGFuY2UsIGJlY2F1c2UgaGFkIG5vIGRhdGVzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1YmplY3RBbGxvdyhjYWxlbmRhci5idWlsZERhdGVTcGFuQXBpKHN1YmplY3REYXRlU3BhbiksIGV2ZW50QXBpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIERhdGUgU2VsZWN0aW9uIFZhbGlkYXRpb25cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY2FsZW5kYXIsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHJlbGV2YW50RXZlbnRTdG9yZSA9IHN0YXRlLmV2ZW50U3RvcmU7XHJcbiAgICAgICAgdmFyIHJlbGV2YW50RGVmcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5kZWZzO1xyXG4gICAgICAgIHZhciByZWxldmFudEluc3RhbmNlcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5pbnN0YW5jZXM7XHJcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLmRhdGVTZWxlY3Rpb247XHJcbiAgICAgICAgdmFyIHNlbGVjdGlvblJhbmdlID0gc2VsZWN0aW9uLnJhbmdlO1xyXG4gICAgICAgIHZhciBzZWxlY3Rpb25Db25maWcgPSBjYWxlbmRhci5zZWxlY3Rpb25Db25maWc7XHJcbiAgICAgICAgaWYgKGZpbHRlckNvbmZpZykge1xyXG4gICAgICAgICAgICBzZWxlY3Rpb25Db25maWcgPSBmaWx0ZXJDb25maWcoc2VsZWN0aW9uQ29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc3RyYWludFxyXG4gICAgICAgIGlmICghYWxsQ29uc3RyYWludHNQYXNzKHNlbGVjdGlvbkNvbmZpZy5jb25zdHJhaW50cywgc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50RXZlbnRTdG9yZSwgc3RhdGUuYnVzaW5lc3NIb3VycywgY2FsZW5kYXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb3ZlcmxhcFxyXG4gICAgICAgIHZhciBvdmVybGFwRnVuYyA9IGNhbGVuZGFyLm9wdCgnc2VsZWN0T3ZlcmxhcCcpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3ZlcmxhcEZ1bmMgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgb3ZlcmxhcEZ1bmMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciByZWxldmFudEluc3RhbmNlSWQgaW4gcmVsZXZhbnRJbnN0YW5jZXMpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGV2YW50SW5zdGFuY2UgPSByZWxldmFudEluc3RhbmNlc1tyZWxldmFudEluc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXHJcbiAgICAgICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50SW5zdGFuY2UucmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uQ29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBGdW5jICYmICFvdmVybGFwRnVuYyhuZXcgRXZlbnRBcGkoY2FsZW5kYXIsIHJlbGV2YW50RGVmc1tyZWxldmFudEluc3RhbmNlLmRlZklkXSwgcmVsZXZhbnRJbnN0YW5jZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzZWxlY3Rpb25Db25maWcuYWxsb3dzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uQWxsb3cgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHZhciBmdWxsRGF0ZVNwYW4gPSBfX2Fzc2lnbih7fSwgZGF0ZVNwYW5NZXRhLCBzZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbkFsbG93KGNhbGVuZGFyLmJ1aWxkRGF0ZVNwYW5BcGkoZnVsbERhdGVTcGFuKSwgbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIENvbnN0cmFpbnQgVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gYWxsQ29uc3RyYWludHNQYXNzKGNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjb25zdHJhaW50c18xID0gY29uc3RyYWludHM7IF9pIDwgY29uc3RyYWludHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c18xW19pXTtcclxuICAgICAgICAgICAgaWYgKCFhbnlSYW5nZXNDb250YWluUmFuZ2UoY29uc3RyYWludFRvUmFuZ2VzKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY2FsZW5kYXIpLCBzdWJqZWN0UmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCAvLyBmb3IgZXhwYW5kaW5nIGEgcmVjdXJyaW5nIGNvbnN0cmFpbnQsIG9yIGV4cGFuZGluZyBidXNpbmVzcyBob3Vyc1xyXG4gICAgb3RoZXJFdmVudFN0b3JlLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyBhbiBldmVuIGdyb3VwIElEXHJcbiAgICBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgJ2J1c2luZXNzSG91cnMnXHJcbiAgICBjYWxlbmRhciAvLyBmb3IgZXhwYW5kaW5nIGJ1c2luZXNzaG91cnNcclxuICAgICkge1xyXG4gICAgICAgIGlmIChjb25zdHJhaW50ID09PSAnYnVzaW5lc3NIb3VycycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIHN1YmplY3RSYW5nZSwgY2FsZW5kYXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdzdHJpbmcnKSB7IC8vIGFuIGdyb3VwIElEXHJcbiAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZmlsdGVyRXZlbnRTdG9yZURlZnMob3RoZXJFdmVudFN0b3JlLCBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudERlZi5ncm91cElkID09PSBjb25zdHJhaW50O1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnb2JqZWN0JyAmJiBjb25zdHJhaW50KSB7IC8vIG5vbi1udWxsIG9iamVjdFxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIGNhbGVuZGFyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTsgLy8gaWYgaXQncyBmYWxzZVxyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogbW92ZSB0byBldmVudC1zdG9yZSBmaWxlP1xyXG4gICAgZnVuY3Rpb24gZXZlbnRTdG9yZVRvUmFuZ2VzKGV2ZW50U3RvcmUpIHtcclxuICAgICAgICB2YXIgaW5zdGFuY2VzID0gZXZlbnRTdG9yZS5pbnN0YW5jZXM7XHJcbiAgICAgICAgdmFyIHJhbmdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYW5nZXM7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBtb3ZlIHRvIGdlb20gZmlsZT9cclxuICAgIGZ1bmN0aW9uIGFueVJhbmdlc0NvbnRhaW5SYW5nZShvdXRlclJhbmdlcywgaW5uZXJSYW5nZSkge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgb3V0ZXJSYW5nZXNfMSA9IG91dGVyUmFuZ2VzOyBfaSA8IG91dGVyUmFuZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRlclJhbmdlID0gb3V0ZXJSYW5nZXNfMVtfaV07XHJcbiAgICAgICAgICAgIGlmIChyYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIFBhcnNpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplQ29uc3RyYWludChpbnB1dCwgY2FsZW5kYXIpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKGlucHV0LCAnJywgY2FsZW5kYXIsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUV2ZW50cyhbaW5wdXRdLCAnJywgY2FsZW5kYXIsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaHRtbEVzY2FwZShzKSB7XHJcbiAgICAgICAgcmV0dXJuIChzICsgJycpLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcclxuICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICcmIzAzOTsnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJzxiciAvPicpO1xyXG4gICAgfVxyXG4gICAgLy8gR2l2ZW4gYSBoYXNoIG9mIENTUyBwcm9wZXJ0aWVzLCByZXR1cm5zIGEgc3RyaW5nIG9mIENTUy5cclxuICAgIC8vIFVzZXMgcHJvcGVydHkgbmFtZXMgYXMtaXMgKG5vIGNhbWVsLWNhc2UgY29udmVyc2lvbikuIFdpbGwgbm90IG1ha2Ugc3RhdGVtZW50cyBmb3IgbnVsbC91bmRlZmluZWQgdmFsdWVzLlxyXG4gICAgZnVuY3Rpb24gY3NzVG9TdHIoY3NzUHJvcHMpIHtcclxuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBjc3NQcm9wcykge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gY3NzUHJvcHNbbmFtZV8xXTtcclxuICAgICAgICAgICAgaWYgKHZhbCAhPSBudWxsICYmIHZhbCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuYW1lXzEgKyAnOicgKyB2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLmpvaW4oJzsnKTtcclxuICAgIH1cclxuICAgIC8vIEdpdmVuIGFuIG9iamVjdCBoYXNoIG9mIEhUTUwgYXR0cmlidXRlIG5hbWVzIHRvIHZhbHVlcyxcclxuICAgIC8vIGdlbmVyYXRlcyBhIHN0cmluZyB0aGF0IGNhbiBiZSBpbmplY3RlZCBiZXR3ZWVuIDwgPiBpbiBIVE1MXHJcbiAgICBmdW5jdGlvbiBhdHRyc1RvU3RyKGF0dHJzKSB7XHJcbiAgICAgICAgdmFyIHBhcnRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIGF0dHJzKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBhdHRyc1tuYW1lXzJdO1xyXG4gICAgICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gobmFtZV8yICsgJz1cIicgKyBodG1sRXNjYXBlKHZhbCkgKyAnXCInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignICcpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VDbGFzc05hbWUocmF3KSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmF3O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmF3LnNwbGl0KC9cXHMrLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBVTlNDT1BFRF9FVkVOVF9VSV9QUk9QUyA9IHtcclxuICAgICAgICBlZGl0YWJsZTogQm9vbGVhbixcclxuICAgICAgICBzdGFydEVkaXRhYmxlOiBCb29sZWFuLFxyXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXHJcbiAgICAgICAgY29uc3RyYWludDogbnVsbCxcclxuICAgICAgICBvdmVybGFwOiBudWxsLFxyXG4gICAgICAgIGFsbG93OiBudWxsLFxyXG4gICAgICAgIGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWUsXHJcbiAgICAgICAgY2xhc3NOYW1lczogcGFyc2VDbGFzc05hbWUsXHJcbiAgICAgICAgY29sb3I6IFN0cmluZyxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcclxuICAgICAgICBib3JkZXJDb2xvcjogU3RyaW5nLFxyXG4gICAgICAgIHRleHRDb2xvcjogU3RyaW5nXHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Vuc2NvcGVkVWlQcm9wcyhyYXdQcm9wcywgY2FsZW5kYXIsIGxlZnRvdmVycykge1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHJlZmluZVByb3BzKHJhd1Byb3BzLCBVTlNDT1BFRF9FVkVOVF9VSV9QUk9QUywge30sIGxlZnRvdmVycyk7XHJcbiAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBub3JtYWxpemVDb25zdHJhaW50KHByb3BzLmNvbnN0cmFpbnQsIGNhbGVuZGFyKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydEVkaXRhYmxlOiBwcm9wcy5zdGFydEVkaXRhYmxlICE9IG51bGwgPyBwcm9wcy5zdGFydEVkaXRhYmxlIDogcHJvcHMuZWRpdGFibGUsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHByb3BzLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IHByb3BzLmR1cmF0aW9uRWRpdGFibGUgOiBwcm9wcy5lZGl0YWJsZSxcclxuICAgICAgICAgICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnQgIT0gbnVsbCA/IFtjb25zdHJhaW50XSA6IFtdLFxyXG4gICAgICAgICAgICBvdmVybGFwOiBwcm9wcy5vdmVybGFwLFxyXG4gICAgICAgICAgICBhbGxvd3M6IHByb3BzLmFsbG93ICE9IG51bGwgPyBbcHJvcHMuYWxsb3ddIDogW10sXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcHJvcHMuYmFja2dyb3VuZENvbG9yIHx8IHByb3BzLmNvbG9yLFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogcHJvcHMuYm9yZGVyQ29sb3IgfHwgcHJvcHMuY29sb3IsXHJcbiAgICAgICAgICAgIHRleHRDb2xvcjogcHJvcHMudGV4dENvbG9yLFxyXG4gICAgICAgICAgICBjbGFzc05hbWVzOiBwcm9wcy5jbGFzc05hbWVzLmNvbmNhdChwcm9wcy5jbGFzc05hbWUpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTY29wZWRVaVByb3BzKHByZWZpeCwgcmF3U2NvcGVkLCBjYWxlbmRhciwgbGVmdG92ZXJzKSB7XHJcbiAgICAgICAgdmFyIHJhd1Vuc2NvcGVkID0ge307XHJcbiAgICAgICAgdmFyIHdhc0ZvdW5kID0ge307XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIFVOU0NPUEVEX0VWRU5UX1VJX1BST1BTKSB7XHJcbiAgICAgICAgICAgIHZhciBzY29wZWRLZXkgPSBwcmVmaXggKyBjYXBpdGFsaXNlRmlyc3RMZXR0ZXIoa2V5KTtcclxuICAgICAgICAgICAgcmF3VW5zY29wZWRba2V5XSA9IHJhd1Njb3BlZFtzY29wZWRLZXldO1xyXG4gICAgICAgICAgICB3YXNGb3VuZFtzY29wZWRLZXldID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJ2V2ZW50Jykge1xyXG4gICAgICAgICAgICByYXdVbnNjb3BlZC5lZGl0YWJsZSA9IHJhd1Njb3BlZC5lZGl0YWJsZTsgLy8gc3BlY2lhbCBjYXNlLiB0aGVyZSBpcyBubyAnZXZlbnRFZGl0YWJsZScsIGp1c3QgJ2VkaXRhYmxlJ1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVmdG92ZXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiByYXdTY29wZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghd2FzRm91bmRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRvdmVyc1trZXldID0gcmF3U2NvcGVkW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NVbnNjb3BlZFVpUHJvcHMocmF3VW5zY29wZWQsIGNhbGVuZGFyKTtcclxuICAgIH1cclxuICAgIHZhciBFTVBUWV9FVkVOVF9VSSA9IHtcclxuICAgICAgICBzdGFydEVkaXRhYmxlOiBudWxsLFxyXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IG51bGwsXHJcbiAgICAgICAgY29uc3RyYWludHM6IFtdLFxyXG4gICAgICAgIG92ZXJsYXA6IG51bGwsXHJcbiAgICAgICAgYWxsb3dzOiBbXSxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxyXG4gICAgICAgIGJvcmRlckNvbG9yOiAnJyxcclxuICAgICAgICB0ZXh0Q29sb3I6ICcnLFxyXG4gICAgICAgIGNsYXNzTmFtZXM6IFtdXHJcbiAgICB9O1xyXG4gICAgLy8gcHJldmVudCBhZ2FpbnN0IHByb2JsZW1zIHdpdGggPDIgYXJncyFcclxuICAgIGZ1bmN0aW9uIGNvbWJpbmVFdmVudFVpcyh1aXMpIHtcclxuICAgICAgICByZXR1cm4gdWlzLnJlZHVjZShjb21iaW5lVHdvRXZlbnRVaXMsIEVNUFRZX0VWRU5UX1VJKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbWJpbmVUd29FdmVudFVpcyhpdGVtMCwgaXRlbTEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydEVkaXRhYmxlOiBpdGVtMS5zdGFydEVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5zdGFydEVkaXRhYmxlIDogaXRlbTAuc3RhcnRFZGl0YWJsZSxcclxuICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogaXRlbTEuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gaXRlbTEuZHVyYXRpb25FZGl0YWJsZSA6IGl0ZW0wLmR1cmF0aW9uRWRpdGFibGUsXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBpdGVtMC5jb25zdHJhaW50cy5jb25jYXQoaXRlbTEuY29uc3RyYWludHMpLFxyXG4gICAgICAgICAgICBvdmVybGFwOiB0eXBlb2YgaXRlbTEub3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gaXRlbTEub3ZlcmxhcCA6IGl0ZW0wLm92ZXJsYXAsXHJcbiAgICAgICAgICAgIGFsbG93czogaXRlbTAuYWxsb3dzLmNvbmNhdChpdGVtMS5hbGxvd3MpLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGl0ZW0xLmJhY2tncm91bmRDb2xvciB8fCBpdGVtMC5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBpdGVtMS5ib3JkZXJDb2xvciB8fCBpdGVtMC5ib3JkZXJDb2xvcixcclxuICAgICAgICAgICAgdGV4dENvbG9yOiBpdGVtMS50ZXh0Q29sb3IgfHwgaXRlbTAudGV4dENvbG9yLFxyXG4gICAgICAgICAgICBjbGFzc05hbWVzOiBpdGVtMC5jbGFzc05hbWVzLmNvbmNhdChpdGVtMS5jbGFzc05hbWVzKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIE5PTl9EQVRFX1BST1BTID0ge1xyXG4gICAgICAgIGlkOiBTdHJpbmcsXHJcbiAgICAgICAgZ3JvdXBJZDogU3RyaW5nLFxyXG4gICAgICAgIHRpdGxlOiBTdHJpbmcsXHJcbiAgICAgICAgdXJsOiBTdHJpbmcsXHJcbiAgICAgICAgcmVuZGVyaW5nOiBTdHJpbmcsXHJcbiAgICAgICAgZXh0ZW5kZWRQcm9wczogbnVsbFxyXG4gICAgfTtcclxuICAgIHZhciBEQVRFX1BST1BTID0ge1xyXG4gICAgICAgIHN0YXJ0OiBudWxsLFxyXG4gICAgICAgIGRhdGU6IG51bGwsXHJcbiAgICAgICAgZW5kOiBudWxsLFxyXG4gICAgICAgIGFsbERheTogbnVsbFxyXG4gICAgfTtcclxuICAgIHZhciB1aWQgPSAwO1xyXG4gICAgZnVuY3Rpb24gcGFyc2VFdmVudChyYXcsIHNvdXJjZUlkLCBjYWxlbmRhciwgYWxsb3dPcGVuUmFuZ2UpIHtcclxuICAgICAgICB2YXIgYWxsRGF5RGVmYXVsdCA9IGNvbXB1dGVJc0FsbERheURlZmF1bHQoc291cmNlSWQsIGNhbGVuZGFyKTtcclxuICAgICAgICB2YXIgbGVmdG92ZXJzMCA9IHt9O1xyXG4gICAgICAgIHZhciByZWN1cnJpbmdSZXMgPSBwYXJzZVJlY3VycmluZyhyYXcsIC8vIHJhdywgYnV0IHdpdGggc2luZ2xlLWV2ZW50IHN0dWZmIHN0cmlwcGVkIG91dFxyXG4gICAgICAgIGFsbERheURlZmF1bHQsIGNhbGVuZGFyLmRhdGVFbnYsIGNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy5yZWN1cnJpbmdUeXBlcywgbGVmdG92ZXJzMCAvLyB3aWxsIHBvcHVsYXRlIHdpdGggbm9uLXJlY3VycmluZyBwcm9wc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHJlY3VycmluZ1Jlcykge1xyXG4gICAgICAgICAgICB2YXIgZGVmID0gcGFyc2VFdmVudERlZihsZWZ0b3ZlcnMwLCBzb3VyY2VJZCwgcmVjdXJyaW5nUmVzLmFsbERheSwgQm9vbGVhbihyZWN1cnJpbmdSZXMuZHVyYXRpb24pLCBjYWxlbmRhcik7XHJcbiAgICAgICAgICAgIGRlZi5yZWN1cnJpbmdEZWYgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlSWQ6IHJlY3VycmluZ1Jlcy50eXBlSWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nUmVzLnR5cGVEYXRhLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHJlY3VycmluZ1Jlcy5kdXJhdGlvblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4geyBkZWY6IGRlZiwgaW5zdGFuY2U6IG51bGwgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0b3ZlcnMxID0ge307XHJcbiAgICAgICAgICAgIHZhciBzaW5nbGVSZXMgPSBwYXJzZVNpbmdsZShyYXcsIGFsbERheURlZmF1bHQsIGNhbGVuZGFyLCBsZWZ0b3ZlcnMxLCBhbGxvd09wZW5SYW5nZSk7XHJcbiAgICAgICAgICAgIGlmIChzaW5nbGVSZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBwYXJzZUV2ZW50RGVmKGxlZnRvdmVyczEsIHNvdXJjZUlkLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjYWxlbmRhcik7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgc2luZ2xlUmVzLnJhbmdlLCBzaW5nbGVSZXMuZm9yY2VkU3RhcnRUem8sIHNpbmdsZVJlcy5mb3JjZWRFbmRUem8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGVmOiBkZWYsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIFdpbGwgTk9UIHBvcHVsYXRlIGV4dGVuZGVkUHJvcHMgd2l0aCB0aGUgbGVmdG92ZXIgcHJvcGVydGllcy5cclxuICAgIFdpbGwgTk9UIHBvcHVsYXRlIGRhdGUtcmVsYXRlZCBwcm9wcy5cclxuICAgIFRoZSBFdmVudE5vbkRhdGVJbnB1dCBoYXMgYmVlbiBub3JtYWxpemVkIChpZCA9PiBwdWJsaWNJZCwgZXRjKS5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50RGVmKHJhdywgc291cmNlSWQsIGFsbERheSwgaGFzRW5kLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBsZWZ0b3ZlcnMgPSB7fTtcclxuICAgICAgICB2YXIgZGVmID0gcGx1Y2tOb25EYXRlUHJvcHMocmF3LCBjYWxlbmRhciwgbGVmdG92ZXJzKTtcclxuICAgICAgICBkZWYuZGVmSWQgPSBTdHJpbmcodWlkKyspO1xyXG4gICAgICAgIGRlZi5zb3VyY2VJZCA9IHNvdXJjZUlkO1xyXG4gICAgICAgIGRlZi5hbGxEYXkgPSBhbGxEYXk7XHJcbiAgICAgICAgZGVmLmhhc0VuZCA9IGhhc0VuZDtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY2FsZW5kYXIucGx1Z2luU3lzdGVtLmhvb2tzLmV2ZW50RGVmUGFyc2VyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGVmUGFyc2VyID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB2YXIgbmV3TGVmdG92ZXJzID0ge307XHJcbiAgICAgICAgICAgIGV2ZW50RGVmUGFyc2VyKGRlZiwgbGVmdG92ZXJzLCBuZXdMZWZ0b3ZlcnMpO1xyXG4gICAgICAgICAgICBsZWZ0b3ZlcnMgPSBuZXdMZWZ0b3ZlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZi5leHRlbmRlZFByb3BzID0gX19hc3NpZ24obGVmdG92ZXJzLCBkZWYuZXh0ZW5kZWRQcm9wcyB8fCB7fSk7XHJcbiAgICAgICAgLy8gaGVscCBvdXQgRXZlbnRBcGkgZnJvbSBoYXZpbmcgdXNlciBtb2RpZnkgcHJvcHNcclxuICAgICAgICBPYmplY3QuZnJlZXplKGRlZi51aS5jbGFzc05hbWVzKTtcclxuICAgICAgICBPYmplY3QuZnJlZXplKGRlZi5leHRlbmRlZFByb3BzKTtcclxuICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWZJZCwgcmFuZ2UsIGZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem8pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpbnN0YW5jZUlkOiBTdHJpbmcodWlkKyspLFxyXG4gICAgICAgICAgICBkZWZJZDogZGVmSWQsXHJcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcclxuICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGZvcmNlZFN0YXJ0VHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkU3RhcnRUem8sXHJcbiAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZm9yY2VkRW5kVHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkRW5kVHpvXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhcnNlU2luZ2xlKHJhdywgYWxsRGF5RGVmYXVsdCwgY2FsZW5kYXIsIGxlZnRvdmVycywgYWxsb3dPcGVuUmFuZ2UpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSBwbHVja0RhdGVQcm9wcyhyYXcsIGxlZnRvdmVycyk7XHJcbiAgICAgICAgdmFyIGFsbERheSA9IHByb3BzLmFsbERheTtcclxuICAgICAgICB2YXIgc3RhcnRNZXRhO1xyXG4gICAgICAgIHZhciBzdGFydE1hcmtlciA9IG51bGw7XHJcbiAgICAgICAgdmFyIGhhc0VuZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBlbmRNZXRhO1xyXG4gICAgICAgIHZhciBlbmRNYXJrZXIgPSBudWxsO1xyXG4gICAgICAgIHN0YXJ0TWV0YSA9IGNhbGVuZGFyLmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShwcm9wcy5zdGFydCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0TWV0YSkge1xyXG4gICAgICAgICAgICBzdGFydE1hcmtlciA9IHN0YXJ0TWV0YS5tYXJrZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFhbGxvd09wZW5SYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLmVuZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVuZE1ldGEgPSBjYWxlbmRhci5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEocHJvcHMuZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChhbGxEYXlEZWZhdWx0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGFsbERheSA9IGFsbERheURlZmF1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdGhlIGRhdGUgcHJvcHMgTEFTVFxyXG4gICAgICAgICAgICAgICAgYWxsRGF5ID0gKCFzdGFydE1ldGEgfHwgc3RhcnRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxsRGF5ICYmIHN0YXJ0TWFya2VyKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRPZkRheShzdGFydE1hcmtlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRNZXRhKSB7XHJcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IGVuZE1ldGEubWFya2VyO1xyXG4gICAgICAgICAgICBpZiAoYWxsRGF5KSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNYXJrZXIgPSBzdGFydE9mRGF5KGVuZE1hcmtlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlciA8PSBzdGFydE1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgZW5kTWFya2VyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGhhc0VuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFhbGxvd09wZW5SYW5nZSkge1xyXG4gICAgICAgICAgICBoYXNFbmQgPSBjYWxlbmRhci5vcHQoJ2ZvcmNlRXZlbnREdXJhdGlvbicpIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICBlbmRNYXJrZXIgPSBjYWxlbmRhci5kYXRlRW52LmFkZChzdGFydE1hcmtlciwgYWxsRGF5ID9cclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhbGxEYXk6IGFsbERheSxcclxuICAgICAgICAgICAgaGFzRW5kOiBoYXNFbmQsXHJcbiAgICAgICAgICAgIHJhbmdlOiB7IHN0YXJ0OiBzdGFydE1hcmtlciwgZW5kOiBlbmRNYXJrZXIgfSxcclxuICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5mb3JjZWRUem8gOiBudWxsLFxyXG4gICAgICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEgPyBlbmRNZXRhLmZvcmNlZFR6byA6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGx1Y2tEYXRlUHJvcHMocmF3LCBsZWZ0b3ZlcnMpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSByZWZpbmVQcm9wcyhyYXcsIERBVEVfUFJPUFMsIHt9LCBsZWZ0b3ZlcnMpO1xyXG4gICAgICAgIHByb3BzLnN0YXJ0ID0gKHByb3BzLnN0YXJ0ICE9PSBudWxsKSA/IHByb3BzLnN0YXJ0IDogcHJvcHMuZGF0ZTtcclxuICAgICAgICBkZWxldGUgcHJvcHMuZGF0ZTtcclxuICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwbHVja05vbkRhdGVQcm9wcyhyYXcsIGNhbGVuZGFyLCBsZWZ0b3ZlcnMpIHtcclxuICAgICAgICB2YXIgcHJlTGVmdG92ZXJzID0ge307XHJcbiAgICAgICAgdmFyIHByb3BzID0gcmVmaW5lUHJvcHMocmF3LCBOT05fREFURV9QUk9QUywge30sIHByZUxlZnRvdmVycyk7XHJcbiAgICAgICAgdmFyIHVpID0gcHJvY2Vzc1Vuc2NvcGVkVWlQcm9wcyhwcmVMZWZ0b3ZlcnMsIGNhbGVuZGFyLCBsZWZ0b3ZlcnMpO1xyXG4gICAgICAgIHByb3BzLnB1YmxpY0lkID0gcHJvcHMuaWQ7XHJcbiAgICAgICAgZGVsZXRlIHByb3BzLmlkO1xyXG4gICAgICAgIHByb3BzLnVpID0gdWk7XHJcbiAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUlzQWxsRGF5RGVmYXVsdChzb3VyY2VJZCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgcmVzID0gbnVsbDtcclxuICAgICAgICBpZiAoc291cmNlSWQpIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGNhbGVuZGFyLnN0YXRlLmV2ZW50U291cmNlc1tzb3VyY2VJZF07XHJcbiAgICAgICAgICAgIHJlcyA9IHNvdXJjZS5hbGxEYXlEZWZhdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzID0gY2FsZW5kYXIub3B0KCdhbGxEYXlEZWZhdWx0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIERFRl9ERUZBVUxUUyA9IHtcclxuICAgICAgICBzdGFydFRpbWU6ICcwOTowMCcsXHJcbiAgICAgICAgZW5kVGltZTogJzE3OjAwJyxcclxuICAgICAgICBkYXlzT2ZXZWVrOiBbMSwgMiwgMywgNCwgNV0sXHJcbiAgICAgICAgcmVuZGVyaW5nOiAnaW52ZXJzZS1iYWNrZ3JvdW5kJyxcclxuICAgICAgICBjbGFzc05hbWVzOiAnZmMtbm9uYnVzaW5lc3MnLFxyXG4gICAgICAgIGdyb3VwSWQ6ICdfYnVzaW5lc3NIb3VycycgLy8gc28gbXVsdGlwbGUgZGVmcyBnZXQgZ3JvdXBlZFxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBUT0RPOiBwYXNzIGFyb3VuZCBhcyBFdmVudERlZkhhc2ghISFcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZUJ1c2luZXNzSG91cnMoaW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKHJlZmluZUlucHV0cyhpbnB1dCksICcnLCBjYWxlbmRhcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWZpbmVJbnB1dHMoaW5wdXQpIHtcclxuICAgICAgICB2YXIgcmF3RGVmcztcclxuICAgICAgICBpZiAoaW5wdXQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmF3RGVmcyA9IFt7fV07IC8vIHdpbGwgZ2V0IERFRl9ERUZBVUxUUyB2ZXJiYXRpbVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICAvLyBpZiBzcGVjaWZ5aW5nIGFuIGFycmF5LCBldmVyeSBzdWItZGVmaW5pdGlvbiBORUVEUyBhIGRheS1vZi13ZWVrXHJcbiAgICAgICAgICAgIHJhd0RlZnMgPSBpbnB1dC5maWx0ZXIoZnVuY3Rpb24gKHJhd0RlZikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd0RlZi5kYXlzT2ZXZWVrO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgcmF3RGVmcyA9IFtpbnB1dF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgeyAvLyBpcyBwcm9iYWJseSBmYWxzZVxyXG4gICAgICAgICAgICByYXdEZWZzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJhd0RlZnMgPSByYXdEZWZzLm1hcChmdW5jdGlvbiAocmF3RGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7fSwgREVGX0RFRkFVTFRTLCByYXdEZWYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByYXdEZWZzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1lbW9pemVSZW5kZXJpbmcocmVuZGVyRnVuYywgdW5yZW5kZXJGdW5jLCBkZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gW107IH1cclxuICAgICAgICB2YXIgZGVwZW5kZW50cyA9IFtdO1xyXG4gICAgICAgIHZhciB0aGlzQ29udGV4dDtcclxuICAgICAgICB2YXIgcHJldkFyZ3M7XHJcbiAgICAgICAgZnVuY3Rpb24gdW5yZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2QXJncykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkZXBlbmRlbnRzXzEgPSBkZXBlbmRlbnRzOyBfaSA8IGRlcGVuZGVudHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW50ID0gZGVwZW5kZW50c18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbnQudW5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh1bnJlbmRlckZ1bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bnJlbmRlckZ1bmMuYXBwbHkodGhpc0NvbnRleHQsIHByZXZBcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZXZBcmdzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiByZXMoKSB7XHJcbiAgICAgICAgICAgIGlmICghcHJldkFyZ3MgfHwgIWlzQXJyYXlzRXF1YWwocHJldkFyZ3MsIGFyZ3VtZW50cykpIHtcclxuICAgICAgICAgICAgICAgIHVucmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzQ29udGV4dCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBwcmV2QXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgICAgIHJlbmRlckZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXMuZGVwZW5kZW50cyA9IGRlcGVuZGVudHM7XHJcbiAgICAgICAgcmVzLnVucmVuZGVyID0gdW5yZW5kZXI7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkZXBlbmRlbmNpZXNfMSA9IGRlcGVuZGVuY2llczsgX2kgPCBkZXBlbmRlbmNpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNfMVtfaV07XHJcbiAgICAgICAgICAgIGRlcGVuZGVuY3kuZGVwZW5kZW50cy5wdXNoKHJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIEVNUFRZX0VWRU5UX1NUT1JFID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7IC8vIGZvciBwdXJlY29tcG9uZW50cy4gVE9ETzoga2VlcCBlbHNld2hlcmVcclxuICAgIHZhciBTcGxpdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBTcGxpdHRlcigpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzID0gbWVtb2l6ZSh0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NwbGl0RGF0ZVNwYW4pO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0RXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc3BsaXRFdmVudFN0b3JlKTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdEluZGl2aWR1YWxVaSA9IG1lbW9pemUodGhpcy5fc3BsaXRJbmRpdmlkdWFsVWkpO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEludGVyYWN0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEludGVyYWN0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSB7fTsgLy8gVE9ETzogdHlwZXNjcmlwdCBwcm90ZWN0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNwbGl0dGVyLnByb3RvdHlwZS5zcGxpdFByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBrZXlJbmZvcyA9IHRoaXMuZ2V0S2V5SW5mbyhwcm9wcyk7XHJcbiAgICAgICAgICAgIHZhciBkZWZLZXlzID0gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzKHByb3BzLmV2ZW50U3RvcmUpO1xyXG4gICAgICAgICAgICB2YXIgZGF0ZVNlbGVjdGlvbnMgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgdmFyIGluZGl2aWR1YWxVaSA9IHRoaXMuc3BsaXRJbmRpdmlkdWFsVWkocHJvcHMuZXZlbnRVaUJhc2VzLCBkZWZLZXlzKTsgLy8gdGhlIGluZGl2aWR1YWwgKmJhc2VzKlxyXG4gICAgICAgICAgICB2YXIgZXZlbnRTdG9yZXMgPSB0aGlzLnNwbGl0RXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBkZWZLZXlzKTtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RHJhZ3MgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZyk7XHJcbiAgICAgICAgICAgIHZhciBldmVudFJlc2l6ZXMgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUpO1xyXG4gICAgICAgICAgICB2YXIgc3BsaXRQcm9wcyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IG1hcEhhc2goa2V5SW5mb3MsIGZ1bmN0aW9uIChpbmZvLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ldmVudFVpQnVpbGRlcnNba2V5XSB8fCBtZW1vaXplKGJ1aWxkRXZlbnRVaUZvcktleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ga2V5SW5mb3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlJbmZvID0ga2V5SW5mb3Nba2V5XTtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudFN0b3JlID0gZXZlbnRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRTtcclxuICAgICAgICAgICAgICAgIHZhciBidWlsZEV2ZW50VWkgPSB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldO1xyXG4gICAgICAgICAgICAgICAgc3BsaXRQcm9wc1trZXldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IGtleUluZm8uYnVzaW5lc3NIb3VycyB8fCBwcm9wcy5idXNpbmVzc0hvdXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IGRhdGVTZWxlY3Rpb25zW2tleV0gfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFN0b3JlLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VWlCYXNlczogYnVpbGRFdmVudFVpKHByb3BzLmV2ZW50VWlCYXNlc1snJ10sIGtleUluZm8udWksIGluZGl2aWR1YWxVaVtrZXldKSxcclxuICAgICAgICAgICAgICAgICAgICBldmVudFNlbGVjdGlvbjogZXZlbnRTdG9yZS5pbnN0YW5jZXNbcHJvcHMuZXZlbnRTZWxlY3Rpb25dID8gcHJvcHMuZXZlbnRTZWxlY3Rpb24gOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICBldmVudERyYWc6IGV2ZW50RHJhZ3Nba2V5XSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZXNba2V5XSB8fCBudWxsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdERhdGVTcGFuID0gZnVuY3Rpb24gKGRhdGVTcGFuKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRlU3BhbnMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKGRhdGVTcGFuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwga2V5c18xID0ga2V5czsgX2kgPCBrZXlzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVNwYW5zW2tleV0gPSBkYXRlU3BhbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZVNwYW5zO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3BsaXR0ZXIucHJvdG90eXBlLl9nZXRLZXlzRm9yRXZlbnREZWZzID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTdG9yZS5kZWZzLCBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwbGl0dGVyLnByb3RvdHlwZS5fc3BsaXRFdmVudFN0b3JlID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUsIGRlZktleXMpIHtcclxuICAgICAgICAgICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xyXG4gICAgICAgICAgICB2YXIgc3BsaXRTdG9yZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgZGVmSWQgaW4gZGVmcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRlZktleXNbZGVmSWRdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0b3Jlc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0gPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XS5kZWZzW2RlZklkXSA9IGRlZnNbZGVmSWRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZGVmS2V5c1tpbnN0YW5jZS5kZWZJZF07IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXRTdG9yZXNba2V5XSkgeyAvLyBtdXN0IGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XS5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNwbGl0U3RvcmVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdEluZGl2aWR1YWxVaSA9IGZ1bmN0aW9uIChldmVudFVpQmFzZXMsIGRlZktleXMpIHtcclxuICAgICAgICAgICAgdmFyIHNwbGl0SGFzaGVzID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGRlZklkIGluIGV2ZW50VWlCYXNlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZklkKSB7IC8vIG5vdCB0aGUgJycga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRlZktleXNbZGVmSWRdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNwbGl0SGFzaGVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0SGFzaGVzW2tleV0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldW2RlZklkXSA9IGV2ZW50VWlCYXNlc1tkZWZJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzcGxpdEhhc2hlcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwbGl0dGVyLnByb3RvdHlwZS5fc3BsaXRJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc3BsaXRTdGF0ZXMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRTdG9yZXNfMSA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cywgdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cykgLy8gY2FuJ3QgdXNlIGNhY2hlZC4gbWlnaHQgYmUgZXZlbnRzIGZyb20gb3RoZXIgY2FsZW5kYXJcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAvLyBjYW4ndCByZWx5IG9uIGRlZktleXMgYmVjYXVzZSBldmVudCBkYXRhIGlzIG11dGF0ZWRcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGVkS2V5c0J5RGVmSWQgPSB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRTdG9yZXNfMSA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLCBtdXRhdGVkS2V5c0J5RGVmSWQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcHVsYXRlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdGF0ZXNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdFN0YXRlc1trZXldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IGFmZmVjdGVkU3RvcmVzXzFba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNfMVtrZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdTZWc6IGludGVyYWN0aW9uLm9yaWdTZWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFmZmVjdGVkU3RvcmVzXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG11dGF0ZWRTdG9yZXNfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNwbGl0dGVyO1xyXG4gICAgfSgpKTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XHJcbiAgICAgICAgdmFyIGJhc2VQYXJ0cyA9IFtdO1xyXG4gICAgICAgIGlmIChhbGxVaSkge1xyXG4gICAgICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudFVpRm9yS2V5KSB7XHJcbiAgICAgICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3R1ZmYgPSB7XHJcbiAgICAgICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGluZGl2aWR1YWxVaSkge1xyXG4gICAgICAgICAgICBfX2Fzc2lnbihzdHVmZiwgaW5kaXZpZHVhbFVpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0dWZmO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdlbmVyYXRlcyBIVE1MIGZvciBhbiBhbmNob3IgdG8gYW5vdGhlciB2aWV3IGludG8gdGhlIGNhbGVuZGFyLlxyXG4gICAgLy8gV2lsbCBlaXRoZXIgZ2VuZXJhdGUgYW4gPGE+IHRhZyBvciBhIG5vbi1jbGlja2FibGUgPHNwYW4+IHRhZywgZGVwZW5kaW5nIG9uIGVuYWJsZWQgc2V0dGluZ3MuXHJcbiAgICAvLyBgZ290b09wdGlvbnNgIGNhbiBlaXRoZXIgYmUgYSBEYXRlTWFya2VyLCBvciBhbiBvYmplY3Qgd2l0aCB0aGUgZm9ybTpcclxuICAgIC8vIHsgZGF0ZSwgdHlwZSwgZm9yY2VPZmYgfVxyXG4gICAgLy8gYHR5cGVgIGlzIGEgdmlldy10eXBlIGxpa2UgXCJkYXlcIiBvciBcIndlZWtcIi4gZGVmYXVsdCB2YWx1ZSBpcyBcImRheVwiLlxyXG4gICAgLy8gYGF0dHJzYCBhbmQgYGlubmVySHRtbGAgYXJlIHVzZSB0byBnZW5lcmF0ZSB0aGUgcmVzdCBvZiB0aGUgSFRNTCB0YWcuXHJcbiAgICBmdW5jdGlvbiBidWlsZEdvdG9BbmNob3JIdG1sKGNvbXBvbmVudCwgZ290b09wdGlvbnMsIGF0dHJzLCBpbm5lckh0bWwpIHtcclxuICAgICAgICB2YXIgZGF0ZUVudiA9IGNvbXBvbmVudC5kYXRlRW52O1xyXG4gICAgICAgIHZhciBkYXRlO1xyXG4gICAgICAgIHZhciB0eXBlO1xyXG4gICAgICAgIHZhciBmb3JjZU9mZjtcclxuICAgICAgICB2YXIgZmluYWxPcHRpb25zO1xyXG4gICAgICAgIGlmIChnb3RvT3B0aW9ucyBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IGdvdG9PcHRpb25zOyAvLyBhIHNpbmdsZSBkYXRlLWxpa2UgaW5wdXRcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSBnb3RvT3B0aW9ucy5kYXRlO1xyXG4gICAgICAgICAgICB0eXBlID0gZ290b09wdGlvbnMudHlwZTtcclxuICAgICAgICAgICAgZm9yY2VPZmYgPSBnb3RvT3B0aW9ucy5mb3JjZU9mZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBkYXRlOiBkYXRlRW52LmZvcm1hdElzbyhkYXRlLCB7IG9taXRUaW1lOiB0cnVlIH0pLFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlIHx8ICdkYXknXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpbm5lckh0bWwgPSBhdHRycztcclxuICAgICAgICAgICAgYXR0cnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhdHRycyA9IGF0dHJzID8gJyAnICsgYXR0cnNUb1N0cihhdHRycykgOiAnJzsgLy8gd2lsbCBoYXZlIGEgbGVhZGluZyBzcGFjZVxyXG4gICAgICAgIGlubmVySHRtbCA9IGlubmVySHRtbCB8fCAnJztcclxuICAgICAgICBpZiAoIWZvcmNlT2ZmICYmIGNvbXBvbmVudC5vcHQoJ25hdkxpbmtzJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8YScgKyBhdHRycyArXHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZ290bz1cIicgKyBodG1sRXNjYXBlKEpTT04uc3RyaW5naWZ5KGZpbmFsT3B0aW9ucykpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sICtcclxuICAgICAgICAgICAgICAgICc8L2E+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPHNwYW4nICsgYXR0cnMgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sICtcclxuICAgICAgICAgICAgICAgICc8L3NwYW4+JztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRBbGxEYXlIdG1sKGNvbXBvbmVudCkge1xyXG4gICAgICAgIHJldHVybiBjb21wb25lbnQub3B0KCdhbGxEYXlIdG1sJykgfHwgaHRtbEVzY2FwZShjb21wb25lbnQub3B0KCdhbGxEYXlUZXh0JykpO1xyXG4gICAgfVxyXG4gICAgLy8gQ29tcHV0ZXMgSFRNTCBjbGFzc05hbWVzIGZvciBhIHNpbmdsZS1kYXkgZWxlbWVudFxyXG4gICAgZnVuY3Rpb24gZ2V0RGF5Q2xhc3NlcyhkYXRlLCBkYXRlUHJvZmlsZSwgY29udGV4dCwgbm9UaGVtZUhpZ2hsaWdodCkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IGNvbnRleHQuY2FsZW5kYXIsIHZpZXcgPSBjb250ZXh0LnZpZXcsIHRoZW1lID0gY29udGV4dC50aGVtZSwgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudjtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xyXG4gICAgICAgIHZhciB0b2RheVN0YXJ0O1xyXG4gICAgICAgIHZhciB0b2RheUVuZDtcclxuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGRhdGUpKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtZGlzYWJsZWQtZGF5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLScgKyBEQVlfSURTW2RhdGUuZ2V0VVRDRGF5KCldKTtcclxuICAgICAgICAgICAgaWYgKHZpZXcub3B0KCdtb250aE1vZGUnKSAmJlxyXG4gICAgICAgICAgICAgICAgZGF0ZUVudi5nZXRNb250aChkYXRlKSAhPT0gZGF0ZUVudi5nZXRNb250aChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLW90aGVyLW1vbnRoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG9kYXlTdGFydCA9IHN0YXJ0T2ZEYXkoY2FsZW5kYXIuZ2V0Tm93KCkpO1xyXG4gICAgICAgICAgICB0b2RheUVuZCA9IGFkZERheXModG9kYXlTdGFydCwgMSk7XHJcbiAgICAgICAgICAgIGlmIChkYXRlIDwgdG9kYXlTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1wYXN0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0ZSA+PSB0b2RheUVuZCkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1mdXR1cmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtdG9kYXknKTtcclxuICAgICAgICAgICAgICAgIGlmIChub1RoZW1lSGlnaGxpZ2h0ICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHRoZW1lLmdldENsYXNzKCd0b2RheScpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgYSByZXN1bHQgYXN5bmNocm9ub3VzbHkuXHJcbiAgICAvLyB0aGUgZnVuY3Rpb24gY2FuIGVpdGhlciBjYWxsIHBhc3NlZC1pbiBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhbGxiYWNrcyxcclxuICAgIC8vIG9yIGl0IGNhbiByZXR1cm4gYSBwcm9taXNlLlxyXG4gICAgLy8gaWYgeW91IG5lZWQgdG8gcGFzcyBhZGRpdGlvbmFsIHBhcmFtcyB0byBmdW5jLCBiaW5kIHRoZW0gZmlyc3QuXHJcbiAgICBmdW5jdGlvbiB1bnByb21pc2lmeShmdW5jLCBzdWNjZXNzLCBmYWlsdXJlKSB7XHJcbiAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzdWNjZXNzL2ZhaWx1cmUgY2FsbGJhY2tzIGJlaW5nIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxyXG4gICAgICAgIC8vIGFuZCBndWFyZCBhZ2FpbnN0IGEgcHJvbWlzZSBBTkQgY2FsbGJhY2sgYmVpbmcgdXNlZCB0b2dldGhlci5cclxuICAgICAgICB2YXIgaXNSZXNvbHZlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB3cmFwcGVkU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHdyYXBwZWRGYWlsdXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZXMgPSBmdW5jKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XHJcbiAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmVzLnRoZW4od3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIE1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE1peGluKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtaXggaW50byBhIENMQVNTXHJcbiAgICAgICAgTWl4aW4ubWl4SW50byA9IGZ1bmN0aW9uIChkZXN0Q2xhc3MpIHtcclxuICAgICAgICAgICAgdGhpcy5taXhJbnRvT2JqKGRlc3RDbGFzcy5wcm90b3R5cGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gbWl4IGludG8gQU5ZIG9iamVjdFxyXG4gICAgICAgIE1peGluLm1peEludG9PYmogPSBmdW5jdGlvbiAoZGVzdE9iaikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZXN0T2JqW25hbWVdKSB7IC8vIGlmIGRlc3RpbmF0aW9uIGRvZXNuJ3QgYWxyZWFkeSBkZWZpbmUgaXRcclxuICAgICAgICAgICAgICAgICAgICBkZXN0T2JqW25hbWVdID0gX3RoaXMucHJvdG90eXBlW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgd2lsbCBvdmVycmlkZSBleGlzdGluZyBtZXRob2RzXHJcbiAgICAgICAgVE9ETzogcmVtb3ZlISBub3QgdXNlZCBhbnltb3JlXHJcbiAgICAgICAgKi9cclxuICAgICAgICBNaXhpbi5taXhPdmVyID0gZnVuY3Rpb24gKGRlc3RDbGFzcykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZGVzdENsYXNzLnByb3RvdHlwZVtuYW1lXSA9IF90aGlzLnByb3RvdHlwZVtuYW1lXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTWl4aW47XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIC8qXHJcbiAgICBVU0FHRTpcclxuICAgICAgaW1wb3J0IHsgZGVmYXVsdCBhcyBFbWl0dGVyTWl4aW4sIEVtaXR0ZXJJbnRlcmZhY2UgfSBmcm9tICcuL0VtaXR0ZXJNaXhpbidcclxuICAgIGluIGNsYXNzOlxyXG4gICAgICBvbjogRW1pdHRlckludGVyZmFjZVsnb24nXVxyXG4gICAgICBvbmU6IEVtaXR0ZXJJbnRlcmZhY2VbJ29uZSddXHJcbiAgICAgIG9mZjogRW1pdHRlckludGVyZmFjZVsnb2ZmJ11cclxuICAgICAgdHJpZ2dlcjogRW1pdHRlckludGVyZmFjZVsndHJpZ2dlciddXHJcbiAgICAgIHRyaWdnZXJXaXRoOiBFbWl0dGVySW50ZXJmYWNlWyd0cmlnZ2VyV2l0aCddXHJcbiAgICAgIGhhc0hhbmRsZXJzOiBFbWl0dGVySW50ZXJmYWNlWydoYXNIYW5kbGVycyddXHJcbiAgICBhZnRlciBjbGFzczpcclxuICAgICAgRW1pdHRlck1peGluLm1peEludG8oVGhlQ2xhc3MpXHJcbiAgICAqL1xyXG4gICAgdmFyIEVtaXR0ZXJNaXhpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRW1pdHRlck1peGluLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEVtaXR0ZXJNaXhpbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgYWRkVG9IYXNoKHRoaXMuX2hhbmRsZXJzIHx8ICh0aGlzLl9oYW5kbGVycyA9IHt9KSwgdHlwZSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHRvZG86IGFkZCBjb21tZW50c1xyXG4gICAgICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgYWRkVG9IYXNoKHRoaXMuX29uZUhhbmRsZXJzIHx8ICh0aGlzLl9vbmVIYW5kbGVycyA9IHt9KSwgdHlwZSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVGcm9tSGFzaCh0aGlzLl9oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX29uZUhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVGcm9tSGFzaCh0aGlzLl9vbmVIYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRW1pdHRlck1peGluLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyV2l0aCh0eXBlLCB0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRW1pdHRlck1peGluLnByb3RvdHlwZS50cmlnZ2VyV2l0aCA9IGZ1bmN0aW9uICh0eXBlLCBjb250ZXh0LCBhcmdzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVycykge1xyXG4gICAgICAgICAgICAgICAgYXBwbHlBbGwodGhpcy5faGFuZGxlcnNbdHlwZV0sIGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbmVIYW5kbGVycykge1xyXG4gICAgICAgICAgICAgICAgYXBwbHlBbGwodGhpcy5fb25lSGFuZGxlcnNbdHlwZV0sIGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX29uZUhhbmRsZXJzW3R5cGVdOyAvLyB3aWxsIG5ldmVyIGZpcmUgYWdhaW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLmhhc0hhbmRsZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9oYW5kbGVycyAmJiB0aGlzLl9oYW5kbGVyc1t0eXBlXSAmJiB0aGlzLl9oYW5kbGVyc1t0eXBlXS5sZW5ndGgpIHx8XHJcbiAgICAgICAgICAgICAgICAodGhpcy5fb25lSGFuZGxlcnMgJiYgdGhpcy5fb25lSGFuZGxlcnNbdHlwZV0gJiYgdGhpcy5fb25lSGFuZGxlcnNbdHlwZV0ubGVuZ3RoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFbWl0dGVyTWl4aW47XHJcbiAgICB9KE1peGluKSk7XHJcbiAgICBmdW5jdGlvbiBhZGRUb0hhc2goaGFzaCwgdHlwZSwgaGFuZGxlcikge1xyXG4gICAgICAgIChoYXNoW3R5cGVdIHx8IChoYXNoW3R5cGVdID0gW10pKVxyXG4gICAgICAgICAgICAucHVzaChoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUZyb21IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgICAgICBpZiAoaGFzaFt0eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgaGFzaFt0eXBlXSA9IGhhc2hbdHlwZV0uZmlsdGVyKGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMgIT09IGhhbmRsZXI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVsZXRlIGhhc2hbdHlwZV07IC8vIHJlbW92ZSBhbGwgaGFuZGxlciBmdW5jcyBmb3IgdGhpcyB0eXBlXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBSZWNvcmRzIG9mZnNldCBpbmZvcm1hdGlvbiBmb3IgYSBzZXQgb2YgZWxlbWVudHMsIHJlbGF0aXZlIHRvIGFuIG9yaWdpbiBlbGVtZW50LlxyXG4gICAgQ2FuIHJlY29yZCB0aGUgbGVmdC9yaWdodCBPUiB0aGUgdG9wL2JvdHRvbSBPUiBib3RoLlxyXG4gICAgUHJvdmlkZXMgbWV0aG9kcyBmb3IgcXVlcnlpbmcgdGhlIGNhY2hlIGJ5IHBvc2l0aW9uLlxyXG4gICAgKi9cclxuICAgIHZhciBQb3NpdGlvbkNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvc2l0aW9uQ2FjaGUob3JpZ2luRWwsIGVscywgaXNIb3Jpem9udGFsLCBpc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luRWwgPSBvcmlnaW5FbDtcclxuICAgICAgICAgICAgdGhpcy5lbHMgPSBlbHM7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIb3Jpem9udGFsID0gaXNIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICB0aGlzLmlzVmVydGljYWwgPSBpc1ZlcnRpY2FsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBRdWVyaWVzIHRoZSBlbHMgZm9yIGNvb3JkaW5hdGVzIGFuZCBzdG9yZXMgdGhlbS5cclxuICAgICAgICAvLyBDYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSB1c2luZyBhbmQgb2YgdGhlIGdldCogbWV0aG9kcyBiZWxvdy5cclxuICAgICAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9yaWdpbkVsID0gdGhpcy5vcmlnaW5FbDtcclxuICAgICAgICAgICAgdmFyIG9yaWdpbkNsaWVudFJlY3QgPSB0aGlzLm9yaWdpbkNsaWVudFJlY3QgPVxyXG4gICAgICAgICAgICAgICAgb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHJlbGF0aXZlIHRvIHZpZXdwb3J0IHRvcC1sZWZ0XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50UmVjdC5sZWZ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkRWxWZXJ0aWNhbHMob3JpZ2luQ2xpZW50UmVjdC50b3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBQb3B1bGF0ZXMgdGhlIGxlZnQvcmlnaHQgaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcclxuICAgICAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5idWlsZEVsSG9yaXpvbnRhbHMgPSBmdW5jdGlvbiAob3JpZ2luQ2xpZW50TGVmdCkge1xyXG4gICAgICAgICAgICB2YXIgbGVmdHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5lbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgbGVmdHMucHVzaChyZWN0LmxlZnQgLSBvcmlnaW5DbGllbnRMZWZ0KTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0cy5wdXNoKHJlY3QucmlnaHQgLSBvcmlnaW5DbGllbnRMZWZ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxlZnRzID0gbGVmdHM7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHRzID0gcmlnaHRzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gUG9wdWxhdGVzIHRoZSB0b3AvYm90dG9tIGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXHJcbiAgICAgICAgUG9zaXRpb25DYWNoZS5wcm90b3R5cGUuYnVpbGRFbFZlcnRpY2FscyA9IGZ1bmN0aW9uIChvcmlnaW5DbGllbnRUb3ApIHtcclxuICAgICAgICAgICAgdmFyIHRvcHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGJvdHRvbXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZWxzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgICAgIHRvcHMucHVzaChyZWN0LnRvcCAtIG9yaWdpbkNsaWVudFRvcCk7XHJcbiAgICAgICAgICAgICAgICBib3R0b21zLnB1c2gocmVjdC5ib3R0b20gLSBvcmlnaW5DbGllbnRUb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudG9wcyA9IHRvcHM7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tcyA9IGJvdHRvbXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cclxuICAgICAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXHJcbiAgICAgICAgUG9zaXRpb25DYWNoZS5wcm90b3R5cGUubGVmdFRvSW5kZXggPSBmdW5jdGlvbiAobGVmdFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0cyA9IHRoaXMubGVmdHM7XHJcbiAgICAgICAgICAgIHZhciByaWdodHMgPSB0aGlzLnJpZ2h0cztcclxuICAgICAgICAgICAgdmFyIGxlbiA9IGxlZnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRQb3NpdGlvbiA+PSBsZWZ0c1tpXSAmJiBsZWZ0UG9zaXRpb24gPCByaWdodHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2l2ZW4gYSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IHZlcnRpY2FsbHkgaW50ZXJzZWN0cy5cclxuICAgICAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXHJcbiAgICAgICAgUG9zaXRpb25DYWNoZS5wcm90b3R5cGUudG9wVG9JbmRleCA9IGZ1bmN0aW9uICh0b3BQb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgdG9wcyA9IHRoaXMudG9wcztcclxuICAgICAgICAgICAgdmFyIGJvdHRvbXMgPSB0aGlzLmJvdHRvbXM7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSB0b3BzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvcFBvc2l0aW9uID49IHRvcHNbaV0gJiYgdG9wUG9zaXRpb24gPCBib3R0b21zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMubGVmdHNbbGVmdEluZGV4XTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgICAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLnRvcHNbdG9wSW5kZXhdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uQ2FjaGU7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIC8qXHJcbiAgICBBbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cclxuICAgIEludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxyXG4gICAgc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cclxuICAgICovXHJcbiAgICB2YXIgU2Nyb2xsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBTY3JvbGxDb250cm9sbGVyKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRNYXhTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldE1heFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFdpZHRoKCkgLSB0aGlzLmdldENsaWVudFdpZHRoKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxWZXJ0aWNhbGx5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXhTY3JvbGxUb3AoKSA+IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxIb3Jpem9udGFsbHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxVcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsRG93biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPCB0aGlzLmdldE1heFNjcm9sbFRvcCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmNhblNjcm9sbFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxMZWZ0KCkgPCB0aGlzLmdldE1heFNjcm9sbExlZnQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTY3JvbGxDb250cm9sbGVyO1xyXG4gICAgfSgpKTtcclxuICAgIHZhciBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRWxlbWVudFNjcm9sbENvbnRyb2xsZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRWxlbWVudFNjcm9sbENvbnRyb2xsZXIoZWwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZWwgPSBlbDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxUb3A7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsTGVmdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAodG9wKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuc2Nyb2xsVG9wID0gdG9wO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAobGVmdCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnNjcm9sbExlZnQgPSBsZWZ0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbEhlaWdodDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLmNsaWVudEhlaWdodDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRWxlbWVudFNjcm9sbENvbnRyb2xsZXI7XHJcbiAgICB9KFNjcm9sbENvbnRyb2xsZXIpKTtcclxuICAgIHZhciBXaW5kb3dTY3JvbGxDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhXaW5kb3dTY3JvbGxDb250cm9sbGVyLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGwod2luZG93LnBhZ2VYT2Zmc2V0LCBuKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsKG4sIHdpbmRvdy5wYWdlWU9mZnNldCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50V2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gV2luZG93U2Nyb2xsQ29udHJvbGxlcjtcclxuICAgIH0oU2Nyb2xsQ29udHJvbGxlcikpO1xyXG5cclxuICAgIC8qXHJcbiAgICBFbWJvZGllcyBhIGRpdiB0aGF0IGhhcyBwb3RlbnRpYWwgc2Nyb2xsYmFyc1xyXG4gICAgKi9cclxuICAgIHZhciBTY3JvbGxDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNjcm9sbENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTY3JvbGxDb21wb25lbnQob3ZlcmZsb3dYLCBvdmVyZmxvd1kpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY3JlYXRlRWxlbWVudCgnZGl2Jywge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmMtc2Nyb2xsZXInXHJcbiAgICAgICAgICAgIH0pKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5vdmVyZmxvd1ggPSBvdmVyZmxvd1g7XHJcbiAgICAgICAgICAgIF90aGlzLm92ZXJmbG93WSA9IG92ZXJmbG93WTtcclxuICAgICAgICAgICAgX3RoaXMuYXBwbHlPdmVyZmxvdygpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHMgdG8gbmF0dXJhbCBoZWlnaHQsIHVubG9ja3Mgb3ZlcmZsb3dcclxuICAgICAgICBTY3JvbGxDb21wb25lbnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodCgnYXV0bycpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5T3ZlcmZsb3coKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLmVsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIE92ZXJmbG93XHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBTY3JvbGxDb21wb25lbnQucHJvdG90eXBlLmFwcGx5T3ZlcmZsb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGFwcGx5U3R5bGUodGhpcy5lbCwge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiB0aGlzLm92ZXJmbG93WCxcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93WTogdGhpcy5vdmVyZmxvd1lcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDYXVzZXMgYW55ICdhdXRvJyBvdmVyZmxvdyB2YWx1ZXMgdG8gcmVzb2x2ZXMgdG8gJ3Njcm9sbCcgb3IgJ2hpZGRlbicuXHJcbiAgICAgICAgLy8gVXNlZnVsIGZvciBwcmVzZXJ2aW5nIHNjcm9sbGJhciB3aWR0aHMgcmVnYXJkbGVzcyBvZiBmdXR1cmUgcmVzaXplcy5cclxuICAgICAgICAvLyBDYW4gcGFzcyBpbiBzY3JvbGxiYXJXaWR0aHMgZm9yIG9wdGltaXphdGlvbi5cclxuICAgICAgICBTY3JvbGxDb21wb25lbnQucHJvdG90eXBlLmxvY2tPdmVyZmxvdyA9IGZ1bmN0aW9uIChzY3JvbGxiYXJXaWR0aHMpIHtcclxuICAgICAgICAgICAgdmFyIG92ZXJmbG93WCA9IHRoaXMub3ZlcmZsb3dYO1xyXG4gICAgICAgICAgICB2YXIgb3ZlcmZsb3dZID0gdGhpcy5vdmVyZmxvd1k7XHJcbiAgICAgICAgICAgIHNjcm9sbGJhcldpZHRocyA9IHNjcm9sbGJhcldpZHRocyB8fCB0aGlzLmdldFNjcm9sbGJhcldpZHRocygpO1xyXG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dYID09PSAnYXV0bycpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93WCA9IChzY3JvbGxiYXJXaWR0aHMuYm90dG9tIHx8IC8vIGhvcml6b250YWwgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhblNjcm9sbEhvcml6b250YWxseSgpIC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgICkgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvdmVyZmxvd1kgPT09ICdhdXRvJykge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dZID0gKHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCB8fCAvLyBob3Jpem9udGFsIHNjcm9sbGJhcnM/XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5TY3JvbGxWZXJ0aWNhbGx5KCkgLy8gT1Igc2Nyb2xsaW5nIHBhbmUgd2l0aCBtYXNzbGVzcyBzY3JvbGxiYXJzP1xyXG4gICAgICAgICAgICAgICAgKSA/ICdzY3JvbGwnIDogJ2hpZGRlbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXBwbHlTdHlsZSh0aGlzLmVsLCB7IG92ZXJmbG93WDogb3ZlcmZsb3dYLCBvdmVyZmxvd1k6IG92ZXJmbG93WSB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xyXG4gICAgICAgICAgICBhcHBseVN0eWxlUHJvcCh0aGlzLmVsLCAnaGVpZ2h0JywgaGVpZ2h0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWRnZXMgPSBjb21wdXRlRWRnZXModGhpcy5lbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGVkZ2VzLnNjcm9sbGJhclJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiBlZGdlcy5zY3JvbGxiYXJCb3R0b21cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTY3JvbGxDb21wb25lbnQ7XHJcbiAgICB9KEVsZW1lbnRTY3JvbGxDb250cm9sbGVyKSk7XHJcblxyXG4gICAgdmFyIFRoZW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFRoZW1lKGNhbGVuZGFyT3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyT3B0aW9ucyA9IGNhbGVuZGFyT3B0aW9ucztcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzSWNvbk92ZXJyaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFRoZW1lLnByb3RvdHlwZS5wcm9jZXNzSWNvbk92ZXJyaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKHRoaXMuY2FsZW5kYXJPcHRpb25zW3RoaXMuaWNvbk92ZXJyaWRlT3B0aW9uXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFRoZW1lLnByb3RvdHlwZS5zZXRJY29uT3ZlcnJpZGUgPSBmdW5jdGlvbiAoaWNvbk92ZXJyaWRlSGFzaCkge1xyXG4gICAgICAgICAgICB2YXIgaWNvbkNsYXNzZXNDb3B5O1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uTmFtZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpY29uT3ZlcnJpZGVIYXNoID09PSAnb2JqZWN0JyAmJiBpY29uT3ZlcnJpZGVIYXNoKSB7IC8vIG5vbi1udWxsIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5ID0gX19hc3NpZ24oe30sIHRoaXMuaWNvbkNsYXNzZXMpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChidXR0b25OYW1lIGluIGljb25PdmVycmlkZUhhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHlbYnV0dG9uTmFtZV0gPSB0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGljb25PdmVycmlkZUhhc2hbYnV0dG9uTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IGljb25DbGFzc2VzQ29weTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpY29uT3ZlcnJpZGVIYXNoID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaGVtZS5wcm90b3R5cGUuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXggPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSB0aGlzLmljb25PdmVycmlkZVByZWZpeDtcclxuICAgICAgICAgICAgaWYgKHByZWZpeCAmJiBjbGFzc05hbWUuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7IC8vIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByZWZpeCArIGNsYXNzTmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGhlbWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzW2tleV0gfHwgJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaGVtZS5wcm90b3R5cGUuZ2V0SWNvbkNsYXNzID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV07XHJcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VJY29uQ2xhc3MgKyAnICcgKyBjbGFzc05hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGhlbWUucHJvdG90eXBlLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyA9IGZ1bmN0aW9uIChjdXN0b21CdXR0b25Qcm9wcykge1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGN1c3RvbUJ1dHRvblByb3BzW3RoaXMuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uXTtcclxuICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlSWNvbkNsYXNzICsgJyAnICsgdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBUaGVtZTtcclxuICAgIH0oKSk7XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHt9O1xyXG4gICAgVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge307XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICcnO1xyXG4gICAgVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICcnO1xyXG5cclxuICAgIHZhciBndWlkID0gMDtcclxuICAgIHZhciBDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ29tcG9uZW50KGNvbnRleHQsIGlzVmlldykge1xyXG4gICAgICAgICAgICAvLyBIQUNLIHRvIHBvcHVsYXRlIHZpZXcgYXQgdG9wIG9mIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uIGNhbGwgY2hhaW5cclxuICAgICAgICAgICAgaWYgKGlzVmlldykge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC52aWV3ID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnVpZCA9IFN0cmluZyhndWlkKyspO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHRoaXMudGhlbWUgPSBjb250ZXh0LnRoZW1lO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSBjb250ZXh0LnZpZXc7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIgPSBjb250ZXh0LmNhbGVuZGFyO1xyXG4gICAgICAgICAgICB0aGlzLmlzUnRsID0gdGhpcy5vcHQoJ2RpcicpID09PSAncnRsJztcclxuICAgICAgICB9XHJcbiAgICAgICAgQ29tcG9uZW50LmFkZEVxdWFsaXR5RnVuY3MgPSBmdW5jdGlvbiAobmV3RnVuY3MpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm90b3R5cGUuZXF1YWxpdHlGdW5jcyA9IF9fYXNzaWduKHt9LCB0aGlzLnByb3RvdHlwZS5lcXVhbGl0eUZ1bmNzLCBuZXdGdW5jcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQub3B0aW9uc1tuYW1lXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHJlY3ljbGVQcm9wcyh0aGlzLnByb3BzIHx8IHt9LCBwcm9wcywgdGhpcy5lcXVhbGl0eUZ1bmNzKSwgYW55Q2hhbmdlcyA9IF9hLmFueUNoYW5nZXMsIGNvbWJvUHJvcHMgPSBfYS5jb21ib1Byb3BzO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzID0gY29tYm9Qcm9wcztcclxuICAgICAgICAgICAgaWYgKGFueUNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKGNvbWJvUHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gYWZ0ZXIgZGVzdHJveSBpcyBjYWxsZWQsIHRoaXMgY29tcG9uZW50IHdvbid0IGV2ZXIgYmUgdXNlZCBhZ2FpblxyXG4gICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICB9KCkpO1xyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5lcXVhbGl0eUZ1bmNzID0ge307XHJcbiAgICAvKlxyXG4gICAgUmV1c2VzIG9sZCB2YWx1ZXMgd2hlbiBlcXVhbC4gSWYgYW55dGhpbmcgaXMgdW5lcXVhbCwgcmV0dXJucyBuZXdQcm9wcyBhcy1pcy5cclxuICAgIEdyZWF0IGZvciBQdXJlQ29tcG9uZW50LCBidXQgd29uJ3QgYmUgZmVhc2libGUgd2l0aCBSZWFjdCwgc28ganVzdCBlbGltaW5hdGUgYW5kIHVzZSBSZWFjdCdzIERPTSBkaWZmaW5nLlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlY3ljbGVQcm9wcyhvbGRQcm9wcywgbmV3UHJvcHMsIGVxdWFsaXR5RnVuY3MpIHtcclxuICAgICAgICB2YXIgY29tYm9Qcm9wcyA9IHt9OyAvLyBzb21lIG9sZCwgc29tZSBuZXdcclxuICAgICAgICB2YXIgYW55Q2hhbmdlcyA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIG9sZFByb3BzICYmIChvbGRQcm9wc1trZXldID09PSBuZXdQcm9wc1trZXldIHx8XHJcbiAgICAgICAgICAgICAgICAoZXF1YWxpdHlGdW5jc1trZXldICYmIGVxdWFsaXR5RnVuY3Nba2V5XShvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldKSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlcXVhbCB0byBvbGQ/IHVzZSBvbGQgcHJvcFxyXG4gICAgICAgICAgICAgICAgY29tYm9Qcm9wc1trZXldID0gb2xkUHJvcHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbWJvUHJvcHNba2V5XSA9IG5ld1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2xkUHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKCEoa2V5IGluIG5ld1Byb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgYW55Q2hhbmdlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBhbnlDaGFuZ2VzOiBhbnlDaGFuZ2VzLCBjb21ib1Byb3BzOiBjb21ib1Byb3BzIH07XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIFBVUlBPU0VTOlxyXG4gICAgLSBob29rIHVwIHRvIGZnLCBmaWxsLCBhbmQgbWlycm9yIHJlbmRlcmVyc1xyXG4gICAgLSBpbnRlcmZhY2UgZm9yIGRyYWdnaW5nIGFuZCBoaXRzXHJcbiAgICAqL1xyXG4gICAgdmFyIERhdGVDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKERhdGVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRGF0ZUNvbXBvbmVudChjb250ZXh0LCBlbCwgaXNWaWV3KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQsIGlzVmlldykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZWwgPSBlbDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLmVsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFRPRE86IFdIQVQgQUJPVVQgKHNvdXJjZVNlZyAmJiBzb3VyY2VTZWcuY29tcG9uZW50LmRvZXNEcmFnTWlycm9yKVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gRXZlbnQgRHJhZy1uLURyb3AgUmVuZGVyaW5nIChmb3IgYm90aCBldmVudHMgYW5kIGV4dGVybmFsIGVsZW1lbnRzKVxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgcmVuZGVyRXZlbnREcmFnU2VncyhzdGF0ZTogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUpIHtcclxuICAgICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBsZXQgeyBpc0V2ZW50LCBzZWdzLCBzb3VyY2VTZWcgfSA9IHN0YXRlXHJcbiAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLmhpZGVCeUhhc2goc3RhdGUuYWZmZWN0ZWRJbnN0YW5jZXMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIGlzIGRyYWdnaW5nIHNvbWV0aGluZyB0aGF0IGlzIGNvbnNpZGVyZWQgYW4gZXZlbnQgd2l0aCByZWFsIGV2ZW50IGRhdGEsXHJcbiAgICAgICAgICAgIC8vIGFuZCB0aGlzIGNvbXBvbmVudCBsaWtlcyB0byBkbyBkcmFnIG1pcnJvcnMgT1IgdGhlIGNvbXBvbmVudCB3aGVyZSB0aGUgc2VnIGNhbWUgZnJvbVxyXG4gICAgICAgICAgICAvLyBsaWtlcyB0byBkbyBkcmFnIG1pcnJvcnMsIHRoZW4gcmVuZGVyIGEgZHJhZyBtaXJyb3IuXHJcbiAgICAgICAgICAgIGlmIChpc0V2ZW50ICYmICh0aGlzLmRvZXNEcmFnTWlycm9yIHx8IHNvdXJjZVNlZyAmJiBzb3VyY2VTZWcuY29tcG9uZW50LmRvZXNEcmFnTWlycm9yKSkge1xyXG4gICAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvclJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvclJlbmRlcmVyLnJlbmRlclNlZ3Moc2VncywgeyBpc0RyYWdnaW5nOiB0cnVlLCBzb3VyY2VTZWcgfSlcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgXHJcbiAgICAgICAgICAgIC8vIGlmIGl0IHdvdWxkIGJlIGltcG9zc2libGUgdG8gcmVuZGVyIGEgZHJhZyBtaXJyb3IgT1IgdGhpcyBjb21wb25lbnQgbGlrZXMgdG8gcmVuZGVyXHJcbiAgICAgICAgICAgIC8vIGhpZ2hsaWdodHMsIHRoZW4gcmVuZGVyIGEgaGlnaGxpZ2h0LlxyXG4gICAgICAgICAgICBpZiAoIWlzRXZlbnQgfHwgdGhpcy5kb2VzRHJhZ0hpZ2hsaWdodCkge1xyXG4gICAgICAgICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyU2VncygnaGlnaGxpZ2h0Jywgc2VncylcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgICAgICAvLyBIaXQgU3lzdGVtXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZFBvc2l0aW9uQ2FjaGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIHRoaXMgc2hvdWxkIGJlIGFic3RyYWN0XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBWYWxpZGF0aW9uXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0ludGVyYWN0aW9uVmFsaWQgPSBmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcclxuICAgICAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZTsgLy8gSEFDS1xyXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VzID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cy5pbnN0YW5jZXM7XHJcbiAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZSkgeyAvLyBIQUNLIGZvciBEYXlUaWxlXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmFuZ2VDb250YWluc1JhbmdlKGRhdGVQcm9maWxlLnZhbGlkUmFuZ2UsIGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBjYWxlbmRhcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0RhdGVTZWxlY3Rpb25WYWxpZCA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZTsgLy8gSEFDS1xyXG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUgJiYgLy8gSEFDSyBmb3IgRGF5VGlsZVxyXG4gICAgICAgICAgICAgICAgIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBzZWxlY3Rpb24ucmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGlzRGF0ZVNlbGVjdGlvblZhbGlkKHNlbGVjdGlvbiwgdGhpcy5jYWxlbmRhcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUcmlnZ2VyaW5nXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAvLyBUT0RPOiBtb3ZlIHRvIENhbGVuZGFyXHJcbiAgICAgICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucHVibGljbHlUcmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyLnB1YmxpY2x5VHJpZ2dlcihuYW1lLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnB1YmxpY2x5VHJpZ2dlckFmdGVyU2l6aW5nID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyLnB1YmxpY2x5VHJpZ2dlckFmdGVyU2l6aW5nKG5hbWUsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaGFzUHVibGljSGFuZGxlcnMgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsZW5kYXIuaGFzUHVibGljSGFuZGxlcnMobmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyUmVuZGVyZWRTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIGlzTWlycm9ycykge1xyXG4gICAgICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNQdWJsaWNIYW5kbGVycygnZXZlbnRQb3NpdGlvbmVkJykpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc2Vnc18xID0gc2VnczsgX2kgPCBzZWdzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXJBZnRlclNpemluZygnZXZlbnRQb3NpdGlvbmVkJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNhbGVuZGFyLCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTWlycm9yOiBpc01pcnJvcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWcuaXNFbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbDogc2VnLmVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogdGhpcyAvLyBzYWZlIHRvIGNhc3QgYmVjYXVzZSB0aGlzIG1ldGhvZCBpcyBvbmx5IGNhbGxlZCBvbiBjb250ZXh0LnZpZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY2FsZW5kYXIuc3RhdGUubG9hZGluZ0xldmVsKSB7IC8vIGF2b2lkIGluaXRpYWwgZW1wdHkgc3RhdGUgd2hpbGUgcGVuZGluZ1xyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXIuYWZ0ZXJTaXppbmdUcmlnZ2Vycy5fZXZlbnRzUG9zaXRpb25lZCA9IFtudWxsXTsgLy8gZmlyZSBvbmNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJXaWxsUmVtb3ZlU2VncyA9IGZ1bmN0aW9uIChzZWdzLCBpc01pcnJvcnMpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzIgPSBzZWdzOyBfaSA8IHNlZ3NfMi5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzXzJbX2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXIudHJpZ2dlcignZXZlbnRFbFJlbW92ZScsIHNlZy5lbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzUHVibGljSGFuZGxlcnMoJ2V2ZW50RGVzdHJveScpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHNlZ3NfMyA9IHNlZ3M7IF9hIDwgc2Vnc18zLmxlbmd0aDsgX2ErKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzXzNbX2FdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudERlc3Ryb3knLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY2FsZW5kYXIsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNNaXJyb3I6IGlzTWlycm9ycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBzZWcuZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiB0aGlzIC8vIHNhZmUgdG8gY2FzdCBiZWNhdXNlIHRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkIG9uIGNvbnRleHQudmlld1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFBvaW50ZXIgSW50ZXJhY3Rpb24gVXRpbHNcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmlzVmFsaWRTZWdEb3duRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnByb3BzLmV2ZW50RHJhZyAmJiAvLyBIQUNLXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5wcm9wcy5ldmVudFJlc2l6ZSAmJiAvLyBIQUNLXHJcbiAgICAgICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtbWlycm9yJykgJiZcclxuICAgICAgICAgICAgICAgICh0aGlzLmlzUG9wb3ZlcigpIHx8ICF0aGlzLmlzSW5Qb3BvdmVyKGVsKSk7XHJcbiAgICAgICAgICAgIC8vIF5hYm92ZSBsaW5lIGVuc3VyZXMgd2UgZG9uJ3QgZGV0ZWN0IGEgc2VnIGludGVyYWN0aW9uIHdpdGhpbiBhIG5lc3RlZCBjb21wb25lbnQuXHJcbiAgICAgICAgICAgIC8vIGl0J3MgYSBIQUNLIGJlY2F1c2UgaXQgb25seSBzdXBwb3J0cyBhIHBvcG92ZXIgYXMgdGhlIG5lc3RlZCBjb21wb25lbnQuXHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc1ZhbGlkRGF0ZURvd25FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICB2YXIgc2VnRWwgPSBlbGVtZW50Q2xvc2VzdChlbCwgdGhpcy5mZ1NlZ1NlbGVjdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuICghc2VnRWwgfHwgc2VnRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1taXJyb3InKSkgJiZcclxuICAgICAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1tb3JlJykgJiYgLy8gYSBcIm1vcmUuLlwiIGxpbmtcclxuICAgICAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJ2FbZGF0YS1nb3RvXScpICYmIC8vIGEgY2xpY2thYmxlIG5hdiBsaW5rXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5pc0luUG9wb3ZlcihlbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc1BvcG92ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtcG9wb3ZlcicpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNJblBvcG92ZXIgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtcG9wb3ZlcicpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEYXRlQ29tcG9uZW50O1xyXG4gICAgfShDb21wb25lbnQpKTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmZnU2VnU2VsZWN0b3IgPSAnLmZjLWV2ZW50LWNvbnRhaW5lciA+IConO1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYmdTZWdTZWxlY3RvciA9ICcuZmMtYmdldmVudDpub3QoLmZjLW5vbmJ1c2luZXNzKSc7XHJcblxyXG4gICAgdmFyIHVpZCQxID0gMDtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBsdWdpbihpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBTdHJpbmcodWlkJDErKyksXHJcbiAgICAgICAgICAgIGRlcHM6IGlucHV0LmRlcHMgfHwgW10sXHJcbiAgICAgICAgICAgIHJlZHVjZXJzOiBpbnB1dC5yZWR1Y2VycyB8fCBbXSxcclxuICAgICAgICAgICAgZXZlbnREZWZQYXJzZXJzOiBpbnB1dC5ldmVudERlZlBhcnNlcnMgfHwgW10sXHJcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBpbnB1dC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyB8fCBbXSxcclxuICAgICAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGlucHV0LmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIHx8IFtdLFxyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGlucHV0LmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyB8fCBbXSxcclxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaW5wdXQuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyB8fCBbXSxcclxuICAgICAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaW5wdXQuZGF0ZVBvaW50VHJhbnNmb3JtcyB8fCBbXSxcclxuICAgICAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBpbnB1dC5kYXRlU3BhblRyYW5zZm9ybXMgfHwgW10sXHJcbiAgICAgICAgICAgIHZpZXdzOiBpbnB1dC52aWV3cyB8fCB7fSxcclxuICAgICAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBpbnB1dC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMgfHwgW10sXHJcbiAgICAgICAgICAgIGlzUHJvcHNWYWxpZDogaW5wdXQuaXNQcm9wc1ZhbGlkIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaW5wdXQuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIHx8IFtdLFxyXG4gICAgICAgICAgICBldmVudFJlc2l6ZUpvaW5UcmFuc2Zvcm1zOiBpbnB1dC5ldmVudFJlc2l6ZUpvaW5UcmFuc2Zvcm1zIHx8IFtdLFxyXG4gICAgICAgICAgICB2aWV3Q29udGFpbmVyTW9kaWZpZXJzOiBpbnB1dC52aWV3Q29udGFpbmVyTW9kaWZpZXJzIHx8IFtdLFxyXG4gICAgICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IGlucHV0LmV2ZW50RHJvcFRyYW5zZm9ybWVycyB8fCBbXSxcclxuICAgICAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBpbnB1dC5jb21wb25lbnRJbnRlcmFjdGlvbnMgfHwgW10sXHJcbiAgICAgICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBpbnB1dC5jYWxlbmRhckludGVyYWN0aW9ucyB8fCBbXSxcclxuICAgICAgICAgICAgdGhlbWVDbGFzc2VzOiBpbnB1dC50aGVtZUNsYXNzZXMgfHwge30sXHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlRGVmczogaW5wdXQuZXZlbnRTb3VyY2VEZWZzIHx8IFtdLFxyXG4gICAgICAgICAgICBjbWRGb3JtYXR0ZXI6IGlucHV0LmNtZEZvcm1hdHRlcixcclxuICAgICAgICAgICAgcmVjdXJyaW5nVHlwZXM6IGlucHV0LnJlY3VycmluZ1R5cGVzIHx8IFtdLFxyXG4gICAgICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IGlucHV0Lm5hbWVkVGltZVpvbmVkSW1wbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZpZXc6IGlucHV0LmRlZmF1bHRWaWV3IHx8ICcnLFxyXG4gICAgICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBpbnB1dC5lbGVtZW50RHJhZ2dpbmdJbXBsLFxyXG4gICAgICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogaW5wdXQub3B0aW9uQ2hhbmdlSGFuZGxlcnMgfHwge31cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIFBsdWdpblN5c3RlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQbHVnaW5TeXN0ZW0oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaG9va3MgPSB7XHJcbiAgICAgICAgICAgICAgICByZWR1Y2VyczogW10sXHJcbiAgICAgICAgICAgICAgICBldmVudERlZlBhcnNlcnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogW10sXHJcbiAgICAgICAgICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgdmlld3M6IHt9LFxyXG4gICAgICAgICAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgIGlzUHJvcHNWYWxpZDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogW10sXHJcbiAgICAgICAgICAgICAgICBldmVudFJlc2l6ZUpvaW5UcmFuc2Zvcm1zOiBbXSxcclxuICAgICAgICAgICAgICAgIHZpZXdDb250YWluZXJNb2RpZmllcnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW10sXHJcbiAgICAgICAgICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogW10sXHJcbiAgICAgICAgICAgICAgICB0aGVtZUNsYXNzZXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBbXSxcclxuICAgICAgICAgICAgICAgIGNtZEZvcm1hdHRlcjogbnVsbCxcclxuICAgICAgICAgICAgICAgIHJlY3VycmluZ1R5cGVzOiBbXSxcclxuICAgICAgICAgICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRWaWV3OiAnJyxcclxuICAgICAgICAgICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge31cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5hZGRlZEhhc2ggPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUGx1Z2luU3lzdGVtLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocGx1Z2luKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hZGRlZEhhc2hbcGx1Z2luLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRlZEhhc2hbcGx1Z2luLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcGx1Z2luLmRlcHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcCA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChkZXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcyA9IGNvbWJpbmVIb29rcyh0aGlzLmhvb2tzLCBwbHVnaW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUGx1Z2luU3lzdGVtO1xyXG4gICAgfSgpKTtcclxuICAgIGZ1bmN0aW9uIGNvbWJpbmVIb29rcyhob29rczAsIGhvb2tzMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlZHVjZXJzOiBob29rczAucmVkdWNlcnMuY29uY2F0KGhvb2tzMS5yZWR1Y2VycyksXHJcbiAgICAgICAgICAgIGV2ZW50RGVmUGFyc2VyczogaG9va3MwLmV2ZW50RGVmUGFyc2Vycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmUGFyc2VycyksXHJcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBob29rczAuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyksXHJcbiAgICAgICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBob29rczAuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMuY29uY2F0KGhvb2tzMS5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyksXHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaG9va3MwLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyksXHJcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IGhvb2tzMC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyksXHJcbiAgICAgICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlUG9pbnRUcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZGF0ZVBvaW50VHJhbnNmb3JtcyksXHJcbiAgICAgICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogaG9va3MwLmRhdGVTcGFuVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVTcGFuVHJhbnNmb3JtcyksXHJcbiAgICAgICAgICAgIHZpZXdzOiBfX2Fzc2lnbih7fSwgaG9va3MwLnZpZXdzLCBob29rczEudmlld3MpLFxyXG4gICAgICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGhvb2tzMC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpLFxyXG4gICAgICAgICAgICBpc1Byb3BzVmFsaWQ6IGhvb2tzMS5pc1Byb3BzVmFsaWQgfHwgaG9va3MwLmlzUHJvcHNWYWxpZCxcclxuICAgICAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBob29rczAuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zKSxcclxuICAgICAgICAgICAgZXZlbnRSZXNpemVKb2luVHJhbnNmb3JtczogaG9va3MwLmV2ZW50UmVzaXplSm9pblRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5ldmVudFJlc2l6ZUpvaW5UcmFuc2Zvcm1zKSxcclxuICAgICAgICAgICAgdmlld0NvbnRhaW5lck1vZGlmaWVyczogaG9va3MwLnZpZXdDb250YWluZXJNb2RpZmllcnMuY29uY2F0KGhvb2tzMS52aWV3Q29udGFpbmVyTW9kaWZpZXJzKSxcclxuICAgICAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBob29rczAuZXZlbnREcm9wVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZXZlbnREcm9wVHJhbnNmb3JtZXJzKSxcclxuICAgICAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGhvb2tzMC5jYWxlbmRhckludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNhbGVuZGFySW50ZXJhY3Rpb25zKSxcclxuICAgICAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBob29rczAuY29tcG9uZW50SW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY29tcG9uZW50SW50ZXJhY3Rpb25zKSxcclxuICAgICAgICAgICAgdGhlbWVDbGFzc2VzOiBfX2Fzc2lnbih7fSwgaG9va3MwLnRoZW1lQ2xhc3NlcywgaG9va3MxLnRoZW1lQ2xhc3NlcyksXHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlRGVmczogaG9va3MwLmV2ZW50U291cmNlRGVmcy5jb25jYXQoaG9va3MxLmV2ZW50U291cmNlRGVmcyksXHJcbiAgICAgICAgICAgIGNtZEZvcm1hdHRlcjogaG9va3MxLmNtZEZvcm1hdHRlciB8fCBob29rczAuY21kRm9ybWF0dGVyLFxyXG4gICAgICAgICAgICByZWN1cnJpbmdUeXBlczogaG9va3MwLnJlY3VycmluZ1R5cGVzLmNvbmNhdChob29rczEucmVjdXJyaW5nVHlwZXMpLFxyXG4gICAgICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IGhvb2tzMS5uYW1lZFRpbWVab25lZEltcGwgfHwgaG9va3MwLm5hbWVkVGltZVpvbmVkSW1wbCxcclxuICAgICAgICAgICAgZGVmYXVsdFZpZXc6IGhvb2tzMC5kZWZhdWx0VmlldyB8fCBob29rczEuZGVmYXVsdFZpZXcsXHJcbiAgICAgICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGhvb2tzMC5lbGVtZW50RHJhZ2dpbmdJbXBsIHx8IGhvb2tzMS5lbGVtZW50RHJhZ2dpbmdJbXBsLFxyXG4gICAgICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogX19hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25DaGFuZ2VIYW5kbGVycywgaG9va3MxLm9wdGlvbkNoYW5nZUhhbmRsZXJzKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGV2ZW50U291cmNlRGVmID0ge1xyXG4gICAgICAgIGlnbm9yZVJhbmdlOiB0cnVlLFxyXG4gICAgICAgIHBhcnNlTWV0YTogZnVuY3Rpb24gKHJhdykge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXcpKSB7IC8vIHNob3J0IGZvcm1cclxuICAgICAgICAgICAgICAgIHJldHVybiByYXc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyYXcuZXZlbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhdy5ldmVudHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmZXRjaDogZnVuY3Rpb24gKGFyZywgc3VjY2Vzcykge1xyXG4gICAgICAgICAgICBzdWNjZXNzKHtcclxuICAgICAgICAgICAgICAgIHJhd0V2ZW50czogYXJnLmV2ZW50U291cmNlLm1ldGFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBBcnJheUV2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZl1cclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBldmVudFNvdXJjZURlZiQxID0ge1xyXG4gICAgICAgIHBhcnNlTWV0YTogZnVuY3Rpb24gKHJhdykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBzaG9ydCBmb3JtXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByYXcuZXZlbnRzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3LmV2ZW50cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiAoYXJnLCBzdWNjZXNzLCBmYWlsdXJlKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRlRW52ID0gYXJnLmNhbGVuZGFyLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciBmdW5jID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XHJcbiAgICAgICAgICAgIHVucHJvbWlzaWZ5KGZ1bmMuYmluZChudWxsLCB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZUVudi50b0RhdGUoYXJnLnJhbmdlLnN0YXJ0KSxcclxuICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi50b0RhdGUoYXJnLnJhbmdlLmVuZCksXHJcbiAgICAgICAgICAgICAgICBzdGFydFN0cjogZGF0ZUVudi5mb3JtYXRJc28oYXJnLnJhbmdlLnN0YXJ0KSxcclxuICAgICAgICAgICAgICAgIGVuZFN0cjogZGF0ZUVudi5mb3JtYXRJc28oYXJnLnJhbmdlLmVuZCksXHJcbiAgICAgICAgICAgICAgICB0aW1lWm9uZTogZGF0ZUVudi50aW1lWm9uZVxyXG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHJhd0V2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzcyh7IHJhd0V2ZW50czogcmF3RXZlbnRzIH0pOyAvLyBuZWVkcyBhbiBvYmplY3QgcmVzcG9uc2VcclxuICAgICAgICAgICAgfSwgZmFpbHVyZSAvLyBzZW5kIGVycm9yT2JqIGRpcmVjdGx5IHRvIGZhaWx1cmUgY2FsbGJhY2tcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIEZ1bmNFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XHJcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMV1cclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlcXVlc3RKc29uKG1ldGhvZCwgdXJsLCBwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XHJcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgdmFyIGJvZHkgPSBudWxsO1xyXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XHJcbiAgICAgICAgICAgIHVybCA9IGluamVjdFF1ZXJ5U3RyaW5nUGFyYW1zKHVybCwgcGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGJvZHkgPSBlbmNvZGVQYXJhbXMocGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcclxuICAgICAgICBpZiAobWV0aG9kICE9PSAnR0VUJykge1xyXG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDQwMCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2socmVzLCB4aHIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVDYWxsYmFjaygnRmFpbHVyZSBwYXJzaW5nIEpTT04nLCB4aHIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmFpbHVyZUNhbGxiYWNrKCdSZXF1ZXN0IGZhaWxlZCcsIHhocik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmYWlsdXJlQ2FsbGJhY2soJ1JlcXVlc3QgZmFpbGVkJywgeGhyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHhoci5zZW5kKGJvZHkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5qZWN0UXVlcnlTdHJpbmdQYXJhbXModXJsLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gdXJsICtcclxuICAgICAgICAgICAgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArXHJcbiAgICAgICAgICAgIGVuY29kZVBhcmFtcyhwYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZW5jb2RlUGFyYW1zKHBhcmFtcykge1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignJicpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBldmVudFNvdXJjZURlZiQyID0ge1xyXG4gICAgICAgIHBhcnNlTWV0YTogZnVuY3Rpb24gKHJhdykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHsgLy8gc2hvcnQgZm9ybVxyXG4gICAgICAgICAgICAgICAgcmF3ID0geyB1cmw6IHJhdyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyYXcgfHwgdHlwZW9mIHJhdyAhPT0gJ29iamVjdCcgfHwgIXJhdy51cmwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1cmw6IHJhdy51cmwsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IChyYXcubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpLFxyXG4gICAgICAgICAgICAgICAgZXh0cmFQYXJhbXM6IHJhdy5leHRyYVBhcmFtcyxcclxuICAgICAgICAgICAgICAgIHN0YXJ0UGFyYW06IHJhdy5zdGFydFBhcmFtLFxyXG4gICAgICAgICAgICAgICAgZW5kUGFyYW06IHJhdy5lbmRQYXJhbSxcclxuICAgICAgICAgICAgICAgIHRpbWVab25lUGFyYW06IHJhdy50aW1lWm9uZVBhcmFtXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmZXRjaDogZnVuY3Rpb24gKGFyZywgc3VjY2VzcywgZmFpbHVyZSkge1xyXG4gICAgICAgICAgICB2YXIgbWV0YSA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdFBhcmFtcyA9IGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCBhcmcucmFuZ2UsIGFyZy5jYWxlbmRhcik7XHJcbiAgICAgICAgICAgIHJlcXVlc3RKc29uKG1ldGEubWV0aG9kLCBtZXRhLnVybCwgcmVxdWVzdFBhcmFtcywgZnVuY3Rpb24gKHJhd0V2ZW50cywgeGhyKSB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzKHsgcmF3RXZlbnRzOiByYXdFdmVudHMsIHhocjogeGhyIH0pO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3JNZXNzYWdlLCB4aHIpIHtcclxuICAgICAgICAgICAgICAgIGZhaWx1cmUoeyBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsIHhocjogeGhyIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIEpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xyXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDJdXHJcbiAgICB9KTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCByYW5nZSwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgZGF0ZUVudiA9IGNhbGVuZGFyLmRhdGVFbnY7XHJcbiAgICAgICAgdmFyIHN0YXJ0UGFyYW07XHJcbiAgICAgICAgdmFyIGVuZFBhcmFtO1xyXG4gICAgICAgIHZhciB0aW1lWm9uZVBhcmFtO1xyXG4gICAgICAgIHZhciBjdXN0b21SZXF1ZXN0UGFyYW1zO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICBzdGFydFBhcmFtID0gbWV0YS5zdGFydFBhcmFtO1xyXG4gICAgICAgIGlmIChzdGFydFBhcmFtID09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RhcnRQYXJhbSA9IGNhbGVuZGFyLm9wdCgnc3RhcnRQYXJhbScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbmRQYXJhbSA9IG1ldGEuZW5kUGFyYW07XHJcbiAgICAgICAgaWYgKGVuZFBhcmFtID09IG51bGwpIHtcclxuICAgICAgICAgICAgZW5kUGFyYW0gPSBjYWxlbmRhci5vcHQoJ2VuZFBhcmFtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpbWVab25lUGFyYW0gPSBtZXRhLnRpbWVab25lUGFyYW07XHJcbiAgICAgICAgaWYgKHRpbWVab25lUGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aW1lWm9uZVBhcmFtID0gY2FsZW5kYXIub3B0KCd0aW1lWm9uZVBhcmFtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldHJpZXZlIGFueSBvdXRib3VuZCBHRVQvUE9TVCBkYXRhIGZyb20gdGhlIG9wdGlvbnNcclxuICAgICAgICBpZiAodHlwZW9mIG1ldGEuZXh0cmFQYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gc3VwcGxpZWQgYXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBrZXkvdmFsdWUgb2JqZWN0XHJcbiAgICAgICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBwcm9iYWJseSBzdXBwbGllZCBhcyBhIHN0cmFpZ2h0IGtleS92YWx1ZSBvYmplY3RcclxuICAgICAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IG1ldGEuZXh0cmFQYXJhbXMgfHwge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9fYXNzaWduKHBhcmFtcywgY3VzdG9tUmVxdWVzdFBhcmFtcyk7XHJcbiAgICAgICAgcGFyYW1zW3N0YXJ0UGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIHBhcmFtc1tlbmRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQpO1xyXG4gICAgICAgIGlmIChkYXRlRW52LnRpbWVab25lICE9PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1t0aW1lWm9uZVBhcmFtXSA9IGRhdGVFbnYudGltZVpvbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlY3VycmluZyA9IHtcclxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHJhd0V2ZW50LCBsZWZ0b3ZlclByb3BzLCBkYXRlRW52KSB7XHJcbiAgICAgICAgICAgIHZhciBjcmVhdGVNYXJrZXIgPSBkYXRlRW52LmNyZWF0ZU1hcmtlci5iaW5kKGRhdGVFbnYpO1xyXG4gICAgICAgICAgICB2YXIgcHJvY2Vzc29ycyA9IHtcclxuICAgICAgICAgICAgICAgIGRheXNPZldlZWs6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgZW5kVGltZTogY3JlYXRlRHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICBzdGFydFJlY3VyOiBjcmVhdGVNYXJrZXIsXHJcbiAgICAgICAgICAgICAgICBlbmRSZWN1cjogY3JlYXRlTWFya2VyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHJlZmluZVByb3BzKHJhd0V2ZW50LCBwcm9jZXNzb3JzLCB7fSwgbGVmdG92ZXJQcm9wcyk7XHJcbiAgICAgICAgICAgIHZhciBhbnlWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW55VmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbnlWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICgnZHVyYXRpb24nIGluIGxlZnRvdmVyUHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKGxlZnRvdmVyUHJvcHMuZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsZWZ0b3ZlclByb3BzLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvbiAmJiBwcm9wcy5zdGFydFRpbWUgJiYgcHJvcHMuZW5kVGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gc3VidHJhY3REdXJhdGlvbnMocHJvcHMuZW5kVGltZSwgcHJvcHMuc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5R3Vlc3M6IEJvb2xlYW4oIXByb3BzLnN0YXJ0VGltZSAmJiAhcHJvcHMuZW5kVGltZSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVEYXRhOiBwcm9wcyAvLyBkb2Vzbid0IG5lZWQgZW5kVGltZSBhbnltb3JlIGJ1dCBvaCB3ZWxsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiAodHlwZURhdGEsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xyXG4gICAgICAgICAgICB2YXIgY2xpcHBlZEZyYW1pbmdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhmcmFtaW5nUmFuZ2UsIHsgc3RhcnQ6IHR5cGVEYXRhLnN0YXJ0UmVjdXIsIGVuZDogdHlwZURhdGEuZW5kUmVjdXIgfSk7XHJcbiAgICAgICAgICAgIGlmIChjbGlwcGVkRnJhbWluZ1JhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmFuZ2VzKHR5cGVEYXRhLmRheXNPZldlZWssIHR5cGVEYXRhLnN0YXJ0VGltZSwgY2xpcHBlZEZyYW1pbmdSYW5nZSwgZGF0ZUVudik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIFNpbXBsZVJlY3VycmVuY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xyXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBbcmVjdXJyaW5nXVxyXG4gICAgfSk7XHJcbiAgICBmdW5jdGlvbiBleHBhbmRSYW5nZXMoZGF5c09mV2Vlaywgc3RhcnRUaW1lLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcclxuICAgICAgICB2YXIgZG93SGFzaCA9IGRheXNPZldlZWsgPyBhcnJheVRvSGFzaChkYXlzT2ZXZWVrKSA6IG51bGw7XHJcbiAgICAgICAgdmFyIGRheU1hcmtlciA9IHN0YXJ0T2ZEYXkoZnJhbWluZ1JhbmdlLnN0YXJ0KTtcclxuICAgICAgICB2YXIgZW5kTWFya2VyID0gZnJhbWluZ1JhbmdlLmVuZDtcclxuICAgICAgICB2YXIgaW5zdGFuY2VTdGFydHMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoZGF5TWFya2VyIDwgZW5kTWFya2VyKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZVN0YXJ0IFxyXG4gICAgICAgICAgICAvLyBpZiBldmVyeWRheSwgb3IgdGhpcyBwYXJ0aWN1bGFyIGRheS1vZi13ZWVrXHJcbiAgICAgICAgICAgID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAvLyBpZiBldmVyeWRheSwgb3IgdGhpcyBwYXJ0aWN1bGFyIGRheS1vZi13ZWVrXHJcbiAgICAgICAgICAgIGlmICghZG93SGFzaCB8fCBkb3dIYXNoW2RheU1hcmtlci5nZXRVVENEYXkoKV0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF0ZUVudi5hZGQoZGF5TWFya2VyLCBzdGFydFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCA9IGRheU1hcmtlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnRzLnB1c2goaW5zdGFuY2VTdGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGF5TWFya2VyID0gYWRkRGF5cyhkYXlNYXJrZXIsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5zdGFuY2VTdGFydHM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIERlZmF1bHRPcHRpb25DaGFuZ2VIYW5kbGVycyA9IGNyZWF0ZVBsdWdpbih7XHJcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHtcclxuICAgICAgICAgICAgZXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzLCBjYWxlbmRhciwgZGVlcEVxdWFsKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFdmVudFNvdXJjZXMoW2V2ZW50c10sIGNhbGVuZGFyLCBkZWVwRXF1YWwpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBldmVudFNvdXJjZXM6IGhhbmRsZUV2ZW50U291cmNlcyxcclxuICAgICAgICAgICAgcGx1Z2luczogaGFuZGxlUGx1Z2luc1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlRXZlbnRTb3VyY2VzKGlucHV0cywgY2FsZW5kYXIsIGRlZXBFcXVhbCkge1xyXG4gICAgICAgIHZhciB1bmZvdW5kU291cmNlcyA9IGhhc2hWYWx1ZXNUb0FycmF5KGNhbGVuZGFyLnN0YXRlLmV2ZW50U291cmNlcyk7XHJcbiAgICAgICAgdmFyIG5ld0lucHV0cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5wdXRzXzEgPSBpbnB1dHM7IF9pIDwgaW5wdXRzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0c18xW19pXTtcclxuICAgICAgICAgICAgdmFyIGlucHV0Rm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmZvdW5kU291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZXBFcXVhbCh1bmZvdW5kU291cmNlc1tpXS5fcmF3LCBpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmZvdW5kU291cmNlcy5zcGxpY2UoaSwgMSk7IC8vIGRlbGV0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Rm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaW5wdXRGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgbmV3SW5wdXRzLnB1c2goaW5wdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgdW5mb3VuZFNvdXJjZXNfMSA9IHVuZm91bmRTb3VyY2VzOyBfYSA8IHVuZm91bmRTb3VyY2VzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB1bmZvdW5kU291cmNlID0gdW5mb3VuZFNvdXJjZXNfMVtfYV07XHJcbiAgICAgICAgICAgIGNhbGVuZGFyLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcclxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiB1bmZvdW5kU291cmNlLnNvdXJjZUlkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIG5ld0lucHV0c18xID0gbmV3SW5wdXRzOyBfYiA8IG5ld0lucHV0c18xLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICB2YXIgbmV3SW5wdXQgPSBuZXdJbnB1dHNfMVtfYl07XHJcbiAgICAgICAgICAgIGNhbGVuZGFyLmFkZEV2ZW50U291cmNlKG5ld0lucHV0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBzaG9ydGNvbWluZzogd29uJ3QgcmVtb3ZlIHBsdWdpbnNcclxuICAgIGZ1bmN0aW9uIGhhbmRsZVBsdWdpbnMoaW5wdXRzLCBjYWxlbmRhcikge1xyXG4gICAgICAgIGNhbGVuZGFyLmFkZFBsdWdpbklucHV0cyhpbnB1dHMpOyAvLyB3aWxsIGdyYWNlZnVsbHkgaGFuZGxlIGR1cGxpY2F0ZXNcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29uZmlnID0ge307IC8vIFRPRE86IG1ha2UgdGhlc2Ugb3B0aW9uc1xyXG4gICAgdmFyIGdsb2JhbERlZmF1bHRzID0ge1xyXG4gICAgICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogJyAtICcsXHJcbiAgICAgICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogJyBcXHUyMDEzICcsXHJcbiAgICAgICAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogJzAxOjAwOjAwJyxcclxuICAgICAgICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXk6IDEgfSxcclxuICAgICAgICBmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxyXG4gICAgICAgIG5leHREYXlUaHJlc2hvbGQ6ICcwMDowMDowMCcsXHJcbiAgICAgICAgLy8gZGlzcGxheVxyXG4gICAgICAgIGNvbHVtbkhlYWRlcjogdHJ1ZSxcclxuICAgICAgICBkZWZhdWx0VmlldzogJycsXHJcbiAgICAgICAgYXNwZWN0UmF0aW86IDEuMzUsXHJcbiAgICAgICAgaGVhZGVyOiB7XHJcbiAgICAgICAgICAgIGxlZnQ6ICd0aXRsZScsXHJcbiAgICAgICAgICAgIGNlbnRlcjogJycsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAndG9kYXkgcHJldixuZXh0J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2Vla2VuZHM6IHRydWUsXHJcbiAgICAgICAgd2Vla051bWJlcnM6IGZhbHNlLFxyXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogJ2xvY2FsJyxcclxuICAgICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgLy8gbm93SW5kaWNhdG9yOiBmYWxzZSxcclxuICAgICAgICBzY3JvbGxUaW1lOiAnMDY6MDA6MDAnLFxyXG4gICAgICAgIG1pblRpbWU6ICcwMDowMDowMCcsXHJcbiAgICAgICAgbWF4VGltZTogJzI0OjAwOjAwJyxcclxuICAgICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiB0cnVlLFxyXG4gICAgICAgIC8vIGV2ZW50IGFqYXhcclxuICAgICAgICBsYXp5RmV0Y2hpbmc6IHRydWUsXHJcbiAgICAgICAgc3RhcnRQYXJhbTogJ3N0YXJ0JyxcclxuICAgICAgICBlbmRQYXJhbTogJ2VuZCcsXHJcbiAgICAgICAgdGltZVpvbmVQYXJhbTogJ3RpbWVab25lJyxcclxuICAgICAgICB0aW1lWm9uZTogJ2xvY2FsJyxcclxuICAgICAgICAvLyBhbGxEYXlEZWZhdWx0OiB1bmRlZmluZWQsXHJcbiAgICAgICAgLy8gbG9jYWxlXHJcbiAgICAgICAgbG9jYWxlczogW10sXHJcbiAgICAgICAgbG9jYWxlOiAnJyxcclxuICAgICAgICAvLyBkaXI6IHdpbGwgZ2V0IHRoaXMgZnJvbSB0aGUgZGVmYXVsdCBsb2NhbGVcclxuICAgICAgICAvLyBidXR0b25JY29uczogbnVsbCxcclxuICAgICAgICAvLyBhbGxvd3Mgc2V0dGluZyBhIG1pbi1oZWlnaHQgdG8gdGhlIGV2ZW50IHNlZ21lbnQgdG8gcHJldmVudCBzaG9ydCBldmVudHMgb3ZlcmxhcHBpbmcgZWFjaCBvdGhlclxyXG4gICAgICAgIHRpbWVHcmlkRXZlbnRNaW5IZWlnaHQ6IDAsXHJcbiAgICAgICAgdGhlbWVTeXN0ZW06ICdzdGFuZGFyZCcsXHJcbiAgICAgICAgLy8gZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IGZhbHNlLFxyXG4gICAgICAgIGRyYWdSZXZlcnREdXJhdGlvbjogNTAwLFxyXG4gICAgICAgIGRyYWdTY3JvbGw6IHRydWUsXHJcbiAgICAgICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgLy8gc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgdW5zZWxlY3RBdXRvOiB0cnVlLFxyXG4gICAgICAgIC8vIHNlbGVjdE1pbkRpc3RhbmNlOiAwLFxyXG4gICAgICAgIGRyb3BBY2NlcHQ6ICcqJyxcclxuICAgICAgICBldmVudE9yZGVyOiAnc3RhcnQsLWR1cmF0aW9uLGFsbERheSx0aXRsZScsXHJcbiAgICAgICAgLy8gXiBpZiBzdGFydCB0aWUsIGxvbmdlciBldmVudHMgZ28gYmVmb3JlIHNob3J0ZXIuIGZpbmFsIHRpZS1icmVha2VyIGlzIHRpdGxlIHRleHRcclxuICAgICAgICAvLyByZXJlbmRlckRlbGF5OiBudWxsLFxyXG4gICAgICAgIGV2ZW50TGltaXQ6IGZhbHNlLFxyXG4gICAgICAgIGV2ZW50TGltaXRDbGljazogJ3BvcG92ZXInLFxyXG4gICAgICAgIGRheVBvcG92ZXJGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxyXG4gICAgICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcclxuICAgICAgICB3aW5kb3dSZXNpemVEZWxheTogMTAwLFxyXG4gICAgICAgIGxvbmdQcmVzc0RlbGF5OiAxMDAwLFxyXG4gICAgICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiA1IC8vIG9ubHkgYXBwbGllcyB0byBtb3VzZVxyXG4gICAgfTtcclxuICAgIHZhciBydGxEZWZhdWx0cyA9IHtcclxuICAgICAgICBoZWFkZXI6IHtcclxuICAgICAgICAgICAgbGVmdDogJ25leHQscHJldiB0b2RheScsXHJcbiAgICAgICAgICAgIGNlbnRlcjogJycsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAndGl0bGUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBidXR0b25JY29uczoge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIFJUTCBzdXBwb3J0IHRoZSByZXNwb25pYmlsaXR5IG9mIHRoZSB0aGVtZVxyXG4gICAgICAgICAgICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLXJpZ2h0JyxcclxuICAgICAgICAgICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcclxuICAgICAgICAgICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0JyxcclxuICAgICAgICAgICAgbmV4dFllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBjb21wbGV4T3B0aW9ucyA9IFtcclxuICAgICAgICAnaGVhZGVyJyxcclxuICAgICAgICAnZm9vdGVyJyxcclxuICAgICAgICAnYnV0dG9uVGV4dCcsXHJcbiAgICAgICAgJ2J1dHRvbkljb25zJ1xyXG4gICAgXTtcclxuICAgIC8vIE1lcmdlcyBhbiBhcnJheSBvZiBvcHRpb24gb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdFxyXG4gICAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbk9ianMpIHtcclxuICAgICAgICByZXR1cm4gbWVyZ2VQcm9wcyhvcHRpb25PYmpzLCBjb21wbGV4T3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgc3R1ZmYgdG8gYSBcInBsdWdpblwiLXJlbGF0ZWQgZmlsZS4uLlxyXG4gICAgdmFyIElOVEVSTkFMX1BMVUdJTlMgPSBbXHJcbiAgICAgICAgQXJyYXlFdmVudFNvdXJjZVBsdWdpbixcclxuICAgICAgICBGdW5jRXZlbnRTb3VyY2VQbHVnaW4sXHJcbiAgICAgICAgSnNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbixcclxuICAgICAgICBTaW1wbGVSZWN1cnJlbmNlUGx1Z2luLFxyXG4gICAgICAgIERlZmF1bHRPcHRpb25DaGFuZ2VIYW5kbGVyc1xyXG4gICAgXTtcclxuICAgIGZ1bmN0aW9uIHJlZmluZVBsdWdpbkRlZnMocGx1Z2luSW5wdXRzKSB7XHJcbiAgICAgICAgdmFyIHBsdWdpbnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBsdWdpbklucHV0c18xID0gcGx1Z2luSW5wdXRzOyBfaSA8IHBsdWdpbklucHV0c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcGx1Z2luSW5wdXQgPSBwbHVnaW5JbnB1dHNfMVtfaV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1Z2luSW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsTmFtZSA9ICdGdWxsQ2FsZW5kYXInICsgY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHBsdWdpbklucHV0KTtcclxuICAgICAgICAgICAgICAgIGlmICghd2luZG93W2dsb2JhbE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQbHVnaW4gZmlsZSBub3QgbG9hZGVkIGZvciAnICsgcGx1Z2luSW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHdpbmRvd1tnbG9iYWxOYW1lXS5kZWZhdWx0KTsgLy8gaXMgYW4gRVM2IG1vZHVsZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbklucHV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSU5URVJOQUxfUExVR0lOUy5jb25jYXQocGx1Z2lucyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFJBV19FTl9MT0NBTEUgPSB7XHJcbiAgICAgICAgY29kZTogJ2VuJyxcclxuICAgICAgICB3ZWVrOiB7XHJcbiAgICAgICAgICAgIGRvdzogMCxcclxuICAgICAgICAgICAgZG95OiA0IC8vIDQgZGF5cyBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgeWVhciB0byBiZSBjb25zaWRlcmVkIHRoZSBmaXJzdCB3ZWVrXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaXI6ICdsdHInLFxyXG4gICAgICAgIGJ1dHRvblRleHQ6IHtcclxuICAgICAgICAgICAgcHJldjogJ3ByZXYnLFxyXG4gICAgICAgICAgICBuZXh0OiAnbmV4dCcsXHJcbiAgICAgICAgICAgIHByZXZZZWFyOiAncHJldiB5ZWFyJyxcclxuICAgICAgICAgICAgbmV4dFllYXI6ICduZXh0IHllYXInLFxyXG4gICAgICAgICAgICB5ZWFyOiAneWVhcicsXHJcbiAgICAgICAgICAgIHRvZGF5OiAndG9kYXknLFxyXG4gICAgICAgICAgICBtb250aDogJ21vbnRoJyxcclxuICAgICAgICAgICAgd2VlazogJ3dlZWsnLFxyXG4gICAgICAgICAgICBkYXk6ICdkYXknLFxyXG4gICAgICAgICAgICBsaXN0OiAnbGlzdCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdlZWtMYWJlbDogJ1cnLFxyXG4gICAgICAgIGFsbERheVRleHQ6ICdhbGwtZGF5JyxcclxuICAgICAgICBldmVudExpbWl0VGV4dDogJ21vcmUnLFxyXG4gICAgICAgIG5vRXZlbnRzTWVzc2FnZTogJ05vIGV2ZW50cyB0byBkaXNwbGF5J1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHBhcnNlUmF3TG9jYWxlcyhleHBsaWNpdFJhd0xvY2FsZXMpIHtcclxuICAgICAgICB2YXIgZGVmYXVsdENvZGUgPSBleHBsaWNpdFJhd0xvY2FsZXMubGVuZ3RoID4gMCA/IGV4cGxpY2l0UmF3TG9jYWxlc1swXS5jb2RlIDogJ2VuJztcclxuICAgICAgICB2YXIgZ2xvYmFsQXJyYXkgPSB3aW5kb3dbJ0Z1bGxDYWxlbmRhckxvY2FsZXNBbGwnXSB8fCBbXTsgLy8gZnJvbSBsb2NhbGVzLWFsbC5qc1xyXG4gICAgICAgIHZhciBnbG9iYWxPYmplY3QgPSB3aW5kb3dbJ0Z1bGxDYWxlbmRhckxvY2FsZXMnXSB8fCB7fTsgLy8gZnJvbSBsb2NhbGVzLyouanMuIGtleXMgYXJlIG1lYW5pbmdsZXNzXHJcbiAgICAgICAgdmFyIGFsbFJhd0xvY2FsZXMgPSBnbG9iYWxBcnJheS5jb25jYXQoLy8gZ2xvYmFsQXJyYXkgaXMgbG93IHByaW9cclxuICAgICAgICBoYXNoVmFsdWVzVG9BcnJheShnbG9iYWxPYmplY3QpLCAvLyBtZWRpdW0gcHJpb1xyXG4gICAgICAgIGV4cGxpY2l0UmF3TG9jYWxlcyAvLyBoaWdoZXN0IHByaW9cclxuICAgICAgICApO1xyXG4gICAgICAgIHZhciByYXdMb2NhbGVNYXAgPSB7XHJcbiAgICAgICAgICAgIGVuOiBSQVdfRU5fTE9DQUxFIC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYWxsUmF3TG9jYWxlc18xID0gYWxsUmF3TG9jYWxlczsgX2kgPCBhbGxSYXdMb2NhbGVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByYXdMb2NhbGUgPSBhbGxSYXdMb2NhbGVzXzFbX2ldO1xyXG4gICAgICAgICAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtYXA6IHJhd0xvY2FsZU1hcCxcclxuICAgICAgICAgICAgZGVmYXVsdENvZGU6IGRlZmF1bHRDb2RlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkTG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXRTaW5ndWxhciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXRTaW5ndWxhcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTG9jYWxlKGlucHV0U2luZ3VsYXIuY29kZSwgW2lucHV0U2luZ3VsYXIuY29kZV0sIGlucHV0U2luZ3VsYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5TG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcXVlcnlMb2NhbGUoY29kZUFyZywgYXZhaWxhYmxlKSB7XHJcbiAgICAgICAgdmFyIGNvZGVzID0gW10uY29uY2F0KGNvZGVBcmcgfHwgW10pOyAvLyB3aWxsIGNvbnZlcnQgdG8gYXJyYXlcclxuICAgICAgICB2YXIgcmF3ID0gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkgfHwgUkFXX0VOX0xPQ0FMRTtcclxuICAgICAgICByZXR1cm4gcGFyc2VMb2NhbGUoY29kZUFyZywgY29kZXMsIHJhdyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBjb2Rlc1tpXS50b0xvY2FsZUxvd2VyQ2FzZSgpLnNwbGl0KCctJyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBwYXJ0cy5sZW5ndGg7IGogPiAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaW1wbGVJZCA9IHBhcnRzLnNsaWNlKDAsIGopLmpvaW4oJy0nKTtcclxuICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGVbc2ltcGxlSWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVtzaW1wbGVJZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KSB7XHJcbiAgICAgICAgdmFyIG1lcmdlZCA9IG1lcmdlUHJvcHMoW1JBV19FTl9MT0NBTEUsIHJhd10sIFsnYnV0dG9uVGV4dCddKTtcclxuICAgICAgICBkZWxldGUgbWVyZ2VkLmNvZGU7IC8vIGRvbid0IHdhbnQgdGhpcyBwYXJ0IG9mIHRoZSBvcHRpb25zXHJcbiAgICAgICAgdmFyIHdlZWsgPSBtZXJnZWQud2VlaztcclxuICAgICAgICBkZWxldGUgbWVyZ2VkLndlZWs7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZUFyZzogY29kZUFyZyxcclxuICAgICAgICAgICAgY29kZXM6IGNvZGVzLFxyXG4gICAgICAgICAgICB3ZWVrOiB3ZWVrLFxyXG4gICAgICAgICAgICBzaW1wbGVOdW1iZXJGb3JtYXQ6IG5ldyBJbnRsLk51bWJlckZvcm1hdChjb2RlQXJnKSxcclxuICAgICAgICAgICAgb3B0aW9uczogbWVyZ2VkXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgT3B0aW9uc01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gT3B0aW9uc01hbmFnZXIob3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3ZlcnJpZGVzID0gX19hc3NpZ24oe30sIG92ZXJyaWRlcyk7IC8vIG1ha2UgYSBjb3B5XHJcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlcyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLm11dGF0ZSA9IGZ1bmN0aW9uICh1cGRhdGVzLCByZW1vdmFscywgaXNEeW5hbWljKSB7XHJcbiAgICAgICAgICAgIHZhciBvdmVycmlkZUhhc2ggPSBpc0R5bmFtaWMgPyB0aGlzLmR5bmFtaWNPdmVycmlkZXMgOiB0aGlzLm92ZXJyaWRlcztcclxuICAgICAgICAgICAgX19hc3NpZ24ob3ZlcnJpZGVIYXNoLCB1cGRhdGVzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByZW1vdmFsc18xID0gcmVtb3ZhbHM7IF9pIDwgcmVtb3ZhbHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHJlbW92YWxzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlSGFzaFtwcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgZmxhdHRlbmVkIG9wdGlvbnMgaGFzaCBmb3IgdGhlIGNhbGVuZGFyIGFuZCBhc3NpZ25zIHRvIGB0aGlzLm9wdGlvbnNgLlxyXG4gICAgICAgIC8vIEFzc3VtZXMgdGhpcy5vdmVycmlkZXMgYW5kIHRoaXMuZHluYW1pY092ZXJyaWRlcyBoYXZlIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC5cclxuICAgICAgICBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogbm90IGEgdmVyeSBlZmZpY2llbnQgc3lzdGVtXHJcbiAgICAgICAgICAgIHZhciBsb2NhbGVzID0gZmlyc3REZWZpbmVkKC8vIGV4cGxpY2l0IGxvY2FsZSBvcHRpb24gZ2l2ZW4/XHJcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlcy5sb2NhbGVzLCB0aGlzLm92ZXJyaWRlcy5sb2NhbGVzLCBnbG9iYWxEZWZhdWx0cy5sb2NhbGVzKTtcclxuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IGZpcnN0RGVmaW5lZCgvLyBleHBsaWNpdCBsb2NhbGVzIG9wdGlvbiBnaXZlbj9cclxuICAgICAgICAgICAgdGhpcy5keW5hbWljT3ZlcnJpZGVzLmxvY2FsZSwgdGhpcy5vdmVycmlkZXMubG9jYWxlLCBnbG9iYWxEZWZhdWx0cy5sb2NhbGUpO1xyXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlID0gcGFyc2VSYXdMb2NhbGVzKGxvY2FsZXMpO1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxlRGVmYXVsdHMgPSBidWlsZExvY2FsZShsb2NhbGUgfHwgYXZhaWxhYmxlLmRlZmF1bHRDb2RlLCBhdmFpbGFibGUubWFwKS5vcHRpb25zO1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gZmlyc3REZWZpbmVkKC8vIGJhc2VkIG9uIG9wdGlvbnMgY29tcHV0ZWQgc28gZmFyLCBpcyBkaXJlY3Rpb24gUlRMP1xyXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNPdmVycmlkZXMuZGlyLCB0aGlzLm92ZXJyaWRlcy5kaXIsIGxvY2FsZURlZmF1bHRzLmRpcik7XHJcbiAgICAgICAgICAgIHZhciBkaXJEZWZhdWx0cyA9IGRpciA9PT0gJ3J0bCcgPyBydGxEZWZhdWx0cyA6IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmRpckRlZmF1bHRzID0gZGlyRGVmYXVsdHM7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGVmYXVsdHMgPSBsb2NhbGVEZWZhdWx0cztcclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlZCA9IG1lcmdlT3B0aW9ucyhbXHJcbiAgICAgICAgICAgICAgICBnbG9iYWxEZWZhdWx0cyxcclxuICAgICAgICAgICAgICAgIGRpckRlZmF1bHRzLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXHJcbiAgICAgICAgICAgICAgICB0aGlzLm92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlc1xyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPcHRpb25zTWFuYWdlcjtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgdmFyIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAgPSB7fTtcclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0obmFtZSwgdGhlQ2xhc3MpIHtcclxuICAgICAgICBjYWxlbmRhclN5c3RlbUNsYXNzTWFwW25hbWVdID0gdGhlQ2xhc3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDYWxlbmRhclN5c3RlbShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjYWxlbmRhclN5c3RlbUNsYXNzTWFwW25hbWVdKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0oKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtLnByb3RvdHlwZS5nZXRNYXJrZXJZZWFyID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtLnByb3RvdHlwZS5nZXRNYXJrZXJNb250aCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLmdldFVUQ01vbnRoKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbS5wcm90b3R5cGUuZ2V0TWFya2VyRGF5ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRGF0ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLmFycmF5VG9NYXJrZXIgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhcnIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLm1hcmtlclRvQXJyYXkgPSBmdW5jdGlvbiAobWFya2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlVG9VdGNBcnJheShtYXJrZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtO1xyXG4gICAgfSgpKTtcclxuICAgIHJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0oJ2dyZWdvcnknLCBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSk7XHJcblxyXG4gICAgdmFyIElTT19SRSA9IC9eXFxzKihcXGR7NH0pKC0oXFxkezJ9KSgtKFxcZHsyfSkoW1QgXShcXGR7Mn0pOihcXGR7Mn0pKDooXFxkezJ9KShcXC4oXFxkKykpPyk/KFp8KChbLStdKShcXGR7Mn0pKDo/KFxcZHsyfSkpPykpPyk/KT8pPyQvO1xyXG4gICAgZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XHJcbiAgICAgICAgdmFyIG0gPSBJU09fUkUuZXhlYyhzdHIpO1xyXG4gICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSBuZXcgRGF0ZShEYXRlLlVUQyhOdW1iZXIobVsxXSksIG1bM10gPyBOdW1iZXIobVszXSkgLSAxIDogMCwgTnVtYmVyKG1bNV0gfHwgMSksIE51bWJlcihtWzddIHx8IDApLCBOdW1iZXIobVs4XSB8fCAwKSwgTnVtYmVyKG1bMTBdIHx8IDApLCBtWzEyXSA/IE51bWJlcignMC4nICsgbVsxMl0pICogMTAwMCA6IDApKTtcclxuICAgICAgICAgICAgaWYgKGlzVmFsaWREYXRlKG1hcmtlcikpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAobVsxM10pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IChtWzE1XSA9PT0gJy0nID8gLTEgOiAxKSAqIChOdW1iZXIobVsxNl0gfHwgMCkgKiA2MCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlcihtWzE4XSB8fCAwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcjogbWFya2VyLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogdGltZVpvbmVPZmZzZXRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIERhdGVFbnYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRGF0ZUVudihzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgdGltZVpvbmUgPSB0aGlzLnRpbWVab25lID0gc2V0dGluZ3MudGltZVpvbmU7XHJcbiAgICAgICAgICAgIHZhciBpc05hbWVkVGltZVpvbmUgPSB0aW1lWm9uZSAhPT0gJ2xvY2FsJyAmJiB0aW1lWm9uZSAhPT0gJ1VUQyc7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCAmJiBpc05hbWVkVGltZVpvbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZWRUaW1lWm9uZUltcGwgPSBuZXcgc2V0dGluZ3MubmFtZWRUaW1lWm9uZUltcGwodGltZVpvbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2FuQ29tcHV0ZU9mZnNldCA9IEJvb2xlYW4oIWlzTmFtZWRUaW1lWm9uZSB8fCB0aGlzLm5hbWVkVGltZVpvbmVJbXBsKTtcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbSA9IGNyZWF0ZUNhbGVuZGFyU3lzdGVtKHNldHRpbmdzLmNhbGVuZGFyU3lzdGVtKTtcclxuICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBzZXR0aW5ncy5sb2NhbGU7XHJcbiAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRvdztcclxuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG95O1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMud2Vla0RveSA9IDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5maXJzdERheSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmZpcnN0RGF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtOdW1iZXJGdW5jID0gc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMud2Vla0xhYmVsID0gc2V0dGluZ3Mud2Vla0xhYmVsICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrTGFiZWwgOiBzZXR0aW5ncy5sb2NhbGUub3B0aW9ucy53ZWVrTGFiZWw7XHJcbiAgICAgICAgICAgIHRoaXMuY21kRm9ybWF0dGVyID0gc2V0dGluZ3MuY21kRm9ybWF0dGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGluZyAvIFBhcnNpbmdcclxuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5jcmVhdGVNYXJrZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGEgPSB0aGlzLmNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAobWV0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1ldGEubWFya2VyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuY3JlYXRlTm93TWFya2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYW5Db21wdXRlT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXBUb01hcmtlcihuZXcgRGF0ZSgpLnZhbHVlT2YoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBjb21wdXRlIHRoZSBjdXJyZW50IGRhdGUgdmFsIGZvciBhIHRpbWV6b25lLFxyXG4gICAgICAgICAgICAgICAgLy8gYmV0dGVyIHRvIGdpdmUgdGhlIGN1cnJlbnQgbG9jYWwgZGF0ZSB2YWxzIHRoYW4gVVRDXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZSgpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLmNyZWF0ZU1hcmtlck1ldGEgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGlucHV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWFya2VyID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSBhcnJheVRvVXRjRGF0ZShpbnB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hcmtlciA9PT0gbnVsbCB8fCAhaXNWYWxpZERhdGUobWFya2VyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgbWFya2VyOiBtYXJrZXIsIGlzVGltZVVuc3BlY2lmaWVkOiBmYWxzZSwgZm9yY2VkVHpvOiBudWxsIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHBhcnNlKHMpO1xyXG4gICAgICAgICAgICBpZiAocGFydHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSBwYXJ0cy5tYXJrZXI7XHJcbiAgICAgICAgICAgIHZhciBmb3JjZWRUem8gPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAocGFydHMudGltZVpvbmVPZmZzZXQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG1hcmtlci52YWx1ZU9mKCkgLSBwYXJ0cy50aW1lWm9uZU9mZnNldCAqIDYwICogMTAwMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBtYXJrZXI6IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IHBhcnRzLmlzVGltZVVuc3BlY2lmaWVkLCBmb3JjZWRUem86IGZvcmNlZFR6byB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQWNjZXNzb3JzXHJcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuZ2V0WWVhciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtYXJrZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuZ2V0TW9udGggPSBmdW5jdGlvbiAobWFya2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG1hcmtlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBBZGRpbmcgLyBTdWJ0cmFjdGluZ1xyXG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChtYXJrZXIsIGR1cikge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xyXG4gICAgICAgICAgICBhWzBdICs9IGR1ci55ZWFycztcclxuICAgICAgICAgICAgYVsxXSArPSBkdXIubW9udGhzO1xyXG4gICAgICAgICAgICBhWzJdICs9IGR1ci5kYXlzO1xyXG4gICAgICAgICAgICBhWzZdICs9IGR1ci5taWxsaXNlY29uZHM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChtYXJrZXIsIGR1cikge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xyXG4gICAgICAgICAgICBhWzBdIC09IGR1ci55ZWFycztcclxuICAgICAgICAgICAgYVsxXSAtPSBkdXIubW9udGhzO1xyXG4gICAgICAgICAgICBhWzJdIC09IGR1ci5kYXlzO1xyXG4gICAgICAgICAgICBhWzZdIC09IGR1ci5taWxsaXNlY29uZHM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5hZGRZZWFycyA9IGZ1bmN0aW9uIChtYXJrZXIsIG4pIHtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcclxuICAgICAgICAgICAgYVswXSArPSBuO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuYWRkTW9udGhzID0gZnVuY3Rpb24gKG1hcmtlciwgbikge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xyXG4gICAgICAgICAgICBhWzFdICs9IG47XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBEaWZmaW5nIFdob2xlIFVuaXRzXHJcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuZGlmZldob2xlWWVhcnMgPSBmdW5jdGlvbiAobTAsIG0xKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWxlbmRhclN5c3RlbSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW07XHJcbiAgICAgICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSAmJlxyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuZGlmZldob2xlTW9udGhzID0gZnVuY3Rpb24gKG0wLCBtMSkge1xyXG4gICAgICAgICAgICB2YXIgY2FsZW5kYXJTeXN0ZW0gPSB0aGlzLmNhbGVuZGFyU3lzdGVtO1xyXG4gICAgICAgICAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkgJiZcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApKSArXHJcbiAgICAgICAgICAgICAgICAgICAgKGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCkpICogMTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBSYW5nZSAvIER1cmF0aW9uXHJcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuZ3JlYXRlc3RXaG9sZVVuaXQgPSBmdW5jdGlvbiAobTAsIG0xKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3llYXInLCB2YWx1ZTogbiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21vbnRoJywgdmFsdWU6IG4gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gZGlmZldob2xlV2Vla3MobTAsIG0xKTtcclxuICAgICAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd3ZWVrJywgdmFsdWU6IG4gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBuIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbiA9IGRpZmZIb3VycyhtMCwgbTEpO1xyXG4gICAgICAgICAgICBpZiAoaXNJbnQobikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG4gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gZGlmZk1pbnV0ZXMobTAsIG0xKTtcclxuICAgICAgICAgICAgaWYgKGlzSW50KG4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG4gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gZGlmZlNlY29uZHMobTAsIG0xKTtcclxuICAgICAgICAgICAgaWYgKGlzSW50KG4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnc2Vjb25kJywgdmFsdWU6IG4gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5jb3VudER1cmF0aW9uc0JldHdlZW4gPSBmdW5jdGlvbiAobTAsIG0xLCBkKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGNhbiB1c2UgZ3JlYXRlc3RXaG9sZVVuaXRcclxuICAgICAgICAgICAgdmFyIGRpZmY7XHJcbiAgICAgICAgICAgIGlmIChkLnllYXJzKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hZZWFycyhkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZC5tb250aHMpIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGQuZGF5cykge1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoRGF5cyhkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyBhc1JvdWdoTXMoZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTdGFydC1PZlxyXG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2YgPSBmdW5jdGlvbiAobSwgdW5pdCkge1xyXG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1bml0ID09PSAnbW9udGgnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mTW9udGgobSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodW5pdCA9PT0gJ3dlZWsnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mV2VlayhtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1bml0ID09PSAnZGF5Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodW5pdCA9PT0gJ2hvdXInKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRPZkhvdXIobSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodW5pdCA9PT0gJ21pbnV0ZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydE9mTWludXRlKG0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuc3RhcnRPZlllYXIgPSBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2ZNb250aCA9IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2ZXZWVrID0gZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxyXG4gICAgICAgICAgICAgICAgbS5nZXRVVENEYXRlKCkgLSAoKG0uZ2V0VVRDRGF5KCkgLSB0aGlzLndlZWtEb3cgKyA3KSAlIDcpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gV2VlayBOdW1iZXJcclxuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS5jb21wdXRlV2Vla051bWJlciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMud2Vla051bWJlckZ1bmMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtOdW1iZXJGdW5jKHRoaXMudG9EYXRlKG1hcmtlcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobWFya2VyLCB0aGlzLndlZWtEb3csIHRoaXMud2Vla0RveSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFRPRE86IGNob2tlIG9uIHRpbWVab25lTmFtZTogbG9uZ1xyXG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChtYXJrZXIsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGVPcHRpb25zID09PSB2b2lkIDApIHsgZGF0ZU9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXI6IG1hcmtlcixcclxuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkVHpvIDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpXHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF0ZUVudi5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgZm9ybWF0dGVyLCBkYXRlT3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoZGF0ZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBkYXRlT3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgICAgIGlmIChkYXRlT3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gYWRkTXMoZW5kLCAtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXRSYW5nZSh7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXI6IHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZFN0YXJ0VHpvICE9IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZFN0YXJ0VHpvIDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihzdGFydClcclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgbWFya2VyOiBlbmQsXHJcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvICE9IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoZW5kKVxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLmZvcm1hdElzbyA9IGZ1bmN0aW9uIChtYXJrZXIsIGV4dHJhT3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoZXh0cmFPcHRpb25zID09PSB2b2lkIDApIHsgZXh0cmFPcHRpb25zID0ge307IH1cclxuICAgICAgICAgICAgdmFyIHRpbWVab25lT2Zmc2V0ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFleHRyYU9wdGlvbnMub21pdFRpbWVab25lT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFPcHRpb25zLmZvcmNlZFR6byAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSBleHRyYU9wdGlvbnMuZm9yY2VkVHpvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBleHRyYU9wdGlvbnMub21pdFRpbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gVGltZVpvbmVcclxuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS50aW1lc3RhbXBUb01hcmtlciA9IGZ1bmN0aW9uIChtcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGRhdGVUb0xvY2FsQXJyYXkobmV3IERhdGUobXMpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycgfHwgIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIERhdGVFbnYucHJvdG90eXBlLm9mZnNldEZvck1hcmtlciA9IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLWFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpLmdldFRpbWV6b25lT2Zmc2V0KCk7IC8vIGNvbnZlcnQgXCJpbnZlcnNlXCIgb2Zmc2V0IHRvIFwibm9ybWFsXCIgb2Zmc2V0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENvbnZlcnNpb25cclxuICAgICAgICBEYXRlRW52LnByb3RvdHlwZS50b0RhdGUgPSBmdW5jdGlvbiAobSwgZm9yY2VkVHpvKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSk7IC8vIG1ha2Ugc3VyZSBpdCdzIGEgY29weVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLSAoZm9yY2VkVHpvIHx8IDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSkgKiAxMDAwICogNjAgLy8gY29udmVydCBtaW51dGVzIC0+IG1zXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRGF0ZUVudjtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgdmFyIFNJTVBMRV9TT1VSQ0VfUFJPUFMgPSB7XHJcbiAgICAgICAgaWQ6IFN0cmluZyxcclxuICAgICAgICBhbGxEYXlEZWZhdWx0OiBCb29sZWFuLFxyXG4gICAgICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogRnVuY3Rpb24sXHJcbiAgICAgICAgc3VjY2VzczogRnVuY3Rpb24sXHJcbiAgICAgICAgZmFpbHVyZTogRnVuY3Rpb25cclxuICAgIH07XHJcbiAgICB2YXIgdWlkJDIgPSAwO1xyXG4gICAgZnVuY3Rpb24gZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgZGVmcyA9IGNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy5ldmVudFNvdXJjZURlZnM7XHJcbiAgICAgICAgcmV0dXJuICFkZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXS5pZ25vcmVSYW5nZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhcnNlRXZlbnRTb3VyY2UocmF3LCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBkZWZzID0gY2FsZW5kYXIucGx1Z2luU3lzdGVtLmhvb2tzLmV2ZW50U291cmNlRGVmcztcclxuICAgICAgICBmb3IgKHZhciBpID0gZGVmcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyAvLyBsYXRlci1hZGRlZCBwbHVnaW5zIHRha2UgcHJlY2VkZW5jZVxyXG4gICAgICAgICAgICB2YXIgZGVmID0gZGVmc1tpXTtcclxuICAgICAgICAgICAgdmFyIG1ldGEgPSBkZWYucGFyc2VNZXRhKHJhdyk7XHJcbiAgICAgICAgICAgIGlmIChtZXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gcGFyc2VFdmVudFNvdXJjZVByb3BzKHR5cGVvZiByYXcgPT09ICdvYmplY3QnID8gcmF3IDoge30sIG1ldGEsIGksIGNhbGVuZGFyKTtcclxuICAgICAgICAgICAgICAgIHJlcy5fcmF3ID0gcmF3O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhcnNlRXZlbnRTb3VyY2VQcm9wcyhyYXcsIG1ldGEsIHNvdXJjZURlZklkLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBsZWZ0b3ZlcnMwID0ge307XHJcbiAgICAgICAgdmFyIHByb3BzID0gcmVmaW5lUHJvcHMocmF3LCBTSU1QTEVfU09VUkNFX1BST1BTLCB7fSwgbGVmdG92ZXJzMCk7XHJcbiAgICAgICAgdmFyIGxlZnRvdmVyczEgPSB7fTtcclxuICAgICAgICB2YXIgdWkgPSBwcm9jZXNzVW5zY29wZWRVaVByb3BzKGxlZnRvdmVyczAsIGNhbGVuZGFyLCBsZWZ0b3ZlcnMxKTtcclxuICAgICAgICBwcm9wcy5pc0ZldGNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgcHJvcHMubGF0ZXN0RmV0Y2hJZCA9ICcnO1xyXG4gICAgICAgIHByb3BzLmZldGNoUmFuZ2UgPSBudWxsO1xyXG4gICAgICAgIHByb3BzLnB1YmxpY0lkID0gU3RyaW5nKHJhdy5pZCB8fCAnJyk7XHJcbiAgICAgICAgcHJvcHMuc291cmNlSWQgPSBTdHJpbmcodWlkJDIrKyk7XHJcbiAgICAgICAgcHJvcHMuc291cmNlRGVmSWQgPSBzb3VyY2VEZWZJZDtcclxuICAgICAgICBwcm9wcy5tZXRhID0gbWV0YTtcclxuICAgICAgICBwcm9wcy51aSA9IHVpO1xyXG4gICAgICAgIHByb3BzLmV4dGVuZGVkUHJvcHMgPSBsZWZ0b3ZlcnMxO1xyXG4gICAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWR1Y2VFdmVudFNvdXJjZXMgKGV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXIpIHtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0FERF9FVkVOVF9TT1VSQ0VTJzogLy8gYWxyZWFkeSBwYXJzZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZXMsIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLCBjYWxlbmRhcik7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcclxuICAgICAgICAgICAgY2FzZSAnTkVYVCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9EQVRFJzpcclxuICAgICAgICAgICAgY2FzZSAnU0VUX1ZJRVdfVFlQRSc6XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hEaXJ0eVNvdXJjZXMoZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY2FsZW5kYXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnRkVUQ0hfRVZFTlRfU09VUkNFUyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9USU1FWk9ORSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWRzID9cclxuICAgICAgICAgICAgICAgICAgICBhcnJheVRvSGFzaChhY3Rpb24uc291cmNlSWRzKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjYWxlbmRhciksIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLCBjYWxlbmRhcik7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzpcclxuICAgICAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVF9FUlJPUic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWl2ZVJlc3BvbnNlKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZUlkLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UpO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgdWlkJDMgPSAwO1xyXG4gICAgZnVuY3Rpb24gYWRkU291cmNlcyhldmVudFNvdXJjZUhhc2gsIHNvdXJjZXMsIGZldGNoUmFuZ2UsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIGhhc2ggPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZXNfMSA9IHNvdXJjZXM7IF9pIDwgc291cmNlc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc18xW19pXTtcclxuICAgICAgICAgICAgaGFzaFtzb3VyY2Uuc291cmNlSWRdID0gc291cmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmV0Y2hSYW5nZSkge1xyXG4gICAgICAgICAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY2FsZW5kYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIGV2ZW50U291cmNlSGFzaCwgaGFzaCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VJZCkge1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlSGFzaCwgZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZS5zb3VyY2VJZCAhPT0gc291cmNlSWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmZXRjaERpcnR5U291cmNlcyhzb3VyY2VIYXNoLCBmZXRjaFJhbmdlLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhzb3VyY2VIYXNoLCBmaWx0ZXJIYXNoKHNvdXJjZUhhc2gsIGZ1bmN0aW9uIChldmVudFNvdXJjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY2FsZW5kYXIpO1xyXG4gICAgICAgIH0pLCBmZXRjaFJhbmdlLCBjYWxlbmRhcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBjYWxlbmRhcikge1xyXG4gICAgICAgIGlmICghZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY2FsZW5kYXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhY2FsZW5kYXIub3B0KCdsYXp5RmV0Y2hpbmcnKSB8fFxyXG4gICAgICAgICAgICAgICAgIWV2ZW50U291cmNlLmZldGNoUmFuZ2UgfHxcclxuICAgICAgICAgICAgICAgIGZldGNoUmFuZ2Uuc3RhcnQgPCBldmVudFNvdXJjZS5mZXRjaFJhbmdlLnN0YXJ0IHx8XHJcbiAgICAgICAgICAgICAgICBmZXRjaFJhbmdlLmVuZCA+IGV2ZW50U291cmNlLmZldGNoUmFuZ2UuZW5kO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZldGNoU291cmNlc0J5SWRzKHByZXZTb3VyY2VzLCBzb3VyY2VJZEhhc2gsIGZldGNoUmFuZ2UsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIG5leHRTb3VyY2VzID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgc291cmNlSWQgaW4gcHJldlNvdXJjZXMpIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHByZXZTb3VyY2VzW3NvdXJjZUlkXTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUlkSGFzaFtzb3VyY2VJZF0pIHtcclxuICAgICAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IGZldGNoU291cmNlKHNvdXJjZSwgZmV0Y2hSYW5nZSwgY2FsZW5kYXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV4dFNvdXJjZXNbc291cmNlSWRdID0gc291cmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0U291cmNlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZldGNoU291cmNlKGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBzb3VyY2VEZWYgPSBjYWxlbmRhci5wbHVnaW5TeXN0ZW0uaG9va3MuZXZlbnRTb3VyY2VEZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXTtcclxuICAgICAgICB2YXIgZmV0Y2hJZCA9IFN0cmluZyh1aWQkMysrKTtcclxuICAgICAgICBzb3VyY2VEZWYuZmV0Y2goe1xyXG4gICAgICAgICAgICBldmVudFNvdXJjZTogZXZlbnRTb3VyY2UsXHJcbiAgICAgICAgICAgIGNhbGVuZGFyOiBjYWxlbmRhcixcclxuICAgICAgICAgICAgcmFuZ2U6IGZldGNoUmFuZ2VcclxuICAgICAgICB9LCBmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgIHZhciByYXdFdmVudHMgPSByZXMucmF3RXZlbnRzO1xyXG4gICAgICAgICAgICB2YXIgY2FsU3VjY2VzcyA9IGNhbGVuZGFyLm9wdCgnZXZlbnRTb3VyY2VTdWNjZXNzJyk7XHJcbiAgICAgICAgICAgIHZhciBjYWxTdWNjZXNzUmVzO1xyXG4gICAgICAgICAgICB2YXIgc291cmNlU3VjY2Vzc1JlcztcclxuICAgICAgICAgICAgaWYgKGV2ZW50U291cmNlLnN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZVN1Y2Nlc3NSZXMgPSBldmVudFNvdXJjZS5zdWNjZXNzKHJhd0V2ZW50cywgcmVzLnhocik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNhbFN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIGNhbFN1Y2Nlc3NSZXMgPSBjYWxTdWNjZXNzKHJhd0V2ZW50cywgcmVzLnhocik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmF3RXZlbnRzID0gc291cmNlU3VjY2Vzc1JlcyB8fCBjYWxTdWNjZXNzUmVzIHx8IHJhd0V2ZW50cztcclxuICAgICAgICAgICAgY2FsZW5kYXIuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcclxuICAgICAgICAgICAgICAgIGZldGNoSWQ6IGZldGNoSWQsXHJcbiAgICAgICAgICAgICAgICBmZXRjaFJhbmdlOiBmZXRjaFJhbmdlLFxyXG4gICAgICAgICAgICAgICAgcmF3RXZlbnRzOiByYXdFdmVudHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWxsRmFpbHVyZSA9IGNhbGVuZGFyLm9wdCgnZXZlbnRTb3VyY2VGYWlsdXJlJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlLCBlcnJvcik7XHJcbiAgICAgICAgICAgIGlmIChldmVudFNvdXJjZS5mYWlsdXJlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5mYWlsdXJlKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2FsbEZhaWx1cmUpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxGYWlsdXJlKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxlbmRhci5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVF9FUlJPUicsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXHJcbiAgICAgICAgICAgICAgICBmZXRjaElkOiBmZXRjaElkLFxyXG4gICAgICAgICAgICAgICAgZmV0Y2hSYW5nZTogZmV0Y2hSYW5nZSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIGV2ZW50U291cmNlLCB7IGlzRmV0Y2hpbmc6IHRydWUsIGxhdGVzdEZldGNoSWQ6IGZldGNoSWQgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWNlaXZlUmVzcG9uc2Uoc291cmNlSGFzaCwgc291cmNlSWQsIGZldGNoSWQsIGZldGNoUmFuZ2UpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIGV2ZW50U291cmNlID0gc291cmNlSGFzaFtzb3VyY2VJZF07XHJcbiAgICAgICAgaWYgKGV2ZW50U291cmNlICYmIC8vIG5vdCBhbHJlYWR5IHJlbW92ZWRcclxuICAgICAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIHNvdXJjZUhhc2gsIChfYSA9IHt9LCBfYVtzb3VyY2VJZF0gPSBfX2Fzc2lnbih7fSwgZXZlbnRTb3VyY2UsIHsgaXNGZXRjaGluZzogZmFsc2UsIGZldGNoUmFuZ2U6IGZldGNoUmFuZ2UgfSksIF9hKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzb3VyY2VIYXNoO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlcywgZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjYWxlbmRhcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIERhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIERhdGVQcm9maWxlR2VuZXJhdG9yKHZpZXdTcGVjLCBjYWxlbmRhcikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdTcGVjID0gdmlld1NwZWM7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHZpZXdTcGVjLm9wdGlvbnM7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZUVudiA9IGNhbGVuZGFyLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIgPSBjYWxlbmRhcjtcclxuICAgICAgICAgICAgdGhpcy5pbml0SGlkZGVuRGF5cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBEYXRlIFJhbmdlIENvbXB1dGF0aW9uXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cclxuICAgICAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRQcmV2ID0gZnVuY3Rpb24gKGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciBwcmV2RGF0ZSA9IGRhdGVFbnYuc3VidHJhY3QoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcclxuICAgICAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwibmV4dFwiIHZpZXcuXHJcbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkTmV4dCA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5kYXRlRW52O1xyXG4gICAgICAgICAgICB2YXIgbmV4dERhdGUgPSBkYXRlRW52LmFkZChkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxyXG4gICAgICAgICAgICBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKG5leHREYXRlLCAxKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSBob2xkaW5nIGRhdGVzL3JhbmdlcyBmb3IgcmVuZGVyaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgICAgICAvLyBPcHRpb25hbCBkaXJlY3Rpb24gcGFyYW0gaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRhdGUgaXMgYmVpbmcgaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWRcclxuICAgICAgICAvLyBmcm9tIGl0cyBwcmV2aW91cyB2YWx1ZS4gZGVjcmVtZW50ZWQgPSAtMSwgaW5jcmVtZW50ZWQgPSAxIChkZWZhdWx0KS5cclxuICAgICAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoY3VycmVudERhdGUsIGRpcmVjdGlvbiwgZm9yY2VUb1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZVRvVmFsaWQgPT09IHZvaWQgMCkgeyBmb3JjZVRvVmFsaWQgPSBmYWxzZTsgfVxyXG4gICAgICAgICAgICB2YXIgdmFsaWRSYW5nZTtcclxuICAgICAgICAgICAgdmFyIG1pblRpbWUgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgbWF4VGltZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50SW5mbztcclxuICAgICAgICAgICAgdmFyIGlzUmFuZ2VBbGxEYXk7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJSYW5nZTtcclxuICAgICAgICAgICAgdmFyIGFjdGl2ZVJhbmdlO1xyXG4gICAgICAgICAgICB2YXIgaXNWYWxpZDtcclxuICAgICAgICAgICAgdmFsaWRSYW5nZSA9IHRoaXMuYnVpbGRWYWxpZFJhbmdlKCk7XHJcbiAgICAgICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHZhbGlkUmFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAoZm9yY2VUb1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoY3VycmVudERhdGUsIHZhbGlkUmFuZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRJbmZvID0gdGhpcy5idWlsZEN1cnJlbnRSYW5nZUluZm8oY3VycmVudERhdGUsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGlzUmFuZ2VBbGxEYXkgPSAvXih5ZWFyfG1vbnRofHdlZWt8ZGF5KSQvLnRlc3QoY3VycmVudEluZm8udW5pdCk7XHJcbiAgICAgICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy5idWlsZFJlbmRlclJhbmdlKHRoaXMudHJpbUhpZGRlbkRheXMoY3VycmVudEluZm8ucmFuZ2UpLCBjdXJyZW50SW5mby51bml0LCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICAgICAgcmVuZGVyUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHJlbmRlclJhbmdlKTtcclxuICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSByZW5kZXJSYW5nZTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd05vbkN1cnJlbnREYXRlcykge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIGN1cnJlbnRJbmZvLnJhbmdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaW5UaW1lID0gY3JlYXRlRHVyYXRpb24odGhpcy5vcHRpb25zLm1pblRpbWUpO1xyXG4gICAgICAgICAgICBtYXhUaW1lID0gY3JlYXRlRHVyYXRpb24odGhpcy5vcHRpb25zLm1heFRpbWUpO1xyXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlUmFuZ2UsIG1pblRpbWUsIG1heFRpbWUpO1xyXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgdmFsaWRSYW5nZSk7IC8vIG1pZ2h0IHJldHVybiBudWxsXHJcbiAgICAgICAgICAgIC8vIGl0J3MgaW52YWxpZCBpZiB0aGUgb3JpZ2luYWxseSByZXF1ZXN0ZWQgZGF0ZSBpcyBub3QgY29udGFpbmVkLFxyXG4gICAgICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cclxuICAgICAgICAgICAgaXNWYWxpZCA9IHJhbmdlc0ludGVyc2VjdChjdXJyZW50SW5mby5yYW5nZSwgdmFsaWRSYW5nZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxyXG4gICAgICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgICAgdmFsaWRSYW5nZTogdmFsaWRSYW5nZSxcclxuICAgICAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cclxuICAgICAgICAgICAgICAgIC8vIGZvciBleGFtcGxlLCBhIG1vbnRoIHZpZXcgbWlnaHQgaGF2ZSAxc3QtMzFzdCwgZXhjbHVkaW5nIHBhZGRlZCBkYXRlc1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJhbmdlOiBjdXJyZW50SW5mby5yYW5nZSxcclxuICAgICAgICAgICAgICAgIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXHJcbiAgICAgICAgICAgICAgICBpc1JhbmdlQWxsRGF5OiBpc1JhbmdlQWxsRGF5LFxyXG4gICAgICAgICAgICAgICAgLy8gZGF0ZXMgdGhhdCBkaXNwbGF5IGV2ZW50cyBhbmQgYWNjZXB0IGRyYWctbi1kcm9wXHJcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVSYW5nZTogYWN0aXZlUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAvLyBkYXRlIHJhbmdlIHdpdGggYSByZW5kZXJlZCBza2VsZXRvblxyXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkZXMgbm90LWFjdGl2ZSBkYXlzIHRoYXQgbmVlZCBzb21lIHNvcnQgb2YgRE9NXHJcbiAgICAgICAgICAgICAgICByZW5kZXJSYW5nZTogcmVuZGVyUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBmaXJzdCB2aXNpYmxlIHRpbWUgb2YgYW55IGdpdmVuIGRheVxyXG4gICAgICAgICAgICAgICAgbWluVGltZTogbWluVGltZSxcclxuICAgICAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcclxuICAgICAgICAgICAgICAgIG1heFRpbWU6IG1heFRpbWUsXHJcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxyXG4gICAgICAgICAgICAgICAgLy8gaG93IGZhciB0aGUgY3VycmVudCBkYXRlIHdpbGwgbW92ZSBmb3IgYSBwcmV2L25leHQgb3BlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICBkYXRlSW5jcmVtZW50OiB0aGlzLmJ1aWxkRGF0ZUluY3JlbWVudChjdXJyZW50SW5mby5kdXJhdGlvbilcclxuICAgICAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQnVpbGRzIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHN0YXJ0L2VuZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgIC8vIEluZGljYXRlcyB0aGUgbWluaW11bS9tYXhpbXVtIGRhdGVzIHRvIGRpc3BsYXkuXHJcbiAgICAgICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cclxuICAgICAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRWYWxpZFJhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYW5nZU9wdGlvbigndmFsaWRSYW5nZScsIHRoaXMuY2FsZW5kYXIuZ2V0Tm93KCkpIHx8XHJcbiAgICAgICAgICAgICAgICB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTsgLy8gY29tcGxldGVseSBvcGVuLWVuZGVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcclxuICAgICAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cclxuICAgICAgICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cclxuICAgICAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXHJcbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgdmlld1NwZWMgPSBfYS52aWV3U3BlYywgZGF0ZUVudiA9IF9hLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciB1bml0ID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGRheUNvdW50O1xyXG4gICAgICAgICAgICBpZiAodmlld1NwZWMuZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gdmlld1NwZWMuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICB1bml0ID0gdmlld1NwZWMuZHVyYXRpb25Vbml0O1xyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKGRheUNvdW50ID0gdGhpcy5vcHRpb25zLmRheUNvdW50KSkge1xyXG4gICAgICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcclxuICAgICAgICAgICAgICAgIHVuaXQgPSBkYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdDtcclxuICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgdW5pdDogdW5pdCwgcmFuZ2U6IHJhbmdlIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuZ2V0RmFsbGJhY2tEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZGF5OiAxIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gUmV0dXJucyBhIG5ldyBhY3RpdmVSYW5nZSB0byBoYXZlIHRpbWUgdmFsdWVzICh1bi1hbWJpZ3VhdGUpXHJcbiAgICAgICAgLy8gbWluVGltZSBvciBtYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxyXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5hZGp1c3RBY3RpdmVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgbWluVGltZSwgbWF4VGltZSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZGF0ZUVudjtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTcGVjLmNsYXNzLnByb3RvdHlwZS51c2VzTWluTWF4VGltZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZXhwYW5kIGFjdGl2ZSByYW5nZSBpZiBtaW5UaW1lIGlzIG5lZ2F0aXZlICh3aHkgbm90IHdoZW4gcG9zaXRpdmU/KVxyXG4gICAgICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKG1pblRpbWUpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7IC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBtaW5UaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgbWF4VGltZSBpcyBiZXlvbmQgb25lIGRheSAod2h5IG5vdCB3aGVuIHBvc2l0aXZlPylcclxuICAgICAgICAgICAgICAgIGlmIChhc1JvdWdoRGF5cyhtYXhUaW1lKSA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgbWF4VGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cclxuICAgICAgICAvLyBgdW5pdGAgaXMgdGhlIGFscmVhZHktY29tcHV0ZWQgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIHVuaXQgb2YgZHVyYXRpb24uXHJcbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24gPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZGF0ZUVudjtcclxuICAgICAgICAgICAgdmFyIGFsaWdubWVudCA9IHRoaXMub3B0aW9ucy5kYXRlQWxpZ25tZW50O1xyXG4gICAgICAgICAgICB2YXIgZGF0ZUluY3JlbWVudElucHV0O1xyXG4gICAgICAgICAgICB2YXIgZGF0ZUluY3JlbWVudER1cmF0aW9uO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgd2hhdCB0aGUgYWxpZ25tZW50IHNob3VsZCBiZVxyXG4gICAgICAgICAgICBpZiAoIWFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZUluY3JlbWVudElucHV0ID0gdGhpcy5vcHRpb25zLmRhdGVJbmNyZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZUluY3JlbWVudElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUluY3JlbWVudER1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24oZGF0ZUluY3JlbWVudElucHV0KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byB1bml0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhc1JvdWdoTXMoZGF0ZUluY3JlbWVudER1cmF0aW9uKSA8IGFzUm91Z2hNcyhkdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnREdXJhdGlvbiwgIWdldFdlZWtzRnJvbUlucHV0KGRhdGVJbmNyZW1lbnRJbnB1dCkpLnVuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSB1bml0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IHVuaXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgdGhlIHZpZXcgZGlzcGxheXMgYSBzaW5nbGUgZGF5IG9yIHNtYWxsZXJcclxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKGR1cmF0aW9uKSA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0hpZGRlbkRheShzdGFydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBzdGFydE9mRGF5KHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wdXRlUmVzKCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2YoZGF0ZSwgYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICByZXMgPSB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb21wdXRlUmVzKCk7XHJcbiAgICAgICAgICAgIC8vIGlmIHJhbmdlIGlzIGNvbXBsZXRlbHkgZW52ZWxvcGVkIGJ5IGhpZGRlbiBkYXlzLCBnbyBwYXN0IHRoZSBoaWRkZW4gZGF5c1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVSZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGEgZGF5Q291bnQgaXMgc3BlY2lmaWVkLlxyXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJhbmdlRnJvbURheUNvdW50ID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciBjdXN0b21BbGlnbm1lbnQgPSB0aGlzLm9wdGlvbnMuZGF0ZUFsaWdubWVudDtcclxuICAgICAgICAgICAgdmFyIHJ1bm5pbmdDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGRhdGU7XHJcbiAgICAgICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21BbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mKHN0YXJ0LCBjdXN0b21BbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcclxuICAgICAgICAvLyB3aGljaCBpcyBhIHdheSB0byBkZWZpbmUgdGhlIGN1cnJlbnRSYW5nZSBhbmQgYWN0aXZlUmFuZ2UgYXQgdGhlIHNhbWUgdGltZS5cclxuICAgICAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZGF0ZUVudjtcclxuICAgICAgICAgICAgdmFyIHZpc2libGVSYW5nZSA9IHRoaXMuZ2V0UmFuZ2VPcHRpb24oJ3Zpc2libGVSYW5nZScsIGRhdGVFbnYudG9EYXRlKGRhdGUpKTtcclxuICAgICAgICAgICAgaWYgKHZpc2libGVSYW5nZSAmJiAodmlzaWJsZVJhbmdlLnN0YXJ0ID09IG51bGwgfHwgdmlzaWJsZVJhbmdlLmVuZCA9PSBudWxsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZpc2libGVSYW5nZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcclxuICAgICAgICAvLyBidXQgd2hpY2ggbWF5IGhhdmUgdm9pZGVkIGRheXMvdGltZXMuXHJcbiAgICAgICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cclxuICAgICAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSYW5nZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGR1cmF0aW9uIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkL3N1YnN0cmFjdGVkIHRvIHRoZSBjdXJyZW50IGRhdGVcclxuICAgICAgICAvLyB3aGVuIGEgcHJldi9uZXh0IG9wZXJhdGlvbiBoYXBwZW5zLlxyXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZERhdGVJbmNyZW1lbnQgPSBmdW5jdGlvbiAoZmFsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnRJbnB1dCA9IHRoaXMub3B0aW9ucy5kYXRlSW5jcmVtZW50O1xyXG4gICAgICAgICAgICB2YXIgY3VzdG9tQWxpZ25tZW50O1xyXG4gICAgICAgICAgICBpZiAoZGF0ZUluY3JlbWVudElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUluY3JlbWVudElucHV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoY3VzdG9tQWxpZ25tZW50ID0gdGhpcy5vcHRpb25zLmRhdGVBbGlnbm1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oMSwgY3VzdG9tQWxpZ25tZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQXJndW1lbnRzIGFmdGVyIG5hbWUgd2lsbCBiZSBmb3J3YXJkZWQgdG8gYSBoeXBvdGhldGljYWwgZnVuY3Rpb24gdmFsdWVcclxuICAgICAgICAvLyBXQVJOSU5HOiBwYXNzZWQtaW4gYXJndW1lbnRzIHdpbGwgYmUgZ2l2ZW4gdG8gZ2VuZXJhdG9yIGZ1bmN0aW9ucyBhcy1pcyBhbmQgY2FuIGNhdXNlIHNpZGUtZWZmZWN0cy5cclxuICAgICAgICAvLyBBbHdheXMgY2xvbmUgeW91ciBvYmplY3RzIGlmIHlvdSBmZWFyIG11dGF0aW9uLlxyXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5nZXRSYW5nZU9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBvdGhlckFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIG90aGVyQXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5vcHRpb25zW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLmFwcGx5KG51bGwsIG90aGVyQXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gcGFyc2VSYW5nZSh2YWwsIHRoaXMuZGF0ZUVudik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZSh2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBIaWRkZW4gRGF5c1xyXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZXMgaW50ZXJuYWwgdmFyaWFibGVzIHJlbGF0ZWQgdG8gY2FsY3VsYXRpbmcgaGlkZGVuIGRheXMtb2Ytd2Vla1xyXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5pbml0SGlkZGVuRGF5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGhpZGRlbkRheXMgPSB0aGlzLm9wdGlvbnMuaGlkZGVuRGF5cyB8fCBbXTsgLy8gYXJyYXkgb2YgZGF5LW9mLXdlZWsgaW5kaWNlcyB0aGF0IGFyZSBoaWRkZW5cclxuICAgICAgICAgICAgdmFyIGlzSGlkZGVuRGF5SGFzaCA9IFtdOyAvLyBpcyB0aGUgZGF5LW9mLXdlZWsgaGlkZGVuPyAoaGFzaCB3aXRoIGRheS1vZi13ZWVrLWluZGV4IC0+IGJvb2wpXHJcbiAgICAgICAgICAgIHZhciBkYXlDbnQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy53ZWVrZW5kcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShpc0hpZGRlbkRheUhhc2hbaV0gPSBoaWRkZW5EYXlzLmluZGV4T2YoaSkgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRheUNudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZGF5Q250KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGlkZGVuRGF5cycpOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gUmVtb3ZlIGRheXMgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIHJhbmdlIHRoYXQgYXJlIGNvbXB1dGVkIGFzIGhpZGRlbi5cclxuICAgICAgICAvLyBJZiB0aGUgd2hvbGUgcmFuZ2UgaXMgdHJpbW1lZCBvZmYsIHJldHVybnMgbnVsbFxyXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS50cmltSGlkZGVuRGF5cyA9IGZ1bmN0aW9uIChyYW5nZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZW5kLCAtMSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XHJcbiAgICAgICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXHJcbiAgICAgICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmlzSGlkZGVuRGF5ID0gZnVuY3Rpb24gKGRheSkge1xyXG4gICAgICAgICAgICBpZiAoZGF5IGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgZGF5ID0gZGF5LmdldFVUQ0RheSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzSGlkZGVuRGF5SGFzaFtkYXldO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxyXG4gICAgICAgIC8vIERPRVMgTk9UIENPTlNJREVSIHZhbGlkUmFuZ2UhXHJcbiAgICAgICAgLy8gSWYgdGhlIGluaXRpYWwgdmFsdWUgb2YgYGRhdGVgIGlzIG5vdCBhIGhpZGRlbiBkYXksIGRvbid0IGRvIGFueXRoaW5nLlxyXG4gICAgICAgIC8vIFBhc3MgYGlzRXhjbHVzaXZlYCBhcyBgdHJ1ZWAgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggYW4gZW5kIGRhdGUuXHJcbiAgICAgICAgLy8gYGluY2AgZGVmYXVsdHMgdG8gYDFgIChpbmNyZW1lbnQgb25lIGRheSBmb3J3YXJkIGVhY2ggdGltZSlcclxuICAgICAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuc2tpcEhpZGRlbkRheXMgPSBmdW5jdGlvbiAoZGF0ZSwgaW5jLCBpc0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICBpZiAoaW5jID09PSB2b2lkIDApIHsgaW5jID0gMTsgfVxyXG4gICAgICAgICAgICBpZiAoaXNFeGNsdXNpdmUgPT09IHZvaWQgMCkgeyBpc0V4Y2x1c2l2ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzSGlkZGVuRGF5SGFzaFsoZGF0ZS5nZXRVVENEYXkoKSArIChpc0V4Y2x1c2l2ZSA/IGluYyA6IDApICsgNykgJSA3XSkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgaW5jKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxuICAgIH0oKSk7XHJcbiAgICAvLyBUT0RPOiBmaW5kIGEgd2F5IHRvIGF2b2lkIGNvbXBhcmluZyBEYXRlUHJvZmlsZXMuIGl0J3MgdGVkaW91c1xyXG4gICAgZnVuY3Rpb24gaXNEYXRlUHJvZmlsZXNFcXVhbChwMCwgcDEpIHtcclxuICAgICAgICByZXR1cm4gcmFuZ2VzRXF1YWwocDAudmFsaWRSYW5nZSwgcDEudmFsaWRSYW5nZSkgJiZcclxuICAgICAgICAgICAgcmFuZ2VzRXF1YWwocDAuYWN0aXZlUmFuZ2UsIHAxLmFjdGl2ZVJhbmdlKSAmJlxyXG4gICAgICAgICAgICByYW5nZXNFcXVhbChwMC5yZW5kZXJSYW5nZSwgcDEucmVuZGVyUmFuZ2UpICYmXHJcbiAgICAgICAgICAgIGR1cmF0aW9uc0VxdWFsKHAwLm1pblRpbWUsIHAxLm1pblRpbWUpICYmXHJcbiAgICAgICAgICAgIGR1cmF0aW9uc0VxdWFsKHAwLm1heFRpbWUsIHAxLm1heFRpbWUpO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgVE9ETzogY29tcGFyZSBtb3JlP1xyXG4gICAgICAgICAgY3VycmVudFJhbmdlOiBEYXRlUmFuZ2VcclxuICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IHN0cmluZ1xyXG4gICAgICAgICAgaXNSYW5nZUFsbERheTogYm9vbGVhblxyXG4gICAgICAgICAgaXNWYWxpZDogYm9vbGVhblxyXG4gICAgICAgICAgZGF0ZUluY3JlbWVudDogRHVyYXRpb25cclxuICAgICAgICAqL1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZSAoc3RhdGUsIGFjdGlvbiwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgdmlld1R5cGUgPSByZWR1Y2VWaWV3VHlwZShzdGF0ZS52aWV3VHlwZSwgYWN0aW9uKTtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSByZWR1Y2VEYXRlUHJvZmlsZShzdGF0ZS5kYXRlUHJvZmlsZSwgYWN0aW9uLCBzdGF0ZS5jdXJyZW50RGF0ZSwgdmlld1R5cGUsIGNhbGVuZGFyKTtcclxuICAgICAgICB2YXIgZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzKHN0YXRlLmV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXIpO1xyXG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSBfX2Fzc2lnbih7fSwgc3RhdGUsIHsgdmlld1R5cGU6IHZpZXdUeXBlLFxyXG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlOiByZWR1Y2VDdXJyZW50RGF0ZShzdGF0ZS5jdXJyZW50RGF0ZSwgYWN0aW9uLCBkYXRlUHJvZmlsZSksIGV2ZW50U291cmNlczogZXZlbnRTb3VyY2VzLCBldmVudFN0b3JlOiByZWR1Y2VFdmVudFN0b3JlKHN0YXRlLmV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXIpLCBkYXRlU2VsZWN0aW9uOiByZWR1Y2VEYXRlU2VsZWN0aW9uKHN0YXRlLmRhdGVTZWxlY3Rpb24sIGFjdGlvbiwgY2FsZW5kYXIpLCBldmVudFNlbGVjdGlvbjogcmVkdWNlU2VsZWN0ZWRFdmVudChzdGF0ZS5ldmVudFNlbGVjdGlvbiwgYWN0aW9uKSwgZXZlbnREcmFnOiByZWR1Y2VFdmVudERyYWcoc3RhdGUuZXZlbnREcmFnLCBhY3Rpb24sIGV2ZW50U291cmNlcywgY2FsZW5kYXIpLCBldmVudFJlc2l6ZTogcmVkdWNlRXZlbnRSZXNpemUoc3RhdGUuZXZlbnRSZXNpemUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBjYWxlbmRhciksIGV2ZW50U291cmNlTG9hZGluZ0xldmVsOiBjb21wdXRlTG9hZGluZ0xldmVsKGV2ZW50U291cmNlcyksIGxvYWRpbmdMZXZlbDogY29tcHV0ZUxvYWRpbmdMZXZlbChldmVudFNvdXJjZXMpIH0pO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjYWxlbmRhci5wbHVnaW5TeXN0ZW0uaG9va3MucmVkdWNlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZWR1Y2VyRnVuYyA9IF9hW19pXTtcclxuICAgICAgICAgICAgbmV4dFN0YXRlID0gcmVkdWNlckZ1bmMobmV4dFN0YXRlLCBhY3Rpb24sIGNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coYWN0aW9uLnR5cGUsIG5leHRTdGF0ZSlcclxuICAgICAgICByZXR1cm4gbmV4dFN0YXRlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVkdWNlVmlld1R5cGUoY3VycmVudFZpZXdUeXBlLCBhY3Rpb24pIHtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9WSUVXX1RZUEUnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi52aWV3VHlwZTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Vmlld1R5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVkdWNlRGF0ZVByb2ZpbGUoY3VycmVudERhdGVQcm9maWxlLCBhY3Rpb24sIGN1cnJlbnREYXRlLCB2aWV3VHlwZSwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgbmV3RGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdQUkVWJzpcclxuICAgICAgICAgICAgICAgIG5ld0RhdGVQcm9maWxlID0gY2FsZW5kYXIuZGF0ZVByb2ZpbGVHZW5lcmF0b3JzW3ZpZXdUeXBlXS5idWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnTkVYVCc6XHJcbiAgICAgICAgICAgICAgICBuZXdEYXRlUHJvZmlsZSA9IGNhbGVuZGFyLmRhdGVQcm9maWxlR2VuZXJhdG9yc1t2aWV3VHlwZV0uYnVpbGROZXh0KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9EQVRFJzpcclxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudERhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIXJhbmdlQ29udGFpbnNNYXJrZXIoY3VycmVudERhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgYWN0aW9uLmRhdGVNYXJrZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0ZVByb2ZpbGUgPSBjYWxlbmRhci5kYXRlUHJvZmlsZUdlbmVyYXRvcnNbdmlld1R5cGVdLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyLCB1bmRlZmluZWQsIHRydWUgLy8gZm9yY2VUb1ZhbGlkXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdTRVRfVklFV19UWVBFJzpcclxuICAgICAgICAgICAgICAgIHZhciBnZW5lcmF0b3IgPSBjYWxlbmRhci5kYXRlUHJvZmlsZUdlbmVyYXRvcnNbdmlld1R5cGVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFnZW5lcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iodmlld1R5cGUgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIEZ1bGxDYWxlbmRhciB2aWV3IFwiJyArIHZpZXdUeXBlICsgJ1wiIGRvZXMgbm90IGV4aXN0LiBNYWtlIHN1cmUgeW91ciBwbHVnaW5zIGFyZSBsb2FkZWQgY29ycmVjdGx5LicgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnTm8gYXZhaWxhYmxlIEZ1bGxDYWxlbmRhciB2aWV3IHBsdWdpbnMuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXdEYXRlUHJvZmlsZSA9IGdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlciB8fCBjdXJyZW50RGF0ZSwgdW5kZWZpbmVkLCB0cnVlIC8vIGZvcmNlVG9WYWxpZFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV3RGF0ZVByb2ZpbGUgJiZcclxuICAgICAgICAgICAgbmV3RGF0ZVByb2ZpbGUuaXNWYWxpZCAmJlxyXG4gICAgICAgICAgICAhKGN1cnJlbnREYXRlUHJvZmlsZSAmJiBpc0RhdGVQcm9maWxlc0VxdWFsKGN1cnJlbnREYXRlUHJvZmlsZSwgbmV3RGF0ZVByb2ZpbGUpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3RGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGVQcm9maWxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlLCBhY3Rpb24sIGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdQUkVWJzpcclxuICAgICAgICAgICAgY2FzZSAnTkVYVCc6XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBjdXJyZW50RGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlICdTRVRfREFURSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9WSUVXX1RZUEUnOlxyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0RhdGUgPSBhY3Rpb24uZGF0ZU1hcmtlciB8fCBjdXJyZW50RGF0ZTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgbmV3RGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0RhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVkdWNlRGF0ZVNlbGVjdGlvbihjdXJyZW50U2VsZWN0aW9uLCBhY3Rpb24sIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdTRUxFQ1RfREFURVMnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5zZWxlY3Rpb247XHJcbiAgICAgICAgICAgIGNhc2UgJ1VOU0VMRUNUX0RBVEVTJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVkdWNlU2VsZWN0ZWRFdmVudChjdXJyZW50SW5zdGFuY2VJZCwgYWN0aW9uKSB7XHJcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdTRUxFQ1RfRVZFTlQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudEluc3RhbmNlSWQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ1VOU0VMRUNUX0VWRU5UJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2VJZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWR1Y2VFdmVudERyYWcoY3VycmVudERyYWcsIGFjdGlvbiwgc291cmNlcywgY2FsZW5kYXIpIHtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcclxuICAgICAgICAgICAgICAgIHZhciBuZXdEcmFnID0gYWN0aW9uLnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3RHJhZy5hZmZlY3RlZEV2ZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdEcmFnLm11dGF0ZWRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogbmV3RHJhZy5pc0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdTZWc6IG5ld0RyYWcub3JpZ1NlZ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FzZSAnVU5TRVRfRVZFTlRfRFJBRyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RHJhZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWR1Y2VFdmVudFJlc2l6ZShjdXJyZW50UmVzaXplLCBhY3Rpb24sIHNvdXJjZXMsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcclxuICAgICAgICAgICAgICAgIHZhciBuZXdSZXNpemUgPSBhY3Rpb24uc3RhdGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdSZXNpemUuYWZmZWN0ZWRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3UmVzaXplLm11dGF0ZWRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogbmV3UmVzaXplLmlzRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1NlZzogbmV3UmVzaXplLm9yaWdTZWdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX1JFU0laRSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50UmVzaXplO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVMb2FkaW5nTGV2ZWwoZXZlbnRTb3VyY2VzKSB7XHJcbiAgICAgICAgdmFyIGNudCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgc291cmNlSWQgaW4gZXZlbnRTb3VyY2VzKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudFNvdXJjZXNbc291cmNlSWRdLmlzRmV0Y2hpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFNUQU5EQVJEX1BST1BTID0ge1xyXG4gICAgICAgIHN0YXJ0OiBudWxsLFxyXG4gICAgICAgIGVuZDogbnVsbCxcclxuICAgICAgICBhbGxEYXk6IEJvb2xlYW5cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBwYXJzZURhdGVTcGFuKHJhdywgZGF0ZUVudiwgZGVmYXVsdER1cmF0aW9uKSB7XHJcbiAgICAgICAgdmFyIHNwYW4gPSBwYXJzZU9wZW5EYXRlU3BhbihyYXcsIGRhdGVFbnYpO1xyXG4gICAgICAgIHZhciByYW5nZSA9IHNwYW4ucmFuZ2U7XHJcbiAgICAgICAgaWYgKCFyYW5nZS5zdGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyYW5nZS5lbmQpIHtcclxuICAgICAgICAgICAgaWYgKGRlZmF1bHREdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlLmVuZCA9IGRhdGVFbnYuYWRkKHJhbmdlLnN0YXJ0LCBkZWZhdWx0RHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzcGFuO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIFRPRE86IHNvbWVob3cgY29tYmluZSB3aXRoIHBhcnNlUmFuZ2U/XHJcbiAgICBXaWxsIHJldHVybiBudWxsIGlmIHRoZSBzdGFydC9lbmQgcHJvcHMgd2VyZSBwcmVzZW50IGJ1dCBwYXJzZWQgaW52YWxpZGx5LlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudikge1xyXG4gICAgICAgIHZhciBsZWZ0b3ZlcnMgPSB7fTtcclxuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHJlZmluZVByb3BzKHJhdywgU1RBTkRBUkRfUFJPUFMsIHt9LCBsZWZ0b3ZlcnMpO1xyXG4gICAgICAgIHZhciBzdGFydE1ldGEgPSBzdGFuZGFyZFByb3BzLnN0YXJ0ID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuc3RhcnQpIDogbnVsbDtcclxuICAgICAgICB2YXIgZW5kTWV0YSA9IHN0YW5kYXJkUHJvcHMuZW5kID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuZW5kKSA6IG51bGw7XHJcbiAgICAgICAgdmFyIGFsbERheSA9IHN0YW5kYXJkUHJvcHMuYWxsRGF5O1xyXG4gICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhbGxEYXkgPSAoc3RhcnRNZXRhICYmIHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcclxuICAgICAgICAgICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdXNlIHRoaXMgbGVmdG92ZXIgb2JqZWN0IGFzIHRoZSBzZWxlY3Rpb24gb2JqZWN0XHJcbiAgICAgICAgbGVmdG92ZXJzLnJhbmdlID0ge1xyXG4gICAgICAgICAgICBzdGFydDogc3RhcnRNZXRhID8gc3RhcnRNZXRhLm1hcmtlciA6IG51bGwsXHJcbiAgICAgICAgICAgIGVuZDogZW5kTWV0YSA/IGVuZE1ldGEubWFya2VyIDogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGVmdG92ZXJzLmFsbERheSA9IGFsbERheTtcclxuICAgICAgICByZXR1cm4gbGVmdG92ZXJzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNEYXRlU3BhbnNFcXVhbChzcGFuMCwgc3BhbjEpIHtcclxuICAgICAgICByZXR1cm4gcmFuZ2VzRXF1YWwoc3BhbjAucmFuZ2UsIHNwYW4xLnJhbmdlKSAmJlxyXG4gICAgICAgICAgICBzcGFuMC5hbGxEYXkgPT09IHNwYW4xLmFsbERheSAmJlxyXG4gICAgICAgICAgICBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSk7XHJcbiAgICB9XHJcbiAgICAvLyB0aGUgTk9OLURBVEUtUkVMQVRFRCBwcm9wc1xyXG4gICAgZnVuY3Rpb24gaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpIHtcclxuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBzcGFuMSkge1xyXG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgIT09ICdyYW5nZScgJiYgcHJvcE5hbWUgIT09ICdhbGxEYXknKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BhbjBbcHJvcE5hbWVdICE9PSBzcGFuMVtwcm9wTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXJlIHRoZXJlIGFueSBwcm9wcyB0aGF0IHNwYW4wIGhhcyB0aGF0IHNwYW4xIERPRVNOJ1QgaGF2ZT9cclxuICAgICAgICAvLyBib3RoIGhhdmUgcmFuZ2UvYWxsRGF5LCBzbyBubyBuZWVkIHRvIHNwZWNpYWwtY2FzZS5cclxuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBzcGFuMCkge1xyXG4gICAgICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiBzcGFuMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGkoc3BhbiwgZGF0ZUVudikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LnRvRGF0ZShzcGFuLnJhbmdlLnN0YXJ0KSxcclxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LnRvRGF0ZShzcGFuLnJhbmdlLmVuZCksXHJcbiAgICAgICAgICAgIHN0YXJ0U3RyOiBkYXRlRW52LmZvcm1hdElzbyhzcGFuLnJhbmdlLnN0YXJ0LCB7IG9taXRUaW1lOiBzcGFuLmFsbERheSB9KSxcclxuICAgICAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhzcGFuLnJhbmdlLmVuZCwgeyBvbWl0VGltZTogc3Bhbi5hbGxEYXkgfSksXHJcbiAgICAgICAgICAgIGFsbERheTogc3Bhbi5hbGxEYXlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGREYXRlUG9pbnRBcGkoc3BhbiwgZGF0ZUVudikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGU6IGRhdGVFbnYudG9EYXRlKHNwYW4ucmFuZ2Uuc3RhcnQpLFxyXG4gICAgICAgICAgICBkYXRlU3RyOiBkYXRlRW52LmZvcm1hdElzbyhzcGFuLnJhbmdlLnN0YXJ0LCB7IG9taXRUaW1lOiBzcGFuLmFsbERheSB9KSxcclxuICAgICAgICAgICAgYWxsRGF5OiBzcGFuLmFsbERheVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuLCBldmVudFVpQmFzZXMsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IHBhcnNlRXZlbnREZWYoeyBlZGl0YWJsZTogZmFsc2UgfSwgJycsIC8vIHNvdXJjZUlkXHJcbiAgICAgICAgZGF0ZVNwYW4uYWxsRGF5LCB0cnVlLCAvLyBoYXNFbmRcclxuICAgICAgICBjYWxlbmRhcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGVmOiBkZWYsXHJcbiAgICAgICAgICAgIHVpOiBjb21waWxlRXZlbnRVaShkZWYsIGV2ZW50VWlCYXNlcyksXHJcbiAgICAgICAgICAgIGluc3RhbmNlOiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgZGF0ZVNwYW4ucmFuZ2UpLFxyXG4gICAgICAgICAgICByYW5nZTogZGF0ZVNwYW4ucmFuZ2UsXHJcbiAgICAgICAgICAgIGlzU3RhcnQ6IHRydWUsXHJcbiAgICAgICAgICAgIGlzRW5kOiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xyXG4gICAgICAgIHZhciBoYXNoID0ge307XHJcbiAgICAgICAgdmFyIHZpZXdUeXBlO1xyXG4gICAgICAgIGZvciAodmlld1R5cGUgaW4gZGVmYXVsdENvbmZpZ3MpIHtcclxuICAgICAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XHJcbiAgICAgICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcclxuICAgICAgICBpZiAoaGFzaFt2aWV3VHlwZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XHJcbiAgICAgICAgaWYgKHZpZXdEZWYpIHtcclxuICAgICAgICAgICAgaGFzaFt2aWV3VHlwZV0gPSB2aWV3RGVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlld0RlZjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xyXG4gICAgICAgIHZhciBkZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZ3Nbdmlld1R5cGVdO1xyXG4gICAgICAgIHZhciBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV07XHJcbiAgICAgICAgdmFyIHF1ZXJ5UHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZGVmYXVsdENvbmZpZyAmJiBkZWZhdWx0Q29uZmlnW25hbWVdICE9PSBudWxsKSA/IGRlZmF1bHRDb25maWdbbmFtZV0gOlxyXG4gICAgICAgICAgICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRoZUNsYXNzID0gcXVlcnlQcm9wKCdjbGFzcycpO1xyXG4gICAgICAgIHZhciBzdXBlclR5cGUgPSBxdWVyeVByb3AoJ3N1cGVyVHlwZScpO1xyXG4gICAgICAgIGlmICghc3VwZXJUeXBlICYmIHRoZUNsYXNzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyVHlwZSA9XHJcbiAgICAgICAgICAgICAgICBmaW5kVmlld05hbWVCeVN1YmNsYXNzKHRoZUNsYXNzLCBvdmVycmlkZUNvbmZpZ3MpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZFZpZXdOYW1lQnlTdWJjbGFzcyh0aGVDbGFzcywgZGVmYXVsdENvbmZpZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3VwZXJEZWYgPSBudWxsO1xyXG4gICAgICAgIGlmIChzdXBlclR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKHN1cGVyVHlwZSA9PT0gdmlld1R5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBoYXZlIGEgY3VzdG9tIHZpZXcgdHlwZSB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VwZXJEZWYgPSBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhlQ2xhc3MgJiYgc3VwZXJEZWYpIHtcclxuICAgICAgICAgICAgdGhlQ2xhc3MgPSBzdXBlckRlZi5jbGFzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGVDbGFzcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdGhyb3cgYSB3YXJuaW5nLCBtaWdodCBiZSBzZXR0aW5ncyBmb3IgYSBzaW5nbGUtdW5pdCB2aWV3XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IHZpZXdUeXBlLFxyXG4gICAgICAgICAgICBjbGFzczogdGhlQ2xhc3MsXHJcbiAgICAgICAgICAgIGRlZmF1bHRzOiBfX2Fzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYuZGVmYXVsdHMgOiB7fSksIChkZWZhdWx0Q29uZmlnID8gZGVmYXVsdENvbmZpZy5vcHRpb25zIDoge30pKSxcclxuICAgICAgICAgICAgb3ZlcnJpZGVzOiBfX2Fzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYub3ZlcnJpZGVzIDoge30pLCAob3ZlcnJpZGVDb25maWcgPyBvdmVycmlkZUNvbmZpZy5vcHRpb25zIDoge30pKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaW5kVmlld05hbWVCeVN1YmNsYXNzKHZpZXdTdWJjbGFzcywgY29uZmlncykge1xyXG4gICAgICAgIHZhciBzdXBlclByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZpZXdTdWJjbGFzcy5wcm90b3R5cGUpO1xyXG4gICAgICAgIGZvciAodmFyIHZpZXdUeXBlIGluIGNvbmZpZ3MpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IGNvbmZpZ3Nbdmlld1R5cGVdO1xyXG4gICAgICAgICAgICAvLyBuZWVkIERJUkVDVCBzdWJjbGFzcywgc28gaW5zdGFuY2VvZiB3b24ndCBkbyBpdFxyXG4gICAgICAgICAgICBpZiAocGFyc2VkLmNsYXNzICYmIHBhcnNlZC5jbGFzcy5wcm90b3R5cGUgPT09IHN1cGVyUHJvdG8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlncyhpbnB1dHMpIHtcclxuICAgICAgICByZXR1cm4gbWFwSGFzaChpbnB1dHMsIHBhcnNlVmlld0NvbmZpZyk7XHJcbiAgICB9XHJcbiAgICB2YXIgVklFV19ERUZfUFJPUFMgPSB7XHJcbiAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgIGNsYXNzOiBudWxsXHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlnKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpbnB1dCA9IHsgY2xhc3M6IGlucHV0IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcHRpb25zID0ge307XHJcbiAgICAgICAgdmFyIHByb3BzID0gcmVmaW5lUHJvcHMoaW5wdXQsIFZJRVdfREVGX1BST1BTLCB7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3VwZXJUeXBlOiBwcm9wcy50eXBlLFxyXG4gICAgICAgICAgICBjbGFzczogcHJvcHMuY2xhc3MsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld1NwZWNzKGRlZmF1bHRJbnB1dHMsIG9wdGlvbnNNYW5hZ2VyKSB7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhkZWZhdWx0SW5wdXRzKTtcclxuICAgICAgICB2YXIgb3ZlcnJpZGVDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhvcHRpb25zTWFuYWdlci5vdmVycmlkZXMudmlld3MpO1xyXG4gICAgICAgIHZhciB2aWV3RGVmcyA9IGNvbXBpbGVWaWV3RGVmcyhkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcclxuICAgICAgICByZXR1cm4gbWFwSGFzaCh2aWV3RGVmcywgZnVuY3Rpb24gKHZpZXdEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25zTWFuYWdlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uc01hbmFnZXIpIHtcclxuICAgICAgICB2YXIgZHVyYXRpb25JbnB1dCA9IHZpZXdEZWYub3ZlcnJpZGVzLmR1cmF0aW9uIHx8XHJcbiAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuZHVyYXRpb24gfHxcclxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIuZHluYW1pY092ZXJyaWRlcy5kdXJhdGlvbiB8fFxyXG4gICAgICAgICAgICBvcHRpb25zTWFuYWdlci5vdmVycmlkZXMuZHVyYXRpb247XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gbnVsbDtcclxuICAgICAgICB2YXIgZHVyYXRpb25Vbml0ID0gJyc7XHJcbiAgICAgICAgdmFyIHNpbmdsZVVuaXQgPSAnJztcclxuICAgICAgICB2YXIgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IHt9O1xyXG4gICAgICAgIGlmIChkdXJhdGlvbklucHV0KSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24oZHVyYXRpb25JbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbikgeyAvLyB2YWxpZD9cclxuICAgICAgICAgICAgICAgIHZhciBkZW5vbSA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbiwgIWdldFdlZWtzRnJvbUlucHV0KGR1cmF0aW9uSW5wdXQpKTtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uVW5pdCA9IGRlbm9tLnVuaXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVub20udmFsdWUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVVbml0ID0gZHVyYXRpb25Vbml0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZVVuaXRPdmVycmlkZXMgPSBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XSA/IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdLm9wdGlvbnMgOiB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcXVlcnlCdXR0b25UZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvblRleHRNYXAgPSBvcHRpb25zLmJ1dHRvblRleHQgfHwge307XHJcbiAgICAgICAgICAgIHZhciBidXR0b25UZXh0S2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5O1xyXG4gICAgICAgICAgICBpZiAoYnV0dG9uVGV4dEtleSAhPSBudWxsICYmIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiB2aWV3RGVmLnR5cGUsXHJcbiAgICAgICAgICAgIGNsYXNzOiB2aWV3RGVmLmNsYXNzLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uVW5pdDogZHVyYXRpb25Vbml0LFxyXG4gICAgICAgICAgICBzaW5nbGVVbml0OiBzaW5nbGVVbml0LFxyXG4gICAgICAgICAgICBvcHRpb25zOiBfX2Fzc2lnbih7fSwgZ2xvYmFsRGVmYXVsdHMsIHZpZXdEZWYuZGVmYXVsdHMsIG9wdGlvbnNNYW5hZ2VyLmRpckRlZmF1bHRzLCBvcHRpb25zTWFuYWdlci5sb2NhbGVEZWZhdWx0cywgb3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzLCBzaW5nbGVVbml0T3ZlcnJpZGVzLCB2aWV3RGVmLm92ZXJyaWRlcywgb3B0aW9uc01hbmFnZXIuZHluYW1pY092ZXJyaWRlcyksXHJcbiAgICAgICAgICAgIGJ1dHRvblRleHRPdmVycmlkZTogcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNNYW5hZ2VyLmR5bmFtaWNPdmVycmlkZXMpIHx8XHJcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzKSB8fCAvLyBjb25zdHJ1Y3Rvci1zcGVjaWZpZWQgYnV0dG9uVGV4dCBsb29rdXAgaGFzaCB0YWtlcyBwcmVjZWRlbmNlXHJcbiAgICAgICAgICAgICAgICB2aWV3RGVmLm92ZXJyaWRlcy5idXR0b25UZXh0LFxyXG4gICAgICAgICAgICBidXR0b25UZXh0RGVmYXVsdDogcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNNYW5hZ2VyLmxvY2FsZURlZmF1bHRzKSB8fFxyXG4gICAgICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNNYW5hZ2VyLmRpckRlZmF1bHRzKSB8fFxyXG4gICAgICAgICAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0IHx8XHJcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQoZ2xvYmFsRGVmYXVsdHMpIHx8XHJcbiAgICAgICAgICAgICAgICB2aWV3RGVmLnR5cGUgLy8gZmFsbCBiYWNrIHRvIGdpdmVuIHZpZXcgbmFtZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFRvb2xiYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFRvb2xiYXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVG9vbGJhcihjb250ZXh0LCBleHRyYUNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVuZGVyTGF5b3V0ID0gbWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5yZW5kZXJMYXlvdXQsIF90aGlzLnVucmVuZGVyTGF5b3V0KTtcclxuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVRpdGxlID0gbWVtb2l6ZVJlbmRlcmluZyhfdGhpcy51cGRhdGVUaXRsZSwgbnVsbCwgW190aGlzLl9yZW5kZXJMYXlvdXRdKTtcclxuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZUFjdGl2ZUJ1dHRvbiA9IG1lbW9pemVSZW5kZXJpbmcoX3RoaXMudXBkYXRlQWN0aXZlQnV0dG9uLCBudWxsLCBbX3RoaXMuX3JlbmRlckxheW91dF0pO1xyXG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlVG9kYXkgPSBtZW1vaXplUmVuZGVyaW5nKF90aGlzLnVwZGF0ZVRvZGF5LCBudWxsLCBbX3RoaXMuX3JlbmRlckxheW91dF0pO1xyXG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlUHJldiA9IG1lbW9pemVSZW5kZXJpbmcoX3RoaXMudXBkYXRlUHJldiwgbnVsbCwgW190aGlzLl9yZW5kZXJMYXlvdXRdKTtcclxuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZU5leHQgPSBtZW1vaXplUmVuZGVyaW5nKF90aGlzLnVwZGF0ZU5leHQsIG51bGwsIFtfdGhpcy5fcmVuZGVyTGF5b3V0XSk7XHJcbiAgICAgICAgICAgIF90aGlzLmVsID0gY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdmYy10b29sYmFyICcgKyBleHRyYUNsYXNzTmFtZSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBUb29sYmFyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTGF5b3V0LnVucmVuZGVyKCk7IC8vIHNob3VsZCB1bnJlbmRlciBldmVyeXRoaW5nIGVsc2VcclxuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLmVsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJMYXlvdXQocHJvcHMubGF5b3V0KTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGl0bGUocHJvcHMudGl0bGUpO1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBY3RpdmVCdXR0b24ocHJvcHMuYWN0aXZlQnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVG9kYXkocHJvcHMuaXNUb2RheUVuYWJsZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQcmV2KHByb3BzLmlzUHJldkVuYWJsZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVOZXh0KHByb3BzLmlzTmV4dEVuYWJsZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVG9vbGJhci5wcm90b3R5cGUucmVuZGVyTGF5b3V0ID0gZnVuY3Rpb24gKGxheW91dCkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcclxuICAgICAgICAgICAgYXBwZW5kVG9FbGVtZW50KGVsLCB0aGlzLnJlbmRlclNlY3Rpb24oJ2xlZnQnLCBsYXlvdXQubGVmdCkpO1xyXG4gICAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQoZWwsIHRoaXMucmVuZGVyU2VjdGlvbignY2VudGVyJywgbGF5b3V0LmNlbnRlcikpO1xyXG4gICAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQoZWwsIHRoaXMucmVuZGVyU2VjdGlvbigncmlnaHQnLCBsYXlvdXQucmlnaHQpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRvb2xiYXIucHJvdG90eXBlLnVucmVuZGVyTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVG9vbGJhci5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgYnV0dG9uU3RyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHRoZW1lID0gX2EudGhlbWUsIGNhbGVuZGFyID0gX2EuY2FsZW5kYXI7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zTWFuYWdlciA9IGNhbGVuZGFyLm9wdGlvbnNNYW5hZ2VyO1xyXG4gICAgICAgICAgICB2YXIgdmlld1NwZWNzID0gY2FsZW5kYXIudmlld1NwZWNzO1xyXG4gICAgICAgICAgICB2YXIgc2VjdGlvbkVsID0gY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdmYy0nICsgcG9zaXRpb24gfSk7XHJcbiAgICAgICAgICAgIHZhciBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBvcHRpb25zTWFuYWdlci5jb21wdXRlZC5jdXN0b21CdXR0b25zIHx8IHt9O1xyXG4gICAgICAgICAgICB2YXIgY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzID0gb3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzLmJ1dHRvblRleHQgfHwge307XHJcbiAgICAgICAgICAgIHZhciBjYWxlbmRhckJ1dHRvblRleHQgPSBvcHRpb25zTWFuYWdlci5jb21wdXRlZC5idXR0b25UZXh0IHx8IHt9O1xyXG4gICAgICAgICAgICBpZiAoYnV0dG9uU3RyKSB7XHJcbiAgICAgICAgICAgICAgICBidXR0b25TdHIuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b25Hcm91cFN0ciwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cENoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzT25seUJ1dHRvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cEVsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAoYnV0dG9uTmFtZSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VzdG9tQnV0dG9uUHJvcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3U3BlYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkNsaWNrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uSWNvbjsgLy8gb25seSBvbmUgb2YgdGhlc2Ugd2lsbCBiZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvblRleHQ7IC8vIFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25Jbm5lckh0bWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25DbGFzc2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uRWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25BcmlhQXR0cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW4ucHVzaChodG1sVG9FbGVtZW50KCc8aDI+Jm5ic3A7PC9oMj4nKSk7IC8vIHdlIGFsd2F5cyB3YW50IGl0IHRvIHRha2UgdXAgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc09ubHlCdXR0b25zID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGN1c3RvbUJ1dHRvblByb3BzID0gY2FsZW5kYXJDdXN0b21CdXR0b25zW2J1dHRvbk5hbWVdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXN0b21CdXR0b25Qcm9wcy5jbGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChidXR0b25FbCwgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGN1c3RvbUJ1dHRvblByb3BzLnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHZpZXdTcGVjID0gdmlld1NwZWNzW2J1dHRvbk5hbWVdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXIuY2hhbmdlVmlldyhidXR0b25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjYWxlbmRhcltidXR0b25OYW1lXSkgeyAvLyBhIGNhbGVuZGFyIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhcltidXR0b25OYW1lXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXNbYnV0dG9uTmFtZV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICBeIGV2ZXJ5dGhpbmcgZWxzZSBpcyBjb25zaWRlcmVkIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25DbGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsYXNzZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnV0dG9uVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25Jbm5lckh0bWwgPSBodG1sRXNjYXBlKGJ1dHRvblRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25BcmlhQXR0ciA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChidXR0b25JY29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbklubmVySHRtbCA9IFwiPHNwYW4gY2xhc3M9J1wiICsgYnV0dG9uSWNvbiArIFwiJz48L3NwYW4+XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkFyaWFBdHRyID0gJyBhcmlhLWxhYmVsPVwiJyArIGJ1dHRvbk5hbWUgKyAnXCInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbCA9IGh0bWxUb0VsZW1lbnQoLy8gdHlwZT1cImJ1dHRvblwiIHNvIHRoYXQgaXQgZG9lc24ndCBzdWJtaXQgYSBmb3JtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJyArIGJ1dHRvbkNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkFyaWFBdHRyICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJz4nICsgYnV0dG9uSW5uZXJIdG1sICsgJzwvYnV0dG9uPicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYnV0dG9uQ2xpY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW4ucHVzaChidXR0b25FbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBDaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkdyb3VwQ2xhc3NOYW1lID0gdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkdyb3VwJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09ubHlCdXR0b25zICYmIGJ1dHRvbkdyb3VwQ2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEVsLmNsYXNzTGlzdC5hZGQoYnV0dG9uR3JvdXBDbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZFRvRWxlbWVudChncm91cEVsLCBncm91cENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbkVsLmFwcGVuZENoaWxkKGdyb3VwRWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kVG9FbGVtZW50KHNlY3Rpb25FbCwgZ3JvdXBDaGlsZHJlbik7IC8vIDEgb3IgMCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uRWw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUb29sYmFyLnByb3RvdHlwZS51cGRhdGVUb2RheSA9IGZ1bmN0aW9uIChpc1RvZGF5RW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUJ1dHRvbkVuYWJsZWQoJ3RvZGF5JywgaXNUb2RheUVuYWJsZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVG9vbGJhci5wcm90b3R5cGUudXBkYXRlUHJldiA9IGZ1bmN0aW9uIChpc1ByZXZFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQnV0dG9uRW5hYmxlZCgncHJldicsIGlzUHJldkVuYWJsZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVG9vbGJhci5wcm90b3R5cGUudXBkYXRlTmV4dCA9IGZ1bmN0aW9uIChpc05leHRFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQnV0dG9uRW5hYmxlZCgnbmV4dCcsIGlzTmV4dEVuYWJsZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVG9vbGJhci5wcm90b3R5cGUudXBkYXRlVGl0bGUgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgICAgICBmaW5kRWxlbWVudHModGhpcy5lbCwgJ2gyJykuZm9yRWFjaChmdW5jdGlvbiAodGl0bGVFbCkge1xyXG4gICAgICAgICAgICAgICAgdGl0bGVFbC5pbm5lclRleHQgPSB0ZXh0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRvb2xiYXIucHJvdG90eXBlLnVwZGF0ZUFjdGl2ZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnRoZW1lLmdldENsYXNzKCdidXR0b25BY3RpdmUnKTtcclxuICAgICAgICAgICAgZmluZEVsZW1lbnRzKHRoaXMuZWwsICdidXR0b24nKS5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b25FbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgJiYgYnV0dG9uRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25FbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25FbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVG9vbGJhci5wcm90b3R5cGUudG9nZ2xlQnV0dG9uRW5hYmxlZCA9IGZ1bmN0aW9uIChidXR0b25OYW1lLCBib29sKSB7XHJcbiAgICAgICAgICAgIGZpbmRFbGVtZW50cyh0aGlzLmVsLCAnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKS5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b25FbCkge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uRWwuZGlzYWJsZWQgPSAhYm9vbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVG9vbGJhcjtcclxuICAgIH0oQ29tcG9uZW50KSk7XHJcblxyXG4gICAgdmFyIENhbGVuZGFyQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhDYWxlbmRhckNvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBDYWxlbmRhckNvbXBvbmVudChjb250ZXh0LCBlbCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVuZGVyVG9vbGJhcnMgPSBtZW1vaXplUmVuZGVyaW5nKF90aGlzLnJlbmRlclRvb2xiYXJzKTtcclxuICAgICAgICAgICAgX3RoaXMuYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyA9IG1lbW9pemUoYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyk7XHJcbiAgICAgICAgICAgIF90aGlzLmVsID0gZWw7XHJcbiAgICAgICAgICAgIHByZXBlbmRUb0VsZW1lbnQoZWwsIF90aGlzLmNvbnRlbnRFbCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdmlldy1jb250YWluZXInIH0pKTtcclxuICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gX3RoaXMuY2FsZW5kYXI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjYWxlbmRhci5wbHVnaW5TeXN0ZW0uaG9va3Mudmlld0NvbnRhaW5lck1vZGlmaWVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RpZnlWaWV3Q29udGFpbmVyID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZ5Vmlld0NvbnRhaW5lcihfdGhpcy5jb250ZW50RWwsIGNhbGVuZGFyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy50b2dnbGVFbENsYXNzTmFtZXModHJ1ZSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbXB1dGVUaXRsZSA9IG1lbW9pemUoY29tcHV0ZVRpdGxlKTtcclxuICAgICAgICAgICAgX3RoaXMucGFyc2VCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZShmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUJ1c2luZXNzSG91cnMoaW5wdXQsIF90aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvb3Rlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb290ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLmNvbnRlbnRFbCk7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRWxDbGFzc05hbWVzKGZhbHNlKTtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUudG9nZ2xlRWxDbGFzc05hbWVzID0gZnVuY3Rpb24gKGJvb2wpIHtcclxuICAgICAgICAgICAgdmFyIGNsYXNzTGlzdCA9IHRoaXMuZWwuY2xhc3NMaXN0O1xyXG4gICAgICAgICAgICB2YXIgZGlyQ2xhc3NOYW1lID0gJ2ZjLScgKyB0aGlzLm9wdCgnZGlyJyk7XHJcbiAgICAgICAgICAgIHZhciB0aGVtZUNsYXNzTmFtZSA9IHRoaXMudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldCcpO1xyXG4gICAgICAgICAgICBpZiAoYm9vbCkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LmFkZCgnZmMnKTtcclxuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoZGlyQ2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQodGhlbWVDbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgnZmMnKTtcclxuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoZGlyQ2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUodGhlbWVDbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZXplSGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IHRoaXMuY29tcHV0ZVRpdGxlKHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy52aWV3U3BlYy5vcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVG9vbGJhcnMocHJvcHMudmlld1NwZWMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5jdXJyZW50RGF0ZSwgcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHRpdGxlKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KHByb3BzLCB0aXRsZSk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnRoYXdIZWlnaHQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJUb29sYmFycyA9IGZ1bmN0aW9uICh2aWV3U3BlYywgZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgdGl0bGUpIHtcclxuICAgICAgICAgICAgdmFyIGhlYWRlckxheW91dCA9IHRoaXMub3B0KCdoZWFkZXInKTtcclxuICAgICAgICAgICAgdmFyIGZvb3RlckxheW91dCA9IHRoaXMub3B0KCdmb290ZXInKTtcclxuICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMuY2FsZW5kYXIuZ2V0Tm93KCk7XHJcbiAgICAgICAgICAgIHZhciB0b2RheUluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChub3cpO1xyXG4gICAgICAgICAgICB2YXIgcHJldkluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcclxuICAgICAgICAgICAgdmFyIG5leHRJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XHJcbiAgICAgICAgICAgIHZhciB0b29sYmFyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVCdXR0b246IHZpZXdTcGVjLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBpc1RvZGF5RW5hYmxlZDogdG9kYXlJbmZvLmlzVmFsaWQgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBub3cpLFxyXG4gICAgICAgICAgICAgICAgaXNQcmV2RW5hYmxlZDogcHJldkluZm8uaXNWYWxpZCxcclxuICAgICAgICAgICAgICAgIGlzTmV4dEVuYWJsZWQ6IG5leHRJbmZvLmlzVmFsaWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGhlYWRlckxheW91dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyID0gbmV3IFRvb2xiYXIodGhpcy5jb250ZXh0LCAnZmMtaGVhZGVyLXRvb2xiYXInKTtcclxuICAgICAgICAgICAgICAgICAgICBwcmVwZW5kVG9FbGVtZW50KHRoaXMuZWwsIHRoaXMuaGVhZGVyLmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyLnJlY2VpdmVQcm9wcyhfX2Fzc2lnbih7IGxheW91dDogaGVhZGVyTGF5b3V0IH0sIHRvb2xiYXJQcm9wcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZvb3RlckxheW91dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZvb3Rlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9vdGVyID0gbmV3IFRvb2xiYXIodGhpcy5jb250ZXh0LCAnZmMtZm9vdGVyLXRvb2xiYXInKTtcclxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQodGhpcy5lbCwgdGhpcy5mb290ZXIuZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5mb290ZXIucmVjZWl2ZVByb3BzKF9fYXNzaWduKHsgbGF5b3V0OiBmb290ZXJMYXlvdXQgfSwgdG9vbGJhclByb3BzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5mb290ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9vdGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9vdGVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclZpZXcgPSBmdW5jdGlvbiAocHJvcHMsIHRpdGxlKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICB2YXIgdmlld1NwZWMgPSBwcm9wcy52aWV3U3BlYywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxuICAgICAgICAgICAgaWYgKCF2aWV3IHx8IHZpZXcudmlld1NwZWMgIT09IHZpZXdTcGVjKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmlldyA9IHRoaXMudmlldyA9IG5ldyB2aWV3U3BlY1snY2xhc3MnXSh7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXI6IHRoaXMuY2FsZW5kYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldzogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlRW52OiB0aGlzLmRhdGVFbnYsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogdmlld1NwZWMub3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgfSwgdmlld1NwZWMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCB0aGlzLmNvbnRlbnRFbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3LmFkZFNjcm9sbCh2aWV3LnF1ZXJ5U2Nyb2xsKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZpZXcudGl0bGUgPSB0aXRsZTsgLy8gZm9yIHRoZSBBUElcclxuICAgICAgICAgICAgdmFyIHZpZXdQcm9wcyA9IHtcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcclxuICAgICAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VCdXNpbmVzc0hvdXJzKHZpZXdTcGVjLm9wdGlvbnMuYnVzaW5lc3NIb3VycyksXHJcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBwcm9wcy5ldmVudFN0b3JlLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBwcm9wcy5ldmVudFVpQmFzZXMsXHJcbiAgICAgICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsXHJcbiAgICAgICAgICAgICAgICBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVycyA9IHRoaXMuYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyh0aGlzLmNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHRyYW5zZm9ybWVyc18xID0gdHJhbnNmb3JtZXJzOyBfaSA8IHRyYW5zZm9ybWVyc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXJzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgX19hc3NpZ24odmlld1Byb3BzLCB0cmFuc2Zvcm1lci50cmFuc2Zvcm0odmlld1Byb3BzLCB2aWV3U3BlYywgcHJvcHMsIHZpZXcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2aWV3LnJlY2VpdmVQcm9wcyh2aWV3UHJvcHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gU2l6aW5nXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uIChpc1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNpemUgPT09IHZvaWQgMCkgeyBpc1Jlc2l6ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcuYWRkU2Nyb2xsKHZpZXcucXVlcnlTY3JvbGwoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzUmVzaXplIHx8IHRoaXMuaXNIZWlnaHRBdXRvID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUhlaWdodFZhcnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVNpemUoaXNSZXNpemUsIHRoaXMudmlld0hlaWdodCwgdGhpcy5pc0hlaWdodEF1dG8pO1xyXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZU5vd0luZGljYXRvcigpOyAvLyB3ZSBuZWVkIHRvIGd1YXJhbnRlZSB0aGlzIHdpbGwgcnVuIGFmdGVyIHVwZGF0ZVNpemVcclxuICAgICAgICAgICAgdmlldy5wb3BTY3JvbGwoaXNSZXNpemUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLmNvbXB1dGVIZWlnaHRWYXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyOyAvLyB5dWNrLiBuZWVkIHRvIGhhbmRsZSBkeW5hbWljIG9wdGlvbnNcclxuICAgICAgICAgICAgdmFyIGhlaWdodElucHV0ID0gY2FsZW5kYXIub3B0KCdoZWlnaHQnKTtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRIZWlnaHRJbnB1dCA9IGNhbGVuZGFyLm9wdCgnY29udGVudEhlaWdodCcpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSGVpZ2h0QXV0byA9IGhlaWdodElucHV0ID09PSAnYXV0bycgfHwgY29udGVudEhlaWdodElucHV0ID09PSAnYXV0byc7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudEhlaWdodElucHV0ID09PSAnbnVtYmVyJykgeyAvLyBleGlzdHMgYW5kIG5vdCAnYXV0bydcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld0hlaWdodCA9IGNvbnRlbnRIZWlnaHRJbnB1dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29udGVudEhlaWdodElucHV0ID09PSAnZnVuY3Rpb24nKSB7IC8vIGV4aXN0cyBhbmQgaXMgYSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3SGVpZ2h0ID0gY29udGVudEhlaWdodElucHV0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGhlaWdodElucHV0ID09PSAnbnVtYmVyJykgeyAvLyBleGlzdHMgYW5kIG5vdCAnYXV0bydcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld0hlaWdodCA9IGhlaWdodElucHV0IC0gdGhpcy5xdWVyeVRvb2xiYXJzSGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGhlaWdodElucHV0ID09PSAnZnVuY3Rpb24nKSB7IC8vIGV4aXN0cyBhbmQgaXMgYSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3SGVpZ2h0ID0gaGVpZ2h0SW5wdXQoKSAtIHRoaXMucXVlcnlUb29sYmFyc0hlaWdodCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhlaWdodElucHV0ID09PSAncGFyZW50JykgeyAvLyBzZXQgdG8gaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50RWwgPSB0aGlzLmVsLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdIZWlnaHQgPSBwYXJlbnRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgLSB0aGlzLnF1ZXJ5VG9vbGJhcnNIZWlnaHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld0hlaWdodCA9IE1hdGgucm91bmQodGhpcy5jb250ZW50RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggL1xyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGNhbGVuZGFyLm9wdCgnYXNwZWN0UmF0aW8nKSwgLjUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLnF1ZXJ5VG9vbGJhcnNIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCArPSBjb21wdXRlSGVpZ2h0QW5kTWFyZ2lucyh0aGlzLmhlYWRlci5lbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZm9vdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgKz0gY29tcHV0ZUhlaWdodEFuZE1hcmdpbnModGhpcy5mb290ZXIuZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBIZWlnaHQgXCJGcmVlemluZ1wiXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUuZnJlZXplSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBhcHBseVN0eWxlKHRoaXMuZWwsIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUudGhhd0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgYXBwbHlTdHlsZSh0aGlzLmVsLCB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcnLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICcnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENhbGVuZGFyQ29tcG9uZW50O1xyXG4gICAgfShDb21wb25lbnQpKTtcclxuICAgIC8vIFRpdGxlIGFuZCBEYXRlIEZvcm1hdHRpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBDb21wdXRlcyB3aGF0IHRoZSB0aXRsZSBhdCB0aGUgdG9wIG9mIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgZm9yIHRoaXMgdmlld1xyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVRpdGxlKGRhdGVQcm9maWxlLCB2aWV3T3B0aW9ucykge1xyXG4gICAgICAgIHZhciByYW5nZTtcclxuICAgICAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxyXG4gICAgICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcclxuICAgICAgICAgICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgeyAvLyBmb3IgZGF5IHVuaXRzIG9yIHNtYWxsZXIsIHVzZSB0aGUgYWN0dWFsIGRheSByYW5nZVxyXG4gICAgICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LmZvcm1hdFJhbmdlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGNyZWF0ZUZvcm1hdHRlcih2aWV3T3B0aW9ucy50aXRsZUZvcm1hdCB8fCBjb21wdXRlVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpLCB2aWV3T3B0aW9ucy50aXRsZVJhbmdlU2VwYXJhdG9yKSwgeyBpc0VuZEV4Y2x1c2l2ZTogZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSB9KTtcclxuICAgIH1cclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgZm9ybWF0IHN0cmluZyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aXRsZSBmb3IgdGhlIGN1cnJlbnQgZGF0ZSByYW5nZS5cclxuICAgIC8vIEF0dGVtcHRzIHRvIGNvbXB1dGUgdGhlIG1vc3QgYXBwcm9wcmlhdGUgZm9ybWF0IGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCB3aXRoIGB0aXRsZUZvcm1hdGAuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgY3VycmVudFJhbmdlVW5pdCA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQ7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICd5ZWFyJykge1xyXG4gICAgICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ21vbnRoJykge1xyXG4gICAgICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycgfTsgLy8gbGlrZSBcIlNlcHRlbWJlciAyMDE0XCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBkYXlzID0gZGlmZldob2xlRGF5cyhkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQsIGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICBpZiAoZGF5cyAhPT0gbnVsbCAmJiBkYXlzID4gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbXVsdGktZGF5IHJhbmdlLiBzaG9ydGVyLCBsaWtlIFwiU2VwIDkgLSAxMCAyMDE0XCJcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdzaG9ydCcsIGRheTogJ251bWVyaWMnIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFBsdWdpblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnModGhlQ2xhc3Nlcykge1xyXG4gICAgICAgIHJldHVybiB0aGVDbGFzc2VzLm1hcChmdW5jdGlvbiAodGhlQ2xhc3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGVDbGFzcygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBJbnRlcmFjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBJbnRlcmFjdGlvbihzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IHNldHRpbmdzLmNvbXBvbmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gSW50ZXJhY3Rpb247XHJcbiAgICB9KCkpO1xyXG4gICAgZnVuY3Rpb24gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcclxuICAgICAgICAgICAgZWw6IGlucHV0LmVsLFxyXG4gICAgICAgICAgICB1c2VFdmVudENlbnRlcjogaW5wdXQudXNlRXZlbnRDZW50ZXIgIT0gbnVsbCA/IGlucHV0LnVzZUV2ZW50Q2VudGVyIDogdHJ1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gX2EgPSB7fSxcclxuICAgICAgICAgICAgX2Fbc2V0dGluZ3MuY29tcG9uZW50LnVpZF0gPSBzZXR0aW5ncyxcclxuICAgICAgICAgICAgX2E7XHJcbiAgICB9XHJcbiAgICAvLyBnbG9iYWwgc3RhdGVcclxuICAgIHZhciBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgPSB7fTtcclxuXHJcbiAgICAvKlxyXG4gICAgRGV0ZWN0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBldmVudCB3aXRoaW4gYSBEYXRlQ29tcG9uZW50XHJcbiAgICAqL1xyXG4gICAgdmFyIEV2ZW50Q2xpY2tpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEV2ZW50Q2xpY2tpbmcsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRDbGlja2luZyhzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlU2VnQ2xpY2sgPSBmdW5jdGlvbiAoZXYsIHNlZ0VsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IGdldEVsU2VnKHNlZ0VsKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWcgJiYgLy8gbWlnaHQgYmUgdGhlIDxkaXY+IHN1cnJvdW5kaW5nIHRoZSBtb3JlIGxpbmtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3VyIHdheSB0byBzaW11bGF0ZSBhIGxpbmsgY2xpY2sgZm9yIGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgPGE+IHRhZ3NcclxuICAgICAgICAgICAgICAgICAgICAvLyBncmFiIGJlZm9yZSB0cmlnZ2VyIGZpcmVkIGluIGNhc2UgdHJpZ2dlciB0cmFzaGVzIERPTSB0aHJ1IHJlcmVuZGVyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1VybENvbnRhaW5lciA9IGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCwgJy5mYy1oYXMtdXJsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGhhc1VybENvbnRhaW5lciA/IGhhc1VybENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhW2hyZWZdJykuaHJlZiA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50Q2xpY2snLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29tcG9uZW50LmNhbGVuZGFyLCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogY29tcG9uZW50LnZpZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmwgJiYgIWV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBfdGhpcy5kZXN0cm95ID0gbGlzdGVuQnlTZWxlY3Rvcihjb21wb25lbnQuZWwsICdjbGljaycsIGNvbXBvbmVudC5mZ1NlZ1NlbGVjdG9yICsgJywnICsgY29tcG9uZW50LmJnU2VnU2VsZWN0b3IsIF90aGlzLmhhbmRsZVNlZ0NsaWNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRXZlbnRDbGlja2luZztcclxuICAgIH0oSW50ZXJhY3Rpb24pKTtcclxuXHJcbiAgICAvKlxyXG4gICAgVHJpZ2dlcnMgZXZlbnRzIGFuZCBhZGRzL3JlbW92ZXMgY29yZSBjbGFzc05hbWVzIHdoZW4gdGhlIHVzZXIncyBwb2ludGVyXHJcbiAgICBlbnRlcnMvbGVhdmVzIGV2ZW50LWVsZW1lbnRzIG9mIGEgY29tcG9uZW50LlxyXG4gICAgKi9cclxuICAgIHZhciBFdmVudEhvdmVyaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhFdmVudEhvdmVyaW5nLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50SG92ZXJpbmcoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZ3MpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIC8vIGZvciBzaW11bGF0aW5nIGFuIGV2ZW50TW91c2VMZWF2ZSB3aGVuIHRoZSBldmVudCBlbCBpcyBkZXN0cm95ZWQgd2hpbGUgbW91c2UgaXMgb3ZlciBpdFxyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVFdmVudEVsUmVtb3ZlID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwgPT09IF90aGlzLmN1cnJlbnRTZWdFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVNlZ0xlYXZlKG51bGwsIF90aGlzLmN1cnJlbnRTZWdFbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVNlZ0VudGVyID0gZnVuY3Rpb24gKGV2LCBzZWdFbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdldEVsU2VnKHNlZ0VsKSkgeyAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIG1ha2Ugc3VyZSBub3QgaG92ZXJpbmcgb3ZlciBtb3JlKyBsaW5rIG9yIGl0cyB3cmFwcGVyXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnRWwuY2xhc3NMaXN0LmFkZCgnZmMtYWxsb3ctbW91c2UtcmVzaXplJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFNlZ0VsID0gc2VnRWw7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckV2ZW50KCdldmVudE1vdXNlRW50ZXInLCBldiwgc2VnRWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVTZWdMZWF2ZSA9IGZ1bmN0aW9uIChldiwgc2VnRWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50U2VnRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWdFbC5jbGFzc0xpc3QucmVtb3ZlKCdmYy1hbGxvdy1tb3VzZS1yZXNpemUnKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50U2VnRWwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudCgnZXZlbnRNb3VzZUxlYXZlJywgZXYsIHNlZ0VsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHNldHRpbmdzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgX3RoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3Rvcihjb21wb25lbnQuZWwsIGNvbXBvbmVudC5mZ1NlZ1NlbGVjdG9yICsgJywnICsgY29tcG9uZW50LmJnU2VnU2VsZWN0b3IsIF90aGlzLmhhbmRsZVNlZ0VudGVyLCBfdGhpcy5oYW5kbGVTZWdMZWF2ZSk7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC5jYWxlbmRhci5vbignZXZlbnRFbFJlbW92ZScsIF90aGlzLmhhbmRsZUV2ZW50RWxSZW1vdmUpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEV2ZW50SG92ZXJpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuY2FsZW5kYXIub2ZmKCdldmVudEVsUmVtb3ZlJywgdGhpcy5oYW5kbGVFdmVudEVsUmVtb3ZlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEV2ZW50SG92ZXJpbmcucHJvdG90eXBlLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIChwdWJsaWNFdk5hbWUsIGV2LCBzZWdFbCkge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIHZhciBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XHJcbiAgICAgICAgICAgIGlmICghZXYgfHwgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcihwdWJsaWNFdk5hbWUsIFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaSh0aGlzLmNvbXBvbmVudC5jYWxlbmRhciwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb21wb25lbnQudmlld1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRXZlbnRIb3ZlcmluZztcclxuICAgIH0oSW50ZXJhY3Rpb24pKTtcclxuXHJcbiAgICB2YXIgU3RhbmRhcmRUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU3RhbmRhcmRUaGVtZSwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTdGFuZGFyZFRoZW1lKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTdGFuZGFyZFRoZW1lO1xyXG4gICAgfShUaGVtZSkpO1xyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcclxuICAgICAgICB3aWRnZXQ6ICdmYy11bnRoZW1lZCcsXHJcbiAgICAgICAgd2lkZ2V0SGVhZGVyOiAnZmMtd2lkZ2V0LWhlYWRlcicsXHJcbiAgICAgICAgd2lkZ2V0Q29udGVudDogJ2ZjLXdpZGdldC1jb250ZW50JyxcclxuICAgICAgICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXHJcbiAgICAgICAgYnV0dG9uOiAnZmMtYnV0dG9uIGZjLWJ1dHRvbi1wcmltYXJ5JyxcclxuICAgICAgICBidXR0b25BY3RpdmU6ICdmYy1idXR0b24tYWN0aXZlJyxcclxuICAgICAgICBwb3BvdmVySGVhZGVyOiAnZmMtd2lkZ2V0LWhlYWRlcicsXHJcbiAgICAgICAgcG9wb3ZlckNvbnRlbnQ6ICdmYy13aWRnZXQtY29udGVudCcsXHJcbiAgICAgICAgLy8gZGF5IGdyaWRcclxuICAgICAgICBoZWFkZXJSb3c6ICdmYy13aWRnZXQtaGVhZGVyJyxcclxuICAgICAgICBkYXlSb3c6ICdmYy13aWRnZXQtY29udGVudCcsXHJcbiAgICAgICAgLy8gbGlzdCB2aWV3XHJcbiAgICAgICAgbGlzdFZpZXc6ICdmYy13aWRnZXQtY29udGVudCdcclxuICAgIH07XHJcbiAgICBTdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nO1xyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XHJcbiAgICAgICAgY2xvc2U6ICdmYy1pY29uLXgnLFxyXG4gICAgICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXHJcbiAgICAgICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXHJcbiAgICAgICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxyXG4gICAgICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1yaWdodCdcclxuICAgIH07XHJcbiAgICBTdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYnV0dG9uSWNvbnMnO1xyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2ljb24nO1xyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJztcclxuXHJcbiAgICB2YXIgQ2FsZW5kYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ2FsZW5kYXIoZWwsIG92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLnBhcnNlUmF3TG9jYWxlcyA9IG1lbW9pemUocGFyc2VSYXdMb2NhbGVzKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZExvY2FsZSA9IG1lbW9pemUoYnVpbGRMb2NhbGUpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRGF0ZUVudiA9IG1lbW9pemUoYnVpbGREYXRlRW52KTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFRoZW1lID0gbWVtb2l6ZShidWlsZFRoZW1lKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlTaW5nbGVCYXNlID0gbWVtb2l6ZSh0aGlzLl9idWlsZEV2ZW50VWlTaW5nbGVCYXNlKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFNlbGVjdGlvbkNvbmZpZyA9IG1lbW9pemUodGhpcy5fYnVpbGRTZWxlY3Rpb25Db25maWcpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlID0gbWVtb2l6ZU91dHB1dChidWlsZEV2ZW50VWlCeVNvdXJjZSwgaXNQcm9wc0VxdWFsKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCYXNlcyA9IG1lbW9pemUoYnVpbGRFdmVudFVpQmFzZXMpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uc1N0b3JlID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5pc1JlZHVjaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIGlzRGlzcGxheWluZzogYm9vbGVhbiA9IGZhbHNlIC8vIGluc3RhbGxlZCBpbiBET00/IGFjY2VwdGluZyByZW5kZXJzP1xyXG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVyZW5kZXIgPSBmYWxzZTsgLy8gbmVlZHMgYSByZW5kZXI/XHJcbiAgICAgICAgICAgIHRoaXMubmVlZHNGdWxsUmVyZW5kZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhbHNlOyAvLyBjdXJyZW50bHkgaW4gdGhlIGV4ZWN1dGVSZW5kZXIgZnVuY3Rpb24/XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyaW5nUGF1c2VEZXB0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGREZWxheWVkUmVyZW5kZXIgPSBtZW1vaXplKGJ1aWxkRGVsYXllZFJlcmVuZGVyKTtcclxuICAgICAgICAgICAgdGhpcy5hZnRlclNpemluZ1RyaWdnZXJzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuaXNWaWV3VXBkYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmlzRGF0ZXNVcGRhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNFdmVudHNVcGRhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlciA9IG5ldyBPcHRpb25zTWFuYWdlcihvdmVycmlkZXMgfHwge30pO1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpblN5c3RlbSA9IG5ldyBQbHVnaW5TeXN0ZW0oKTtcclxuICAgICAgICAgICAgLy8gb25seSBkbyBvbmNlLiBkb24ndCBkbyBpbiBoYW5kbGVPcHRpb25zLiBiZWNhdXNlIGNhbid0IHJlbW92ZSBwbHVnaW5zXHJcbiAgICAgICAgICAgIHRoaXMuYWRkUGx1Z2luSW5wdXRzKHRoaXMub3B0aW9uc01hbmFnZXIuY29tcHV0ZWQucGx1Z2lucyB8fCBbXSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlT3B0aW9ucyh0aGlzLm9wdGlvbnNNYW5hZ2VyLmNvbXB1dGVkKTtcclxuICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ19pbml0Jyk7IC8vIGZvciB0ZXN0c1xyXG4gICAgICAgICAgICB0aGlzLmh5ZHJhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhckludGVyYWN0aW9ucyA9IHRoaXMucGx1Z2luU3lzdGVtLmhvb2tzLmNhbGVuZGFySW50ZXJhY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjYWxlbmRhckludGVyYWN0aW9uQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKF90aGlzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5hZGRQbHVnaW5JbnB1dHMgPSBmdW5jdGlvbiAocGx1Z2luSW5wdXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBwbHVnaW5EZWZzID0gcmVmaW5lUGx1Z2luRGVmcyhwbHVnaW5JbnB1dHMpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBsdWdpbkRlZnNfMSA9IHBsdWdpbkRlZnM7IF9pIDwgcGx1Z2luRGVmc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBsdWdpbkRlZiA9IHBsdWdpbkRlZnNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpblN5c3RlbS5hZGQocGx1Z2luRGVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhbGVuZGFyLnByb3RvdHlwZSwgXCJ2aWV3XCIsIHtcclxuICAgICAgICAgICAgLy8gcHVibGljIEFQSVxyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCA/IHRoaXMuY29tcG9uZW50LnZpZXcgOiBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBQdWJsaWMgQVBJIGZvciByZW5kZXJpbmdcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyYWJsZUV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmluZEhhbmRsZXJzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVSZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlcmVuZGVyKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuYmluZEhhbmRsZXJzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5kZXN0cm95KCk7IC8vIGRvbid0IG51bGwtb3V0LiBpbiBjYXNlIEFQSSBuZWVkcyBhY2Nlc3NcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDsgLy8gdW1tID8/P1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2FsZW5kYXJJbnRlcmFjdGlvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdfZGVzdHJveWVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEhhbmRsZXJzXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuYmluZEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAvLyBldmVudCBkZWxlZ2F0aW9uIGZvciBuYXYgbGlua3NcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVOYXZMaW5rTGlzdGVuZXIgPSBsaXN0ZW5CeVNlbGVjdG9yKHRoaXMuZWwsICdjbGljaycsICdhW2RhdGEtZ290b10nLCBmdW5jdGlvbiAoZXYsIGFuY2hvckVsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ290b09wdGlvbnMgPSBhbmNob3JFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZ290bycpO1xyXG4gICAgICAgICAgICAgICAgZ290b09wdGlvbnMgPSBnb3RvT3B0aW9ucyA/IEpTT04ucGFyc2UoZ290b09wdGlvbnMpIDoge307XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZUVudiA9IF90aGlzLmRhdGVFbnY7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZU1hcmtlciA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGdvdG9PcHRpb25zLmRhdGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZpZXdUeXBlID0gZ290b09wdGlvbnMudHlwZTtcclxuICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IGxpa2UgXCJuYXZMaW5rRGF5Q2xpY2tcIi4gbWlnaHQgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbUFjdGlvbiA9IF90aGlzLnZpZXdPcHQoJ25hdkxpbmsnICsgY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHZpZXdUeXBlKSArICdDbGljaycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24oZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlciksIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdCgnaGFuZGxlV2luZG93UmVzaXplJykpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLndpbmRvd1Jlc2l6ZVByb3h5ID0gZGVib3VuY2UoLy8gcHJldmVudHMgcmFwaWQgY2FsbHNcclxuICAgICAgICAgICAgICAgIHRoaXMud2luZG93UmVzaXplLmJpbmQodGhpcyksIHRoaXMub3B0KCd3aW5kb3dSZXNpemVEZWxheScpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS51bmJpbmRIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVOYXZMaW5rTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMud2luZG93UmVzaXplUHJveHkpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLndpbmRvd1Jlc2l6ZVByb3h5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMud2luZG93UmVzaXplUHJveHkgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBEaXNwYXRjaGVyXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuaHlkcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuYnVpbGRJbml0aWFsU3RhdGUoKTtcclxuICAgICAgICAgICAgdmFyIHJhd1NvdXJjZXMgPSB0aGlzLm9wdCgnZXZlbnRTb3VyY2VzJykgfHwgW107XHJcbiAgICAgICAgICAgIHZhciBzaW5nbGVSYXdTb3VyY2UgPSB0aGlzLm9wdCgnZXZlbnRzJyk7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VzID0gW107IC8vIHBhcnNlZFxyXG4gICAgICAgICAgICBpZiAoc2luZ2xlUmF3U291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQoc2luZ2xlUmF3U291cmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHJhd1NvdXJjZXNfMSA9IHJhd1NvdXJjZXM7IF9pIDwgcmF3U291cmNlc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhd1NvdXJjZSA9IHJhd1NvdXJjZXNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gcGFyc2VFdmVudFNvdXJjZShyYXdTb3VyY2UsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hSZW5kZXJpbmcoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2goeyB0eXBlOiAnSU5JVCcgfSk7IC8vIHBhc3MgaW4gc291cmNlcyBoZXJlP1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2goeyB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLCBzb3VyY2VzOiBzb3VyY2VzIH0pO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfVklFV19UWVBFJyxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogX3RoaXMub3B0KCdkZWZhdWx0VmlldycpIHx8IF90aGlzLnBsdWdpblN5c3RlbS5ob29rcy5kZWZhdWx0Vmlld1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmJ1aWxkSW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdmlld1R5cGU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBsb2FkaW5nTGV2ZWw6IDAsXHJcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZUxvYWRpbmdMZXZlbDogMCxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlOiB0aGlzLmdldEluaXRpYWxEYXRlKCksXHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlczoge30sXHJcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcclxuICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IG51bGwsXHJcbiAgICAgICAgICAgICAgICBldmVudFNlbGVjdGlvbjogJycsXHJcbiAgICAgICAgICAgICAgICBldmVudERyYWc6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBldmVudFJlc2l6ZTogbnVsbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnB1c2goYWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVkdWNpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNSZWR1Y2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuYWN0aW9uUXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucmVkdWNlKHRoaXMuc3RhdGUsIHRoaXMuYWN0aW9uUXVldWUuc2hpZnQoKSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlZHVjaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9sZFN0YXRlLmxvYWRpbmdMZXZlbCAmJiBuZXdTdGF0ZS5sb2FkaW5nTGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignbG9hZGluZycsIFt0cnVlXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRTdGF0ZS5sb2FkaW5nTGV2ZWwgJiYgIW5ld1N0YXRlLmxvYWRpbmdMZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdsb2FkaW5nJywgW2ZhbHNlXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuY29tcG9uZW50ICYmIHRoaXMuY29tcG9uZW50LnZpZXc7XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuZXZlbnRTdG9yZSAhPT0gbmV3U3RhdGUuZXZlbnRTdG9yZSB8fCB0aGlzLm5lZWRzRnVsbFJlcmVuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlLmV2ZW50U3RvcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0V2ZW50c1VwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZS5kYXRlUHJvZmlsZSAhPT0gbmV3U3RhdGUuZGF0ZVByb2ZpbGUgfHwgdGhpcy5uZWVkc0Z1bGxSZXJlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZS5kYXRlUHJvZmlsZSAmJiB2aWV3KSB7IC8vIHdoeSB3b3VsZCB2aWV3IGJlIG51bGwhP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZGF0ZXNEZXN0cm95JywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWw6IHZpZXcuZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEYXRlc1VwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlLnZpZXdUeXBlICE9PSBuZXdTdGF0ZS52aWV3VHlwZSB8fCB0aGlzLm5lZWRzRnVsbFJlcmVuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlLnZpZXdUeXBlICYmIHZpZXcpIHsgLy8gd2h5IHdvdWxkIHZpZXcgYmUgbnVsbCE/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd2aWV3U2tlbGV0b25EZXN0cm95JywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWw6IHZpZXcuZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNWaWV3VXBkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RSZXJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24sIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2Uoc3RhdGUsIGFjdGlvbiwgY2FsZW5kYXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gUmVuZGVyIFF1ZXVlXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVxdWVzdFJlcmVuZGVyID0gZnVuY3Rpb24gKG5lZWRzRnVsbCkge1xyXG4gICAgICAgICAgICBpZiAobmVlZHNGdWxsID09PSB2b2lkIDApIHsgbmVlZHNGdWxsID0gZmFsc2U7IH1cclxuICAgICAgICAgICAgdGhpcy5uZWVkc1JlcmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5uZWVkc0Z1bGxSZXJlbmRlciA9IHRoaXMubmVlZHNGdWxsUmVyZW5kZXIgfHwgbmVlZHNGdWxsO1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRSZXJlbmRlcigpOyAvLyB3aWxsIGNhbGwgYSBkZWJvdW5jZWQtdmVyc2lvbiBvZiB0cnlSZXJlbmRlclxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnRyeVJlcmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQgJiYgLy8gbXVzdCBiZSBhY2NlcHRpbmcgcmVuZGVyc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc1JlcmVuZGVyICYmIC8vIGluZGljYXRlcyB0aGF0IGEgcmVyZW5kZXIgd2FzIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICAgICAgIXRoaXMucmVuZGVyaW5nUGF1c2VEZXB0aCAmJiAvLyBub3QgcGF1c2VkXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5pc1JlbmRlcmluZyAvLyBub3QgY3VycmVudGx5IGluIHRoZSByZW5kZXIgbG9vcFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0ZVJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuYmF0Y2hSZW5kZXJpbmcgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ1BhdXNlRGVwdGgrKztcclxuICAgICAgICAgICAgZnVuYygpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ1BhdXNlRGVwdGgtLTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubmVlZHNSZXJlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVyZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gUmVuZGVyaW5nXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZXhlY3V0ZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5lZWRzRnVsbFJlcmVuZGVyID0gdGhpcy5uZWVkc0Z1bGxSZXJlbmRlcjsgLy8gc2F2ZSBiZWZvcmUgY2xlYXJpbmdcclxuICAgICAgICAgICAgLy8gY2xlYXIgdGhlc2UgQkVGT1JFIHRoZSByZW5kZXIgc28gdGhhdCBuZXcgdmFsdWVzIHdpbGwgYWNjdW11bGF0ZSBkdXJpbmcgcmVuZGVyXHJcbiAgICAgICAgICAgIHRoaXMubmVlZHNSZXJlbmRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLm5lZWRzRnVsbFJlcmVuZGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNvbXBvbmVudChuZWVkc0Z1bGxSZXJlbmRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gcmVjZWl2ZWQgYSByZXJlbmRlciByZXF1ZXN0IHdoaWxlIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkc1JlcmVuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRSZXJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIGRvbid0IGNhbGwgdGhpcyBkaXJlY3RseS4gdXNlIGV4ZWN1dGVSZW5kZXIgaW5zdGVhZFxyXG4gICAgICAgICovXHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlckNvbXBvbmVudCA9IGZ1bmN0aW9uIChuZWVkc0Z1bGwpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgc3RhdGUgPSBfYS5zdGF0ZSwgY29tcG9uZW50ID0gX2EuY29tcG9uZW50O1xyXG4gICAgICAgICAgICB2YXIgdmlld1R5cGUgPSBzdGF0ZS52aWV3VHlwZTtcclxuICAgICAgICAgICAgdmFyIHZpZXdTcGVjID0gdGhpcy52aWV3U3BlY3Nbdmlld1R5cGVdO1xyXG4gICAgICAgICAgICB2YXIgc2F2ZWRTY3JvbGwgPSAobmVlZHNGdWxsICYmIGNvbXBvbmVudCkgPyBjb21wb25lbnQudmlldy5xdWVyeVNjcm9sbCgpIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKCF2aWV3U3BlYykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlldyB0eXBlIFxcXCJcIiArIHZpZXdUeXBlICsgXCJcXFwiIGlzIG5vdCB2YWxpZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBldmVudCBzb3VyY2VzIGFyZSBzdGlsbCBsb2FkaW5nIGFuZCBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgaGFzbid0IGJlZW4gZW5hYmxlZCxcclxuICAgICAgICAgICAgLy8ga2VlcCByZW5kZXJpbmcgdGhlIGxhc3QgZnVsbHkgbG9hZGVkIHNldCBvZiBldmVudHNcclxuICAgICAgICAgICAgdmFyIHJlbmRlcmFibGVFdmVudFN0b3JlID0gdGhpcy5yZW5kZXJhYmxlRXZlbnRTdG9yZSA9XHJcbiAgICAgICAgICAgICAgICAoc3RhdGUuZXZlbnRTb3VyY2VMb2FkaW5nTGV2ZWwgJiYgIXRoaXMub3B0KCdwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nJykpID9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmFibGVFdmVudFN0b3JlIDpcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFN0b3JlO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRVaVNpbmdsZUJhc2UgPSB0aGlzLmJ1aWxkRXZlbnRVaVNpbmdsZUJhc2Uodmlld1NwZWMub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHZhciBldmVudFVpQnlTb3VyY2UgPSB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlKHN0YXRlLmV2ZW50U291cmNlcyk7XHJcbiAgICAgICAgICAgIHZhciBldmVudFVpQmFzZXMgPSB0aGlzLmV2ZW50VWlCYXNlcyA9IHRoaXMuYnVpbGRFdmVudFVpQmFzZXMocmVuZGVyYWJsZUV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSk7XHJcbiAgICAgICAgICAgIGlmIChuZWVkc0Z1bGwgfHwgIWNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5mcmVlemVIZWlnaHQoKTsgLy8gbmV4dCBjb21wb25lbnQgd2lsbCB1bmZyZWV6ZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCA9IG5ldyBDYWxlbmRhckNvbXBvbmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXI6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldzogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlRW52OiB0aGlzLmRhdGVFbnYsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zTWFuYWdlci5jb21wdXRlZFxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5lbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzVmlld1VwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0RhdGVzVXBkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzRXZlbnRzVXBkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29tcG9uZW50LnJlY2VpdmVQcm9wcyhfX2Fzc2lnbih7fSwgc3RhdGUsIHsgdmlld1NwZWM6IHZpZXdTcGVjLCBkYXRlUHJvZmlsZTogc3RhdGUuZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yOiB0aGlzLmRhdGVQcm9maWxlR2VuZXJhdG9yc1t2aWV3VHlwZV0sIGV2ZW50U3RvcmU6IHJlbmRlcmFibGVFdmVudFN0b3JlLCBldmVudFVpQmFzZXM6IGV2ZW50VWlCYXNlcywgZGF0ZVNlbGVjdGlvbjogc3RhdGUuZGF0ZVNlbGVjdGlvbiwgZXZlbnRTZWxlY3Rpb246IHN0YXRlLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHN0YXRlLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHN0YXRlLmV2ZW50UmVzaXplIH0pKTtcclxuICAgICAgICAgICAgaWYgKHNhdmVkU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudmlldy5hcHBseVNjcm9sbChzYXZlZFNjcm9sbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmlld1VwZGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNWaWV3VXBkYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3ZpZXdTa2VsZXRvblJlbmRlcicsIFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbXBvbmVudC52aWV3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbDogY29tcG9uZW50LnZpZXcuZWxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RhdGVzVXBkYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0RhdGVzVXBkYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2RhdGVzUmVuZGVyJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogY29tcG9uZW50LnZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBjb21wb25lbnQudmlldy5lbFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRXZlbnRzVXBkYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0V2ZW50c1VwZGF0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VBZnRlclNpemluZ1RyaWdnZXJzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBPcHRpb25zXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuc2V0T3B0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRlT3B0aW9ucygoX2EgPSB7fSwgX2FbbmFtZV0gPSB2YWwsIF9hKSwgW10sIHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNNYW5hZ2VyLmNvbXB1dGVkW25hbWVdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNNYW5hZ2VyLmNvbXB1dGVkW25hbWVdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnZpZXdPcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3T3B0cygpW25hbWVdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnZpZXdPcHRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3U3BlY3NbdGhpcy5zdGF0ZS52aWV3VHlwZV0ub3B0aW9ucztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgaGFuZGxlcyBvcHRpb24gY2hhbmdlcyAobGlrZSBhIGRpZmYpXHJcbiAgICAgICAgKi9cclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUubXV0YXRlT3B0aW9ucyA9IGZ1bmN0aW9uICh1cGRhdGVzLCByZW1vdmFscywgaXNEeW5hbWljLCBkZWVwRXF1YWwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNoYW5nZUhhbmRsZXJzID0gdGhpcy5wbHVnaW5TeXN0ZW0uaG9va3Mub3B0aW9uQ2hhbmdlSGFuZGxlcnM7XHJcbiAgICAgICAgICAgIHZhciBub3JtYWxVcGRhdGVzID0ge307XHJcbiAgICAgICAgICAgIHZhciBzcGVjaWFsVXBkYXRlcyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb2xkRGF0ZUVudiA9IHRoaXMuZGF0ZUVudjsgLy8gZG8gdGhpcyBiZWZvcmUgaGFuZGxlT3B0aW9uc1xyXG4gICAgICAgICAgICB2YXIgaXNUaW1lWm9uZURpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBpc1NpemVEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgYW55RGlmZmljdWx0T3B0aW9ucyA9IEJvb2xlYW4ocmVtb3ZhbHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIHVwZGF0ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VIYW5kbGVyc1tuYW1lXzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbFVwZGF0ZXNbbmFtZV8xXSA9IHVwZGF0ZXNbbmFtZV8xXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFVwZGF0ZXNbbmFtZV8xXSA9IHVwZGF0ZXNbbmFtZV8xXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzIgaW4gbm9ybWFsVXBkYXRlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKC9eKGhlaWdodHxjb250ZW50SGVpZ2h0fGFzcGVjdFJhdGlvKSQvLnRlc3QobmFtZV8yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzU2l6ZURpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eKGRlZmF1bHREYXRlfGRlZmF1bHRWaWV3KSQvLnRlc3QobmFtZV8yKSkgO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW55RGlmZmljdWx0T3B0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVfMiA9PT0gJ3RpbWVab25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RpbWVab25lRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLm11dGF0ZShub3JtYWxVcGRhdGVzLCByZW1vdmFscywgaXNEeW5hbWljKTtcclxuICAgICAgICAgICAgaWYgKGFueURpZmZpY3VsdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT3B0aW9ucyh0aGlzLm9wdGlvbnNNYW5hZ2VyLmNvbXB1dGVkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNGdWxsUmVyZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hSZW5kZXJpbmcoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFueURpZmZpY3VsdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUaW1lWm9uZURpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVElNRVpPTkUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRGF0ZUVudjogb2xkRGF0ZUVudlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLyogSEFDS1xyXG4gICAgICAgICAgICAgICAgICAgIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgY2FsbGluZyB0aGlzLnJlcXVlc3RSZXJlbmRlcih0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1dCByZWNvbXB1dGVzIHRoZSBzdGF0ZSdzIGRhdGVQcm9maWxlXHJcbiAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfVklFV19UWVBFJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld1R5cGU6IF90aGlzLnN0YXRlLnZpZXdUeXBlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1NpemVEaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVNpemUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgdXBkYXRlc1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZXBFcXVhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMyBpbiBzcGVjaWFsVXBkYXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIYW5kbGVyc1tuYW1lXzNdKHNwZWNpYWxVcGRhdGVzW25hbWVfM10sIF90aGlzLCBkZWVwRXF1YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIHJlYnVpbGRzIHRoaW5ncyBiYXNlZCBvZmYgb2YgYSBjb21wbGV0ZSBzZXQgb2YgcmVmaW5lZCBvcHRpb25zXHJcbiAgICAgICAgKi9cclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuaGFuZGxlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBwbHVnaW5Ib29rcyA9IHRoaXMucGx1Z2luU3lzdGVtLmhvb2tzO1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ob3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKG9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZFJlcmVuZGVyID0gdGhpcy5idWlsZERlbGF5ZWRSZXJlbmRlcihvcHRpb25zLnJlcmVuZGVyRGVsYXkpO1xyXG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gdGhpcy5idWlsZFRoZW1lKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlID0gdGhpcy5wYXJzZVJhd0xvY2FsZXMob3B0aW9ucy5sb2NhbGVzKTtcclxuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVSYXdMb2NhbGVzID0gYXZhaWxhYmxlLm1hcDtcclxuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMuYnVpbGRMb2NhbGUob3B0aW9ucy5sb2NhbGUgfHwgYXZhaWxhYmxlLmRlZmF1bHRDb2RlLCBhdmFpbGFibGUubWFwKTtcclxuICAgICAgICAgICAgdGhpcy5kYXRlRW52ID0gdGhpcy5idWlsZERhdGVFbnYobG9jYWxlLCBvcHRpb25zLnRpbWVab25lLCBwbHVnaW5Ib29rcy5uYW1lZFRpbWVab25lZEltcGwsIG9wdGlvbnMuZmlyc3REYXksIG9wdGlvbnMud2Vla051bWJlckNhbGN1bGF0aW9uLCBvcHRpb25zLndlZWtMYWJlbCwgcGx1Z2luSG9va3MuY21kRm9ybWF0dGVyKTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Db25maWcgPSB0aGlzLmJ1aWxkU2VsZWN0aW9uQ29uZmlnKG9wdGlvbnMpOyAvLyBuZWVkcyBkYXRlRW52LiBkbyBhZnRlciA6KFxyXG4gICAgICAgICAgICAvLyBpbmVmZmVjaWVudCB0byBkbyBldmVyeSB0aW1lP1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdTcGVjcyA9IGJ1aWxkVmlld1NwZWNzKHBsdWdpbkhvb2tzLnZpZXdzLCB0aGlzLm9wdGlvbnNNYW5hZ2VyKTtcclxuICAgICAgICAgICAgLy8gaW5lZmZlY2llbnQgdG8gZG8gZXZlcnkgdGltZT9cclxuICAgICAgICAgICAgdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvcnMgPSBtYXBIYXNoKHRoaXMudmlld1NwZWNzLCBmdW5jdGlvbiAodmlld1NwZWMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmlld1NwZWMuY2xhc3MucHJvdG90eXBlLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3Modmlld1NwZWMsIF90aGlzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0QXZhaWxhYmxlTG9jYWxlQ29kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmF2YWlsYWJsZVJhd0xvY2FsZXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLl9idWlsZFNlbGVjdGlvbkNvbmZpZyA9IGZ1bmN0aW9uIChyYXdPcHRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzU2NvcGVkVWlQcm9wcygnc2VsZWN0JywgcmF3T3B0cywgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuX2J1aWxkRXZlbnRVaVNpbmdsZUJhc2UgPSBmdW5jdGlvbiAocmF3T3B0cykge1xyXG4gICAgICAgICAgICBpZiAocmF3T3B0cy5lZGl0YWJsZSkgeyAvLyBzbyAnZWRpdGFibGUnIGFmZmVjdGVkIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgcmF3T3B0cyA9IF9fYXNzaWduKHt9LCByYXdPcHRzLCB7IGV2ZW50RWRpdGFibGU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NTY29wZWRVaVByb3BzKCdldmVudCcsIHJhd09wdHMsIHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gVHJpZ2dlclxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmhhc1B1YmxpY0hhbmRsZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGFuZGxlcnMobmFtZSkgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0KG5hbWUpOyAvLyBoYW5kbGVyIHNwZWNpZmllZCBpbiBvcHRpb25zXHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucHVibGljbHlUcmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIG9wdEhhbmRsZXIgPSB0aGlzLm9wdChuYW1lKTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyV2l0aChuYW1lLCB0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgaWYgKG9wdEhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRIYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucHVibGljbHlUcmlnZ2VyQWZ0ZXJTaXppbmcgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xyXG4gICAgICAgICAgICB2YXIgYWZ0ZXJTaXppbmdUcmlnZ2VycyA9IHRoaXMuYWZ0ZXJTaXppbmdUcmlnZ2VycztcclxuICAgICAgICAgICAgKGFmdGVyU2l6aW5nVHJpZ2dlcnNbbmFtZV0gfHwgKGFmdGVyU2l6aW5nVHJpZ2dlcnNbbmFtZV0gPSBbXSkpLnB1c2goYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVsZWFzZUFmdGVyU2l6aW5nVHJpZ2dlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhZnRlclNpemluZ1RyaWdnZXJzID0gdGhpcy5hZnRlclNpemluZ1RyaWdnZXJzO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzQgaW4gYWZ0ZXJTaXppbmdUcmlnZ2Vycykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGFmdGVyU2l6aW5nVHJpZ2dlcnNbbmFtZV80XTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcihuYW1lXzQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJTaXppbmdUcmlnZ2VycyA9IHt9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gVmlld1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgdmlldyBpcyBva2F5IHRvIGluc3RhbnRpYXRlIGF0IHNvbWUgcG9pbnRcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuaXNWYWxpZFZpZXdUeXBlID0gZnVuY3Rpb24gKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMudmlld1NwZWNzW3ZpZXdUeXBlXSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuY2hhbmdlVmlldyA9IGZ1bmN0aW9uICh2aWV3VHlwZSwgZGF0ZU9yUmFuZ2UpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVNYXJrZXIgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZS5zdGFydCAmJiBkYXRlT3JSYW5nZS5lbmQpIHsgLy8gYSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIubXV0YXRlKHsgdmlzaWJsZVJhbmdlOiBkYXRlT3JSYW5nZSB9LCBbXSk7IC8vIHdpbGwgbm90IHJlcmVuZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVPcHRpb25zKHRoaXMub3B0aW9uc01hbmFnZXIuY29tcHV0ZWQpOyAvLyAuLi5idXQgeXVja1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIGEgZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIgPSB0aGlzLmRhdGVFbnYuY3JlYXRlTWFya2VyKGRhdGVPclJhbmdlKTsgLy8ganVzdCBsaWtlIGdvdG9EYXRlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfVklFV19UWVBFJyxcclxuICAgICAgICAgICAgICAgIHZpZXdUeXBlOiB2aWV3VHlwZSxcclxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IGRhdGVNYXJrZXJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBGb3JjZXMgbmF2aWdhdGlvbiB0byBhIHZpZXcgZm9yIHRoZSBnaXZlbiBkYXRlLlxyXG4gICAgICAgIC8vIGB2aWV3VHlwZWAgY2FuIGJlIGEgc3BlY2lmaWMgdmlldyBuYW1lIG9yIGEgZ2VuZXJpYyBvbmUgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLlxyXG4gICAgICAgIC8vIG5lZWRzIHRvIGNoYW5nZVxyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS56b29tVG8gPSBmdW5jdGlvbiAoZGF0ZU1hcmtlciwgdmlld1R5cGUpIHtcclxuICAgICAgICAgICAgdmFyIHNwZWM7XHJcbiAgICAgICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cclxuICAgICAgICAgICAgc3BlYyA9IHRoaXMudmlld1NwZWNzW3ZpZXdUeXBlXSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIGlmIChzcGVjKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX1ZJRVdfVFlQRScsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGU6IHNwZWMudHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlTWFya2VyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfREFURScsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZU1hcmtlclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cclxuICAgICAgICAvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldFVuaXRWaWV3U3BlYyA9IGZ1bmN0aW9uICh1bml0KSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgdmFyIHZpZXdUeXBlcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIHNwZWM7XHJcbiAgICAgICAgICAgIC8vIHB1dCB2aWV3cyB0aGF0IGhhdmUgYnV0dG9ucyBmaXJzdC4gdGhlcmUgd2lsbCBiZSBkdXBsaWNhdGVzLCBidXQgb2hcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5oZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdUeXBlcy5wdXNoLmFwcGx5KHZpZXdUeXBlcywgY29tcG9uZW50LmhlYWRlci52aWV3c1dpdGhCdXR0b25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmZvb3Rlcikge1xyXG4gICAgICAgICAgICAgICAgdmlld1R5cGVzLnB1c2guYXBwbHkodmlld1R5cGVzLCBjb21wb25lbnQuZm9vdGVyLnZpZXdzV2l0aEJ1dHRvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIHZpZXdUeXBlIGluIHRoaXMudmlld1NwZWNzKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3BlYyA9IHRoaXMudmlld1NwZWNzW3ZpZXdUeXBlc1tpXV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjLnNpbmdsZVVuaXQgPT09IHVuaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwZWM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDdXJyZW50IERhdGVcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHREYXRlSW5wdXQgPSB0aGlzLm9wdCgnZGVmYXVsdERhdGUnKTtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXHJcbiAgICAgICAgICAgIGlmIChkZWZhdWx0RGF0ZUlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYuY3JlYXRlTWFya2VyKGRlZmF1bHREYXRlSW5wdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm93KCk7IC8vIGdldE5vdyBhbHJlYWR5IHJldHVybnMgdW56b25lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1BSRVYnIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdORVhUJyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5wcmV2WWVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfREFURScsXHJcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiB0aGlzLmRhdGVFbnYuYWRkWWVhcnModGhpcy5zdGF0ZS5jdXJyZW50RGF0ZSwgLTEpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLm5leHRZZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9EQVRFJyxcclxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHRoaXMuZGF0ZUVudi5hZGRZZWFycyh0aGlzLnN0YXRlLmN1cnJlbnREYXRlLCAxKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS50b2RheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfREFURScsXHJcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiB0aGlzLmdldE5vdygpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmdvdG9EYXRlID0gZnVuY3Rpb24gKHpvbmVkRGF0ZUlucHV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX0RBVEUnLFxyXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogdGhpcy5kYXRlRW52LmNyZWF0ZU1hcmtlcih6b25lZERhdGVJbnB1dClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5jcmVtZW50RGF0ZSA9IGZ1bmN0aW9uIChkZWx0YUlucHV0KSB7XHJcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEpIHsgLy8gZWxzZSwgd2FybiBhYm91dCBpbnZhbGlkIGlucHV0P1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9EQVRFJyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiB0aGlzLmRhdGVFbnYuYWRkKHRoaXMuc3RhdGUuY3VycmVudERhdGUsIGRlbHRhKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGZvciBleHRlcm5hbCBBUElcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5zdGF0ZS5jdXJyZW50RGF0ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBEYXRlIEZvcm1hdHRpbmcgVXRpbHNcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5mb3JtYXREYXRlID0gZnVuY3Rpb24gKGQsIGZvcm1hdHRlcikge1xyXG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZGF0ZUVudjtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGRhdGVFbnYuY3JlYXRlTWFya2VyKGQpLCBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0dGVyKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBgc2V0dGluZ3NgIGlzIGZvciBmb3JtYXR0ZXIgQU5EIGlzRW5kRXhjbHVzaXZlXHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKGQwLCBkMSwgc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGRhdGVFbnYuY3JlYXRlTWFya2VyKGQwKSwgZGF0ZUVudi5jcmVhdGVNYXJrZXIoZDEpLCBjcmVhdGVGb3JtYXR0ZXIoc2V0dGluZ3MsIHRoaXMub3B0KCdkZWZhdWx0UmFuZ2VTZXBhcmF0b3InKSksIHNldHRpbmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5mb3JtYXRJc28gPSBmdW5jdGlvbiAoZCwgb21pdFRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdElzbyhkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgeyBvbWl0VGltZTogb21pdFRpbWUgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTaXppbmdcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS53aW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGFuZGxpbmdXaW5kb3dSZXNpemUgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ICYmIC8vIHdoeT9cclxuICAgICAgICAgICAgICAgIGV2LnRhcmdldCA9PT0gd2luZG93IC8vIG5vdCBhIGpxdWkgcmVzaXplIGV2ZW50XHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0hhbmRsaW5nV2luZG93UmVzaXplID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIFt0aGlzLnZpZXddKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNIYW5kbGluZ1dpbmRvd1Jlc2l6ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7IC8vIHdoZW4/XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC51cGRhdGVTaXplKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDb21wb25lbnQgUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHNldHRpbmdzSW5wdXQpIHtcclxuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCk7XHJcbiAgICAgICAgICAgIHZhciBERUZBVUxUX0lOVEVSQUNUSU9OUyA9IFtcclxuICAgICAgICAgICAgICAgIEV2ZW50Q2xpY2tpbmcsXHJcbiAgICAgICAgICAgICAgICBFdmVudEhvdmVyaW5nXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbkNsYXNzZXMgPSBERUZBVUxUX0lOVEVSQUNUSU9OUy5jb25jYXQodGhpcy5wbHVnaW5TeXN0ZW0uaG9va3MuY29tcG9uZW50SW50ZXJhY3Rpb25zKTtcclxuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9ucyA9IGludGVyYWN0aW9uQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKGludGVyYWN0aW9uQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW50ZXJhY3Rpb25DbGFzcyhzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdID0gaW50ZXJhY3Rpb25zO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF0gPSBzZXR0aW5ncztcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xyXG4gICAgICAgICAgICBkZWxldGUgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gRGF0ZSBTZWxlY3Rpb24gLyBFdmVudCBTZWxlY3Rpb24gLyBEYXlDbGlja1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy8gdGhpcyBwdWJsaWMgbWV0aG9kIHJlY2VpdmVzIHN0YXJ0L2VuZCBkYXRlcyBpbiBhbnkgZm9ybWF0LCB3aXRoIGFueSB0aW1lem9uZVxyXG4gICAgICAgIC8vIE5PVEU6IGFyZ3Mgd2VyZSBjaGFuZ2VkIGZyb20gdjNcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGRhdGVPck9iaiwgZW5kRGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uSW5wdXQ7XHJcbiAgICAgICAgICAgIGlmIChlbmREYXRlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlT3JPYmouc3RhcnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0gZGF0ZU9yT2JqO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogZGF0ZU9yT2JqLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kRGF0ZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gcGFyc2VEYXRlU3BhbihzZWxlY3Rpb25JbnB1dCwgdGhpcy5kYXRlRW52LCBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSkgLy8gVE9ETzogY2FjaGUgdGhpcz9cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikgeyAvLyB0aHJvdyBwYXJzZSBlcnJvciBvdGhlcndpc2U/XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogc2VsZWN0aW9uIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRGF0ZVNlbGVjdChzZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBwdWJsaWMgbWV0aG9kXHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnVuc2VsZWN0ID0gZnVuY3Rpb24gKHBldikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5kYXRlU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0RBVEVTJyB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckRhdGVVbnNlbGVjdChwZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUudHJpZ2dlckRhdGVTZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0aW9uLCBwZXYpIHtcclxuICAgICAgICAgICAgdmFyIGFyZyA9IF9fYXNzaWduKHt9LCB0aGlzLmJ1aWxkRGF0ZVNwYW5BcGkoc2VsZWN0aW9uKSwgeyBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCwgdmlldzogdGhpcy52aWV3IH0pO1xyXG4gICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignc2VsZWN0JywgW2FyZ10pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnRyaWdnZXJEYXRlVW5zZWxlY3QgPSBmdW5jdGlvbiAocGV2KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd1bnNlbGVjdCcsIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3OiB0aGlzLnZpZXdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUT0RPOiByZWNlaXZlIHBldj9cclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUudHJpZ2dlckRhdGVDbGljayA9IGZ1bmN0aW9uIChkYXRlU3BhbiwgZGF5RWwsIHZpZXcsIGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBhcmcgPSBfX2Fzc2lnbih7fSwgdGhpcy5idWlsZERhdGVQb2ludEFwaShkYXRlU3BhbiksIHsgZGF5RWw6IGRheUVsLCBqc0V2ZW50OiBldiwgLy8gSXMgdGhpcyBhbHdheXMgYSBtb3VzZSBldmVudD8gU2VlICM0NjU1XHJcbiAgICAgICAgICAgICAgICB2aWV3OiB2aWV3IH0pO1xyXG4gICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZGF0ZUNsaWNrJywgW2FyZ10pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmJ1aWxkRGF0ZVBvaW50QXBpID0gZnVuY3Rpb24gKGRhdGVTcGFuKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5wbHVnaW5TeXN0ZW0uaG9va3MuZGF0ZVBvaW50VHJhbnNmb3JtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBfX2Fzc2lnbihwcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX19hc3NpZ24ocHJvcHMsIGJ1aWxkRGF0ZVBvaW50QXBpKGRhdGVTcGFuLCB0aGlzLmRhdGVFbnYpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmJ1aWxkRGF0ZVNwYW5BcGkgPSBmdW5jdGlvbiAoZGF0ZVNwYW4pIHtcclxuICAgICAgICAgICAgdmFyIHByb3BzID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnBsdWdpblN5c3RlbS5ob29rcy5kYXRlU3BhblRyYW5zZm9ybXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgX19hc3NpZ24ocHJvcHMsIHRyYW5zZm9ybShkYXRlU3BhbiwgdGhpcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9fYXNzaWduKHByb3BzLCBidWlsZERhdGVTcGFuQXBpKGRhdGVTcGFuLCB0aGlzLmRhdGVFbnYpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gRGF0ZSBVdGlsc1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy8gUmV0dXJucyBhIERhdGVNYXJrZXIgZm9yIHRoZSBjdXJyZW50IGRhdGUsIGFzIGRlZmluZWQgYnkgdGhlIGNsaWVudCdzIGNvbXB1dGVyIG9yIGZyb20gdGhlIGBub3dgIG9wdGlvblxyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXROb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBub3cgPSB0aGlzLm9wdCgnbm93Jyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm93ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBub3cgPSBub3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm93ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYuY3JlYXRlTm93TWFya2VyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi5jcmVhdGVNYXJrZXIobm93KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEV2ZW50LURhdGUgVXRpbGl0aWVzXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAvLyBHaXZlbiBhbiBldmVudCdzIGFsbERheSBzdGF0dXMgYW5kIHN0YXJ0IGRhdGUsIHJldHVybiB3aGF0IGl0cyBmYWxsYmFjayBlbmQgZGF0ZSBzaG91bGQgYmUuXHJcbiAgICAgICAgLy8gVE9ETzogcmVuYW1lIHRvIGNvbXB1dGVEZWZhdWx0RXZlbnRFbmRcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RGVmYXVsdEV2ZW50RW5kID0gZnVuY3Rpb24gKGFsbERheSwgbWFya2VyKSB7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBtYXJrZXI7XHJcbiAgICAgICAgICAgIGlmIChhbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuZGF0ZUVudi5hZGQoZW5kLCB0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuZGF0ZUVudi5hZGQoZW5kLCB0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBQdWJsaWMgRXZlbnRzIEFQSVxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50SW5wdXQsIHNvdXJjZUlucHV0KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudElucHV0IGluc3RhbmNlb2YgRXZlbnRBcGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBldmVudElucHV0Ll9kZWY7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBldmVudElucHV0Ll9pbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50U3RvcmUuZGVmc1tkZWYuZGVmSWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUoeyBkZWY6IGRlZiwgaW5zdGFuY2U6IGluc3RhbmNlIH0pIC8vIFRPRE86IGJldHRlciB1dGlsIGZvciB0d28gYXJncz9cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudElucHV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VJZDtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VBcGkpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZUlkID0gc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VJbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlQXBpID0gdGhpcy5nZXRFdmVudFNvdXJjZUJ5SWQoc291cmNlSW5wdXQpOyAvLyBUT0RPOiB1c2UgYW4gaW50ZXJuYWwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIGlmICghc291cmNlQXBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBhbiBldmVudCBzb3VyY2Ugd2l0aCBJRCBcIicgKyBzb3VyY2VJbnB1dCArICdcIicpOyAvLyBUT0RPOiB0ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZCA9IHNvdXJjZUFwaS5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0dXBsZSA9IHBhcnNlRXZlbnQoZXZlbnRJbnB1dCwgc291cmNlSWQsIHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAodHVwbGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEFwaSh0aGlzLCB0dXBsZS5kZWYsIHR1cGxlLmRlZi5yZWN1cnJpbmdEZWYgPyBudWxsIDogdHVwbGUuaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemVcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RXZlbnRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUuZXZlbnRTdG9yZSwgZGVmcyA9IF9hLmRlZnMsIGluc3RhbmNlcyA9IF9hLmluc3RhbmNlcztcclxuICAgICAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmID0gZGVmc1tkZWZJZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmLnB1YmxpY0lkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRBcGkodGhpcywgZGVmLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZGVmSWQgPT09IGRlZi5kZWZJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRBcGkodGhpcywgZGVmLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLmV2ZW50U3RvcmUsIGRlZnMgPSBfYS5kZWZzLCBpbnN0YW5jZXMgPSBfYS5pbnN0YW5jZXM7XHJcbiAgICAgICAgICAgIHZhciBldmVudEFwaXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlZiA9IGRlZnNbaW5zdGFuY2UuZGVmSWRdO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50QXBpKHRoaXMsIGRlZiwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRBcGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQUxMX0VWRU5UUycgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVyZW5kZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVTRVRfRVZFTlRTJyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFB1YmxpYyBFdmVudCBTb3VyY2VzIEFQSVxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEV2ZW50U291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZUhhc2ggPSB0aGlzLnN0YXRlLmV2ZW50U291cmNlcztcclxuICAgICAgICAgICAgdmFyIHNvdXJjZUFwaXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VBcGlzLnB1c2gobmV3IEV2ZW50U291cmNlQXBpKHRoaXMsIHNvdXJjZUhhc2hbaW50ZXJuYWxJZF0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlQXBpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRFdmVudFNvdXJjZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZUhhc2ggPSB0aGlzLnN0YXRlLmV2ZW50U291cmNlcztcclxuICAgICAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBzb3VyY2VJZCBpbiBzb3VyY2VIYXNoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlSGFzaFtzb3VyY2VJZF0ucHVibGljSWQgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUFwaSh0aGlzLCBzb3VyY2VIYXNoW3NvdXJjZUlkXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUuYWRkRXZlbnRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlSW5wdXQpIHtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VBcGkpIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50U291cmNlc1tzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VzOiBbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZV1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VJbnB1dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZXZlbnRTb3VyY2UgPSBwYXJzZUV2ZW50U291cmNlKHNvdXJjZUlucHV0LCB0aGlzKTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50U291cmNlKSB7IC8vIFRPRE86IGVycm9yIG90aGVyd2lzZT9cclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLCBzb3VyY2VzOiBbZXZlbnRTb3VyY2VdIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUFwaSh0aGlzLCBldmVudFNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnRTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUycgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxlbmRhci5wcm90b3R5cGUucmVmZXRjaEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFNjcm9sbFxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgQ2FsZW5kYXIucHJvdG90eXBlLnNjcm9sbFRvVGltZSA9IGZ1bmN0aW9uICh0aW1lSW5wdXQpIHtcclxuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24odGltZUlucHV0KTtcclxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC52aWV3LnNjcm9sbFRvRHVyYXRpb24oZHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ2FsZW5kYXI7XHJcbiAgICB9KCkpO1xyXG4gICAgRW1pdHRlck1peGluLm1peEludG8oQ2FsZW5kYXIpO1xyXG4gICAgLy8gZm9yIG1lbW9pemVyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF0ZUVudihsb2NhbGUsIHRpbWVab25lLCBuYW1lZFRpbWVab25lSW1wbCwgZmlyc3REYXksIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiwgd2Vla0xhYmVsLCBjbWRGb3JtYXR0ZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGVFbnYoe1xyXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbTogJ2dyZWdvcnknLFxyXG4gICAgICAgICAgICB0aW1lWm9uZTogdGltZVpvbmUsXHJcbiAgICAgICAgICAgIG5hbWVkVGltZVpvbmVJbXBsOiBuYW1lZFRpbWVab25lSW1wbCxcclxuICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXHJcbiAgICAgICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogd2Vla051bWJlckNhbGN1bGF0aW9uLFxyXG4gICAgICAgICAgICBmaXJzdERheTogZmlyc3REYXksXHJcbiAgICAgICAgICAgIHdlZWtMYWJlbDogd2Vla0xhYmVsLFxyXG4gICAgICAgICAgICBjbWRGb3JtYXR0ZXI6IGNtZEZvcm1hdHRlclxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRUaGVtZShjYWxlbmRhck9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgdGhlbWVDbGFzcyA9IHRoaXMucGx1Z2luU3lzdGVtLmhvb2tzLnRoZW1lQ2xhc3Nlc1tjYWxlbmRhck9wdGlvbnMudGhlbWVTeXN0ZW1dIHx8IFN0YW5kYXJkVGhlbWU7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGVtZUNsYXNzKGNhbGVuZGFyT3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZERlbGF5ZWRSZXJlbmRlcih3YWl0KSB7XHJcbiAgICAgICAgdmFyIGZ1bmMgPSB0aGlzLnRyeVJlcmVuZGVyLmJpbmQodGhpcyk7XHJcbiAgICAgICAgaWYgKHdhaXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmdW5jID0gZGVib3VuY2UoZnVuYywgd2FpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTb3VyY2VzLCBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlLnVpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudFVpQmFzZXMoZXZlbnREZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50VWlCYXNlcyA9IHsgJyc6IGV2ZW50VWlTaW5nbGVCYXNlIH07XHJcbiAgICAgICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWYgPSBldmVudERlZnNbZGVmSWRdO1xyXG4gICAgICAgICAgICBpZiAoZGVmLnNvdXJjZUlkICYmIGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXNbZGVmSWRdID0gZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50VWlCYXNlcztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVmlldywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBWaWV3KGNvbnRleHQsIHZpZXdTcGVjLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgcGFyZW50RWwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCwgY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdmYy12aWV3IGZjLScgKyB2aWV3U3BlYy50eXBlICsgJy12aWV3JyB9KSwgdHJ1ZSAvLyBpc1ZpZXcgKEhBQ0spXHJcbiAgICAgICAgICAgICkgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyRGF0ZXNNZW0gPSBtZW1vaXplUmVuZGVyaW5nKF90aGlzLnJlbmRlckRhdGVzV3JhcCwgX3RoaXMudW5yZW5kZXJEYXRlc1dyYXApO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJCdXNpbmVzc0hvdXJzTWVtID0gbWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5yZW5kZXJCdXNpbmVzc0hvdXJzLCBfdGhpcy51bnJlbmRlckJ1c2luZXNzSG91cnMsIFtfdGhpcy5yZW5kZXJEYXRlc01lbV0pO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJEYXRlU2VsZWN0aW9uTWVtID0gbWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5yZW5kZXJEYXRlU2VsZWN0aW9uV3JhcCwgX3RoaXMudW5yZW5kZXJEYXRlU2VsZWN0aW9uV3JhcCwgW190aGlzLnJlbmRlckRhdGVzTWVtXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckV2ZW50c01lbSA9IG1lbW9pemVSZW5kZXJpbmcoX3RoaXMucmVuZGVyRXZlbnRzLCBfdGhpcy51bnJlbmRlckV2ZW50cywgW190aGlzLnJlbmRlckRhdGVzTWVtXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckV2ZW50U2VsZWN0aW9uTWVtID0gbWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5yZW5kZXJFdmVudFNlbGVjdGlvbldyYXAsIF90aGlzLnVucmVuZGVyRXZlbnRTZWxlY3Rpb25XcmFwLCBbX3RoaXMucmVuZGVyRXZlbnRzTWVtXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckV2ZW50RHJhZ01lbSA9IG1lbW9pemVSZW5kZXJpbmcoX3RoaXMucmVuZGVyRXZlbnREcmFnV3JhcCwgX3RoaXMudW5yZW5kZXJFdmVudERyYWdXcmFwLCBbX3RoaXMucmVuZGVyRGF0ZXNNZW1dKTtcclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyRXZlbnRSZXNpemVNZW0gPSBtZW1vaXplUmVuZGVyaW5nKF90aGlzLnJlbmRlckV2ZW50UmVzaXplV3JhcCwgX3RoaXMudW5yZW5kZXJFdmVudFJlc2l6ZVdyYXAsIFtfdGhpcy5yZW5kZXJEYXRlc01lbV0pO1xyXG4gICAgICAgICAgICBfdGhpcy52aWV3U3BlYyA9IHZpZXdTcGVjO1xyXG4gICAgICAgICAgICBfdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvciA9IGRhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG4gICAgICAgICAgICBfdGhpcy50eXBlID0gdmlld1NwZWMudHlwZTtcclxuICAgICAgICAgICAgX3RoaXMuZXZlbnRPcmRlclNwZWNzID0gcGFyc2VGaWVsZFNwZWNzKF90aGlzLm9wdCgnZXZlbnRPcmRlcicpKTtcclxuICAgICAgICAgICAgX3RoaXMubmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKF90aGlzLm9wdCgnbmV4dERheVRocmVzaG9sZCcpKTtcclxuICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQoX3RoaXMuZWwpO1xyXG4gICAgICAgICAgICBfdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3LnByb3RvdHlwZSwgXCJhY3RpdmVTdGFydFwiLCB7XHJcbiAgICAgICAgICAgIC8vIERhdGUgU2V0dGluZy9VbnNldHRpbmdcclxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLnByb3BzLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLnN0YXJ0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXcucHJvdG90eXBlLCBcImFjdGl2ZUVuZFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5wcm9wcy5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlldy5wcm90b3R5cGUsIFwiY3VycmVudFN0YXJ0XCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLnByb3BzLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3LnByb3RvdHlwZSwgXCJjdXJyZW50RW5kXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLnByb3BzLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBHZW5lcmFsIFJlbmRlcmluZ1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0ZXNNZW0ocHJvcHMuZGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckJ1c2luZXNzSG91cnNNZW0ocHJvcHMuYnVzaW5lc3NIb3Vycyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0ZVNlbGVjdGlvbk1lbShwcm9wcy5kYXRlU2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJFdmVudHNNZW0ocHJvcHMuZXZlbnRTdG9yZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnRTZWxlY3Rpb25NZW0ocHJvcHMuZXZlbnRTZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50RHJhZ01lbShwcm9wcy5ldmVudERyYWcpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50UmVzaXplTWVtKHByb3BzLmV2ZW50UmVzaXplKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckRhdGVzTWVtLnVucmVuZGVyKCk7IC8vIHNob3VsZCB1bnJlbmRlciBldmVyeXRoaW5nIGVsc2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFNpemluZ1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uIChpc1Jlc2l6ZSwgdmlld0hlaWdodCwgaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6ZSB8fCAvLyBIQUNLUy4uLlxyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXIuaXNWaWV3VXBkYXRlZCB8fFxyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXIuaXNEYXRlc1VwZGF0ZWQgfHxcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyLmlzRXZlbnRzVXBkYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc29ydCBvZiB0aGUgY2F0Y2gtYWxsIHNpemluZ1xyXG4gICAgICAgICAgICAgICAgLy8gYW55dGhpbmcgdGhhdCBtaWdodCBjYXVzZSBkaW1lbnNpb24gY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCYXNlU2l6ZShpc1Jlc2l6ZSwgdmlld0hlaWdodCwgaXNBdXRvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUudXBkYXRlQmFzZVNpemUgPSBmdW5jdGlvbiAoaXNSZXNpemUsIHZpZXdIZWlnaHQsIGlzQXV0bykge1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gRGF0ZSBSZW5kZXJpbmdcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckRhdGVzV3JhcCA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckRhdGVzKGRhdGVQcm9maWxlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRTY3JvbGwoe1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uKHRoaXMub3B0KCdzY3JvbGxUaW1lJykpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0Tm93SW5kaWNhdG9yKGRhdGVQcm9maWxlKTsgLy8gc2hvdWxkbid0IHJlbmRlciB5ZXQgYmVjYXVzZSB1cGRhdGVTaXplIHdpbGwgYmUgY2FsbGVkIHNvb25cclxuICAgICAgICB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnVucmVuZGVyRGF0ZXNXcmFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BOb3dJbmRpY2F0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy51bnJlbmRlckRhdGVzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkgeyB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnVucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgLy8gQnVzaW5lc3MgSG91cnNcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckJ1c2luZXNzSG91cnMgPSBmdW5jdGlvbiAoYnVzaW5lc3NIb3VycykgeyB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnVucmVuZGVyQnVzaW5lc3NIb3VycyA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICAvLyBEYXRlIFNlbGVjdGlvblxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUucmVuZGVyRGF0ZVNlbGVjdGlvbldyYXAgPSBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0ZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlckRhdGVTZWxlY3Rpb25XcmFwID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVucmVuZGVyRGF0ZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS5yZW5kZXJEYXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHNlbGVjdGlvbikgeyB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnVucmVuZGVyRGF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHsgfTtcclxuICAgICAgICAvLyBFdmVudCBSZW5kZXJpbmdcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckV2ZW50cyA9IGZ1bmN0aW9uIChldmVudFN0b3JlKSB7IH07XHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUudW5yZW5kZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgLy8gdXRpbCBmb3Igc3ViY2xhc3Nlc1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnNsaWNlRXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUsIGFsbERheSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgICByZXR1cm4gc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIHByb3BzLmV2ZW50VWlCYXNlcywgcHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGFsbERheSA/IHRoaXMubmV4dERheVRocmVzaG9sZCA6IG51bGwpLmZnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZUV2ZW50RHJhZ2dhYmxlID0gZnVuY3Rpb24gKGV2ZW50RGVmLCBldmVudFVpKSB7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lcnMgPSB0aGlzLmNhbGVuZGFyLnBsdWdpblN5c3RlbS5ob29rcy5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycztcclxuICAgICAgICAgICAgdmFyIHZhbCA9IGV2ZW50VWkuc3RhcnRFZGl0YWJsZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB0cmFuc2Zvcm1lcnNfMSA9IHRyYW5zZm9ybWVyczsgX2kgPCB0cmFuc2Zvcm1lcnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyc18xW19pXTtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHRyYW5zZm9ybWVyKHZhbCwgZXZlbnREZWYsIGV2ZW50VWksIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS5jb21wdXRlRXZlbnRTdGFydFJlc2l6YWJsZSA9IGZ1bmN0aW9uIChldmVudERlZiwgZXZlbnRVaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRVaS5kdXJhdGlvbkVkaXRhYmxlICYmIHRoaXMub3B0KCdldmVudFJlc2l6YWJsZUZyb21TdGFydCcpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZUV2ZW50RW5kUmVzaXphYmxlID0gZnVuY3Rpb24gKGV2ZW50RGVmLCBldmVudFVpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudFVpLmR1cmF0aW9uRWRpdGFibGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBFdmVudCBTZWxlY3Rpb25cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckV2ZW50U2VsZWN0aW9uV3JhcCA9IGZ1bmN0aW9uIChpbnN0YW5jZUlkKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50U2VsZWN0aW9uKGluc3RhbmNlSWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlckV2ZW50U2VsZWN0aW9uV3JhcCA9IGZ1bmN0aW9uIChpbnN0YW5jZUlkKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVucmVuZGVyRXZlbnRTZWxlY3Rpb24oaW5zdGFuY2VJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckV2ZW50U2VsZWN0aW9uID0gZnVuY3Rpb24gKGluc3RhbmNlSWQpIHsgfTtcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlckV2ZW50U2VsZWN0aW9uID0gZnVuY3Rpb24gKGluc3RhbmNlSWQpIHsgfTtcclxuICAgICAgICAvLyBFdmVudCBEcmFnXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBWaWV3LnByb3RvdHlwZS5yZW5kZXJFdmVudERyYWdXcmFwID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFdmVudERyYWcoc3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlckV2ZW50RHJhZ1dyYXAgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVucmVuZGVyRXZlbnREcmFnKHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUucmVuZGVyRXZlbnREcmFnID0gZnVuY3Rpb24gKHN0YXRlKSB7IH07XHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUudW5yZW5kZXJFdmVudERyYWcgPSBmdW5jdGlvbiAoc3RhdGUpIHsgfTtcclxuICAgICAgICAvLyBFdmVudCBSZXNpemVcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplV3JhcCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnRSZXNpemUoc3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlckV2ZW50UmVzaXplV3JhcCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5yZW5kZXJFdmVudFJlc2l6ZShzdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKHN0YXRlKSB7IH07XHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUudW5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChzdGF0ZSkgeyB9O1xyXG4gICAgICAgIC8qIE5vdyBJbmRpY2F0b3JcclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgIC8vIEltbWVkaWF0ZWx5IHJlbmRlciB0aGUgY3VycmVudCB0aW1lIGluZGljYXRvciBhbmQgYmVnaW5zIHJlLXJlbmRlcmluZyBpdCBhdCBhbiBpbnRlcnZhbCxcclxuICAgICAgICAvLyB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoaXMuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpLlxyXG4gICAgICAgIC8vIFRPRE86IHNvbWVob3cgZG8gdGhpcyBmb3IgdGhlIGN1cnJlbnQgd2hvbGUgZGF5J3MgYmFja2dyb3VuZCB0b29cclxuICAgICAgICBWaWV3LnByb3RvdHlwZS5zdGFydE5vd0luZGljYXRvciA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZGF0ZUVudjtcclxuICAgICAgICAgICAgdmFyIHVuaXQ7XHJcbiAgICAgICAgICAgIHZhciB1cGRhdGU7XHJcbiAgICAgICAgICAgIHZhciBkZWxheTsgLy8gbXMgd2FpdCB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHQoJ25vd0luZGljYXRvcicpKSB7XHJcbiAgICAgICAgICAgICAgICB1bml0ID0gdGhpcy5nZXROb3dJbmRpY2F0b3JVbml0KGRhdGVQcm9maWxlKTtcclxuICAgICAgICAgICAgICAgIGlmICh1bml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdGhpcy51cGRhdGVOb3dJbmRpY2F0b3IuYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxOb3dEYXRlID0gdGhpcy5jYWxlbmRhci5nZXROb3coKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IHVudGlsIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgaW50ZXJ2YWxcclxuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IGRhdGVFbnYuYWRkKGRhdGVFbnYuc3RhcnRPZih0aGlzLmluaXRpYWxOb3dEYXRlLCB1bml0KSwgY3JlYXRlRHVyYXRpb24oMSwgdW5pdCkpLnZhbHVlT2YoKSAtIHRoaXMuaW5pdGlhbE5vd0RhdGUudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGFsd2F5cyB1c2Ugc2V0VGltZW91dCwgd2FpdGluZyB1bnRpbCBzdGFydCBvZiBuZXh0IHVuaXRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheSA9IDEwMDA7IC8vIGV2ZXJ5IHNlY29uZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSAxMDAwICogNjA7IC8vIG90aGVyd2lzZSwgZXZlcnkgbWludXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCA9IHNldEludGVydmFsKHVwZGF0ZSwgZGVsYXkpOyAvLyB1cGRhdGUgZXZlcnkgaW50ZXJ2YWxcclxuICAgICAgICAgICAgICAgICAgICB9LCBkZWxheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJpbmcgd2lsbCBiZSBpbml0aWF0ZWQgaW4gdXBkYXRlU2l6ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyByZXJlbmRlcnMgdGhlIG5vdyBpbmRpY2F0b3IsIGNvbXB1dGluZyB0aGUgbmV3IGN1cnJlbnQgdGltZSBmcm9tIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGhhcyBwYXNzZWRcclxuICAgICAgICAvLyBzaW5jZSB0aGUgaW5pdGlhbCBnZXROb3cgY2FsbC5cclxuICAgICAgICBWaWV3LnByb3RvdHlwZS51cGRhdGVOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmRhdGVQcm9maWxlICYmIC8vIGEgd2F5IHRvIGRldGVybWluZSBpZiBkYXRlcyB3ZXJlIHJlbmRlcmVkIHlldFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsTm93RGF0ZSAvLyBhY3RpdmF0ZWQgYmVmb3JlP1xyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5yZW5kZXJOb3dJbmRpY2F0b3IoKTsgLy8gd29uJ3QgdW5yZW5kZXIgaWYgdW5uZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm93SW5kaWNhdG9yKGFkZE1zKHRoaXMuaW5pdGlhbE5vd0RhdGUsIG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBJbW1lZGlhdGVseSB1bnJlbmRlcnMgdGhlIHZpZXcncyBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGFuZCBzdG9wcyBhbnkgcmUtcmVuZGVyaW5nIHRpbWVycy5cclxuICAgICAgICAvLyBXb24ndCBjYXVzZSBzaWRlIGVmZmVjdHMgaWYgaW5kaWNhdG9yIGlzbid0IHJlbmRlcmVkLlxyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnN0b3BOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvckludGVydmFsSUQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy51bnJlbmRlck5vd0luZGljYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLmdldE5vd0luZGljYXRvclVuaXQgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBSZW5kZXJzIGEgY3VycmVudCB0aW1lIGluZGljYXRvciBhdCB0aGUgZ2l2ZW4gZGF0ZXRpbWVcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS5yZW5kZXJOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBTVUJDTEFTU0VTIE1VU1QgUEFTUyBUTyBDSElMRFJFTiFcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFVuZG9lcyB0aGUgcmVuZGVyaW5nIGFjdGlvbnMgZnJvbSByZW5kZXJOb3dJbmRpY2F0b3JcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS51bnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gU1VCQ0xBU1NFUyBNVVNUIFBBU1MgVE8gQ0hJTERSRU4hXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBTY3JvbGxlclxyXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgVmlldy5wcm90b3R5cGUuYWRkU2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgICAgICB2YXIgcXVldWVkU2Nyb2xsID0gdGhpcy5xdWV1ZWRTY3JvbGwgfHwgKHRoaXMucXVldWVkU2Nyb2xsID0ge30pO1xyXG4gICAgICAgICAgICBfX2Fzc2lnbihxdWV1ZWRTY3JvbGwsIHNjcm9sbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS5wb3BTY3JvbGwgPSBmdW5jdGlvbiAoaXNSZXNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHBseVF1ZXVlZFNjcm9sbChpc1Jlc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucXVldWVkU2Nyb2xsID0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLmFwcGx5UXVldWVkU2Nyb2xsID0gZnVuY3Rpb24gKGlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTY3JvbGwodGhpcy5xdWV1ZWRTY3JvbGwgfHwge30sIGlzUmVzaXplKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnF1ZXJ5U2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsID0ge307XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmRhdGVQcm9maWxlKSB7IC8vIGRhdGVzIHJlbmRlcmVkIHlldD9cclxuICAgICAgICAgICAgICAgIF9fYXNzaWduKHNjcm9sbCwgdGhpcy5xdWVyeURhdGVTY3JvbGwoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNjcm9sbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLmFwcGx5U2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCwgaXNSZXNpemUpIHtcclxuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gc2Nyb2xsLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNjcm9sbC5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmRhdGVQcm9maWxlKSB7IC8vIGRhdGVzIHJlbmRlcmVkIHlldD9cclxuICAgICAgICAgICAgICAgICAgICBfX2Fzc2lnbihzY3JvbGwsIHRoaXMuY29tcHV0ZURhdGVTY3JvbGwoZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5kYXRlUHJvZmlsZSkgeyAvLyBkYXRlcyByZW5kZXJlZCB5ZXQ/XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5RGF0ZVNjcm9sbChzY3JvbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS5jb21wdXRlRGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4ge307IC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIFZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt9OyAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS5hcHBseURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGZvciBBUElcclxuICAgICAgICBWaWV3LnByb3RvdHlwZS5zY3JvbGxUb0R1cmF0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTY3JvbGwoeyBkdXJhdGlvbjogZHVyYXRpb24gfSwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFZpZXc7XHJcbiAgICB9KERhdGVDb21wb25lbnQpKTtcclxuICAgIEVtaXR0ZXJNaXhpbi5taXhJbnRvKFZpZXcpO1xyXG4gICAgVmlldy5wcm90b3R5cGUudXNlc01pbk1heFRpbWUgPSBmYWxzZTtcclxuICAgIFZpZXcucHJvdG90eXBlLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxuXHJcbiAgICB2YXIgRmdFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEZnRXZlbnRSZW5kZXJlcihjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VncyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmlzU2l6ZURpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEZnRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VncyA9IGZ1bmN0aW9uIChzZWdzLCBtaXJyb3JJbmZvKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFuZ2VVcGRhdGVkKCk7IC8vIGNhbGxlZCB0b28gZnJlcXVlbnRseSA6KFxyXG4gICAgICAgICAgICAvLyByZW5kZXIgYW4gYC5lbGAgb24gZWFjaCBzZWdcclxuICAgICAgICAgICAgLy8gcmV0dXJucyBhIHN1YnNldCBvZiB0aGUgc2Vncy4gc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWRcclxuICAgICAgICAgICAgc2VncyA9IHRoaXMucmVuZGVyU2VnRWxzKHNlZ3MsIG1pcnJvckluZm8pO1xyXG4gICAgICAgICAgICB0aGlzLnNlZ3MgPSBzZWdzO1xyXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNlZ3Moc2VncywgbWlycm9ySW5mbyk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTaXplRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudmlldy50cmlnZ2VyUmVuZGVyZWRTZWdzKHRoaXMuc2VncywgQm9vbGVhbihtaXJyb3JJbmZvKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gKF9zZWdzLCBtaXJyb3JJbmZvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC52aWV3LnRyaWdnZXJXaWxsUmVtb3ZlU2Vncyh0aGlzLnNlZ3MsIEJvb2xlYW4obWlycm9ySW5mbykpO1xyXG4gICAgICAgICAgICB0aGlzLmRldGFjaFNlZ3ModGhpcy5zZWdzKTtcclxuICAgICAgICAgICAgdGhpcy5zZWdzID0gW107XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBVcGRhdGVzIHZhbHVlcyB0aGF0IHJlbHkgb24gb3B0aW9ucyBhbmQgYWxzbyByZWxhdGUgdG8gcmFuZ2VcclxuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJhbmdlVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmNvbnRleHQub3B0aW9ucztcclxuICAgICAgICAgICAgdmFyIGRpc3BsYXlFdmVudFRpbWU7XHJcbiAgICAgICAgICAgIHZhciBkaXNwbGF5RXZlbnRFbmQ7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRUaW1lRm9ybWF0ID0gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IHRoaXMuY29tcHV0ZUV2ZW50VGltZUZvcm1hdCgpLCBvcHRpb25zLmRlZmF1bHRSYW5nZVNlcGFyYXRvcik7XHJcbiAgICAgICAgICAgIGRpc3BsYXlFdmVudFRpbWUgPSBvcHRpb25zLmRpc3BsYXlFdmVudFRpbWU7XHJcbiAgICAgICAgICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlFdmVudFRpbWUgPSB0aGlzLmNvbXB1dGVEaXNwbGF5RXZlbnRUaW1lKCk7IC8vIG1pZ2h0IGJlIGJhc2VkIG9mZiBvZiByYW5nZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IG9wdGlvbnMuZGlzcGxheUV2ZW50RW5kO1xyXG4gICAgICAgICAgICBpZiAoZGlzcGxheUV2ZW50RW5kID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IHRoaXMuY29tcHV0ZURpc3BsYXlFdmVudEVuZCgpOyAvLyBtaWdodCBiZSBiYXNlZCBvZmYgb2YgcmFuZ2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlFdmVudFRpbWUgPSBkaXNwbGF5RXZlbnRUaW1lO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlFdmVudEVuZCA9IGRpc3BsYXlFdmVudEVuZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnQuXHJcbiAgICAgICAgLy8gT25seSByZXR1cm5zIHNlZ21lbnRzIHRoYXQgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkLlxyXG4gICAgICAgIEZnRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VnRWxzID0gZnVuY3Rpb24gKHNlZ3MsIG1pcnJvckluZm8pIHtcclxuICAgICAgICAgICAgdmFyIGh0bWwgPSAnJztcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGlmIChzZWdzLmxlbmd0aCkgeyAvLyBkb24ndCBidWlsZCBhbiBlbXB0eSBodG1sIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgLy8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIGV2ZW50IHNlZ21lbnQgSFRNTFxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMucmVuZGVyU2VnSHRtbChzZWdzW2ldLCBtaXJyb3JJbmZvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEdyYWIgaW5kaXZpZHVhbCBlbGVtZW50cyBmcm9tIHRoZSBjb21iaW5lZCBIVE1MIHN0cmluZy4gVXNlIGVhY2ggYXMgdGhlIGRlZmF1bHQgcmVuZGVyaW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlbiwgY29tcHV0ZSB0aGUgJ2VsJyBmb3IgZWFjaCBzZWdtZW50LiBBbiBlbCBtaWdodCBiZSBudWxsIGlmIHRoZSBldmVudFJlbmRlciBjYWxsYmFjayByZXR1cm5lZCBmYWxzZS5cclxuICAgICAgICAgICAgICAgIGh0bWxUb0VsZW1lbnRzKGh0bWwpLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZy5lbCA9IGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc2VncyA9IGZpbHRlclNlZ3NWaWFFbHModGhpcy5jb250ZXh0LnZpZXcsIHNlZ3MsIEJvb2xlYW4obWlycm9ySW5mbykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJpYyB1dGlsaXR5IGZvciBnZW5lcmF0aW5nIHRoZSBIVE1MIGNsYXNzTmFtZXMgZm9yIGFuIGV2ZW50IHNlZ21lbnQncyBlbGVtZW50XHJcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTZWdDbGFzc2VzID0gZnVuY3Rpb24gKHNlZywgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlLCBtaXJyb3JJbmZvKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gW1xyXG4gICAgICAgICAgICAgICAgJ2ZjLWV2ZW50JyxcclxuICAgICAgICAgICAgICAgIHNlZy5pc1N0YXJ0ID8gJ2ZjLXN0YXJ0JyA6ICdmYy1ub3Qtc3RhcnQnLFxyXG4gICAgICAgICAgICAgICAgc2VnLmlzRW5kID8gJ2ZjLWVuZCcgOiAnZmMtbm90LWVuZCdcclxuICAgICAgICAgICAgXS5jb25jYXQoc2VnLmV2ZW50UmFuZ2UudWkuY2xhc3NOYW1lcyk7XHJcbiAgICAgICAgICAgIGlmIChpc0RyYWdnYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1kcmFnZ2FibGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNSZXNpemFibGUpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtcmVzaXphYmxlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1pcnJvckluZm8pIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtbWlycm9yJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWlycm9ySW5mby5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1kcmFnZ2luZycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1pcnJvckluZm8uaXNSZXNpemluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtcmVzaXppbmcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkIG9uIGFuIGV2ZW50J3MgZWxlbWVudC5cclxuICAgICAgICAvLyBgcmFuZ2VgIGNhbiBiZSB0aGUgRXZlbnQgb2JqZWN0IGl0c2VsZiwgb3Igc29tZXRoaW5nIHJhbmdlLWxpa2UsIHdpdGggYXQgbGVhc3QgYSBgc3RhcnRgLlxyXG4gICAgICAgIC8vIElmIGV2ZW50IHRpbWVzIGFyZSBkaXNhYmxlZCwgb3IgdGhlIGV2ZW50IGhhcyBubyB0aW1lLCB3aWxsIHJldHVybiBhIGJsYW5rIHN0cmluZy5cclxuICAgICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBmb3JtYXR0ZXIgd2lsbCBkZWZhdWx0IHRvIHRoZSBldmVudFRpbWVGb3JtYXQgc2V0dGluZyxcclxuICAgICAgICAvLyBhbmQgZGlzcGxheUVuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGRpc3BsYXlFdmVudEVuZCBzZXR0aW5nLlxyXG4gICAgICAgIEZnRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGltZVRleHQgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZSwgZm9ybWF0dGVyLCBkaXNwbGF5RW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWYgPSBldmVudFJhbmdlLmRlZiwgaW5zdGFuY2UgPSBldmVudFJhbmdlLmluc3RhbmNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGltZVRleHQoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGRlZi5oYXNFbmQgPyBpbnN0YW5jZS5yYW5nZS5lbmQgOiBudWxsLCBkZWYuYWxsRGF5LCBmb3JtYXR0ZXIsIGRpc3BsYXlFbmQsIGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCBpbnN0YW5jZS5mb3JjZWRFbmRUem8pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5fZ2V0VGltZVRleHQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgYWxsRGF5LCBmb3JtYXR0ZXIsIGRpc3BsYXlFbmQsIGZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem8pIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmNvbnRleHQuZGF0ZUVudjtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdHRlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIgPSB0aGlzLmV2ZW50VGltZUZvcm1hdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlzcGxheUVuZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5RW5kID0gdGhpcy5kaXNwbGF5RXZlbnRFbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheUV2ZW50VGltZSAmJiAhYWxsRGF5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheUVuZCAmJiBlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzdGFydCwgZW5kLCBmb3JtYXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGZvcmNlZFN0YXJ0VHpvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRFbmRUem86IGZvcmNlZEVuZFR6b1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KHN0YXJ0LCBmb3JtYXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkVHpvOiBmb3JjZWRTdGFydFR6b1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZnRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZUV2ZW50VGltZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJyxcclxuICAgICAgICAgICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxyXG4gICAgICAgICAgICAgICAgb21pdFplcm9NaW51dGU6IHRydWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZnRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZURpc3BsYXlFdmVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgZXZlbnQgc2tpbi1yZWxhdGVkIENTUyBwcm9wZXJ0aWVzXHJcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTa2luQ3NzID0gZnVuY3Rpb24gKHVpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHVpLmJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgICAgICdib3JkZXItY29sb3InOiB1aS5ib3JkZXJDb2xvcixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiB1aS50ZXh0Q29sb3JcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZnRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuc29ydEV2ZW50U2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgICAgIHZhciBzcGVjcyA9IHRoaXMuY29udGV4dC52aWV3LmV2ZW50T3JkZXJTcGVjcztcclxuICAgICAgICAgICAgdmFyIG9ianMgPSBzZWdzLm1hcChidWlsZFNlZ0NvbXBhcmVPYmopO1xyXG4gICAgICAgICAgICBvYmpzLnNvcnQoZnVuY3Rpb24gKG9iajAsIG9iajEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIHNwZWNzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmpzLm1hcChmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuX3NlZztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVTaXplcyA9IGZ1bmN0aW9uIChmb3JjZSkge1xyXG4gICAgICAgICAgICBpZiAoZm9yY2UgfHwgdGhpcy5pc1NpemVEaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlU2VnU2l6ZXModGhpcy5zZWdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5hc3NpZ25TaXplcyA9IGZ1bmN0aW9uIChmb3JjZSkge1xyXG4gICAgICAgICAgICBpZiAoZm9yY2UgfHwgdGhpcy5pc1NpemVEaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc3NpZ25TZWdTaXplcyh0aGlzLnNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NpemVEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVTZWdTaXplcyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGZ0V2ZW50UmVuZGVyZXIucHJvdG90eXBlLmFzc2lnblNlZ1NpemVzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIE1hbmlwdWxhdGlvbiBvbiByZW5kZXJlZCBzZWdzXHJcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5oaWRlQnlIYXNoID0gZnVuY3Rpb24gKGhhc2gpIHtcclxuICAgICAgICAgICAgaWYgKGhhc2gpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNlZ3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZyA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaFtzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcuZWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5zaG93QnlIYXNoID0gZnVuY3Rpb24gKGhhc2gpIHtcclxuICAgICAgICAgICAgaWYgKGhhc2gpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNlZ3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZyA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaFtzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcuZWwuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5zZWxlY3RCeUluc3RhbmNlSWQgPSBmdW5jdGlvbiAoaW5zdGFuY2VJZCkge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VJZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2VnczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudEluc3RhbmNlID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2UgJiYgZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkID09PSBpbnN0YW5jZUlkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZy5lbCAvLyBuZWNlc3Nhcnk/XHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZy5lbC5jbGFzc0xpc3QuYWRkKCdmYy1zZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmdFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnNlbGVjdEJ5SW5zdGFuY2VJZCA9IGZ1bmN0aW9uIChpbnN0YW5jZUlkKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUlkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zZWdzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZy5lbCkgeyAvLyBuZWNlc3Nhcnk/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZy5lbC5jbGFzc0xpc3QucmVtb3ZlKCdmYy1zZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEZnRXZlbnRSZW5kZXJlcjtcclxuICAgIH0oKSk7XHJcbiAgICAvLyByZXR1cm5zIGEgb2JqZWN0IHdpdGggYWxsIHByaW1pdGl2ZSBwcm9wcyB0aGF0IGNhbiBiZSBjb21wYXJlZFxyXG4gICAgZnVuY3Rpb24gYnVpbGRTZWdDb21wYXJlT2JqKHNlZykge1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZjtcclxuICAgICAgICB2YXIgcmFuZ2UgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5yYW5nZTtcclxuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydCA/IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA6IDA7IC8vIFRPRE86IGJldHRlciBzdXBwb3J0IGZvciBvcGVuLXJhbmdlIGV2ZW50c1xyXG4gICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQgPyByYW5nZS5lbmQudmFsdWVPZigpIDogMDsgLy8gXCJcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIGV2ZW50RGVmLmV4dGVuZGVkUHJvcHMsIGV2ZW50RGVmLCB7IGlkOiBldmVudERlZi5wdWJsaWNJZCwgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGVuZCwgZHVyYXRpb246IGVuZCAtIHN0YXJ0LCBhbGxEYXk6IE51bWJlcihldmVudERlZi5hbGxEYXkpLCBfc2VnOiBzZWcgLy8gZm9yIGxhdGVyIHJldHJpZXZhbFxyXG4gICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgRmlsbFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEZpbGxSZW5kZXJlcihjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFNlZ1RhZyA9ICdkaXYnO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5U2l6ZUZsYWdzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRWxzQnlUeXBlID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuc2Vnc0J5VHlwZSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmdldFNlZ3NCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWdzQnlUeXBlW3R5cGVdIHx8IFtdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRTZWdzID0gdGhpcy5yZW5kZXJTZWdFbHModHlwZSwgc2Vncyk7IC8vIGFzc2lnbmVzIGAuZWxgIHRvIGVhY2ggc2VnLiByZXR1cm5zIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCBzZWdzXHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXJFbHMgPSB0aGlzLmF0dGFjaFNlZ3ModHlwZSwgcmVuZGVyZWRTZWdzKTtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lckVscykge1xyXG4gICAgICAgICAgICAgICAgKF9hID0gKHRoaXMuY29udGFpbmVyRWxzQnlUeXBlW3R5cGVdIHx8ICh0aGlzLmNvbnRhaW5lckVsc0J5VHlwZVt0eXBlXSA9IFtdKSkpLnB1c2guYXBwbHkoX2EsIGNvbnRhaW5lckVscyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZWdzQnlUeXBlW3R5cGVdID0gcmVuZGVyZWRTZWdzO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2JnRXZlbnQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudmlldy50cmlnZ2VyUmVuZGVyZWRTZWdzKHJlbmRlcmVkU2VncywgZmFsc2UpOyAvLyBpc01pcnJvcj1mYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHlTaXplRmxhZ3NbdHlwZV0gPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gVW5yZW5kZXJzIGEgc3BlY2lmaWMgdHlwZSBvZiBmaWxsIHRoYXQgaXMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXHJcbiAgICAgICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdzID0gdGhpcy5zZWdzQnlUeXBlW3R5cGVdO1xyXG4gICAgICAgICAgICBpZiAoc2Vncykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdiZ0V2ZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC52aWV3LnRyaWdnZXJXaWxsUmVtb3ZlU2VncyhzZWdzLCBmYWxzZSk7IC8vIGlzTWlycm9yPWZhbHNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaFNlZ3ModHlwZSwgc2Vncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICAgICAgLy8gT25seSByZXR1cm5zIHNlZ21lbnRzIHRoYXQgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkLlxyXG4gICAgICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGh0bWwgPSAnJztcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGlmIChzZWdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIHNlZ21lbnQgSFRNTFxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMucmVuZGVyU2VnSHRtbCh0eXBlLCBzZWdzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEdyYWIgaW5kaXZpZHVhbCBlbGVtZW50cyBmcm9tIHRoZSBjb21iaW5lZCBIVE1MIHN0cmluZy4gVXNlIGVhY2ggYXMgdGhlIGRlZmF1bHQgcmVuZGVyaW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlbiwgY29tcHV0ZSB0aGUgJ2VsJyBmb3IgZWFjaCBzZWdtZW50LlxyXG4gICAgICAgICAgICAgICAgaHRtbFRvRWxlbWVudHMoaHRtbCkuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnLmVsID0gZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2JnRXZlbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VncyA9IGZpbHRlclNlZ3NWaWFFbHModGhpcy5jb250ZXh0LnZpZXcsIHNlZ3MsIGZhbHNlIC8vIGlzTWlycm9yLiBiYWNrZ3JvdW5kIGV2ZW50cyBjYW4gbmV2ZXIgYmUgbWlycm9yIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgZWxlbWVudCB0eXBlPyAod291bGQgYmUgYmFkIGlmIGEgbm9uLVREIHdlcmUgaW5zZXJ0ZWQgaW50byBhIHRhYmxlIGZvciBleGFtcGxlKVxyXG4gICAgICAgICAgICAgICAgc2VncyA9IHNlZ3MuZmlsdGVyKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudE1hdGNoZXMoc2VnLmVsLCBfdGhpcy5maWxsU2VnVGFnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBIVE1MIG5lZWRlZCBmb3Igb25lIGZpbGwgc2VnbWVudC4gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGRpZmZlcmVudCB0eXBlcy5cclxuICAgICAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ0h0bWwgPSBmdW5jdGlvbiAodHlwZSwgc2VnKSB7XHJcbiAgICAgICAgICAgIHZhciBjc3MgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gJ2hpZ2hsaWdodCcgJiYgdHlwZSAhPT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgICAgICBjc3MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBzZWcuZXZlbnRSYW5nZS51aS5iYWNrZ3JvdW5kQ29sb3JcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdoaWdobGlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5jb25jYXQoc2VnLmV2ZW50UmFuZ2UudWkuY2xhc3NOYW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdidXNpbmVzc0hvdXJzJykge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1iZ2V2ZW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLScgKyB0eXBlLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnPCcgKyB0aGlzLmZpbGxTZWdUYWcgK1xyXG4gICAgICAgICAgICAgICAgKGNsYXNzTmFtZXMubGVuZ3RoID8gJyBjbGFzcz1cIicgKyBjbGFzc05hbWVzLmpvaW4oJyAnKSArICdcIicgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgKGNzcyA/ICcgc3R5bGU9XCInICsgY3NzVG9TdHIoY3NzKSArICdcIicgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgJz48LycgKyB0aGlzLmZpbGxTZWdUYWcgKyAnPic7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmRldGFjaFNlZ3MgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyRWxzID0gdGhpcy5jb250YWluZXJFbHNCeVR5cGVbdHlwZV07XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXJFbHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVscy5mb3JFYWNoKHJlbW92ZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGFpbmVyRWxzQnlUeXBlW3R5cGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVTaXplcyA9IGZ1bmN0aW9uIChmb3JjZSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuc2Vnc0J5VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlIHx8IHRoaXMuZGlydHlTaXplRmxhZ3NbdHlwZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVTZWdTaXplcyh0aGlzLnNlZ3NCeVR5cGVbdHlwZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmFzc2lnblNpemVzID0gZnVuY3Rpb24gKGZvcmNlKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5zZWdzQnlUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UgfHwgdGhpcy5kaXJ0eVNpemVGbGFnc1t0eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduU2VnU2l6ZXModGhpcy5zZWdzQnlUeXBlW3R5cGVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5U2l6ZUZsYWdzID0ge307XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVTZWdTaXplcyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmFzc2lnblNlZ1NpemVzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBGaWxsUmVuZGVyZXI7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIHZhciBOYW1lZFRpbWVab25lSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBOYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lWm9uZU5hbWUgPSB0aW1lWm9uZU5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOYW1lZFRpbWVab25lSW1wbDtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgLypcclxuICAgIEFuIGFic3RyYWN0aW9uIGZvciBhIGRyYWdnaW5nIGludGVyYWN0aW9uIG9yaWdpbmF0aW5nIG9uIGFuIGV2ZW50LlxyXG4gICAgRG9lcyBoaWdoZXItbGV2ZWwgdGhpbmdzIHRoYW4gUG9pbnRlckRyYWdnZXIsIHN1Y2ggYXMgcG9zc2libHk6XHJcbiAgICAtIGEgXCJtaXJyb3JcIiB0aGF0IG1vdmVzIHdpdGggdGhlIHBvaW50ZXJcclxuICAgIC0gYSBtaW5pbXVtIG51bWJlciBvZiBwaXhlbHMgb3Igb3RoZXIgY3JpdGVyaWEgZm9yIGEgdHJ1ZSBkcmFnIHRvIGJlZ2luXHJcblxyXG4gICAgc3ViY2xhc3NlcyBtdXN0IGVtaXQ6XHJcbiAgICAtIHBvaW50ZXJkb3duXHJcbiAgICAtIGRyYWdzdGFydFxyXG4gICAgLSBkcmFnbW92ZVxyXG4gICAgLSBwb2ludGVydXBcclxuICAgIC0gZHJhZ2VuZFxyXG4gICAgKi9cclxuICAgIHZhciBFbGVtZW50RHJhZ2dpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRWxlbWVudERyYWdnaW5nKGVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyTWl4aW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JJc1Zpc2libGUgPSBmdW5jdGlvbiAoYm9vbCkge1xyXG4gICAgICAgICAgICAvLyBvcHRpb25hbCBpZiBzdWJjbGFzcyBkb2Vzbid0IHdhbnQgdG8gc3VwcG9ydCBhIG1pcnJvclxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JOZWVkc1JldmVydCA9IGZ1bmN0aW9uIChib29sKSB7XHJcbiAgICAgICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldEF1dG9TY3JvbGxFbmFibGVkID0gZnVuY3Rpb24gKGJvb2wpIHtcclxuICAgICAgICAgICAgLy8gb3B0aW9uYWxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFbGVtZW50RHJhZ2dpbmc7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZUlucHV0LCBzZXR0aW5ncykge1xyXG4gICAgICAgIGlmIChzZXR0aW5ncyA9PT0gdm9pZCAwKSB7IHNldHRpbmdzID0ge307IH1cclxuICAgICAgICB2YXIgZGF0ZUVudiA9IGJ1aWxkRGF0ZUVudiQxKHNldHRpbmdzKTtcclxuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzKTtcclxuICAgICAgICB2YXIgZGF0ZU1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZGF0ZUlucHV0KTtcclxuICAgICAgICBpZiAoIWRhdGVNZXRhKSB7IC8vIFRPRE86IHdhcm5pbmc/XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGRhdGVNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XHJcbiAgICAgICAgICAgIGZvcmNlZFR6bzogZGF0ZU1ldGEuZm9yY2VkVHpvXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRSYW5nZShzdGFydElucHV0LCBlbmRJbnB1dCwgc2V0dGluZ3MgLy8gbWl4dHVyZSBvZiBlbnYgYW5kIGZvcm1hdHRlciBzZXR0aW5nc1xyXG4gICAgKSB7XHJcbiAgICAgICAgdmFyIGRhdGVFbnYgPSBidWlsZERhdGVFbnYkMSh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnICYmIHNldHRpbmdzID8gc2V0dGluZ3MgOiB7fSk7IC8vIHBhc3MgaW4gaWYgbm9uLW51bGwgb2JqZWN0XHJcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihzZXR0aW5ncywgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yKTtcclxuICAgICAgICB2YXIgc3RhcnRNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YXJ0SW5wdXQpO1xyXG4gICAgICAgIHZhciBlbmRNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGVuZElucHV0KTtcclxuICAgICAgICBpZiAoIXN0YXJ0TWV0YSB8fCAhZW5kTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHN0YXJ0TWV0YS5tYXJrZXIsIGVuZE1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcclxuICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YS5mb3JjZWRUem8sXHJcbiAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YS5mb3JjZWRUem8sXHJcbiAgICAgICAgICAgIGlzRW5kRXhjbHVzaXZlOiBzZXR0aW5ncy5pc0VuZEV4Y2x1c2l2ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxyXG4gICAgZnVuY3Rpb24gYnVpbGREYXRlRW52JDEoc2V0dGluZ3MpIHtcclxuICAgICAgICB2YXIgbG9jYWxlID0gYnVpbGRMb2NhbGUoc2V0dGluZ3MubG9jYWxlIHx8ICdlbicsIHBhcnNlUmF3TG9jYWxlcyhbXSkubWFwKTsgLy8gVE9ETzogZG9uJ3QgaGFyZGNvZGUgJ2VuJyBldmVyeXdoZXJlXHJcbiAgICAgICAgLy8gZW5zdXJlIHJlcXVpcmVkIHNldHRpbmdzXHJcbiAgICAgICAgc2V0dGluZ3MgPSBfX2Fzc2lnbih7IHRpbWVab25lOiBnbG9iYWxEZWZhdWx0cy50aW1lWm9uZSwgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyB9LCBzZXR0aW5ncywgeyBsb2NhbGU6IGxvY2FsZSB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGVFbnYoc2V0dGluZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBEUkFHX01FVEFfUFJPUFMgPSB7XHJcbiAgICAgICAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcclxuICAgICAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXHJcbiAgICAgICAgY3JlYXRlOiBCb29sZWFuLFxyXG4gICAgICAgIHNvdXJjZUlkOiBTdHJpbmdcclxuICAgIH07XHJcbiAgICB2YXIgRFJBR19NRVRBX0RFRkFVTFRTID0ge1xyXG4gICAgICAgIGNyZWF0ZTogdHJ1ZVxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHBhcnNlRHJhZ01ldGEocmF3KSB7XHJcbiAgICAgICAgdmFyIGxlZnRvdmVyUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgcmVmaW5lZCA9IHJlZmluZVByb3BzKHJhdywgRFJBR19NRVRBX1BST1BTLCBEUkFHX01FVEFfREVGQVVMVFMsIGxlZnRvdmVyUHJvcHMpO1xyXG4gICAgICAgIHJlZmluZWQubGVmdG92ZXJQcm9wcyA9IGxlZnRvdmVyUHJvcHM7XHJcbiAgICAgICAgcmV0dXJuIHJlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0KGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXlDbnQpIHtcclxuICAgICAgICAvLyBpZiBtb3JlIHRoYW4gb25lIHdlZWsgcm93LCBvciBpZiB0aGVyZSBhcmUgYSBsb3Qgb2YgY29sdW1ucyB3aXRoIG5vdCBtdWNoIHNwYWNlLFxyXG4gICAgICAgIC8vIHB1dCBqdXN0IHRoZSBkYXkgbnVtYmVycyB3aWxsIGJlIGluIGVhY2ggY2VsbFxyXG4gICAgICAgIGlmICghZGF0ZXNSZXBEaXN0aW5jdERheXMgfHwgZGF5Q250ID4gMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgd2Vla2RheTogJ3Nob3J0JyB9OyAvLyBcIlNhdFwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRheUNudCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdudW1lcmljJywgZGF5OiAnbnVtZXJpYycsIG9taXRDb21tYXM6IHRydWUgfTsgLy8gXCJTYXQgMTEvMTJcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgd2Vla2RheTogJ2xvbmcnIH07IC8vIFwiU2F0dXJkYXlcIlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlckRhdGVDZWxsKGRhdGVNYXJrZXIsIGRhdGVQcm9maWxlLCBkYXRlc1JlcERpc3RpbmN0RGF5cywgY29sQ250LCBjb2xIZWFkRm9ybWF0LCBjb250ZXh0LCBjb2xzcGFuLCBvdGhlckF0dHJzKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSBjb250ZXh0LnZpZXcsIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIHRoZW1lID0gY29udGV4dC50aGVtZSwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcclxuICAgICAgICB2YXIgaXNEYXRlVmFsaWQgPSByYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBkYXRlTWFya2VyKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAnZmMtZGF5LWhlYWRlcicsXHJcbiAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIGlubmVySHRtbDtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29sdW1uSGVhZGVySHRtbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpbm5lckh0bWwgPSBvcHRpb25zLmNvbHVtbkhlYWRlckh0bWwoZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5jb2x1bW5IZWFkZXJUZXh0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlubmVySHRtbCA9IGh0bWxFc2NhcGUob3B0aW9ucy5jb2x1bW5IZWFkZXJUZXh0KGRhdGVFbnYudG9EYXRlKGRhdGVNYXJrZXIpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbm5lckh0bWwgPSBodG1sRXNjYXBlKGRhdGVFbnYuZm9ybWF0KGRhdGVNYXJrZXIsIGNvbEhlYWRGb3JtYXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgb25seSBvbmUgcm93IG9mIGRheXMsIHRoZSBjbGFzc05hbWVzIG9uIHRoZSBoZWFkZXIgY2FuIHJlcHJlc2VudCB0aGUgc3BlY2lmaWMgZGF5cyBiZW5lYXRoXHJcbiAgICAgICAgaWYgKGRhdGVzUmVwRGlzdGluY3REYXlzKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzLmNvbmNhdChcclxuICAgICAgICAgICAgLy8gaW5jbHVkZXMgdGhlIGRheS1vZi13ZWVrIGNsYXNzXHJcbiAgICAgICAgICAgIC8vIG5vVGhlbWVIaWdobGlnaHQ9dHJ1ZSAoZG9uJ3QgaGlnaGxpZ2h0IHRoZSBoZWFkZXIpXHJcbiAgICAgICAgICAgIGdldERheUNsYXNzZXMoZGF0ZU1hcmtlciwgZGF0ZVByb2ZpbGUsIGNvbnRleHQsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtJyArIERBWV9JRFNbZGF0ZU1hcmtlci5nZXRVVENEYXkoKV0pOyAvLyBvbmx5IGFkZCB0aGUgZGF5LW9mLXdlZWsgY2xhc3NcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0aCBjbGFzcz1cIicgKyBjbGFzc05hbWVzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAoKGlzRGF0ZVZhbGlkICYmIGRhdGVzUmVwRGlzdGluY3REYXlzKSA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlRW52LmZvcm1hdElzbyhkYXRlTWFya2VyLCB7IG9taXRUaW1lOiB0cnVlIH0pICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoY29sc3BhbiA+IDEgP1xyXG4gICAgICAgICAgICAgICAgJyBjb2xzcGFuPVwiJyArIGNvbHNwYW4gKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChvdGhlckF0dHJzID9cclxuICAgICAgICAgICAgICAgICcgJyArIG90aGVyQXR0cnMgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgKGlzRGF0ZVZhbGlkID9cclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IG1ha2UgYSBsaW5rIGlmIHRoZSBoZWFkaW5nIGNvdWxkIHJlcHJlc2VudCBtdWx0aXBsZSBkYXlzLCBvciBpZiB0aGVyZSdzIG9ubHkgb25lIGRheSAoZm9yY2VPZmYpXHJcbiAgICAgICAgICAgICAgICBidWlsZEdvdG9BbmNob3JIdG1sKHZpZXcsIHsgZGF0ZTogZGF0ZU1hcmtlciwgZm9yY2VPZmY6ICFkYXRlc1JlcERpc3RpbmN0RGF5cyB8fCBjb2xDbnQgPT09IDEgfSwgaW5uZXJIdG1sKSA6XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgdmFsaWQsIGRpc3BsYXkgdGV4dCwgYnV0IG5vIGxpbmtcclxuICAgICAgICAgICAgICAgIGlubmVySHRtbCkgK1xyXG4gICAgICAgICAgICAnPC90aD4nO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBEYXlIZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKERheUhlYWRlciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBEYXlIZWFkZXIoY29udGV4dCwgcGFyZW50RWwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCkgfHwgdGhpcztcclxuICAgICAgICAgICAgcGFyZW50RWwuaW5uZXJIVE1MID0gJyc7IC8vIGJlY2F1c2UgbWlnaHQgYmUgbmJzcFxyXG4gICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChfdGhpcy5lbCA9IGh0bWxUb0VsZW1lbnQoJzxkaXYgY2xhc3M9XCJmYy1yb3cgJyArIF90aGlzLnRoZW1lLmdldENsYXNzKCdoZWFkZXJSb3cnKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgX3RoaXMudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgJzx0aGVhZD48L3RoZWFkPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JykpO1xyXG4gICAgICAgICAgICBfdGhpcy50aGVhZCA9IF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ3RoZWFkJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgRGF5SGVhZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZW1vdmVFbGVtZW50KHRoaXMuZWwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF5SGVhZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVzID0gcHJvcHMuZGF0ZXMsIGRhdGVzUmVwRGlzdGluY3REYXlzID0gcHJvcHMuZGF0ZXNSZXBEaXN0aW5jdERheXM7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMucmVuZGVySW50cm9IdG1sKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHByb3BzLnJlbmRlckludHJvSHRtbCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29sSGVhZEZvcm1hdCA9IGNyZWF0ZUZvcm1hdHRlcih0aGlzLm9wdCgnY29sdW1uSGVhZGVyRm9ybWF0JykgfHxcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZXMubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZGF0ZXNfMSA9IGRhdGVzOyBfaSA8IGRhdGVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IGRhdGVzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChyZW5kZXJEYXRlQ2VsbChkYXRlLCBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVzLmxlbmd0aCwgY29sSGVhZEZvcm1hdCwgdGhpcy5jb250ZXh0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSdGwpIHtcclxuICAgICAgICAgICAgICAgIHBhcnRzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRoZWFkLmlubmVySFRNTCA9ICc8dHI+JyArIHBhcnRzLmpvaW4oJycpICsgJzwvdHI+JztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEYXlIZWFkZXI7XHJcbiAgICB9KENvbXBvbmVudCkpO1xyXG5cclxuICAgIHZhciBEYXlTZXJpZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRGF5U2VyaWVzKHJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHJhbmdlLnN0YXJ0O1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gcmFuZ2UuZW5kO1xyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgZGF0ZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGRheUluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIHdoaWxlIChkYXRlIDwgZW5kKSB7IC8vIGxvb3AgZWFjaCBkYXkgZnJvbSBzdGFydCB0byBlbmRcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZUdlbmVyYXRvci5pc0hpZGRlbkRheShkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChkYXlJbmRleCArIDAuNSk7IC8vIG1hcmsgdGhhdCBpdCdzIGJldHdlZW4gaW5kaWNlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF5SW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVzLnB1c2goZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkYXRlID0gYWRkRGF5cyhkYXRlLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRhdGVzID0gZGF0ZXM7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlcyA9IGluZGljZXM7XHJcbiAgICAgICAgICAgIHRoaXMuY250ID0gZGF0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEYXlTZXJpZXMucHJvdG90eXBlLnNsaWNlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChyYW5nZS5zdGFydCk7IC8vIGluY2x1c2l2ZSBmaXJzdCBpbmRleFxyXG4gICAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgoYWRkRGF5cyhyYW5nZS5lbmQsIC0xKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XHJcbiAgICAgICAgICAgIHZhciBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGgubWF4KDAsIGZpcnN0SW5kZXgpO1xyXG4gICAgICAgICAgICB2YXIgY2xpcHBlZExhc3RJbmRleCA9IE1hdGgubWluKHRoaXMuY250IC0gMSwgbGFzdEluZGV4KTtcclxuICAgICAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xyXG4gICAgICAgICAgICBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGguY2VpbChjbGlwcGVkRmlyc3RJbmRleCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxyXG4gICAgICAgICAgICBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5mbG9vcihjbGlwcGVkTGFzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxyXG4gICAgICAgICAgICBpZiAoY2xpcHBlZEZpcnN0SW5kZXggPD0gY2xpcHBlZExhc3RJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdEluZGV4OiBjbGlwcGVkRmlyc3RJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXg6IGNsaXBwZWRMYXN0SW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogZmlyc3RJbmRleCA9PT0gY2xpcHBlZEZpcnN0SW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IGxhc3RJbmRleCA9PT0gY2xpcHBlZExhc3RJbmRleFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHaXZlbiBhIGRhdGUsIHJldHVybnMgaXRzIGNocm9ub2xvY2lhbCBjZWxsLWluZGV4IGZyb20gdGhlIGZpcnN0IGNlbGwgb2YgdGhlIGdyaWQuXHJcbiAgICAgICAgLy8gSWYgdGhlIGRhdGUgbGllcyBiZXR3ZWVuIGNlbGxzIChiZWNhdXNlIG9mIGhpZGRlbkRheXMpLCByZXR1cm5zIGEgZmxvYXRpbmctcG9pbnQgdmFsdWUgYmV0d2VlbiBvZmZzZXRzLlxyXG4gICAgICAgIC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxyXG4gICAgICAgIC8vIElmIGFmdGVyIHRoZSBsYXN0IG9mZnNldCwgcmV0dXJucyBhbiBvZmZzZXQgcGFzdCB0aGUgbGFzdCBjZWxsIG9mZnNldC5cclxuICAgICAgICAvLyBPbmx5IHdvcmtzIGZvciAqc3RhcnQqIGRhdGVzIG9mIGNlbGxzLiBXaWxsIG5vdCB3b3JrIGZvciBleGNsdXNpdmUgZW5kIGRhdGVzIGZvciBjZWxscy5cclxuICAgICAgICBEYXlTZXJpZXMucHJvdG90eXBlLmdldERhdGVEYXlJbmRleCA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xyXG4gICAgICAgICAgICB2YXIgZGF5T2Zmc2V0ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aGlzLmRhdGVzWzBdLCBkYXRlKSk7XHJcbiAgICAgICAgICAgIGlmIChkYXlPZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kaWNlc1swXSAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF5T2Zmc2V0ID49IGluZGljZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRpY2VzW2RheU9mZnNldF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEYXlTZXJpZXM7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIHZhciBEYXlUYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEYXlUYWJsZShkYXlTZXJpZXMsIGJyZWFrT25XZWVrcykge1xyXG4gICAgICAgICAgICB2YXIgZGF0ZXMgPSBkYXlTZXJpZXMuZGF0ZXM7XHJcbiAgICAgICAgICAgIHZhciBkYXlzUGVyUm93O1xyXG4gICAgICAgICAgICB2YXIgZmlyc3REYXk7XHJcbiAgICAgICAgICAgIHZhciByb3dDbnQ7XHJcbiAgICAgICAgICAgIGlmIChicmVha09uV2Vla3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvdW50IGNvbHVtbnMgdW50aWwgdGhlIGRheS1vZi13ZWVrIHJlcGVhdHNcclxuICAgICAgICAgICAgICAgIGZpcnN0RGF5ID0gZGF0ZXNbMF0uZ2V0VVRDRGF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZXNbZGF5c1BlclJvd10uZ2V0VVRDRGF5KCkgPT09IGZpcnN0RGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvd0NudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBkYXlzUGVyUm93ID0gZGF0ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucm93Q250ID0gcm93Q250O1xyXG4gICAgICAgICAgICB0aGlzLmNvbENudCA9IGRheXNQZXJSb3c7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5U2VyaWVzID0gZGF5U2VyaWVzO1xyXG4gICAgICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy5idWlsZENlbGxzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyRGF0ZXMgPSB0aGlzLmJ1aWxkSGVhZGVyRGF0ZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRGF5VGFibGUucHJvdG90eXBlLmJ1aWxkQ2VsbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByb3dzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHRoaXMuYnVpbGRDZWxsKHJvdywgY29sKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByb3dzLnB1c2goY2VsbHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByb3dzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF5VGFibGUucHJvdG90eXBlLmJ1aWxkQ2VsbCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZGF0ZTogdGhpcy5kYXlTZXJpZXMuZGF0ZXNbcm93ICogdGhpcy5jb2xDbnQgKyBjb2xdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXlUYWJsZS5wcm90b3R5cGUuYnVpbGRIZWFkZXJEYXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICAgICAgZGF0ZXMucHVzaCh0aGlzLmNlbGxzWzBdW2NvbF0uZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF5VGFibGUucHJvdG90eXBlLnNsaWNlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgdmFyIGNvbENudCA9IHRoaXMuY29sQ250O1xyXG4gICAgICAgICAgICB2YXIgc2VyaWVzU2VnID0gdGhpcy5kYXlTZXJpZXMuc2xpY2VSYW5nZShyYW5nZSk7XHJcbiAgICAgICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgICAgIGlmIChzZXJpZXNTZWcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdEluZGV4ID0gc2VyaWVzU2VnLmZpcnN0SW5kZXgsIGxhc3RJbmRleCA9IHNlcmllc1NlZy5sYXN0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBmaXJzdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDw9IGxhc3RJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gY29sQ250KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gTWF0aC5taW4oKHJvdyArIDEpICogY29sQ250LCBsYXN0SW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RDb2w6IGluZGV4ICUgY29sQ250LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q29sOiAobmV4dEluZGV4IC0gMSkgJSBjb2xDbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlcmllc1NlZy5pc1N0YXJ0ICYmIGluZGV4ID09PSBmaXJzdEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VyaWVzU2VnLmlzRW5kICYmIChuZXh0SW5kZXggLSAxKSA9PT0gbGFzdEluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRGF5VGFibGU7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIHZhciBTbGljZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gU2xpY2VyKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNsaWNlQnVzaW5lc3NIb3VycyA9IG1lbW9pemUodGhpcy5fc2xpY2VCdXNpbmVzc0hvdXJzKTtcclxuICAgICAgICAgICAgdGhpcy5zbGljZURhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NsaWNlRGF0ZVNwYW4pO1xyXG4gICAgICAgICAgICB0aGlzLnNsaWNlRXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc2xpY2VFdmVudFN0b3JlKTtcclxuICAgICAgICAgICAgdGhpcy5zbGljZUV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuc2xpY2VFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNsaWNlci5wcm90b3R5cGUuc2xpY2VQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGV2ZW50VWlCYXNlcyA9IHByb3BzLmV2ZW50VWlCYXNlcztcclxuICAgICAgICAgICAgdmFyIGV2ZW50U2VncyA9IHRoaXMuc2xpY2VFdmVudFN0b3JlLmFwcGx5KHRoaXMsIFtwcm9wcy5ldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb21wb25lbnRdLmNvbmNhdChleHRyYUFyZ3MpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25TZWdzOiB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbi5hcHBseSh0aGlzLCBbcHJvcHMuZGF0ZVNlbGVjdGlvbiwgZXZlbnRVaUJhc2VzLCBjb21wb25lbnRdLmNvbmNhdChleHRyYUFyZ3MpKSxcclxuICAgICAgICAgICAgICAgIGJ1c2luZXNzSG91clNlZ3M6IHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzLmFwcGx5KHRoaXMsIFtwcm9wcy5idXNpbmVzc0hvdXJzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29tcG9uZW50XS5jb25jYXQoZXh0cmFBcmdzKSksXHJcbiAgICAgICAgICAgICAgICBmZ0V2ZW50U2VnczogZXZlbnRTZWdzLmZnLFxyXG4gICAgICAgICAgICAgICAgYmdFdmVudFNlZ3M6IGV2ZW50U2Vncy5iZyxcclxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogdGhpcy5zbGljZUV2ZW50RHJhZy5hcHBseSh0aGlzLCBbcHJvcHMuZXZlbnREcmFnLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb21wb25lbnRdLmNvbmNhdChleHRyYUFyZ3MpKSxcclxuICAgICAgICAgICAgICAgIGV2ZW50UmVzaXplOiB0aGlzLnNsaWNlRXZlbnRSZXNpemUuYXBwbHkodGhpcywgW3Byb3BzLmV2ZW50UmVzaXplLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb21wb25lbnRdLmNvbmNhdChleHRyYUFyZ3MpKSxcclxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvblxyXG4gICAgICAgICAgICB9OyAvLyBUT0RPOiBnaXZlIGludGVyYWN0aW9uU2Vncz9cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNsaWNlci5wcm90b3R5cGUuc2xpY2VOb3dEYXRlID0gZnVuY3Rpb24gKC8vIGRvZXMgbm90IG1lbW9pemVcclxuICAgICAgICBkYXRlLCBjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhQXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFBcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zbGljZURhdGVTcGFuLmFwcGx5KHRoaXMsIFt7IHJhbmdlOiB7IHN0YXJ0OiBkYXRlLCBlbmQ6IGFkZE1zKGRhdGUsIDEpIH0sIGFsbERheTogZmFsc2UgfSxcclxuICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50XS5jb25jYXQoZXh0cmFBcmdzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTbGljZXIucHJvdG90eXBlLl9zbGljZUJ1c2luZXNzSG91cnMgPSBmdW5jdGlvbiAoYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFidXNpbmVzc0hvdXJzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRXZlbnRTdG9yZS5hcHBseSh0aGlzLCBbZXhwYW5kUmVjdXJyaW5nKGJ1c2luZXNzSG91cnMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIGNvbXBvbmVudC5jYWxlbmRhciksXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlLFxyXG4gICAgICAgICAgICAgICAgbmV4dERheVRocmVzaG9sZCxcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudF0uY29uY2F0KGV4dHJhQXJncykpLmJnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VFdmVudFN0b3JlID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gNTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA1XSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2ZW50U3RvcmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIG5leHREYXlUaHJlc2hvbGQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBiZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmJnLCBjb21wb25lbnQsIGV4dHJhQXJncyksXHJcbiAgICAgICAgICAgICAgICAgICAgZmc6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgY29tcG9uZW50LCBleHRyYUFyZ3MpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgYmc6IFtdLCBmZzogW10gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChpbnRlcmFjdGlvbiwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSA1OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDVdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNlZ3M6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgY29tcG9uZW50LCBleHRyYUFyZ3MpLFxyXG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLmluc3RhbmNlcyxcclxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VTZWc6IGludGVyYWN0aW9uLm9yaWdTZWdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNsaWNlci5wcm90b3R5cGUuX3NsaWNlRGF0ZVNwYW4gPSBmdW5jdGlvbiAoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWRhdGVTcGFuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuLCBldmVudFVpQmFzZXMsIGNvbXBvbmVudC5jYWxlbmRhcik7XHJcbiAgICAgICAgICAgIHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlLmFwcGx5KHRoaXMsIFtkYXRlU3Bhbi5yYW5nZV0uY29uY2F0KGV4dHJhQXJncykpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHNlZ3NfMSA9IHNlZ3M7IF9hIDwgc2Vnc18xLmxlbmd0aDsgX2ErKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMVtfYV07XHJcbiAgICAgICAgICAgICAgICBzZWcuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLypcclxuICAgICAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcclxuICAgICAgICAqL1xyXG4gICAgICAgIFNsaWNlci5wcm90b3R5cGUuc2xpY2VFdmVudFJhbmdlcyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcywgY29tcG9uZW50LCAvLyBUT0RPOiBraWxsXHJcbiAgICAgICAgZXh0cmFBcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZXZlbnRSYW5nZXNfMSA9IGV2ZW50UmFuZ2VzOyBfaSA8IGV2ZW50UmFuZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2VzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoLmFwcGx5KHNlZ3MsIHRoaXMuc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGNvbXBvbmVudCwgZXh0cmFBcmdzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgU2xpY2VyLnByb3RvdHlwZS5zbGljZUV2ZW50UmFuZ2UgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZSwgY29tcG9uZW50LCAvLyBUT0RPOiBraWxsXHJcbiAgICAgICAgZXh0cmFBcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlLmFwcGx5KHRoaXMsIFtldmVudFJhbmdlLnJhbmdlXS5jb25jYXQoZXh0cmFBcmdzKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc2Vnc18yID0gc2VnczsgX2kgPCBzZWdzXzIubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18yW19pXTtcclxuICAgICAgICAgICAgICAgIHNlZy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XHJcbiAgICAgICAgICAgICAgICBzZWcuaXNTdGFydCA9IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWcuaXNTdGFydDtcclxuICAgICAgICAgICAgICAgIHNlZy5pc0VuZCA9IGV2ZW50UmFuZ2UuaXNFbmQgJiYgc2VnLmlzRW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNsaWNlcjtcclxuICAgIH0oKSk7XHJcbiAgICAvKlxyXG4gICAgZm9yIGluY29ycG9yYXRpbmcgbWluVGltZS9tYXhUaW1lIGlmIGFwcHJvcHJpYXRlXHJcbiAgICBUT0RPOiBzaG91bGQgYmUgcGFydCBvZiBEYXRlUHJvZmlsZSFcclxuICAgIFRpbWVsaW5lRGF0ZVByb2ZpbGUgYWxyZWFkeSBkb2VzIHRoaXMgYnR3XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBpc0NvbXBvbmVudEFsbERheSkge1xyXG4gICAgICAgIHZhciByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xyXG4gICAgICAgIGlmIChpc0NvbXBvbmVudEFsbERheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBhZGRNcyhyYW5nZS5zdGFydCwgZGF0ZVByb2ZpbGUubWluVGltZS5taWxsaXNlY29uZHMpLFxyXG4gICAgICAgICAgICBlbmQ6IGFkZE1zKHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGUubWF4VGltZS5taWxsaXNlY29uZHMgLSA4NjRlNSkgLy8gODY0ZTUgPSBtcyBpbiBhIGRheVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXhwb3J0c1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHZhciB2ZXJzaW9uID0gJzQuMy4xJztcclxuXHJcbiAgICBleHBvcnRzLkNhbGVuZGFyID0gQ2FsZW5kYXI7XHJcbiAgICBleHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcclxuICAgIGV4cG9ydHMuRGF0ZUNvbXBvbmVudCA9IERhdGVDb21wb25lbnQ7XHJcbiAgICBleHBvcnRzLkRhdGVFbnYgPSBEYXRlRW52O1xyXG4gICAgZXhwb3J0cy5EYXRlUHJvZmlsZUdlbmVyYXRvciA9IERhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG4gICAgZXhwb3J0cy5EYXlIZWFkZXIgPSBEYXlIZWFkZXI7XHJcbiAgICBleHBvcnRzLkRheVNlcmllcyA9IERheVNlcmllcztcclxuICAgIGV4cG9ydHMuRGF5VGFibGUgPSBEYXlUYWJsZTtcclxuICAgIGV4cG9ydHMuRWxlbWVudERyYWdnaW5nID0gRWxlbWVudERyYWdnaW5nO1xyXG4gICAgZXhwb3J0cy5FbGVtZW50U2Nyb2xsQ29udHJvbGxlciA9IEVsZW1lbnRTY3JvbGxDb250cm9sbGVyO1xyXG4gICAgZXhwb3J0cy5FbWl0dGVyTWl4aW4gPSBFbWl0dGVyTWl4aW47XHJcbiAgICBleHBvcnRzLkV2ZW50QXBpID0gRXZlbnRBcGk7XHJcbiAgICBleHBvcnRzLkZnRXZlbnRSZW5kZXJlciA9IEZnRXZlbnRSZW5kZXJlcjtcclxuICAgIGV4cG9ydHMuRmlsbFJlbmRlcmVyID0gRmlsbFJlbmRlcmVyO1xyXG4gICAgZXhwb3J0cy5JbnRlcmFjdGlvbiA9IEludGVyYWN0aW9uO1xyXG4gICAgZXhwb3J0cy5NaXhpbiA9IE1peGluO1xyXG4gICAgZXhwb3J0cy5OYW1lZFRpbWVab25lSW1wbCA9IE5hbWVkVGltZVpvbmVJbXBsO1xyXG4gICAgZXhwb3J0cy5Qb3NpdGlvbkNhY2hlID0gUG9zaXRpb25DYWNoZTtcclxuICAgIGV4cG9ydHMuU2Nyb2xsQ29tcG9uZW50ID0gU2Nyb2xsQ29tcG9uZW50O1xyXG4gICAgZXhwb3J0cy5TY3JvbGxDb250cm9sbGVyID0gU2Nyb2xsQ29udHJvbGxlcjtcclxuICAgIGV4cG9ydHMuU2xpY2VyID0gU2xpY2VyO1xyXG4gICAgZXhwb3J0cy5TcGxpdHRlciA9IFNwbGl0dGVyO1xyXG4gICAgZXhwb3J0cy5UaGVtZSA9IFRoZW1lO1xyXG4gICAgZXhwb3J0cy5WaWV3ID0gVmlldztcclxuICAgIGV4cG9ydHMuV2luZG93U2Nyb2xsQ29udHJvbGxlciA9IFdpbmRvd1Njcm9sbENvbnRyb2xsZXI7XHJcbiAgICBleHBvcnRzLmFkZERheXMgPSBhZGREYXlzO1xyXG4gICAgZXhwb3J0cy5hZGREdXJhdGlvbnMgPSBhZGREdXJhdGlvbnM7XHJcbiAgICBleHBvcnRzLmFkZE1zID0gYWRkTXM7XHJcbiAgICBleHBvcnRzLmFkZFdlZWtzID0gYWRkV2Vla3M7XHJcbiAgICBleHBvcnRzLmFsbG93Q29udGV4dE1lbnUgPSBhbGxvd0NvbnRleHRNZW51O1xyXG4gICAgZXhwb3J0cy5hbGxvd1NlbGVjdGlvbiA9IGFsbG93U2VsZWN0aW9uO1xyXG4gICAgZXhwb3J0cy5hcHBlbmRUb0VsZW1lbnQgPSBhcHBlbmRUb0VsZW1lbnQ7XHJcbiAgICBleHBvcnRzLmFwcGx5QWxsID0gYXBwbHlBbGw7XHJcbiAgICBleHBvcnRzLmFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlO1xyXG4gICAgZXhwb3J0cy5hcHBseVN0eWxlID0gYXBwbHlTdHlsZTtcclxuICAgIGV4cG9ydHMuYXBwbHlTdHlsZVByb3AgPSBhcHBseVN0eWxlUHJvcDtcclxuICAgIGV4cG9ydHMuYXNSb3VnaE1pbnV0ZXMgPSBhc1JvdWdoTWludXRlcztcclxuICAgIGV4cG9ydHMuYXNSb3VnaE1zID0gYXNSb3VnaE1zO1xyXG4gICAgZXhwb3J0cy5hc1JvdWdoU2Vjb25kcyA9IGFzUm91Z2hTZWNvbmRzO1xyXG4gICAgZXhwb3J0cy5idWlsZEdvdG9BbmNob3JIdG1sID0gYnVpbGRHb3RvQW5jaG9ySHRtbDtcclxuICAgIGV4cG9ydHMuYnVpbGRTZWdDb21wYXJlT2JqID0gYnVpbGRTZWdDb21wYXJlT2JqO1xyXG4gICAgZXhwb3J0cy5jYXBpdGFsaXNlRmlyc3RMZXR0ZXIgPSBjYXBpdGFsaXNlRmlyc3RMZXR0ZXI7XHJcbiAgICBleHBvcnRzLmNvbWJpbmVFdmVudFVpcyA9IGNvbWJpbmVFdmVudFVpcztcclxuICAgIGV4cG9ydHMuY29tcGFyZUJ5RmllbGRTcGVjID0gY29tcGFyZUJ5RmllbGRTcGVjO1xyXG4gICAgZXhwb3J0cy5jb21wYXJlQnlGaWVsZFNwZWNzID0gY29tcGFyZUJ5RmllbGRTcGVjcztcclxuICAgIGV4cG9ydHMuY29tcGFyZU51bWJlcnMgPSBjb21wYXJlTnVtYmVycztcclxuICAgIGV4cG9ydHMuY29tcGVuc2F0ZVNjcm9sbCA9IGNvbXBlbnNhdGVTY3JvbGw7XHJcbiAgICBleHBvcnRzLmNvbXB1dGVDbGlwcGluZ1JlY3QgPSBjb21wdXRlQ2xpcHBpbmdSZWN0O1xyXG4gICAgZXhwb3J0cy5jb21wdXRlRWRnZXMgPSBjb21wdXRlRWRnZXM7XHJcbiAgICBleHBvcnRzLmNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCA9IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdDtcclxuICAgIGV4cG9ydHMuY29tcHV0ZUhlaWdodEFuZE1hcmdpbnMgPSBjb21wdXRlSGVpZ2h0QW5kTWFyZ2lucztcclxuICAgIGV4cG9ydHMuY29tcHV0ZUlubmVyUmVjdCA9IGNvbXB1dGVJbm5lclJlY3Q7XHJcbiAgICBleHBvcnRzLmNvbXB1dGVSZWN0ID0gY29tcHV0ZVJlY3Q7XHJcbiAgICBleHBvcnRzLmNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlO1xyXG4gICAgZXhwb3J0cy5jb25maWcgPSBjb25maWc7XHJcbiAgICBleHBvcnRzLmNvbnN0cmFpblBvaW50ID0gY29uc3RyYWluUG9pbnQ7XHJcbiAgICBleHBvcnRzLmNyZWF0ZUR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb247XHJcbiAgICBleHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xyXG4gICAgZXhwb3J0cy5jcmVhdGVFbXB0eUV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmU7XHJcbiAgICBleHBvcnRzLmNyZWF0ZUV2ZW50SW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlO1xyXG4gICAgZXhwb3J0cy5jcmVhdGVGb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXI7XHJcbiAgICBleHBvcnRzLmNyZWF0ZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbjtcclxuICAgIGV4cG9ydHMuY3NzVG9TdHIgPSBjc3NUb1N0cjtcclxuICAgIGV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcclxuICAgIGV4cG9ydHMuZGlmZkRhdGVzID0gZGlmZkRhdGVzO1xyXG4gICAgZXhwb3J0cy5kaWZmRGF5QW5kVGltZSA9IGRpZmZEYXlBbmRUaW1lO1xyXG4gICAgZXhwb3J0cy5kaWZmRGF5cyA9IGRpZmZEYXlzO1xyXG4gICAgZXhwb3J0cy5kaWZmUG9pbnRzID0gZGlmZlBvaW50cztcclxuICAgIGV4cG9ydHMuZGlmZldlZWtzID0gZGlmZldlZWtzO1xyXG4gICAgZXhwb3J0cy5kaWZmV2hvbGVEYXlzID0gZGlmZldob2xlRGF5cztcclxuICAgIGV4cG9ydHMuZGlmZldob2xlV2Vla3MgPSBkaWZmV2hvbGVXZWVrcztcclxuICAgIGV4cG9ydHMuZGlzYWJsZUN1cnNvciA9IGRpc2FibGVDdXJzb3I7XHJcbiAgICBleHBvcnRzLmRpc3RyaWJ1dGVIZWlnaHQgPSBkaXN0cmlidXRlSGVpZ2h0O1xyXG4gICAgZXhwb3J0cy5lbGVtZW50Q2xvc2VzdCA9IGVsZW1lbnRDbG9zZXN0O1xyXG4gICAgZXhwb3J0cy5lbGVtZW50TWF0Y2hlcyA9IGVsZW1lbnRNYXRjaGVzO1xyXG4gICAgZXhwb3J0cy5lbmFibGVDdXJzb3IgPSBlbmFibGVDdXJzb3I7XHJcbiAgICBleHBvcnRzLmV2ZW50VHVwbGVUb1N0b3JlID0gZXZlbnRUdXBsZVRvU3RvcmU7XHJcbiAgICBleHBvcnRzLmZpbHRlckV2ZW50U3RvcmVEZWZzID0gZmlsdGVyRXZlbnRTdG9yZURlZnM7XHJcbiAgICBleHBvcnRzLmZpbHRlckhhc2ggPSBmaWx0ZXJIYXNoO1xyXG4gICAgZXhwb3J0cy5maW5kQ2hpbGRyZW4gPSBmaW5kQ2hpbGRyZW47XHJcbiAgICBleHBvcnRzLmZpbmRFbGVtZW50cyA9IGZpbmRFbGVtZW50cztcclxuICAgIGV4cG9ydHMuZmxleGlibGVDb21wYXJlID0gZmxleGlibGVDb21wYXJlO1xyXG4gICAgZXhwb3J0cy5mb3JjZUNsYXNzTmFtZSA9IGZvcmNlQ2xhc3NOYW1lO1xyXG4gICAgZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcclxuICAgIGV4cG9ydHMuZm9ybWF0SXNvVGltZVN0cmluZyA9IGZvcm1hdElzb1RpbWVTdHJpbmc7XHJcbiAgICBleHBvcnRzLmZvcm1hdFJhbmdlID0gZm9ybWF0UmFuZ2U7XHJcbiAgICBleHBvcnRzLmdldEFsbERheUh0bWwgPSBnZXRBbGxEYXlIdG1sO1xyXG4gICAgZXhwb3J0cy5nZXRDbGlwcGluZ1BhcmVudHMgPSBnZXRDbGlwcGluZ1BhcmVudHM7XHJcbiAgICBleHBvcnRzLmdldERheUNsYXNzZXMgPSBnZXREYXlDbGFzc2VzO1xyXG4gICAgZXhwb3J0cy5nZXRFbFNlZyA9IGdldEVsU2VnO1xyXG4gICAgZXhwb3J0cy5nZXRSZWN0Q2VudGVyID0gZ2V0UmVjdENlbnRlcjtcclxuICAgIGV4cG9ydHMuZ2V0UmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cztcclxuICAgIGV4cG9ydHMuZ2xvYmFsRGVmYXVsdHMgPSBnbG9iYWxEZWZhdWx0cztcclxuICAgIGV4cG9ydHMuZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yO1xyXG4gICAgZXhwb3J0cy5oYXNCZ1JlbmRlcmluZyA9IGhhc0JnUmVuZGVyaW5nO1xyXG4gICAgZXhwb3J0cy5odG1sRXNjYXBlID0gaHRtbEVzY2FwZTtcclxuICAgIGV4cG9ydHMuaHRtbFRvRWxlbWVudCA9IGh0bWxUb0VsZW1lbnQ7XHJcbiAgICBleHBvcnRzLmluc2VydEFmdGVyRWxlbWVudCA9IGluc2VydEFmdGVyRWxlbWVudDtcclxuICAgIGV4cG9ydHMuaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlID0gaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlO1xyXG4gICAgZXhwb3J0cy5pbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZSA9IGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlO1xyXG4gICAgZXhwb3J0cy5pbnRlcnNlY3RSYW5nZXMgPSBpbnRlcnNlY3RSYW5nZXM7XHJcbiAgICBleHBvcnRzLmludGVyc2VjdFJlY3RzID0gaW50ZXJzZWN0UmVjdHM7XHJcbiAgICBleHBvcnRzLmlzQXJyYXlzRXF1YWwgPSBpc0FycmF5c0VxdWFsO1xyXG4gICAgZXhwb3J0cy5pc0RhdGVTcGFuc0VxdWFsID0gaXNEYXRlU3BhbnNFcXVhbDtcclxuICAgIGV4cG9ydHMuaXNJbnQgPSBpc0ludDtcclxuICAgIGV4cG9ydHMuaXNJbnRlcmFjdGlvblZhbGlkID0gaXNJbnRlcmFjdGlvblZhbGlkO1xyXG4gICAgZXhwb3J0cy5pc011bHRpRGF5UmFuZ2UgPSBpc011bHRpRGF5UmFuZ2U7XHJcbiAgICBleHBvcnRzLmlzUHJvcHNFcXVhbCA9IGlzUHJvcHNFcXVhbDtcclxuICAgIGV4cG9ydHMuaXNQcm9wc1ZhbGlkID0gaXNQcm9wc1ZhbGlkO1xyXG4gICAgZXhwb3J0cy5pc1NpbmdsZURheSA9IGlzU2luZ2xlRGF5O1xyXG4gICAgZXhwb3J0cy5pc1ZhbGlkRGF0ZSA9IGlzVmFsaWREYXRlO1xyXG4gICAgZXhwb3J0cy5saXN0ZW5CeVNlbGVjdG9yID0gbGlzdGVuQnlTZWxlY3RvcjtcclxuICAgIGV4cG9ydHMubWFwSGFzaCA9IG1hcEhhc2g7XHJcbiAgICBleHBvcnRzLm1hdGNoQ2VsbFdpZHRocyA9IG1hdGNoQ2VsbFdpZHRocztcclxuICAgIGV4cG9ydHMubWVtb2l6ZSA9IG1lbW9pemU7XHJcbiAgICBleHBvcnRzLm1lbW9pemVPdXRwdXQgPSBtZW1vaXplT3V0cHV0O1xyXG4gICAgZXhwb3J0cy5tZW1vaXplUmVuZGVyaW5nID0gbWVtb2l6ZVJlbmRlcmluZztcclxuICAgIGV4cG9ydHMubWVyZ2VFdmVudFN0b3JlcyA9IG1lcmdlRXZlbnRTdG9yZXM7XHJcbiAgICBleHBvcnRzLm11bHRpcGx5RHVyYXRpb24gPSBtdWx0aXBseUR1cmF0aW9uO1xyXG4gICAgZXhwb3J0cy5wYWRTdGFydCA9IHBhZFN0YXJ0O1xyXG4gICAgZXhwb3J0cy5wYXJzZUJ1c2luZXNzSG91cnMgPSBwYXJzZUJ1c2luZXNzSG91cnM7XHJcbiAgICBleHBvcnRzLnBhcnNlRHJhZ01ldGEgPSBwYXJzZURyYWdNZXRhO1xyXG4gICAgZXhwb3J0cy5wYXJzZUV2ZW50RGVmID0gcGFyc2VFdmVudERlZjtcclxuICAgIGV4cG9ydHMucGFyc2VGaWVsZFNwZWNzID0gcGFyc2VGaWVsZFNwZWNzO1xyXG4gICAgZXhwb3J0cy5wYXJzZU1hcmtlciA9IHBhcnNlO1xyXG4gICAgZXhwb3J0cy5wb2ludEluc2lkZVJlY3QgPSBwb2ludEluc2lkZVJlY3Q7XHJcbiAgICBleHBvcnRzLnByZXBlbmRUb0VsZW1lbnQgPSBwcmVwZW5kVG9FbGVtZW50O1xyXG4gICAgZXhwb3J0cy5wcmV2ZW50Q29udGV4dE1lbnUgPSBwcmV2ZW50Q29udGV4dE1lbnU7XHJcbiAgICBleHBvcnRzLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XHJcbiAgICBleHBvcnRzLnByZXZlbnRTZWxlY3Rpb24gPSBwcmV2ZW50U2VsZWN0aW9uO1xyXG4gICAgZXhwb3J0cy5wcm9jZXNzU2NvcGVkVWlQcm9wcyA9IHByb2Nlc3NTY29wZWRVaVByb3BzO1xyXG4gICAgZXhwb3J0cy5yYW5nZUNvbnRhaW5zTWFya2VyID0gcmFuZ2VDb250YWluc01hcmtlcjtcclxuICAgIGV4cG9ydHMucmFuZ2VDb250YWluc1JhbmdlID0gcmFuZ2VDb250YWluc1JhbmdlO1xyXG4gICAgZXhwb3J0cy5yYW5nZXNFcXVhbCA9IHJhbmdlc0VxdWFsO1xyXG4gICAgZXhwb3J0cy5yYW5nZXNJbnRlcnNlY3QgPSByYW5nZXNJbnRlcnNlY3Q7XHJcbiAgICBleHBvcnRzLnJlZmluZVByb3BzID0gcmVmaW5lUHJvcHM7XHJcbiAgICBleHBvcnRzLnJlbW92ZUVsZW1lbnQgPSByZW1vdmVFbGVtZW50O1xyXG4gICAgZXhwb3J0cy5yZW1vdmVFeGFjdCA9IHJlbW92ZUV4YWN0O1xyXG4gICAgZXhwb3J0cy5yZW5kZXJEYXRlQ2VsbCA9IHJlbmRlckRhdGVDZWxsO1xyXG4gICAgZXhwb3J0cy5yZXF1ZXN0SnNvbiA9IHJlcXVlc3RKc29uO1xyXG4gICAgZXhwb3J0cy5zbGljZUV2ZW50U3RvcmUgPSBzbGljZUV2ZW50U3RvcmU7XHJcbiAgICBleHBvcnRzLnN0YXJ0T2ZEYXkgPSBzdGFydE9mRGF5O1xyXG4gICAgZXhwb3J0cy5zdWJ0cmFjdElubmVyRWxIZWlnaHQgPSBzdWJ0cmFjdElubmVyRWxIZWlnaHQ7XHJcbiAgICBleHBvcnRzLnRyYW5zbGF0ZVJlY3QgPSB0cmFuc2xhdGVSZWN0O1xyXG4gICAgZXhwb3J0cy51bmNvbXBlbnNhdGVTY3JvbGwgPSB1bmNvbXBlbnNhdGVTY3JvbGw7XHJcbiAgICBleHBvcnRzLnVuZGlzdHJpYnV0ZUhlaWdodCA9IHVuZGlzdHJpYnV0ZUhlaWdodDtcclxuICAgIGV4cG9ydHMudW5wcm9taXNpZnkgPSB1bnByb21pc2lmeTtcclxuICAgIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBleHBvcnRzLndoZW5UcmFuc2l0aW9uRG9uZSA9IHdoZW5UcmFuc2l0aW9uRG9uZTtcclxuICAgIGV4cG9ydHMud2hvbGVEaXZpZGVEdXJhdGlvbnMgPSB3aG9sZURpdmlkZUR1cmF0aW9ucztcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxufSkpO1xyXG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCIvKiFcclxuRnVsbENhbGVuZGFyIERheSBHcmlkIFBsdWdpbiB2NC4zLjBcclxuRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xyXG4oYykgMjAxOSBBZGFtIFNoYXdcclxuKi9cclxuXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0BmdWxsY2FsZW5kYXIvY29yZScpKSA6XHJcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0BmdWxsY2FsZW5kYXIvY29yZSddLCBmYWN0b3J5KSA6XHJcbiAgICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLkZ1bGxDYWxlbmRhckRheUdyaWQgPSB7fSwgZ2xvYmFsLkZ1bGxDYWxlbmRhcikpO1xyXG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBjb3JlKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbiAgICB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG4gICAgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiAgICBUSElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAgICBLSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbiAgICBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG4gICAgTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcbiAgICBTZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuICAgIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbiAgICAvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBEYXlHcmlkRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKERheUdyaWREYXRlUHJvZmlsZUdlbmVyYXRvciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBEYXlHcmlkRGF0ZVByb2ZpbGVHZW5lcmF0b3IoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIGRhdGUgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgICAgIERheUdyaWREYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJSYW5nZSA9IF9zdXBlci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZS5jYWxsKHRoaXMsIGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHJlbmRlclJhbmdlLnN0YXJ0O1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gcmVuZGVyUmFuZ2UuZW5kO1xyXG4gICAgICAgICAgICB2YXIgZW5kT2ZXZWVrO1xyXG4gICAgICAgICAgICAvLyB5ZWFyIGFuZCBtb250aCB2aWV3cyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHdlZWtzLiB0aGlzIGlzIGFscmVhZHkgZG9uZSBmb3Igd2Vla1xyXG4gICAgICAgICAgICBpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGN1cnJlbnRSYW5nZVVuaXQpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZldlZWsoc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBlbmQtb2Ytd2VlayBpZiBub3QgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgZW5kT2ZXZWVrID0gZGF0ZUVudi5zdGFydE9mV2VlayhlbmQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZE9mV2Vlay52YWx1ZU9mKCkgIT09IGVuZC52YWx1ZU9mKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBjb3JlLmFkZFdlZWtzKGVuZE9mV2VlaywgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZW5zdXJlIDYgd2Vla3NcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tb250aE1vZGUgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXhlZFdlZWtDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvd0NudCA9IE1hdGguY2VpbCgvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXHJcbiAgICAgICAgICAgICAgICBjb3JlLmRpZmZXZWVrcyhzdGFydCwgZW5kKSk7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBjb3JlLmFkZFdlZWtzKGVuZCwgNiAtIHJvd0NudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERheUdyaWREYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxuICAgIH0oY29yZS5EYXRlUHJvZmlsZUdlbmVyYXRvcikpO1xyXG5cclxuICAgIC8qIEEgcmVjdGFuZ3VsYXIgcGFuZWwgdGhhdCBpcyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgb3ZlciBvdGhlciBjb250ZW50XHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIE9wdGlvbnM6XHJcbiAgICAgIC0gY2xhc3NOYW1lIChzdHJpbmcpXHJcbiAgICAgIC0gY29udGVudCAoSFRNTCBzdHJpbmcsIGVsZW1lbnQsIG9yIGVsZW1lbnQgYXJyYXkpXHJcbiAgICAgIC0gcGFyZW50RWxcclxuICAgICAgLSB0b3BcclxuICAgICAgLSBsZWZ0XHJcbiAgICAgIC0gcmlnaHQgKHRoZSB4IGNvb3JkIG9mIHdoZXJlIHRoZSByaWdodCBlZGdlIHNob3VsZCBiZS4gbm90IGEgXCJDU1NcIiByaWdodClcclxuICAgICAgLSBhdXRvSGlkZSAoYm9vbGVhbilcclxuICAgICAgLSBzaG93IChjYWxsYmFjaylcclxuICAgICAgLSBoaWRlIChjYWxsYmFjaylcclxuICAgICovXHJcbiAgICB2YXIgUG9wb3ZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQb3BvdmVyKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5pc0hpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMubWFyZ2luID0gMTA7IC8vIHRoZSBzcGFjZSByZXF1aXJlZCBiZXR3ZWVuIHRoZSBwb3BvdmVyIGFuZCB0aGUgZWRnZXMgb2YgdGhlIHNjcm9sbCBjb250YWluZXJcclxuICAgICAgICAgICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudE1vdXNlZG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZWwgJiYgIV90aGlzLmVsLmNvbnRhaW5zKGV2LnRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNob3dzIHRoZSBwb3BvdmVyIG9uIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uIFJlbmRlcnMgaXQgaWYgbm90IGFscmVhZHlcclxuICAgICAgICBQb3BvdmVyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzaG93Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEhpZGVzIHRoZSBwb3BvdmVyLCB0aHJvdWdoIENTUywgYnV0IGRvZXMgbm90IHJlbW92ZSBpdCBmcm9tIHRoZSBET01cclxuICAgICAgICBQb3BvdmVyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdoaWRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENyZWF0ZXMgYHRoaXMuZWxgIGFuZCByZW5kZXJzIGNvbnRlbnQgaW5zaWRlIG9mIGl0XHJcbiAgICAgICAgUG9wb3Zlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbCA9IGNvcmUuY3JlYXRlRWxlbWVudCgnZGl2Jywge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmMtcG9wb3ZlciAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAnMCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogJzAnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50KGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcHRpb25zLnBhcmVudEVsLmFwcGVuZENoaWxkKGVsKTtcclxuICAgICAgICAgICAgLy8gd2hlbiBhIGNsaWNrIGhhcHBlbnMgb24gYW55dGhpbmcgaW5zaWRlIHdpdGggYSAnZmMtY2xvc2UnIGNsYXNzTmFtZSwgaGlkZSB0aGUgcG9wb3ZlclxyXG4gICAgICAgICAgICBjb3JlLmxpc3RlbkJ5U2VsZWN0b3IoZWwsICdjbGljaycsICcuZmMtY2xvc2UnLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmF1dG9IaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmRvY3VtZW50TW91c2Vkb3duKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gSGlkZXMgYW5kIHVucmVnaXN0ZXJzIGFueSBoYW5kbGVyc1xyXG4gICAgICAgIFBvcG92ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICAgICAgY29yZS5yZW1vdmVFbGVtZW50KHRoaXMuZWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5kb2N1bWVudE1vdXNlZG93bik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBQb3NpdGlvbnMgdGhlIHBvcG92ZXIgb3B0aW1hbGx5LCB1c2luZyB0aGUgdG9wL2xlZnQvcmlnaHQgb3B0aW9uc1xyXG4gICAgICAgIFBvcG92ZXIucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcclxuICAgICAgICAgICAgdmFyIGVsRGltcyA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBvbmx5IHVzZWQgZm9yIHdpZHRoLGhlaWdodFxyXG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gY29yZS5jb21wdXRlUmVjdChlbC5vZmZzZXRQYXJlbnQpO1xyXG4gICAgICAgICAgICB2YXIgY2xpcHBpbmdSZWN0ID0gY29yZS5jb21wdXRlQ2xpcHBpbmdSZWN0KG9wdGlvbnMucGFyZW50RWwpO1xyXG4gICAgICAgICAgICB2YXIgdG9wOyAvLyB0aGUgXCJwb3NpdGlvblwiIChub3QgXCJvZmZzZXRcIikgdmFsdWVzIGZvciB0aGUgcG9wb3ZlclxyXG4gICAgICAgICAgICB2YXIgbGVmdDsgLy9cclxuICAgICAgICAgICAgLy8gY29tcHV0ZSB0b3AgYW5kIGxlZnRcclxuICAgICAgICAgICAgdG9wID0gb3B0aW9ucy50b3AgfHwgMDtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gb3B0aW9ucy5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IG9wdGlvbnMucmlnaHQgLSBlbERpbXMud2lkdGg7IC8vIGRlcml2ZSB0aGUgbGVmdCB2YWx1ZSBmcm9tIHRoZSByaWdodCB2YWx1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29uc3RyYWluIHRvIHRoZSB2aWV3IHBvcnQuIGlmIGNvbnN0cmFpbmVkIGJ5IHR3byBlZGdlcywgZ2l2ZSBwcmVjZWRlbmNlIHRvIHRvcC9sZWZ0XHJcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKHRvcCwgY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGVsRGltcy5oZWlnaHQgLSB0aGlzLm1hcmdpbik7XHJcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgY2xpcHBpbmdSZWN0LnRvcCArIHRoaXMubWFyZ2luKTtcclxuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWluKGxlZnQsIGNsaXBwaW5nUmVjdC5yaWdodCAtIGVsRGltcy53aWR0aCAtIHRoaXMubWFyZ2luKTtcclxuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIGNsaXBwaW5nUmVjdC5sZWZ0ICsgdGhpcy5tYXJnaW4pO1xyXG4gICAgICAgICAgICBjb3JlLmFwcGx5U3R5bGUoZWwsIHtcclxuICAgICAgICAgICAgICAgIHRvcDogdG9wIC0gb3JpZ2luLnRvcCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQgLSBvcmlnaW4ubGVmdFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFRyaWdnZXJzIGEgY2FsbGJhY2suIENhbGxzIGEgZnVuY3Rpb24gaW4gdGhlIG9wdGlvbiBoYXNoIG9mIHRoZSBzYW1lIG5hbWUuXHJcbiAgICAgICAgLy8gQXJndW1lbnRzIGJleW9uZCB0aGUgZmlyc3QgYG5hbWVgIGFyZSBmb3J3YXJkZWQgb24uXHJcbiAgICAgICAgLy8gVE9ETzogYmV0dGVyIGNvZGUgcmV1c2UgZm9yIHRoaXMuIFJlcGVhdCBjb2RlXHJcbiAgICAgICAgLy8gY2FuIGtpbGwgdGhpcz8/P1xyXG4gICAgICAgIFBvcG92ZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQb3BvdmVyO1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICAvKiBFdmVudC1yZW5kZXJpbmcgbWV0aG9kcyBmb3IgdGhlIERheUdyaWQgY2xhc3NcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gXCJTaW1wbGVcIiBpcyBiYWQgYSBuYW1lLiBoYXMgbm90aGluZyB0byBkbyB3aXRoIFNpbXBsZURheUdyaWRcclxuICAgIHZhciBTaW1wbGVEYXlHcmlkRXZlbnRSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU2ltcGxlRGF5R3JpZEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gU2ltcGxlRGF5R3JpZEV2ZW50UmVuZGVyZXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBIVE1MIHRvIGJlIHVzZWQgZm9yIHRoZSBkZWZhdWx0IGVsZW1lbnQgZm9yIGFuIGluZGl2aWR1YWwgc2VnbWVudFxyXG4gICAgICAgIFNpbXBsZURheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdIdG1sID0gZnVuY3Rpb24gKHNlZywgbWlycm9ySW5mbykge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIHZpZXcgPSBfYS52aWV3LCBvcHRpb25zID0gX2Eub3B0aW9ucztcclxuICAgICAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGVmID0gZXZlbnRSYW5nZS5kZWY7XHJcbiAgICAgICAgICAgIHZhciBldmVudFVpID0gZXZlbnRSYW5nZS51aTtcclxuICAgICAgICAgICAgdmFyIGFsbERheSA9IGV2ZW50RGVmLmFsbERheTtcclxuICAgICAgICAgICAgdmFyIGlzRHJhZ2dhYmxlID0gdmlldy5jb21wdXRlRXZlbnREcmFnZ2FibGUoZXZlbnREZWYsIGV2ZW50VWkpO1xyXG4gICAgICAgICAgICB2YXIgaXNSZXNpemFibGVGcm9tU3RhcnQgPSBhbGxEYXkgJiYgc2VnLmlzU3RhcnQgJiYgdmlldy5jb21wdXRlRXZlbnRTdGFydFJlc2l6YWJsZShldmVudERlZiwgZXZlbnRVaSk7XHJcbiAgICAgICAgICAgIHZhciBpc1Jlc2l6YWJsZUZyb21FbmQgPSBhbGxEYXkgJiYgc2VnLmlzRW5kICYmIHZpZXcuY29tcHV0ZUV2ZW50RW5kUmVzaXphYmxlKGV2ZW50RGVmLCBldmVudFVpKTtcclxuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSB0aGlzLmdldFNlZ0NsYXNzZXMoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGVGcm9tU3RhcnQgfHwgaXNSZXNpemFibGVGcm9tRW5kLCBtaXJyb3JJbmZvKTtcclxuICAgICAgICAgICAgdmFyIHNraW5Dc3MgPSBjb3JlLmNzc1RvU3RyKHRoaXMuZ2V0U2tpbkNzcyhldmVudFVpKSk7XHJcbiAgICAgICAgICAgIHZhciB0aW1lSHRtbCA9ICcnO1xyXG4gICAgICAgICAgICB2YXIgdGltZVRleHQ7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZUh0bWw7XHJcbiAgICAgICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LWdyaWQtZXZlbnQnLCAnZmMtaC1ldmVudCcpO1xyXG4gICAgICAgICAgICAvLyBPbmx5IGRpc3BsYXkgYSB0aW1lZCBldmVudHMgdGltZSBpZiBpdCBpcyB0aGUgc3RhcnRpbmcgc2VnbWVudFxyXG4gICAgICAgICAgICBpZiAoc2VnLmlzU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIHRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChldmVudFJhbmdlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVIdG1sID0gJzxzcGFuIGNsYXNzPVwiZmMtdGltZVwiPicgKyBjb3JlLmh0bWxFc2NhcGUodGltZVRleHQpICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpdGxlSHRtbCA9XHJcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYy10aXRsZVwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgIChjb3JlLmh0bWxFc2NhcGUoZXZlbnREZWYudGl0bGUgfHwgJycpIHx8ICcmbmJzcDsnKSArIC8vIHdlIGFsd2F5cyB3YW50IG9uZSBsaW5lIG9mIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICc8L3NwYW4+JztcclxuICAgICAgICAgICAgcmV0dXJuICc8YSBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAgICAgKGV2ZW50RGVmLnVybCA/XHJcbiAgICAgICAgICAgICAgICAgICAgJyBocmVmPVwiJyArIGNvcmUuaHRtbEVzY2FwZShldmVudERlZi51cmwpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgICAgIChza2luQ3NzID9cclxuICAgICAgICAgICAgICAgICAgICAnIHN0eWxlPVwiJyArIHNraW5Dc3MgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY29udGVudFwiPicgK1xyXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMuZGlyID09PSAncnRsJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVIdG1sICsgJyAnICsgdGltZUh0bWwgOiAvLyBwdXQgYSBuYXR1cmFsIHNwYWNlIGluIGJldHdlZW5cclxuICAgICAgICAgICAgICAgICAgICB0aW1lSHRtbCArICcgJyArIHRpdGxlSHRtbCAvL1xyXG4gICAgICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAoaXNSZXNpemFibGVGcm9tU3RhcnQgP1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1zdGFydC1yZXNpemVyXCI+PC9kaXY+JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgICAgIChpc1Jlc2l6YWJsZUZyb21FbmQgP1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1lbmQtcmVzaXplclwiPjwvZGl2PicgOlxyXG4gICAgICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICAgICAnPC9hPic7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgZXZlbnQgdGltZSBmb3JtYXR0aW5nIHN0cmluZyBpZiBgZXZlbnRUaW1lRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXHJcbiAgICAgICAgU2ltcGxlRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBob3VyOiAnbnVtZXJpYycsXHJcbiAgICAgICAgICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcclxuICAgICAgICAgICAgICAgIG9taXRaZXJvTWludXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWVyaWRpZW06ICduYXJyb3cnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTaW1wbGVEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZURpc3BsYXlFdmVudEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUT0RPOiBzb21laG93IGNvbnNpZGVyIHRoZSBvcmlnaW5hdGluZyBEYXlHcmlkJ3MgY29sdW1uIGNvdW50XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2ltcGxlRGF5R3JpZEV2ZW50UmVuZGVyZXI7XHJcbiAgICB9KGNvcmUuRmdFdmVudFJlbmRlcmVyKSk7XHJcblxyXG4gICAgLyogRXZlbnQtcmVuZGVyaW5nIG1ldGhvZHMgZm9yIHRoZSBEYXlHcmlkIGNsYXNzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIHZhciBEYXlHcmlkRXZlbnRSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRGF5R3JpZEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRGF5R3JpZEV2ZW50UmVuZGVyZXIoZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkYXlHcmlkLmNvbnRleHQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmRheUdyaWQgPSBkYXlHcmlkO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbmRlcnMgdGhlIGdpdmVuIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHMgb250byB0aGUgZ3JpZFxyXG4gICAgICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIG1pcnJvckluZm8pIHtcclxuICAgICAgICAgICAgdmFyIHJvd1N0cnVjdHMgPSB0aGlzLnJvd1N0cnVjdHMgPSB0aGlzLnJlbmRlclNlZ1Jvd3Moc2Vncyk7XHJcbiAgICAgICAgICAgIC8vIGFwcGVuZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b25cclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJvd0Vscy5mb3JFYWNoKGZ1bmN0aW9uIChyb3dOb2RlLCBpKSB7XHJcbiAgICAgICAgICAgICAgICByb3dOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5mYy1jb250ZW50LXNrZWxldG9uID4gdGFibGUnKS5hcHBlbmRDaGlsZChyb3dTdHJ1Y3RzW2ldLnRib2R5RWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgXCJtb3JlLi5cIiBldmVudHMgcG9wb3ZlclxyXG4gICAgICAgICAgICBpZiAoIW1pcnJvckluZm8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5yZW1vdmVTZWdQb3BvdmVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFVucmVuZGVycyBhbGwgY3VycmVudGx5IHJlbmRlcmVkIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHNcclxuICAgICAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZGV0YWNoU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJvd1N0cnVjdHMgPSB0aGlzLnJvd1N0cnVjdHMgfHwgW107XHJcbiAgICAgICAgICAgIHZhciByb3dTdHJ1Y3Q7XHJcbiAgICAgICAgICAgIHdoaWxlICgocm93U3RydWN0ID0gcm93U3RydWN0cy5wb3AoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvcmUucmVtb3ZlRWxlbWVudChyb3dTdHJ1Y3QudGJvZHlFbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yb3dTdHJ1Y3RzID0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFVzZXMgdGhlIGdpdmVuIGV2ZW50cyBhcnJheSB0byBnZW5lcmF0ZSA8dGJvZHk+IGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIGVhY2ggcm93J3MgY29udGVudCBza2VsZXRvbi5cclxuICAgICAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHJvd1N0cnVjdCBvYmplY3RzIChzZWUgdGhlIGJvdHRvbSBvZiBgcmVuZGVyU2VnUm93YCkuXHJcbiAgICAgICAgLy8gUFJFQ09ORElUSU9OOiBlYWNoIHNlZ21lbnQgc2hvdWQgYWxyZWFkeSBoYXZlIGEgcmVuZGVyZWQgYW5kIGFzc2lnbmVkIGAuZWxgXHJcbiAgICAgICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ1Jvd3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgICAgICB2YXIgcm93U3RydWN0cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgc2VnUm93cztcclxuICAgICAgICAgICAgdmFyIHJvdztcclxuICAgICAgICAgICAgc2VnUm93cyA9IHRoaXMuZ3JvdXBTZWdSb3dzKHNlZ3MpOyAvLyBncm91cCBpbnRvIG5lc3RlZCBhcnJheXNcclxuICAgICAgICAgICAgLy8gaXRlcmF0ZSBlYWNoIHJvdyBvZiBzZWdtZW50IGdyb3VwaW5nc1xyXG4gICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHNlZ1Jvd3MubGVuZ3RoOyByb3crKykge1xyXG4gICAgICAgICAgICAgICAgcm93U3RydWN0cy5wdXNoKHRoaXMucmVuZGVyU2VnUm93KHJvdywgc2VnUm93c1tyb3ddKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJvd1N0cnVjdHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHaXZlbiBhIHJvdyAjIGFuZCBhbiBhcnJheSBvZiBzZWdtZW50cyBhbGwgaW4gdGhlIHNhbWUgcm93LCByZW5kZXIgYSA8dGJvZHk+IGVsZW1lbnQsIGEgc2tlbGV0b24gdGhhdCBjb250YWluc1xyXG4gICAgICAgIC8vIHRoZSBzZWdtZW50cy4gUmV0dXJucyBvYmplY3Qgd2l0aCBhIGJ1bmNoIG9mIGludGVybmFsIGRhdGEgYWJvdXQgaG93IHRoZSByZW5kZXIgd2FzIGNhbGN1bGF0ZWQuXHJcbiAgICAgICAgLy8gTk9URTogbW9kaWZpZXMgcm93U2Vnc1xyXG4gICAgICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdSb3cgPSBmdW5jdGlvbiAocm93LCByb3dTZWdzKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXlHcmlkID0gdGhpcy5kYXlHcmlkO1xyXG4gICAgICAgICAgICB2YXIgY29sQ250ID0gZGF5R3JpZC5jb2xDbnQsIGlzUnRsID0gZGF5R3JpZC5pc1J0bDtcclxuICAgICAgICAgICAgdmFyIHNlZ0xldmVscyA9IHRoaXMuYnVpbGRTZWdMZXZlbHMocm93U2Vncyk7IC8vIGdyb3VwIGludG8gc3ViLWFycmF5cyBvZiBsZXZlbHNcclxuICAgICAgICAgICAgdmFyIGxldmVsQ250ID0gTWF0aC5tYXgoMSwgc2VnTGV2ZWxzLmxlbmd0aCk7IC8vIGVuc3VyZSBhdCBsZWFzdCBvbmUgbGV2ZWxcclxuICAgICAgICAgICAgdmFyIHRib2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcclxuICAgICAgICAgICAgdmFyIHNlZ01hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIHdoaWNoIHNlZ21lbnRzIGFyZSByZW5kZXJlZCBpbnRvIHdoaWNoIGxldmVsK2NvbCBjZWxsc1xyXG4gICAgICAgICAgICB2YXIgY2VsbE1hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIGFsbCA8dGQ+IGVsZW1lbnRzIG9mIHRoZSBsZXZlbCtjb2wgbWF0cml4XHJcbiAgICAgICAgICAgIHZhciBsb25lQ2VsbE1hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIDx0ZD4gZWxlbWVudHMgdGhhdCBvbmx5IHRha2UgdXAgYSBzaW5nbGUgY29sdW1uXHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgbGV2ZWxTZWdzO1xyXG4gICAgICAgICAgICB2YXIgY29sO1xyXG4gICAgICAgICAgICB2YXIgdHI7XHJcbiAgICAgICAgICAgIHZhciBqO1xyXG4gICAgICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgICAgICB2YXIgdGQ7XHJcbiAgICAgICAgICAgIC8vIHBvcHVsYXRlcyBlbXB0eSBjZWxscyBmcm9tIHRoZSBjdXJyZW50IGNvbHVtbiAoYGNvbGApIHRvIGBlbmRDb2xgXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVtcHR5Q2VsbHNVbnRpbChlbmRDb2wpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb2wgPCBlbmRDb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gZ3JhYiBhIGNlbGwgZnJvbSB0aGUgbGV2ZWwgYWJvdmUgYW5kIGV4dGVuZCBpdHMgcm93c3Bhbi4gb3RoZXJ3aXNlLCBjcmVhdGUgYSBmcmVzaCBjZWxsXHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSAobG9uZUNlbGxNYXRyaXhbaSAtIDFdIHx8IFtdKVtjb2xdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZC5yb3dTcGFuID0gKHRkLnJvd1NwYW4gfHwgMSkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvbmVDZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcclxuICAgICAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxDbnQ7IGkrKykgeyAvLyBpdGVyYXRlIHRocm91Z2ggYWxsIGxldmVsc1xyXG4gICAgICAgICAgICAgICAgbGV2ZWxTZWdzID0gc2VnTGV2ZWxzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29sID0gMDtcclxuICAgICAgICAgICAgICAgIHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcclxuICAgICAgICAgICAgICAgIHNlZ01hdHJpeC5wdXNoKFtdKTtcclxuICAgICAgICAgICAgICAgIGNlbGxNYXRyaXgucHVzaChbXSk7XHJcbiAgICAgICAgICAgICAgICBsb25lQ2VsbE1hdHJpeC5wdXNoKFtdKTtcclxuICAgICAgICAgICAgICAgIC8vIGxldmVsQ250IG1pZ2h0IGJlIDEgZXZlbiB0aG91Z2ggdGhlcmUgYXJlIG5vIGFjdHVhbCBsZXZlbHMuIHByb3RlY3QgYWdhaW5zdCB0aGlzLlxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzaW5nbGUgZW1wdHkgcm93IGlzIHVzZWZ1bCBmb3Igc3R5bGluZy5cclxuICAgICAgICAgICAgICAgIGlmIChsZXZlbFNlZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGV2ZWxTZWdzLmxlbmd0aDsgaisrKSB7IC8vIGl0ZXJhdGUgdGhyb3VnaCBzZWdtZW50cyBpbiBsZXZlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcgPSBsZXZlbFNlZ3Nbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5sYXN0Q29sKSA6IHNlZy5maXJzdENvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5maXJzdENvbCkgOiBzZWcubGFzdENvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKGxlZnRDb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjb250YWluZXIgdGhhdCBvY2N1cGllcyBvciBtb3JlIGNvbHVtbnMuIGFwcGVuZCB0aGUgZXZlbnQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGQgPSBjb3JlLmNyZWF0ZUVsZW1lbnQoJ3RkJywgeyBjbGFzc05hbWU6ICdmYy1ldmVudC1jb250YWluZXInIH0sIHNlZy5lbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0Q29sICE9PSByaWdodENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGQuY29sU3BhbiA9IHJpZ2h0Q29sIC0gbGVmdENvbCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIGEgc2luZ2xlLWNvbHVtbiBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb25lQ2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbCA8PSByaWdodENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdNYXRyaXhbaV1bY29sXSA9IHNlZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwoY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgcm93XHJcbiAgICAgICAgICAgICAgICB2YXIgaW50cm9IdG1sID0gZGF5R3JpZC5yZW5kZXJQcm9wcy5yZW5kZXJJbnRyb0h0bWwoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnRyb0h0bWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF5R3JpZC5pc1J0bCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLmFwcGVuZFRvRWxlbWVudCh0ciwgaW50cm9IdG1sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUucHJlcGVuZFRvRWxlbWVudCh0ciwgaW50cm9IdG1sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0Ym9keS5hcHBlbmRDaGlsZCh0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICAgICAgdGJvZHlFbDogdGJvZHksXHJcbiAgICAgICAgICAgICAgICBjZWxsTWF0cml4OiBjZWxsTWF0cml4LFxyXG4gICAgICAgICAgICAgICAgc2VnTWF0cml4OiBzZWdNYXRyaXgsXHJcbiAgICAgICAgICAgICAgICBzZWdMZXZlbHM6IHNlZ0xldmVscyxcclxuICAgICAgICAgICAgICAgIHNlZ3M6IHJvd1NlZ3NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFN0YWNrcyBhIGZsYXQgYXJyYXkgb2Ygc2VnbWVudHMsIHdoaWNoIGFyZSBhbGwgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSByb3csIGludG8gc3ViYXJyYXlzIG9mIHZlcnRpY2FsIGxldmVscy5cclxuICAgICAgICAvLyBOT1RFOiBtb2RpZmllcyBzZWdzXHJcbiAgICAgICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkU2VnTGV2ZWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5kYXlHcmlkLCBpc1J0bCA9IF9hLmlzUnRsLCBjb2xDbnQgPSBfYS5jb2xDbnQ7XHJcbiAgICAgICAgICAgIHZhciBsZXZlbHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgICAgIHZhciBqO1xyXG4gICAgICAgICAgICAvLyBHaXZlIHByZWZlcmVuY2UgdG8gZWxlbWVudHMgd2l0aCBjZXJ0YWluIGNyaXRlcmlhLCBzbyB0aGV5IGhhdmVcclxuICAgICAgICAgICAgLy8gYSBjaGFuY2UgdG8gYmUgY2xvc2VyIHRvIHRoZSB0b3AuXHJcbiAgICAgICAgICAgIHNlZ3MgPSB0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGxldmVscywgc3RhcnRpbmcgd2l0aCB0aGUgdG9wbW9zdCwgdW50aWwgdGhlIHNlZ21lbnQgZG9lc24ndCBjb2xsaWRlIHdpdGggb3RoZXIgc2VnbWVudHNcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGF5U2VnQ29sbGlzaW9uKHNlZywgbGV2ZWxzW2pdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBgamAgbm93IGhvbGRzIHRoZSBkZXNpcmVkIHN1YnJvdyBpbmRleFxyXG4gICAgICAgICAgICAgICAgc2VnLmxldmVsID0gajtcclxuICAgICAgICAgICAgICAgIHNlZy5sZWZ0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5sYXN0Q29sKSA6IHNlZy5maXJzdENvbDsgLy8gZm9yIHNvcnRpbmcgb25seVxyXG4gICAgICAgICAgICAgICAgc2VnLnJpZ2h0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5maXJzdENvbCkgOiBzZWcubGFzdENvbCAvLyBmb3Igc29ydGluZyBvbmx5XHJcbiAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAobGV2ZWxzW2pdIHx8IChsZXZlbHNbal0gPSBbXSkpLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBvcmRlciBzZWdtZW50cyBsZWZ0LXRvLXJpZ2h0LiB2ZXJ5IGltcG9ydGFudCBpZiBjYWxlbmRhciBpcyBSVExcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgbGV2ZWxzW2pdLnNvcnQoY29tcGFyZURheVNlZ0NvbHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsZXZlbHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHaXZlbiBhIGZsYXQgYXJyYXkgb2Ygc2VnbWVudHMsIHJldHVybiBhbiBhcnJheSBvZiBzdWItYXJyYXlzLCBncm91cGVkIGJ5IGVhY2ggc2VnbWVudCdzIHJvd1xyXG4gICAgICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5ncm91cFNlZ1Jvd3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgICAgICB2YXIgc2VnUm93cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF5R3JpZC5yb3dDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2VnUm93cy5wdXNoKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2VnUm93c1tzZWdzW2ldLnJvd10ucHVzaChzZWdzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VnUm93cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENvbXB1dGVzIGEgZGVmYXVsdCBgZGlzcGxheUV2ZW50RW5kYCB2YWx1ZSBpZiBvbmUgaXMgbm90IGV4cGxpY2x0eSBkZWZpbmVkXHJcbiAgICAgICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheUdyaWQuY29sQ250ID09PSAxOyAvLyB3ZSdsbCBsaWtlbHkgaGF2ZSBzcGFjZSBpZiB0aGVyZSdzIG9ubHkgb25lIGRheVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERheUdyaWRFdmVudFJlbmRlcmVyO1xyXG4gICAgfShTaW1wbGVEYXlHcmlkRXZlbnRSZW5kZXJlcikpO1xyXG4gICAgLy8gQ29tcHV0ZXMgd2hldGhlciB0d28gc2VnbWVudHMnIGNvbHVtbnMgY29sbGlkZS4gVGhleSBhcmUgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSByb3cuXHJcbiAgICBmdW5jdGlvbiBpc0RheVNlZ0NvbGxpc2lvbihzZWcsIG90aGVyU2Vncykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBvdGhlclNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3RoZXJTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG90aGVyU2VnID0gb3RoZXJTZWdzW2ldO1xyXG4gICAgICAgICAgICBpZiAob3RoZXJTZWcuZmlyc3RDb2wgPD0gc2VnLmxhc3RDb2wgJiZcclxuICAgICAgICAgICAgICAgIG90aGVyU2VnLmxhc3RDb2wgPj0gc2VnLmZpcnN0Q29sKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgdGhlIGxlZnRtb3N0IGV2ZW50XHJcbiAgICBmdW5jdGlvbiBjb21wYXJlRGF5U2VnQ29scyhhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEubGVmdENvbCAtIGIubGVmdENvbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgRGF5R3JpZE1pcnJvclJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhEYXlHcmlkTWlycm9yUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRGF5R3JpZE1pcnJvclJlbmRlcmVyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERheUdyaWRNaXJyb3JSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoU2VncyA9IGZ1bmN0aW9uIChzZWdzLCBtaXJyb3JJbmZvKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VTZWcgPSBtaXJyb3JJbmZvLnNvdXJjZVNlZztcclxuICAgICAgICAgICAgdmFyIHJvd1N0cnVjdHMgPSB0aGlzLnJvd1N0cnVjdHMgPSB0aGlzLnJlbmRlclNlZ1Jvd3Moc2Vncyk7XHJcbiAgICAgICAgICAgIC8vIGluamVjdCBlYWNoIG5ldyBldmVudCBza2VsZXRvbiBpbnRvIGVhY2ggYXNzb2NpYXRlZCByb3dcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJvd0Vscy5mb3JFYWNoKGZ1bmN0aW9uIChyb3dOb2RlLCByb3cpIHtcclxuICAgICAgICAgICAgICAgIHZhciBza2VsZXRvbkVsID0gY29yZS5odG1sVG9FbGVtZW50KCc8ZGl2IGNsYXNzPVwiZmMtbWlycm9yLXNrZWxldG9uXCI+PHRhYmxlPjwvdGFibGU+PC9kaXY+Jyk7IC8vIHdpbGwgYmUgYWJzb2x1dGVseSBwb3NpdGlvbmVkXHJcbiAgICAgICAgICAgICAgICB2YXIgc2tlbGV0b25Ub3BFbDtcclxuICAgICAgICAgICAgICAgIHZhciBza2VsZXRvblRvcDtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIG9yaWdpbmFsIHNlZ21lbnQsIG1hdGNoIHRoZSB0b3AgcG9zaXRpb24uIE90aGVyd2lzZSwgcHV0IGl0IGF0IHRoZSByb3cncyB0b3AgbGV2ZWxcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VTZWcgJiYgc291cmNlU2VnLnJvdyA9PT0gcm93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25Ub3BFbCA9IHNvdXJjZVNlZy5lbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wRWwgPSByb3dOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5mYy1jb250ZW50LXNrZWxldG9uIHRib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFza2VsZXRvblRvcEVsKSB7IC8vIHdoZW4gbm8gZXZlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wRWwgPSByb3dOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5mYy1jb250ZW50LXNrZWxldG9uIHRhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25Ub3AgPSBza2VsZXRvblRvcEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtXHJcbiAgICAgICAgICAgICAgICAgICAgcm93Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7IC8vIHRoZSBvZmZzZXRQYXJlbnQgb3JpZ2luXHJcbiAgICAgICAgICAgICAgICBza2VsZXRvbkVsLnN0eWxlLnRvcCA9IHNrZWxldG9uVG9wICsgJ3B4JztcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uRWwucXVlcnlTZWxlY3RvcigndGFibGUnKS5hcHBlbmRDaGlsZChyb3dTdHJ1Y3RzW3Jvd10udGJvZHlFbCk7XHJcbiAgICAgICAgICAgICAgICByb3dOb2RlLmFwcGVuZENoaWxkKHNrZWxldG9uRWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEYXlHcmlkTWlycm9yUmVuZGVyZXI7XHJcbiAgICB9KERheUdyaWRFdmVudFJlbmRlcmVyKSk7XHJcblxyXG4gICAgdmFyIEVNUFRZX0NFTExfSFRNTCA9ICc8dGQgc3R5bGU9XCJwb2ludGVyLWV2ZW50czpub25lXCI+PC90ZD4nO1xyXG4gICAgdmFyIERheUdyaWRGaWxsUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKERheUdyaWRGaWxsUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRGF5R3JpZEZpbGxSZW5kZXJlcihkYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRheUdyaWQuY29udGV4dCkgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZmlsbFNlZ1RhZyA9ICd0ZCc7IC8vIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHRhZyBuYW1lXHJcbiAgICAgICAgICAgIF90aGlzLmRheUdyaWQgPSBkYXlHcmlkO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERheUdyaWRGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xyXG4gICAgICAgICAgICAvLyBkb24ndCByZW5kZXIgdGltZWQgYmFja2dyb3VuZCBldmVudHNcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdiZ0V2ZW50Jykge1xyXG4gICAgICAgICAgICAgICAgc2VncyA9IHNlZ3MuZmlsdGVyKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVuZGVyU2Vncy5jYWxsKHRoaXMsIHR5cGUsIHNlZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF5R3JpZEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoU2VncyA9IGZ1bmN0aW9uICh0eXBlLCBzZWdzKSB7XHJcbiAgICAgICAgICAgIHZhciBlbHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgICAgIHZhciBza2VsZXRvbkVsO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uRWwgPSB0aGlzLnJlbmRlckZpbGxSb3codHlwZSwgc2VnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5yb3dFbHNbc2VnLnJvd10uYXBwZW5kQ2hpbGQoc2tlbGV0b25FbCk7XHJcbiAgICAgICAgICAgICAgICBlbHMucHVzaChza2VsZXRvbkVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZWxzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIG5lZWRlZCBmb3Igb25lIHJvdyBvZiBhIGZpbGwuIFJlcXVpcmVzIHRoZSBzZWcncyBlbCB0byBiZSByZW5kZXJlZC5cclxuICAgICAgICBEYXlHcmlkRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGaWxsUm93ID0gZnVuY3Rpb24gKHR5cGUsIHNlZykge1xyXG4gICAgICAgICAgICB2YXIgZGF5R3JpZCA9IHRoaXMuZGF5R3JpZDtcclxuICAgICAgICAgICAgdmFyIGNvbENudCA9IGRheUdyaWQuY29sQ250LCBpc1J0bCA9IGRheUdyaWQuaXNSdGw7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5sYXN0Q29sKSA6IHNlZy5maXJzdENvbDtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5maXJzdENvbCkgOiBzZWcubGFzdENvbDtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Q29sID0gbGVmdENvbDtcclxuICAgICAgICAgICAgdmFyIGVuZENvbCA9IHJpZ2h0Q29sICsgMTtcclxuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZTtcclxuICAgICAgICAgICAgdmFyIHNrZWxldG9uRWw7XHJcbiAgICAgICAgICAgIHZhciB0ckVsO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSAnYmdldmVudCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2tlbGV0b25FbCA9IGNvcmUuaHRtbFRvRWxlbWVudCgnPGRpdiBjbGFzcz1cImZjLScgKyBjbGFzc05hbWUgKyAnLXNrZWxldG9uXCI+JyArXHJcbiAgICAgICAgICAgICAgICAnPHRhYmxlPjx0cj48L3RyPjwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICAgICAgICAgIHRyRWwgPSBza2VsZXRvbkVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0cicpWzBdO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRDb2wgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb3JlLmFwcGVuZFRvRWxlbWVudCh0ckVsLCBcclxuICAgICAgICAgICAgICAgIC8vIHdpbGwgY3JlYXRlIChzdGFydENvbCArIDEpIHRkJ3NcclxuICAgICAgICAgICAgICAgIG5ldyBBcnJheShzdGFydENvbCArIDEpLmpvaW4oRU1QVFlfQ0VMTF9IVE1MKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VnLmVsLmNvbFNwYW4gPSBlbmRDb2wgLSBzdGFydENvbDtcclxuICAgICAgICAgICAgdHJFbC5hcHBlbmRDaGlsZChzZWcuZWwpO1xyXG4gICAgICAgICAgICBpZiAoZW5kQ29sIDwgY29sQ250KSB7XHJcbiAgICAgICAgICAgICAgICBjb3JlLmFwcGVuZFRvRWxlbWVudCh0ckVsLCBcclxuICAgICAgICAgICAgICAgIC8vIHdpbGwgY3JlYXRlIChjb2xDbnQgLSBlbmRDb2wpIHRkJ3NcclxuICAgICAgICAgICAgICAgIG5ldyBBcnJheShjb2xDbnQgLSBlbmRDb2wgKyAxKS5qb2luKEVNUFRZX0NFTExfSFRNTCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbnRyb0h0bWwgPSBkYXlHcmlkLnJlbmRlclByb3BzLnJlbmRlckludHJvSHRtbCgpO1xyXG4gICAgICAgICAgICBpZiAoaW50cm9IdG1sKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF5R3JpZC5pc1J0bCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuYXBwZW5kVG9FbGVtZW50KHRyRWwsIGludHJvSHRtbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLnByZXBlbmRUb0VsZW1lbnQodHJFbCwgaW50cm9IdG1sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2tlbGV0b25FbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEYXlHcmlkRmlsbFJlbmRlcmVyO1xyXG4gICAgfShjb3JlLkZpbGxSZW5kZXJlcikpO1xyXG5cclxuICAgIHZhciBEYXlUaWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhEYXlUaWxlLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIERheVRpbGUoY29udGV4dCwgZWwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCwgZWwpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBldmVudFJlbmRlcmVyID0gX3RoaXMuZXZlbnRSZW5kZXJlciA9IG5ldyBEYXlUaWxlRXZlbnRSZW5kZXJlcihfdGhpcyk7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJGcmFtZSA9IF90aGlzLnJlbmRlckZyYW1lID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKF90aGlzLl9yZW5kZXJGcmFtZSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckZnRXZlbnRzID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGV2ZW50UmVuZGVyZXIucmVuZGVyU2Vncy5iaW5kKGV2ZW50UmVuZGVyZXIpLCBldmVudFJlbmRlcmVyLnVucmVuZGVyLmJpbmQoZXZlbnRSZW5kZXJlciksIFtyZW5kZXJGcmFtZV0pO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJFdmVudFNlbGVjdGlvbiA9IGNvcmUubWVtb2l6ZVJlbmRlcmluZyhldmVudFJlbmRlcmVyLnNlbGVjdEJ5SW5zdGFuY2VJZC5iaW5kKGV2ZW50UmVuZGVyZXIpLCBldmVudFJlbmRlcmVyLnVuc2VsZWN0QnlJbnN0YW5jZUlkLmJpbmQoZXZlbnRSZW5kZXJlciksIFtfdGhpcy5yZW5kZXJGZ0V2ZW50c10pO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJFdmVudERyYWcgPSBjb3JlLm1lbW9pemVSZW5kZXJpbmcoZXZlbnRSZW5kZXJlci5oaWRlQnlIYXNoLmJpbmQoZXZlbnRSZW5kZXJlciksIGV2ZW50UmVuZGVyZXIuc2hvd0J5SGFzaC5iaW5kKGV2ZW50UmVuZGVyZXIpLCBbcmVuZGVyRnJhbWVdKTtcclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyRXZlbnRSZXNpemUgPSBjb3JlLm1lbW9pemVSZW5kZXJpbmcoZXZlbnRSZW5kZXJlci5oaWRlQnlIYXNoLmJpbmQoZXZlbnRSZW5kZXJlciksIGV2ZW50UmVuZGVyZXIuc2hvd0J5SGFzaC5iaW5kKGV2ZW50UmVuZGVyZXIpLCBbcmVuZGVyRnJhbWVdKTtcclxuICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhci5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzLCB7XHJcbiAgICAgICAgICAgICAgICBlbDogX3RoaXMuZWwsXHJcbiAgICAgICAgICAgICAgICB1c2VFdmVudENlbnRlcjogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgRGF5VGlsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRnJhbWUocHJvcHMuZGF0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRmdFdmVudHMocHJvcHMuZmdTZWdzKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJFdmVudFNlbGVjdGlvbihwcm9wcy5ldmVudFNlbGVjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZ0luc3RhbmNlcyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemVJbnN0YW5jZXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF5VGlsZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRnJhbWUudW5yZW5kZXIoKTsgLy8gc2hvdWxkIHVucmVuZGVyIGV2ZXJ5dGhpbmcgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERheVRpbGUucHJvdG90eXBlLl9yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHRoZW1lID0gX2EudGhlbWUsIGRhdGVFbnYgPSBfYS5kYXRlRW52O1xyXG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBjb3JlLmNyZWF0ZUZvcm1hdHRlcih0aGlzLm9wdCgnZGF5UG9wb3ZlckZvcm1hdCcpKSAvLyBUT0RPOiBjYWNoZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLmVsLmlubmVySFRNTCA9XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWhlYWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJIZWFkZXInKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYy10aXRsZVwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuaHRtbEVzY2FwZSh0aXRsZSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmMtY2xvc2UgJyArIHRoZW1lLmdldEljb25DbGFzcygnY2xvc2UnKSArICdcIj48L3NwYW4+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYm9keSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJDb250ZW50JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JztcclxuICAgICAgICAgICAgdGhpcy5zZWdDb250YWluZXJFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LWNvbnRhaW5lcicpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF5VGlsZS5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGUgPSB0aGlzLnByb3BzLmRhdGU7IC8vIEhBQ0tcclxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uTGVmdCA8IGVsV2lkdGggJiYgcG9zaXRpb25Ub3AgPCBlbEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVNwYW46IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogeyBzdGFydDogZGF0ZSwgZW5kOiBjb3JlLmFkZERheXMoZGF0ZSwgMSkgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGF5RWw6IHRoaXMuZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBlbFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGVsSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBsYXllcjogMVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERheVRpbGU7XHJcbiAgICB9KGNvcmUuRGF0ZUNvbXBvbmVudCkpO1xyXG4gICAgdmFyIERheVRpbGVFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhEYXlUaWxlRXZlbnRSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBEYXlUaWxlRXZlbnRSZW5kZXJlcihkYXlUaWxlKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRheVRpbGUuY29udGV4dCkgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZGF5VGlsZSA9IGRheVRpbGU7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgRGF5VGlsZUV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaFNlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ3NfMSA9IHNlZ3M7IF9pIDwgc2Vnc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMVtfaV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRheVRpbGUuc2VnQ29udGFpbmVyRWwuYXBwZW5kQ2hpbGQoc2VnLmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF5VGlsZUV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmRldGFjaFNlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ3NfMiA9IHNlZ3M7IF9pIDwgc2Vnc18yLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMltfaV07XHJcbiAgICAgICAgICAgICAgICBjb3JlLnJlbW92ZUVsZW1lbnQoc2VnLmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERheVRpbGVFdmVudFJlbmRlcmVyO1xyXG4gICAgfShTaW1wbGVEYXlHcmlkRXZlbnRSZW5kZXJlcikpO1xyXG5cclxuICAgIHZhciBEYXlCZ1JvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEYXlCZ1Jvdyhjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERheUJnUm93LnByb3RvdHlwZS5yZW5kZXJIdG1sID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMucmVuZGVySW50cm9IdG1sKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHByb3BzLnJlbmRlckludHJvSHRtbCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcHJvcHMuY2VsbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocmVuZGVyQ2VsbEh0bWwoY2VsbC5kYXRlLCBwcm9wcy5kYXRlUHJvZmlsZSwgdGhpcy5jb250ZXh0LCBjZWxsLmh0bWxBdHRycykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghcHJvcHMuY2VsbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKCc8dGQgY2xhc3M9XCJmYy1kYXkgJyArIHRoaXMuY29udGV4dC50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiPjwvdGQ+Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vcHRpb25zLmRpciA9PT0gJ3J0bCcpIHtcclxuICAgICAgICAgICAgICAgIHBhcnRzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJzx0cj4nICsgcGFydHMuam9pbignJykgKyAnPC90cj4nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERheUJnUm93O1xyXG4gICAgfSgpKTtcclxuICAgIGZ1bmN0aW9uIHJlbmRlckNlbGxIdG1sKGRhdGUsIGRhdGVQcm9maWxlLCBjb250ZXh0LCBvdGhlckF0dHJzKSB7XHJcbiAgICAgICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIHRoZW1lID0gY29udGV4dC50aGVtZTtcclxuICAgICAgICB2YXIgaXNEYXRlVmFsaWQgPSBjb3JlLnJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGRhdGUpOyAvLyBUT0RPOiBjYWxsZWQgdG9vIGZyZXF1ZW50bHkuIGNhY2hlIHNvbWVob3cuXHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBjb3JlLmdldERheUNsYXNzZXMoZGF0ZSwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpO1xyXG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5JywgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSk7XHJcbiAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGlzRGF0ZVZhbGlkID9cclxuICAgICAgICAgICAgICAgICcgZGF0YS1kYXRlPVwiJyArIGRhdGVFbnYuZm9ybWF0SXNvKGRhdGUsIHsgb21pdFRpbWU6IHRydWUgfSkgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChvdGhlckF0dHJzID9cclxuICAgICAgICAgICAgICAgICcgJyArIG90aGVyQXR0cnMgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJz48L3RkPic7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIERBWV9OVU1fRk9STUFUID0gY29yZS5jcmVhdGVGb3JtYXR0ZXIoeyBkYXk6ICdudW1lcmljJyB9KTtcclxuICAgIHZhciBXRUVLX05VTV9GT1JNQVQgPSBjb3JlLmNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICdudW1lcmljJyB9KTtcclxuICAgIHZhciBEYXlHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhEYXlHcmlkLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIERheUdyaWQoY29udGV4dCwgZWwsIHJlbmRlclByb3BzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQsIGVsKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5ib3R0b21Db29yZFBhZGRpbmcgPSAwOyAvLyBoYWNrIGZvciBleHRlbmRpbmcgdGhlIGhpdCBhcmVhIGZvciB0aGUgbGFzdCByb3cgb2YgdGhlIGNvb3JkaW5hdGUgZ3JpZFxyXG4gICAgICAgICAgICBfdGhpcy5pc0NlbGxTaXplc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBldmVudFJlbmRlcmVyID0gX3RoaXMuZXZlbnRSZW5kZXJlciA9IG5ldyBEYXlHcmlkRXZlbnRSZW5kZXJlcihfdGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBmaWxsUmVuZGVyZXIgPSBfdGhpcy5maWxsUmVuZGVyZXIgPSBuZXcgRGF5R3JpZEZpbGxSZW5kZXJlcihfdGhpcyk7XHJcbiAgICAgICAgICAgIF90aGlzLm1pcnJvclJlbmRlcmVyID0gbmV3IERheUdyaWRNaXJyb3JSZW5kZXJlcihfdGhpcyk7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJDZWxscyA9IF90aGlzLnJlbmRlckNlbGxzID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKF90aGlzLl9yZW5kZXJDZWxscywgX3RoaXMuX3VucmVuZGVyQ2VsbHMpO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJCdXNpbmVzc0hvdXJzID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGZpbGxSZW5kZXJlci5yZW5kZXJTZWdzLmJpbmQoZmlsbFJlbmRlcmVyLCAnYnVzaW5lc3NIb3VycycpLCBmaWxsUmVuZGVyZXIudW5yZW5kZXIuYmluZChmaWxsUmVuZGVyZXIsICdidXNpbmVzc0hvdXJzJyksIFtyZW5kZXJDZWxsc10pO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJEYXRlU2VsZWN0aW9uID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGZpbGxSZW5kZXJlci5yZW5kZXJTZWdzLmJpbmQoZmlsbFJlbmRlcmVyLCAnaGlnaGxpZ2h0JyksIGZpbGxSZW5kZXJlci51bnJlbmRlci5iaW5kKGZpbGxSZW5kZXJlciwgJ2hpZ2hsaWdodCcpLCBbcmVuZGVyQ2VsbHNdKTtcclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyQmdFdmVudHMgPSBjb3JlLm1lbW9pemVSZW5kZXJpbmcoZmlsbFJlbmRlcmVyLnJlbmRlclNlZ3MuYmluZChmaWxsUmVuZGVyZXIsICdiZ0V2ZW50JyksIGZpbGxSZW5kZXJlci51bnJlbmRlci5iaW5kKGZpbGxSZW5kZXJlciwgJ2JnRXZlbnQnKSwgW3JlbmRlckNlbGxzXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckZnRXZlbnRzID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGV2ZW50UmVuZGVyZXIucmVuZGVyU2Vncy5iaW5kKGV2ZW50UmVuZGVyZXIpLCBldmVudFJlbmRlcmVyLnVucmVuZGVyLmJpbmQoZXZlbnRSZW5kZXJlciksIFtyZW5kZXJDZWxsc10pO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJFdmVudFNlbGVjdGlvbiA9IGNvcmUubWVtb2l6ZVJlbmRlcmluZyhldmVudFJlbmRlcmVyLnNlbGVjdEJ5SW5zdGFuY2VJZC5iaW5kKGV2ZW50UmVuZGVyZXIpLCBldmVudFJlbmRlcmVyLnVuc2VsZWN0QnlJbnN0YW5jZUlkLmJpbmQoZXZlbnRSZW5kZXJlciksIFtfdGhpcy5yZW5kZXJGZ0V2ZW50c10pO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJFdmVudERyYWcgPSBjb3JlLm1lbW9pemVSZW5kZXJpbmcoX3RoaXMuX3JlbmRlckV2ZW50RHJhZywgX3RoaXMuX3VucmVuZGVyRXZlbnREcmFnLCBbcmVuZGVyQ2VsbHNdKTtcclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyRXZlbnRSZXNpemUgPSBjb3JlLm1lbW9pemVSZW5kZXJpbmcoX3RoaXMuX3JlbmRlckV2ZW50UmVzaXplLCBfdGhpcy5fdW5yZW5kZXJFdmVudFJlc2l6ZSwgW3JlbmRlckNlbGxzXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlclByb3BzID0gcmVuZGVyUHJvcHM7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHZhciBjZWxscyA9IHByb3BzLmNlbGxzO1xyXG4gICAgICAgICAgICB0aGlzLnJvd0NudCA9IGNlbGxzLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5jb2xDbnQgPSBjZWxsc1swXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2VsbHMoY2VsbHMsIHByb3BzLmlzUmlnaWQpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckJ1c2luZXNzSG91cnMocHJvcHMuYnVzaW5lc3NIb3VyU2Vncyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uU2Vncyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmdFdmVudHMocHJvcHMuYmdFdmVudFNlZ3MpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckZnRXZlbnRzKHByb3BzLmZnRXZlbnRTZWdzKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJFdmVudFNlbGVjdGlvbihwcm9wcy5ldmVudFNlbGVjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWdQb3BvdmVyVGlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTZWdQb3BvdmVyVGlsZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJDZWxscy51bnJlbmRlcigpOyAvLyB3aWxsIHVucmVuZGVyIGV2ZXJ5dGhpbmcgZWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0Q2VsbFJhbmdlID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdLmRhdGU7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBjb3JlLmFkZERheXMoc3RhcnQsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS51cGRhdGVTZWdQb3BvdmVyVGlsZSA9IGZ1bmN0aW9uIChkYXRlLCBzZWdzKSB7XHJcbiAgICAgICAgICAgIHZhciBvd25Qcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIHRoaXMuc2VnUG9wb3ZlclRpbGUucmVjZWl2ZVByb3BzKHtcclxuICAgICAgICAgICAgICAgIGRhdGU6IGRhdGUgfHwgdGhpcy5zZWdQb3BvdmVyVGlsZS5wcm9wcy5kYXRlLFxyXG4gICAgICAgICAgICAgICAgZmdTZWdzOiBzZWdzIHx8IHRoaXMuc2VnUG9wb3ZlclRpbGUucHJvcHMuZmdTZWdzLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IG93blByb3BzLmV2ZW50U2VsZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnSW5zdGFuY2VzOiBvd25Qcm9wcy5ldmVudERyYWcgPyBvd25Qcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemVJbnN0YW5jZXM6IG93blByb3BzLmV2ZW50UmVzaXplID8gb3duUHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogRGF0ZSBSZW5kZXJpbmdcclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLl9yZW5kZXJDZWxscyA9IGZ1bmN0aW9uIChjZWxscywgaXNSaWdpZCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCB2aWV3ID0gX2EudmlldywgZGF0ZUVudiA9IF9hLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IHRoaXMsIHJvd0NudCA9IF9iLnJvd0NudCwgY29sQ250ID0gX2IuY29sQ250O1xyXG4gICAgICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgICAgICB2YXIgcm93O1xyXG4gICAgICAgICAgICB2YXIgY29sO1xyXG4gICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gdGhpcy5yZW5kZXJEYXlSb3dIdG1sKHJvdywgaXNSaWdpZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSBodG1sO1xyXG4gICAgICAgICAgICB0aGlzLnJvd0VscyA9IGNvcmUuZmluZEVsZW1lbnRzKHRoaXMuZWwsICcuZmMtcm93Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2VsbEVscyA9IGNvcmUuZmluZEVsZW1lbnRzKHRoaXMuZWwsICcuZmMtZGF5LCAuZmMtZGlzYWJsZWQtZGF5Jyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUnRsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxFbHMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucm93UG9zaXRpb25zID0gbmV3IGNvcmUuUG9zaXRpb25DYWNoZSh0aGlzLmVsLCB0aGlzLnJvd0VscywgZmFsc2UsIHRydWUgLy8gdmVydGljYWxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xQb3NpdGlvbnMgPSBuZXcgY29yZS5Qb3NpdGlvbkNhY2hlKHRoaXMuZWwsIHRoaXMuY2VsbEVscy5zbGljZSgwLCBjb2xDbnQpLCAvLyBvbmx5IHRoZSBmaXJzdCByb3dcclxuICAgICAgICAgICAgdHJ1ZSwgZmFsc2UgLy8gaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGRheVJlbmRlciB3aXRoIGVhY2ggY2VsbCdzIGVsZW1lbnRcclxuICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dDbnQ7IHJvdysrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZGF5UmVuZGVyJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShjZWxsc1tyb3ddW2NvbF0uZGF0ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbDogdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogdmlld1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pc0NlbGxTaXplc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLl91bnJlbmRlckNlbGxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNlZ1BvcG92ZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgYSBzaW5nbGUgcm93LCB3aGljaCBpcyBhIGRpdiB0aGF0IHdyYXBzIGEgdGFibGUuXHJcbiAgICAgICAgLy8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyRGF5Um93SHRtbCA9IGZ1bmN0aW9uIChyb3csIGlzUmlnaWQpIHtcclxuICAgICAgICAgICAgdmFyIHRoZW1lID0gdGhpcy50aGVtZTtcclxuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbJ2ZjLXJvdycsICdmYy13ZWVrJywgdGhlbWUuZ2V0Q2xhc3MoJ2RheVJvdycpXTtcclxuICAgICAgICAgICAgaWYgKGlzUmlnaWQpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtcmlnaWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYmdSb3cgPSBuZXcgRGF5QmdSb3codGhpcy5jb250ZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1iZ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICBiZ1Jvdy5yZW5kZXJIdG1sKHtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsczogdGhpcy5wcm9wcy5jZWxsc1tyb3ddLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiB0aGlzLnByb3BzLmRhdGVQcm9maWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckludHJvSHRtbDogdGhpcy5yZW5kZXJQcm9wcy5yZW5kZXJCZ0ludHJvSHRtbFxyXG4gICAgICAgICAgICAgICAgfSkgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtc2tlbGV0b25cIj4nICtcclxuICAgICAgICAgICAgICAgICc8dGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAodGhpcy5nZXRJc051bWJlcnNWaXNpYmxlKCkgP1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGhlYWQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTnVtYmVyVHJIdG1sKHJvdykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nIDpcclxuICAgICAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JztcclxuICAgICAgICB9O1xyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLmdldElzTnVtYmVyc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldElzRGF5TnVtYmVyc1Zpc2libGUoKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJQcm9wcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclByb3BzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLmdldElzRGF5TnVtYmVyc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0NudCA+IDE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBHcmlkIE51bWJlciBSZW5kZXJpbmdcclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck51bWJlclRySHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICAgICAgdmFyIGludHJvID0gdGhpcy5yZW5kZXJQcm9wcy5yZW5kZXJOdW1iZXJJbnRyb0h0bWwocm93LCB0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICAgICAodGhpcy5pc1J0bCA/ICcnIDogaW50cm8pICtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTnVtYmVyQ2VsbHNIdG1sKHJvdykgK1xyXG4gICAgICAgICAgICAgICAgKHRoaXMuaXNSdGwgPyBpbnRybyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyTnVtYmVyQ2VsbHNIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgICAgICB2YXIgaHRtbHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICAgICAgdmFyIGRhdGU7XHJcbiAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF0uZGF0ZTtcclxuICAgICAgICAgICAgICAgIGh0bWxzLnB1c2godGhpcy5yZW5kZXJOdW1iZXJDZWxsSHRtbChkYXRlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSdGwpIHtcclxuICAgICAgICAgICAgICAgIGh0bWxzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaHRtbHMuam9pbignJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSA8dGQ+cyBvZiB0aGUgXCJudW1iZXJcIiByb3cgaW4gdGhlIERheUdyaWQncyBjb250ZW50IHNrZWxldG9uLlxyXG4gICAgICAgIC8vIFRoZSBudW1iZXIgcm93IHdpbGwgb25seSBleGlzdCBpZiBlaXRoZXIgZGF5IG51bWJlcnMgb3Igd2VlayBudW1iZXJzIGFyZSB0dXJuZWQgb24uXHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyTnVtYmVyQ2VsbEh0bWwgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCB2aWV3ID0gX2EudmlldywgZGF0ZUVudiA9IF9hLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgICAgIHZhciBpc0RhdGVWYWxpZCA9IGNvcmUucmFuZ2VDb250YWluc01hcmtlcih0aGlzLnByb3BzLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBkYXRlKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxyXG4gICAgICAgICAgICB2YXIgaXNEYXlOdW1iZXJWaXNpYmxlID0gdGhpcy5nZXRJc0RheU51bWJlcnNWaXNpYmxlKCkgJiYgaXNEYXRlVmFsaWQ7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc2VzO1xyXG4gICAgICAgICAgICB2YXIgd2Vla0NhbGNGaXJzdERvdztcclxuICAgICAgICAgICAgaWYgKCFpc0RheU51bWJlclZpc2libGUgJiYgIXRoaXMucmVuZGVyUHJvcHMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gbnVtYmVycyBpbiBkYXkgY2VsbCAod2VlayBudW1iZXIgbXVzdCBiZSBhbG9uZyB0aGUgc2lkZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRkPjwvdGQ+JzsgLy8gIHdpbGwgY3JlYXRlIGFuIGVtcHR5IHNwYWNlIGFib3ZlIGV2ZW50cyA6KFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsYXNzZXMgPSBjb3JlLmdldERheUNsYXNzZXMoZGF0ZSwgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSwgdGhpcy5jb250ZXh0KTtcclxuICAgICAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXktdG9wJyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlclByb3BzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHdlZWtDYWxjRmlyc3REb3cgPSBkYXRlRW52LndlZWtEb3c7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaHRtbCArPSAnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAoaXNEYXRlVmFsaWQgP1xyXG4gICAgICAgICAgICAgICAgICAgICcgZGF0YS1kYXRlPVwiJyArIGRhdGVFbnYuZm9ybWF0SXNvKGRhdGUsIHsgb21pdFRpbWU6IHRydWUgfSkgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAgICAgJz4nO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJQcm9wcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlICYmIChkYXRlLmdldFVUQ0RheSgpID09PSB3ZWVrQ2FsY0ZpcnN0RG93KSkge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSBjb3JlLmJ1aWxkR290b0FuY2hvckh0bWwodmlldywgeyBkYXRlOiBkYXRlLCB0eXBlOiAnd2VlaycgfSwgeyAnY2xhc3MnOiAnZmMtd2Vlay1udW1iZXInIH0sIGRhdGVFbnYuZm9ybWF0KGRhdGUsIFdFRUtfTlVNX0ZPUk1BVCkgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNEYXlOdW1iZXJWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9IGNvcmUuYnVpbGRHb3RvQW5jaG9ySHRtbCh2aWV3LCBkYXRlLCB7ICdjbGFzcyc6ICdmYy1kYXktbnVtYmVyJyB9LCBkYXRlRW52LmZvcm1hdChkYXRlLCBEQVlfTlVNX0ZPUk1BVCkgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBodG1sICs9ICc8L3RkPic7XHJcbiAgICAgICAgICAgIHJldHVybiBodG1sO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogU2l6aW5nXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKGlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGZpbGxSZW5kZXJlciA9IF9hLmZpbGxSZW5kZXJlciwgZXZlbnRSZW5kZXJlciA9IF9hLmV2ZW50UmVuZGVyZXIsIG1pcnJvclJlbmRlcmVyID0gX2EubWlycm9yUmVuZGVyZXI7XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6ZSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0NlbGxTaXplc0RpcnR5IHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuY2FsZW5kYXIuaXNFdmVudHNVcGRhdGVkIC8vIGhhY2tcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUG9zaXRpb25DYWNoZXMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNDZWxsU2l6ZXNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbGxSZW5kZXJlci5jb21wdXRlU2l6ZXMoaXNSZXNpemUpO1xyXG4gICAgICAgICAgICBldmVudFJlbmRlcmVyLmNvbXB1dGVTaXplcyhpc1Jlc2l6ZSk7XHJcbiAgICAgICAgICAgIG1pcnJvclJlbmRlcmVyLmNvbXB1dGVTaXplcyhpc1Jlc2l6ZSk7XHJcbiAgICAgICAgICAgIGZpbGxSZW5kZXJlci5hc3NpZ25TaXplcyhpc1Jlc2l6ZSk7XHJcbiAgICAgICAgICAgIGV2ZW50UmVuZGVyZXIuYXNzaWduU2l6ZXMoaXNSZXNpemUpO1xyXG4gICAgICAgICAgICBtaXJyb3JSZW5kZXJlci5hc3NpZ25TaXplcyhpc1Jlc2l6ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5idWlsZFBvc2l0aW9uQ2FjaGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQ29sUG9zaXRpb25zKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRSb3dQb3NpdGlvbnMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLmJ1aWxkQ29sUG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbFBvc2l0aW9ucy5idWlsZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUuYnVpbGRSb3dQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm93UG9zaXRpb25zLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgIHRoaXMucm93UG9zaXRpb25zLmJvdHRvbXNbdGhpcy5yb3dDbnQgLSAxXSArPSB0aGlzLmJvdHRvbUNvb3JkUGFkZGluZzsgLy8gaGFja1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogSGl0IFN5c3RlbVxyXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUucG9zaXRpb25Ub0hpdCA9IGZ1bmN0aW9uIChsZWZ0UG9zaXRpb24sIHRvcFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbFBvc2l0aW9ucyA9IF9hLmNvbFBvc2l0aW9ucywgcm93UG9zaXRpb25zID0gX2Eucm93UG9zaXRpb25zO1xyXG4gICAgICAgICAgICB2YXIgY29sID0gY29sUG9zaXRpb25zLmxlZnRUb0luZGV4KGxlZnRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZhciByb3cgPSByb3dQb3NpdGlvbnMudG9wVG9JbmRleCh0b3BQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlU3Bhbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogdGhpcy5nZXRDZWxsUmFuZ2Uocm93LCBjb2wpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxEYXk6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUVsOiB0aGlzLmdldENlbGxFbChyb3csIGNvbCksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVSZWN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbFBvc2l0aW9ucy5sZWZ0c1tjb2xdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogY29sUG9zaXRpb25zLnJpZ2h0c1tjb2xdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHJvd1Bvc2l0aW9ucy50b3BzW3Jvd10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogcm93UG9zaXRpb25zLmJvdHRvbXNbcm93XVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIENlbGwgU3lzdGVtXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAvLyBGWUk6IHRoZSBmaXJzdCBjb2x1bW4gaXMgdGhlIGxlZnRtb3N0IGNvbHVtbiwgcmVnYXJkbGVzcyBvZiBkYXRlXHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0Q2VsbEVsID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGxFbHNbcm93ICogdGhpcy5jb2xDbnQgKyBjb2xdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogRXZlbnQgRHJhZyBWaXN1YWxpemF0aW9uXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5fcmVuZGVyRXZlbnREcmFnID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLmhpZGVCeUhhc2goc3RhdGUuYWZmZWN0ZWRJbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyU2VncygnaGlnaGxpZ2h0Jywgc3RhdGUuc2Vncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLl91bnJlbmRlckV2ZW50RHJhZyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5zaG93QnlIYXNoKHN0YXRlLmFmZmVjdGVkSW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnVucmVuZGVyKCdoaWdobGlnaHQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogRXZlbnQgUmVzaXplIFZpc3VhbGl6YXRpb25cclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLl9yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5oaWRlQnlIYXNoKHN0YXRlLmFmZmVjdGVkSW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnJlbmRlclNlZ3MoJ2hpZ2hsaWdodCcsIHN0YXRlLnNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JSZW5kZXJlci5yZW5kZXJTZWdzKHN0YXRlLnNlZ3MsIHsgaXNSZXNpemluZzogdHJ1ZSwgc291cmNlU2VnOiBzdGF0ZS5zb3VyY2VTZWcgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLl91bnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnNob3dCeUhhc2goc3RhdGUuYWZmZWN0ZWRJbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIudW5yZW5kZXIoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JSZW5kZXJlci51bnJlbmRlcihzdGF0ZS5zZWdzLCB7IGlzUmVzaXppbmc6IHRydWUsIHNvdXJjZVNlZzogc3RhdGUuc291cmNlU2VnIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBNb3JlKyBMaW5rIFBvcG92ZXJcclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLnJlbW92ZVNlZ1BvcG92ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlZ1BvcG92ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VnUG9wb3Zlci5oaWRlKCk7IC8vIGluIGhhbmRsZXIsIHdpbGwgY2FsbCBzZWdQb3BvdmVyJ3MgcmVtb3ZlRWxlbWVudFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBMaW1pdHMgdGhlIG51bWJlciBvZiBcImxldmVsc1wiICh2ZXJ0aWNhbGx5IHN0YWNraW5nIGxheWVycyBvZiBldmVudHMpIGZvciBlYWNoIHJvdyBvZiB0aGUgZ3JpZC5cclxuICAgICAgICAvLyBgbGV2ZWxMaW1pdGAgY2FuIGJlIGZhbHNlIChkb24ndCBsaW1pdCksIGEgbnVtYmVyLCBvciB0cnVlIChzaG91bGQgYmUgY29tcHV0ZWQpLlxyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLmxpbWl0Um93cyA9IGZ1bmN0aW9uIChsZXZlbExpbWl0KSB7XHJcbiAgICAgICAgICAgIHZhciByb3dTdHJ1Y3RzID0gdGhpcy5ldmVudFJlbmRlcmVyLnJvd1N0cnVjdHMgfHwgW107XHJcbiAgICAgICAgICAgIHZhciByb3c7IC8vIHJvdyAjXHJcbiAgICAgICAgICAgIHZhciByb3dMZXZlbExpbWl0O1xyXG4gICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd1N0cnVjdHMubGVuZ3RoOyByb3crKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bmxpbWl0Um93KHJvdyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxldmVsTGltaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3dMZXZlbExpbWl0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbGV2ZWxMaW1pdCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3dMZXZlbExpbWl0ID0gbGV2ZWxMaW1pdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd0xldmVsTGltaXQgPSB0aGlzLmNvbXB1dGVSb3dMZXZlbExpbWl0KHJvdyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocm93TGV2ZWxMaW1pdCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0Um93KHJvdywgcm93TGV2ZWxMaW1pdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENvbXB1dGVzIHRoZSBudW1iZXIgb2YgbGV2ZWxzIGEgcm93IHdpbGwgYWNjb21vZGF0ZSB3aXRob3V0IGdvaW5nIG91dHNpZGUgaXRzIGJvdW5kcy5cclxuICAgICAgICAvLyBBc3N1bWVzIHRoZSByb3cgaXMgXCJyaWdpZFwiIChtYWludGFpbnMgYSBjb25zdGFudCBoZWlnaHQgcmVnYXJkbGVzcyBvZiB3aGF0IGlzIGluc2lkZSkuXHJcbiAgICAgICAgLy8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUuY29tcHV0ZVJvd0xldmVsTGltaXQgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgICAgIHZhciByb3dFbCA9IHRoaXMucm93RWxzW3Jvd107IC8vIHRoZSBjb250YWluaW5nIFwiZmFrZVwiIHJvdyBkaXZcclxuICAgICAgICAgICAgdmFyIHJvd0JvdHRvbSA9IHJvd0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbTsgLy8gcmVsYXRpdmUgdG8gdmlld3BvcnQhXHJcbiAgICAgICAgICAgIHZhciB0ckVscyA9IGNvcmUuZmluZENoaWxkcmVuKHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzW3Jvd10udGJvZHlFbCk7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgdHJFbDtcclxuICAgICAgICAgICAgLy8gUmV2ZWFsIG9uZSBsZXZlbCA8dHI+IGF0IGEgdGltZSBhbmQgc3RvcCB3aGVuIHdlIGZpbmQgb25lIG91dCBvZiBib3VuZHNcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRyRWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ckVsID0gdHJFbHNbaV07XHJcbiAgICAgICAgICAgICAgICB0ckVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLWxpbWl0ZWQnKTsgLy8gcmVzZXQgdG8gb3JpZ2luYWwgc3RhdGUgKHJldmVhbClcclxuICAgICAgICAgICAgICAgIGlmICh0ckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSA+IHJvd0JvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gc2hvdWxkIG5vdCBsaW1pdCBhdCBhbGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIExpbWl0cyB0aGUgZ2l2ZW4gZ3JpZCByb3cgdG8gdGhlIG1heGltdW0gbnVtYmVyIG9mIGxldmVscyBhbmQgaW5qZWN0cyBcIm1vcmVcIiBsaW5rcyBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgLy8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXHJcbiAgICAgICAgLy8gYGxldmVsTGltaXRgIGlzIGEgbnVtYmVyIGZvciB0aGUgbWF4aW11bSAoaW5jbHVzaXZlKSBudW1iZXIgb2YgbGV2ZWxzIGFsbG93ZWQuXHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUubGltaXRSb3cgPSBmdW5jdGlvbiAocm93LCBsZXZlbExpbWl0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbENudCA9IF9hLmNvbENudCwgaXNSdGwgPSBfYS5pc1J0bDtcclxuICAgICAgICAgICAgdmFyIHJvd1N0cnVjdCA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzW3Jvd107XHJcbiAgICAgICAgICAgIHZhciBtb3JlTm9kZXMgPSBbXTsgLy8gYXJyYXkgb2YgXCJtb3JlXCIgPGE+IGxpbmtzIGFuZCA8dGQ+IERPTSBub2Rlc1xyXG4gICAgICAgICAgICB2YXIgY29sID0gMDsgLy8gY29sICMsIGxlZnQtdG8tcmlnaHQgKG5vdCBjaHJvbm9sb2dpY2FsbHkpXHJcbiAgICAgICAgICAgIHZhciBsZXZlbFNlZ3M7IC8vIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cyBpbiB0aGUgbGFzdCBhbGxvd2FibGUgbGV2ZWwsIG9yZGVyZWQgbGVmdC10by1yaWdodFxyXG4gICAgICAgICAgICB2YXIgY2VsbE1hdHJpeDsgLy8gYSBtYXRyaXggKGJ5IGxldmVsLCB0aGVuIGNvbHVtbikgb2YgYWxsIDx0ZD4gZWxlbWVudHMgaW4gdGhlIHJvd1xyXG4gICAgICAgICAgICB2YXIgbGltaXRlZE5vZGVzOyAvLyBhcnJheSBvZiB0ZW1wb3JhcmlseSBoaWRkZW4gbGV2ZWwgPHRyPiBhbmQgc2VnbWVudCA8dGQ+IERPTSBub2Rlc1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIHNlZztcclxuICAgICAgICAgICAgdmFyIHNlZ3NCZWxvdzsgLy8gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIGJlbG93IGBzZWdgIGluIHRoZSBjdXJyZW50IGBjb2xgXHJcbiAgICAgICAgICAgIHZhciB0b3RhbFNlZ3NCZWxvdzsgLy8gdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzIGJlbG93IGBzZWdgIGluIGFueSBvZiB0aGUgY29sdW1ucyBgc2VnYCBvY2N1cGllc1xyXG4gICAgICAgICAgICB2YXIgY29sU2Vnc0JlbG93OyAvLyBhcnJheSBvZiBzZWdtZW50IGFycmF5cywgYmVsb3cgc2VnLCBvbmUgZm9yIGVhY2ggY29sdW1uIChvZmZzZXQgZnJvbSBzZWdzJ3MgZmlyc3QgY29sdW1uKVxyXG4gICAgICAgICAgICB2YXIgdGQ7XHJcbiAgICAgICAgICAgIHZhciByb3dTcGFuO1xyXG4gICAgICAgICAgICB2YXIgc2VnTW9yZU5vZGVzOyAvLyBhcnJheSBvZiBcIm1vcmVcIiA8dGQ+IGNlbGxzIHRoYXQgd2lsbCBzdGFuZC1pbiBmb3IgdGhlIGN1cnJlbnQgc2VnJ3MgY2VsbFxyXG4gICAgICAgICAgICB2YXIgajtcclxuICAgICAgICAgICAgdmFyIG1vcmVUZDtcclxuICAgICAgICAgICAgdmFyIG1vcmVXcmFwO1xyXG4gICAgICAgICAgICB2YXIgbW9yZUxpbms7XHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGVzIHRocm91Z2ggZW1wdHkgbGV2ZWwgY2VsbHMgYW5kIHBsYWNlcyBcIm1vcmVcIiBsaW5rcyBpbnNpZGUgaWYgbmVlZCBiZVxyXG4gICAgICAgICAgICB2YXIgZW1wdHlDZWxsc1VudGlsID0gZnVuY3Rpb24gKGVuZENvbCkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbCA8IGVuZENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3NCZWxvdyA9IF90aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vnc0JlbG93Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZCA9IGNlbGxNYXRyaXhbbGV2ZWxMaW1pdCAtIDFdW2NvbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVMaW5rID0gX3RoaXMucmVuZGVyTW9yZUxpbmsocm93LCBjb2wsIHNlZ3NCZWxvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVXcmFwID0gY29yZS5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCBtb3JlTGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRkLmFwcGVuZENoaWxkKG1vcmVXcmFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZU5vZGVzLnB1c2gobW9yZVdyYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGxldmVsTGltaXQgJiYgbGV2ZWxMaW1pdCA8IHJvd1N0cnVjdC5zZWdMZXZlbHMubGVuZ3RoKSB7IC8vIGlzIGl0IGFjdHVhbGx5IG92ZXIgdGhlIGxpbWl0P1xyXG4gICAgICAgICAgICAgICAgbGV2ZWxTZWdzID0gcm93U3RydWN0LnNlZ0xldmVsc1tsZXZlbExpbWl0IC0gMV07XHJcbiAgICAgICAgICAgICAgICBjZWxsTWF0cml4ID0gcm93U3RydWN0LmNlbGxNYXRyaXg7XHJcbiAgICAgICAgICAgICAgICBsaW1pdGVkTm9kZXMgPSBjb3JlLmZpbmRDaGlsZHJlbihyb3dTdHJ1Y3QudGJvZHlFbCkuc2xpY2UobGV2ZWxMaW1pdCk7IC8vIGdldCBsZXZlbCA8dHI+IGVsZW1lbnRzIHBhc3QgdGhlIGxpbWl0XHJcbiAgICAgICAgICAgICAgICBsaW1pdGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnZmMtbGltaXRlZCcpOyAvLyBoaWRlIGVsZW1lbnRzIGFuZCBnZXQgYSBzaW1wbGUgRE9NLW5vZGVzIGFycmF5XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgdGhvdWdoIHNlZ21lbnRzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbFxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZyA9IGxldmVsU2Vnc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdENvbCA9IGlzUnRsID8gKGNvbENudCAtIDEgLSBzZWcubGFzdENvbCkgOiBzZWcuZmlyc3RDb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q29sID0gaXNSdGwgPyAoY29sQ250IC0gMSAtIHNlZy5maXJzdENvbCkgOiBzZWcubGFzdENvbDtcclxuICAgICAgICAgICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwobGVmdENvbCk7IC8vIHByb2Nlc3MgZW1wdHkgY2VsbHMgYmVmb3JlIHRoZSBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lICphbGwqIHNlZ21lbnRzIGJlbG93IGBzZWdgIHRoYXQgb2NjdXB5IHRoZSBzYW1lIGNvbHVtbnNcclxuICAgICAgICAgICAgICAgICAgICBjb2xTZWdzQmVsb3cgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbFNlZ3NCZWxvdyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbCA8PSByaWdodENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdzQmVsb3cgPSB0aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sU2Vnc0JlbG93LnB1c2goc2Vnc0JlbG93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxTZWdzQmVsb3cgKz0gc2Vnc0JlbG93Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbFNlZ3NCZWxvdykgeyAvLyBkbyB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhpcyBzZWdtZW50IHdpdGggb25lIG9yIG1hbnkgXCJtb3JlXCIgbGlua3M/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRkID0gY2VsbE1hdHJpeFtsZXZlbExpbWl0IC0gMV1bbGVmdENvbF07IC8vIHRoZSBzZWdtZW50J3MgcGFyZW50IGNlbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93U3BhbiA9IHRkLnJvd1NwYW4gfHwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnTW9yZU5vZGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYSByZXBsYWNlbWVudCA8dGQ+IGZvciBlYWNoIGNvbHVtbiB0aGUgc2VnbWVudCBvY2N1cGllcy4gd2lsbCBiZSBvbmUgZm9yIGVhY2ggY29sc3BhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29sU2Vnc0JlbG93Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JlVGQgPSBjb3JlLmNyZWF0ZUVsZW1lbnQoJ3RkJywgeyBjbGFzc05hbWU6ICdmYy1tb3JlLWNlbGwnLCByb3dTcGFuOiByb3dTcGFuIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vnc0JlbG93ID0gY29sU2Vnc0JlbG93W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9yZUxpbmsgPSB0aGlzLnJlbmRlck1vcmVMaW5rKHJvdywgbGVmdENvbCArIGosIFtzZWddLmNvbmNhdChzZWdzQmVsb3cpIC8vIGNvdW50IHNlZyBhcyBoaWRkZW4gdG9vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9yZVdyYXAgPSBjb3JlLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsIG1vcmVMaW5rKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVUZC5hcHBlbmRDaGlsZChtb3JlV3JhcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdNb3JlTm9kZXMucHVzaChtb3JlVGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9yZU5vZGVzLnB1c2gobW9yZVRkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZC5jbGFzc0xpc3QuYWRkKCdmYy1saW1pdGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuaW5zZXJ0QWZ0ZXJFbGVtZW50KHRkLCBzZWdNb3JlTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdGVkTm9kZXMucHVzaCh0ZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKHRoaXMuY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgbGV2ZWxcclxuICAgICAgICAgICAgICAgIHJvd1N0cnVjdC5tb3JlRWxzID0gbW9yZU5vZGVzOyAvLyBmb3IgZWFzeSB1bmRvaW5nIGxhdGVyXHJcbiAgICAgICAgICAgICAgICByb3dTdHJ1Y3QubGltaXRlZEVscyA9IGxpbWl0ZWROb2RlczsgLy8gZm9yIGVhc3kgdW5kb2luZyBsYXRlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBSZXZlYWxzIGFsbCBsZXZlbHMgYW5kIHJlbW92ZXMgYWxsIFwibW9yZVwiLXJlbGF0ZWQgZWxlbWVudHMgZm9yIGEgZ3JpZCdzIHJvdy5cclxuICAgICAgICAvLyBgcm93YCBpcyBhIHJvdyBudW1iZXIuXHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUudW5saW1pdFJvdyA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICAgICAgdmFyIHJvd1N0cnVjdCA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzW3Jvd107XHJcbiAgICAgICAgICAgIGlmIChyb3dTdHJ1Y3QubW9yZUVscykge1xyXG4gICAgICAgICAgICAgICAgcm93U3RydWN0Lm1vcmVFbHMuZm9yRWFjaChjb3JlLnJlbW92ZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcm93U3RydWN0Lm1vcmVFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyb3dTdHJ1Y3QubGltaXRlZEVscykge1xyXG4gICAgICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMuZm9yRWFjaChmdW5jdGlvbiAobGltaXRlZEVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGltaXRlZEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLWxpbWl0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBSZW5kZXJzIGFuIDxhPiBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyBoaWRkZW4gZXZlbnQgZWxlbWVudCBmb3IgYSBjZWxsLlxyXG4gICAgICAgIC8vIFJlc3BvbnNpYmxlIGZvciBhdHRhY2hpbmcgY2xpY2sgaGFuZGxlciBhcyB3ZWxsLlxyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck1vcmVMaW5rID0gZnVuY3Rpb24gKHJvdywgY29sLCBoaWRkZW5TZWdzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHZpZXcgPSBfYS52aWV3LCBkYXRlRW52ID0gX2EuZGF0ZUVudjtcclxuICAgICAgICAgICAgdmFyIGEgPSBjb3JlLmNyZWF0ZUVsZW1lbnQoJ2EnLCB7IGNsYXNzTmFtZTogJ2ZjLW1vcmUnIH0pO1xyXG4gICAgICAgICAgICBhLmlubmVyVGV4dCA9IHRoaXMuZ2V0TW9yZUxpbmtUZXh0KGhpZGRlblNlZ3MubGVuZ3RoKTtcclxuICAgICAgICAgICAgYS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsaWNrT3B0aW9uID0gX3RoaXMub3B0KCdldmVudExpbWl0Q2xpY2snKTtcclxuICAgICAgICAgICAgICAgIHZhciBfY29sID0gX3RoaXMuaXNSdGwgPyBfdGhpcy5jb2xDbnQgLSBjb2wgLSAxIDogY29sOyAvLyBIQUNLOiBwcm9wcy5jZWxscyBoYXMgZGlmZmVyZW50IGRpciBzeXN0ZW0/XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IF90aGlzLnByb3BzLmNlbGxzW3Jvd11bX2NvbF0uZGF0ZTtcclxuICAgICAgICAgICAgICAgIHZhciBtb3JlRWwgPSBldi5jdXJyZW50VGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGRheUVsID0gX3RoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKTtcclxuICAgICAgICAgICAgICAgIHZhciBhbGxTZWdzID0gX3RoaXMuZ2V0Q2VsbFNlZ3Mocm93LCBjb2wpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzY29wZSB0aGUgc2VnbWVudHMgdG8gYmUgd2l0aGluIHRoZSBjZWxsJ3MgZGF0ZVxyXG4gICAgICAgICAgICAgICAgdmFyIHJlc2xpY2VkQWxsU2VncyA9IF90aGlzLnJlc2xpY2VEYXlTZWdzKGFsbFNlZ3MsIGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc2xpY2VkSGlkZGVuU2VncyA9IF90aGlzLnJlc2xpY2VEYXlTZWdzKGhpZGRlblNlZ3MsIGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjbGlja09wdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgYW4gYXRvbWljIG9wdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrT3B0aW9uID0gX3RoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudExpbWl0Q2xpY2snLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWw6IGRheUVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9yZUVsOiBtb3JlRWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdzOiByZXNsaWNlZEFsbFNlZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5TZWdzOiByZXNsaWNlZEhpZGRlblNlZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNsaWNrT3B0aW9uID09PSAncG9wb3ZlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaG93U2VnUG9wb3Zlcihyb3csIGNvbCwgbW9yZUVsLCByZXNsaWNlZEFsbFNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNsaWNrT3B0aW9uID09PSAnc3RyaW5nJykgeyAvLyBhIHZpZXcgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuY2FsZW5kYXIuem9vbVRvKGRhdGUsIGNsaWNrT3B0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gUmV2ZWFscyB0aGUgcG9wb3ZlciB0aGF0IGRpc3BsYXlzIGFsbCBldmVudHMgd2l0aGluIGEgY2VsbFxyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLnNob3dTZWdQb3BvdmVyID0gZnVuY3Rpb24gKHJvdywgY29sLCBtb3JlTGluaywgc2Vncykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBjYWxlbmRhciA9IF9hLmNhbGVuZGFyLCB2aWV3ID0gX2EudmlldywgdGhlbWUgPSBfYS50aGVtZTtcclxuICAgICAgICAgICAgdmFyIF9jb2wgPSB0aGlzLmlzUnRsID8gdGhpcy5jb2xDbnQgLSBjb2wgLSAxIDogY29sOyAvLyBIQUNLOiBwcm9wcy5jZWxscyBoYXMgZGlmZmVyZW50IGRpciBzeXN0ZW0/XHJcbiAgICAgICAgICAgIHZhciBtb3JlV3JhcCA9IG1vcmVMaW5rLnBhcmVudE5vZGU7IC8vIHRoZSA8ZGl2PiB3cmFwcGVyIGFyb3VuZCB0aGUgPGE+XHJcbiAgICAgICAgICAgIHZhciB0b3BFbDsgLy8gdGhlIGVsZW1lbnQgd2Ugd2FudCB0byBtYXRjaCB0aGUgdG9wIGNvb3JkaW5hdGUgb2ZcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJvd0NudCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdG9wRWwgPSB2aWV3LmVsOyAvLyB3aWxsIGNhdXNlIHRoZSBwb3BvdmVyIHRvIGNvdmVyIGFueSBzb3J0IG9mIGhlYWRlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG9wRWwgPSB0aGlzLnJvd0Vsc1tyb3ddOyAvLyB3aWxsIGFsaWduIHdpdGggdG9wIG9mIHJvd1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdmYy1tb3JlLXBvcG92ZXIgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyJyksXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRFbDogdmlldy5lbCxcclxuICAgICAgICAgICAgICAgIHRvcDogY29yZS5jb21wdXRlUmVjdCh0b3BFbCkudG9wLFxyXG4gICAgICAgICAgICAgICAgYXV0b0hpZGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWdQb3BvdmVyVGlsZSA9IG5ldyBEYXlUaWxlKF90aGlzLmNvbnRleHQsIGVsKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVTZWdQb3BvdmVyVGlsZShfdGhpcy5wcm9wcy5jZWxsc1tyb3ddW19jb2xdLmRhdGUsIHNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWdQb3BvdmVyVGlsZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VnUG9wb3ZlclRpbGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlZ1BvcG92ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlZ1BvcG92ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxyXG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIG1vcmVXcmFwIGluc3RlYWQgb2YgdGhlIDx0ZD4gdG8gYXZvaWQgYm9yZGVyIGNvbmZ1c2lvbi5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSdGwpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMucmlnaHQgPSBjb3JlLmNvbXB1dGVSZWN0KG1vcmVXcmFwKS5yaWdodCArIDE7IC8vICsxIHRvIGJlIG92ZXIgY2VsbCBib3JkZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubGVmdCA9IGNvcmUuY29tcHV0ZVJlY3QobW9yZVdyYXApLmxlZnQgLSAxOyAvLyAtMSB0byBiZSBvdmVyIGNlbGwgYm9yZGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZWdQb3BvdmVyID0gbmV3IFBvcG92ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VnUG9wb3Zlci5zaG93KCk7XHJcbiAgICAgICAgICAgIGNhbGVuZGFyLnJlbGVhc2VBZnRlclNpemluZ1RyaWdnZXJzKCk7IC8vIGhhY2sgZm9yIGV2ZW50UG9zaXRpb25lZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2l2ZW4gdGhlIGV2ZW50cyB3aXRoaW4gYW4gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzLCByZXNsaWNlIHRoZW0gdG8gYmUgaW4gYSBzaW5nbGUgZGF5XHJcbiAgICAgICAgRGF5R3JpZC5wcm90b3R5cGUucmVzbGljZURheVNlZ3MgPSBmdW5jdGlvbiAoc2VncywgZGF5RGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgZGF5U3RhcnQgPSBkYXlEYXRlO1xyXG4gICAgICAgICAgICB2YXIgZGF5RW5kID0gY29yZS5hZGREYXlzKGRheVN0YXJ0LCAxKTtcclxuICAgICAgICAgICAgdmFyIGRheVJhbmdlID0geyBzdGFydDogZGF5U3RhcnQsIGVuZDogZGF5RW5kIH07XHJcbiAgICAgICAgICAgIHZhciBuZXdTZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc2Vnc18xID0gc2VnczsgX2kgPCBzZWdzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18xW19pXTtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudFJhbmdlID0gc2VnLmV2ZW50UmFuZ2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ1JhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcclxuICAgICAgICAgICAgICAgIHZhciBzbGljZWRSYW5nZSA9IGNvcmUuaW50ZXJzZWN0UmFuZ2VzKG9yaWdSYW5nZSwgZGF5UmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2Vncy5wdXNoKF9fYXNzaWduKHt9LCBzZWcsIHsgZXZlbnRSYW5nZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBldmVudFJhbmdlLmRlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpOiBfX2Fzc2lnbih7fSwgZXZlbnRSYW5nZS51aSwgeyBkdXJhdGlvbkVkaXRhYmxlOiBmYWxzZSB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBldmVudFJhbmdlLmluc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0ICYmIHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gb3JpZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSwgaXNFbmQ6IHNlZy5pc0VuZCAmJiBzbGljZWRSYW5nZS5lbmQudmFsdWVPZigpID09PSBvcmlnUmFuZ2UuZW5kLnZhbHVlT2YoKSB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ld1NlZ3M7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgaW5zaWRlIGEgXCJtb3JlXCIgbGluaywgZ2l2ZW4gdGhlIG51bWJlciBvZiBldmVudHMgaXQgcmVwcmVzZW50c1xyXG4gICAgICAgIERheUdyaWQucHJvdG90eXBlLmdldE1vcmVMaW5rVGV4dCA9IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0KCdldmVudExpbWl0VGV4dCcpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdChudW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcrJyArIG51bSArICcgJyArIG9wdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gUmV0dXJucyBzZWdtZW50cyB3aXRoaW4gYSBnaXZlbiBjZWxsLlxyXG4gICAgICAgIC8vIElmIGBzdGFydExldmVsYCBpcyBzcGVjaWZpZWQsIHJldHVybnMgb25seSBldmVudHMgaW5jbHVkaW5nIGFuZCBiZWxvdyB0aGF0IGxldmVsLiBPdGhlcndpc2UgcmV0dXJucyBhbGwgc2Vncy5cclxuICAgICAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRDZWxsU2VncyA9IGZ1bmN0aW9uIChyb3csIGNvbCwgc3RhcnRMZXZlbCkge1xyXG4gICAgICAgICAgICB2YXIgc2VnTWF0cml4ID0gdGhpcy5ldmVudFJlbmRlcmVyLnJvd1N0cnVjdHNbcm93XS5zZWdNYXRyaXg7XHJcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHN0YXJ0TGV2ZWwgfHwgMDtcclxuICAgICAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHNlZztcclxuICAgICAgICAgICAgd2hpbGUgKGxldmVsIDwgc2VnTWF0cml4Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgc2VnID0gc2VnTWF0cml4W2xldmVsXVtjb2xdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaChzZWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV2ZWwrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VncztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEYXlHcmlkO1xyXG4gICAgfShjb3JlLkRhdGVDb21wb25lbnQpKTtcclxuXHJcbiAgICB2YXIgV0VFS19OVU1fRk9STUFUJDEgPSBjb3JlLmNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICdudW1lcmljJyB9KTtcclxuICAgIC8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciB0aGUgZGF5Z3JpZCB2aWV3cywgYXMgd2VsbCBhcyBtb250aCB2aWV3LiBSZW5kZXJzIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNlbGxzLlxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBJdCBpcyBhIG1hbmFnZXIgZm9yIGEgRGF5R3JpZCBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cclxuICAgIC8vIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXHJcbiAgICB2YXIgRGF5R3JpZFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKERheUdyaWRWaWV3LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIERheUdyaWRWaWV3KGNvbnRleHQsIHZpZXdTcGVjLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgcGFyZW50RWwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCwgdmlld1NwZWMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBwYXJlbnRFbCkgfHwgdGhpcztcclxuICAgICAgICAgICAgLyogSGVhZGVyIFJlbmRlcmluZ1xyXG4gICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSB0aGUgZGF5LW9mIHdlZWsgaGVhZGVyIGNlbGxzXHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckhlYWRJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhlbWUgPSBfdGhpcy50aGVtZTtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwiZmMtd2Vlay1udW1iZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiAnICsgX3RoaXMud2Vla051bWJlclN0eWxlQXR0cigpICsgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuPicgKyAvLyBuZWVkZWQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLmh0bWxFc2NhcGUoX3RoaXMub3B0KCd3ZWVrTGFiZWwnKSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC90aD4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKiBEYXkgR3JpZCBSZW5kZXJpbmdcclxuICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgY29udGVudC1za2VsZXRvbiBjZWxscyB0aGF0IGRpc3BsYXkgdGhlIGRheS93ZWVrIG51bWJlcnNcclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyRGF5R3JpZE51bWJlckludHJvSHRtbCA9IGZ1bmN0aW9uIChyb3csIGRheUdyaWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRlRW52ID0gX3RoaXMuZGF0ZUVudjtcclxuICAgICAgICAgICAgICAgIHZhciB3ZWVrU3RhcnQgPSBkYXlHcmlkLnByb3BzLmNlbGxzW3Jvd11bMF0uZGF0ZTtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXJcIiAnICsgX3RoaXMud2Vla051bWJlclN0eWxlQXR0cigpICsgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5idWlsZEdvdG9BbmNob3JIdG1sKC8vIGFzaWRlIGZyb20gbGluaywgaW1wb3J0YW50IGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMsIHsgZGF0ZTogd2Vla1N0YXJ0LCB0eXBlOiAnd2VlaycsIGZvcmNlT2ZmOiBkYXlHcmlkLmNvbENudCA9PT0gMSB9LCBkYXRlRW52LmZvcm1hdCh3ZWVrU3RhcnQsIFdFRUtfTlVNX0ZPUk1BVCQxKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC90ZD4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgZGF5IGJnIGNlbGxzIGZvciBlYWNoIGRheS1yb3dcclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyRGF5R3JpZEJnSW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoZW1lID0gX3RoaXMudGhlbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIiAnICsgX3RoaXMud2Vla051bWJlclN0eWxlQXR0cigpICsgJz48L3RkPic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGV2ZXJ5IG90aGVyIHR5cGUgb2Ygcm93IGdlbmVyYXRlZCBieSBEYXlHcmlkLlxyXG4gICAgICAgICAgICAvLyBBZmZlY3RzIG1pcnJvci1za2VsZXRvbiBhbmQgaGlnaGxpZ2h0LXNrZWxldG9uIHJvd3MuXHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckRheUdyaWRJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlclwiICcgKyBfdGhpcy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnZmMtZGF5R3JpZC12aWV3Jyk7XHJcbiAgICAgICAgICAgIF90aGlzLmVsLmlubmVySFRNTCA9IF90aGlzLnJlbmRlclNrZWxldG9uSHRtbCgpO1xyXG4gICAgICAgICAgICBfdGhpcy5zY3JvbGxlciA9IG5ldyBjb3JlLlNjcm9sbENvbXBvbmVudCgnaGlkZGVuJywgLy8gb3ZlcmZsb3cgeFxyXG4gICAgICAgICAgICAnYXV0bycgLy8gb3ZlcmZsb3cgeVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB2YXIgZGF5R3JpZENvbnRhaW5lckVsID0gX3RoaXMuc2Nyb2xsZXIuZWw7XHJcbiAgICAgICAgICAgIF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1ib2R5ID4gdHIgPiB0ZCcpLmFwcGVuZENoaWxkKGRheUdyaWRDb250YWluZXJFbCk7XHJcbiAgICAgICAgICAgIGRheUdyaWRDb250YWluZXJFbC5jbGFzc0xpc3QuYWRkKCdmYy1kYXktZ3JpZC1jb250YWluZXInKTtcclxuICAgICAgICAgICAgdmFyIGRheUdyaWRFbCA9IGNvcmUuY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdmYy1kYXktZ3JpZCcgfSk7XHJcbiAgICAgICAgICAgIGRheUdyaWRDb250YWluZXJFbC5hcHBlbmRDaGlsZChkYXlHcmlkRWwpO1xyXG4gICAgICAgICAgICB2YXIgY2VsbFdlZWtOdW1iZXJzVmlzaWJsZTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnd2Vla051bWJlcnMnKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnd2Vla051bWJlcnNXaXRoaW5EYXlzJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsV2Vla051bWJlcnNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjZWxsV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuZGF5R3JpZCA9IG5ldyBEYXlHcmlkKF90aGlzLmNvbnRleHQsIGRheUdyaWRFbCwge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyTnVtYmVySW50cm9IdG1sOiBfdGhpcy5yZW5kZXJEYXlHcmlkTnVtYmVySW50cm9IdG1sLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyQmdJbnRyb0h0bWw6IF90aGlzLnJlbmRlckRheUdyaWRCZ0ludHJvSHRtbCxcclxuICAgICAgICAgICAgICAgIHJlbmRlckludHJvSHRtbDogX3RoaXMucmVuZGVyRGF5R3JpZEludHJvSHRtbCxcclxuICAgICAgICAgICAgICAgIGNvbFdlZWtOdW1iZXJzVmlzaWJsZTogX3RoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgY2VsbFdlZWtOdW1iZXJzVmlzaWJsZTogY2VsbFdlZWtOdW1iZXJzVmlzaWJsZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEYXlHcmlkVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBIVE1MIHNrZWxldG9uIGZvciB0aGUgdmlldy5cclxuICAgICAgICAvLyBUaGUgZGF5LWdyaWQgY29tcG9uZW50IHdpbGwgcmVuZGVyIGluc2lkZSBvZiBhIGNvbnRhaW5lciBkZWZpbmVkIGJ5IHRoaXMgSFRNTC5cclxuICAgICAgICBEYXlHcmlkVmlldy5wcm90b3R5cGUucmVuZGVyU2tlbGV0b25IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnRoZW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICAodGhpcy5vcHQoJ2NvbHVtbkhlYWRlcicpID9cclxuICAgICAgICAgICAgICAgICAgICAnPHRoZWFkIGNsYXNzPVwiZmMtaGVhZFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtaGVhZC1jb250YWluZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIj4mbmJzcDs8L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgICAgICc8dGJvZHkgY2xhc3M9XCJmYy1ib2R5XCI+JyArXHJcbiAgICAgICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiPjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICc8L3Rib2R5PicgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGFibGU+JztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSB3ZWVrIG51bWJlciBjb2x1bW4sIGlmIGl0IGlzIGtub3duXHJcbiAgICAgICAgRGF5R3JpZFZpZXcucHJvdG90eXBlLndlZWtOdW1iZXJTdHlsZUF0dHIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLndlZWtOdW1iZXJXaWR0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3N0eWxlPVwid2lkdGg6JyArIHRoaXMud2Vla051bWJlcldpZHRoICsgJ3B4XCInO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIERldGVybWluZXMgd2hldGhlciBlYWNoIHJvdyBzaG91bGQgaGF2ZSBhIGNvbnN0YW50IGhlaWdodFxyXG4gICAgICAgIERheUdyaWRWaWV3LnByb3RvdHlwZS5oYXNSaWdpZFJvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudExpbWl0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXQnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogRGltZW5zaW9uc1xyXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgRGF5R3JpZFZpZXcucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoaXNSZXNpemUsIHZpZXdIZWlnaHQsIGlzQXV0bykge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCBpc1Jlc2l6ZSwgdmlld0hlaWdodCwgaXNBdXRvKTsgLy8gd2lsbCBjYWxsIHVwZGF0ZUJhc2VTaXplLiBpbXBvcnRhbnQgdGhhdCBleGVjdXRlcyBmaXJzdFxyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQudXBkYXRlU2l6ZShpc1Jlc2l6ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBSZWZyZXNoZXMgdGhlIGhvcml6b250YWwgZGltZW5zaW9ucyBvZiB0aGUgdmlld1xyXG4gICAgICAgIERheUdyaWRWaWV3LnByb3RvdHlwZS51cGRhdGVCYXNlU2l6ZSA9IGZ1bmN0aW9uIChpc1Jlc2l6ZSwgdmlld0hlaWdodCwgaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXlHcmlkID0gdGhpcy5kYXlHcmlkO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XHJcbiAgICAgICAgICAgIHZhciBoZWFkUm93RWwgPSB0aGlzLmhlYWRlciA/IHRoaXMuaGVhZGVyLmVsIDogbnVsbDsgLy8gSEFDS1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aHM7XHJcbiAgICAgICAgICAgIC8vIGhhY2sgdG8gZ2l2ZSB0aGUgdmlldyBzb21lIGhlaWdodCBwcmlvciB0byBkYXlHcmlkJ3MgY29sdW1ucyBiZWluZyByZW5kZXJlZFxyXG4gICAgICAgICAgICAvLyBUT0RPOiBzZXBhcmF0ZSBzZXR0aW5nIGhlaWdodCBmcm9tIHNjcm9sbGVyIFZTIGRheUdyaWQuXHJcbiAgICAgICAgICAgIGlmICghZGF5R3JpZC5yb3dFbHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh2aWV3SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIHdlZWsgbnVtYmVyIGNlbGxzIHJ1bm5pbmcgZG93biB0aGUgc2lkZSBoYXZlIHRoZSBzYW1lIHdpZHRoLlxyXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrTnVtYmVyV2lkdGggPSBjb3JlLm1hdGNoQ2VsbFdpZHRocyhjb3JlLmZpbmRFbGVtZW50cyh0aGlzLmVsLCAnLmZjLXdlZWstbnVtYmVyJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IGFsbCBoZWlnaHRzIHRvIGJlIG5hdHVyYWxcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5jbGVhcigpO1xyXG4gICAgICAgICAgICBpZiAoaGVhZFJvd0VsKSB7XHJcbiAgICAgICAgICAgICAgICBjb3JlLnVuY29tcGVuc2F0ZVNjcm9sbChoZWFkUm93RWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRheUdyaWQucmVtb3ZlU2VnUG9wb3ZlcigpOyAvLyBraWxsIHRoZSBcIm1vcmVcIiBwb3BvdmVyIGlmIGRpc3BsYXllZFxyXG4gICAgICAgICAgICAvLyBpcyB0aGUgZXZlbnQgbGltaXQgYSBjb25zdGFudCBsZXZlbCBudW1iZXI/XHJcbiAgICAgICAgICAgIGlmIChldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgZGF5R3JpZC5saW1pdFJvd3MoZXZlbnRMaW1pdCk7IC8vIGxpbWl0IHRoZSBsZXZlbHMgZmlyc3Qgc28gdGhlIGhlaWdodCBjYW4gcmVkaXN0cmlidXRlIGFmdGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZGlzdHJpYnV0ZSB0aGUgaGVpZ2h0IHRvIHRoZSByb3dzXHJcbiAgICAgICAgICAgIC8vICh2aWV3SGVpZ2h0IGlzIGEgXCJyZWNvbW1lbmRlZFwiIHZhbHVlIGlmIGlzQXV0bylcclxuICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh2aWV3SGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5zZXRHcmlkSGVpZ2h0KHNjcm9sbGVySGVpZ2h0LCBpc0F1dG8pO1xyXG4gICAgICAgICAgICAvLyBpcyB0aGUgZXZlbnQgbGltaXQgZHluYW1pY2FsbHkgY2FsY3VsYXRlZD9cclxuICAgICAgICAgICAgaWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBkYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTsgLy8gbGltaXQgdGhlIGxldmVscyBhZnRlciB0aGUgZ3JpZCdzIHJvdyBoZWlnaHRzIGhhdmUgYmVlbiBzZXRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzQXV0bykgeyAvLyBzaG91bGQgd2UgZm9yY2UgZGltZW5zaW9ucyBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lcj9cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHNjcm9sbGJhcldpZHRocyA9IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7IC8vIHVzaW5nIHNjcm9sbGJhcnM/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRSb3dFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLmNvbXBlbnNhdGVTY3JvbGwoaGVhZFJvd0VsLCBzY3JvbGxiYXJXaWR0aHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBkb2luZyB0aGUgc2Nyb2xsYmFyIGNvbXBlbnNhdGlvbiBtaWdodCBoYXZlIGNyZWF0ZWQgdGV4dCBvdmVyZmxvdyB3aGljaCBjcmVhdGVkIG1vcmUgaGVpZ2h0LiByZWRvXHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh2aWV3SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBndWFyYW50ZWVzIHRoZSBzYW1lIHNjcm9sbGJhciB3aWR0aHNcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIubG9ja092ZXJmbG93KHNjcm9sbGJhcldpZHRocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGdpdmVuIGEgZGVzaXJlZCB0b3RhbCBoZWlnaHQgb2YgdGhlIHZpZXcsIHJldHVybnMgd2hhdCB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGxlciBzaG91bGQgYmVcclxuICAgICAgICBEYXlHcmlkVmlldy5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVySGVpZ2h0ID0gZnVuY3Rpb24gKHZpZXdIZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdIZWlnaHQgLVxyXG4gICAgICAgICAgICAgICAgY29yZS5zdWJ0cmFjdElubmVyRWxIZWlnaHQodGhpcy5lbCwgdGhpcy5zY3JvbGxlci5lbCk7IC8vIGV2ZXJ5dGhpbmcgdGhhdCdzIE5PVCB0aGUgc2Nyb2xsZXJcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFNldHMgdGhlIGhlaWdodCBvZiBqdXN0IHRoZSBEYXlHcmlkIGNvbXBvbmVudCBpbiB0aGlzIHZpZXdcclxuICAgICAgICBEYXlHcmlkVmlldy5wcm90b3R5cGUuc2V0R3JpZEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQsIGlzQXV0bykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHQoJ21vbnRoTW9kZScpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBhdXRvLCBtYWtlIHRoZSBoZWlnaHQgb2YgZWFjaCByb3cgdGhlIGhlaWdodCB0aGF0IGl0IHdvdWxkIGJlIGlmIHRoZXJlIHdlcmUgNiB3ZWVrc1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0bykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAqPSB0aGlzLmRheUdyaWQucm93Q250IC8gNjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvcmUuZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzLCBoZWlnaHQsICFpc0F1dG8pOyAvLyBpZiBhdXRvLCBkb24ndCBjb21wZW5zYXRlIGZvciBoZWlnaHQtaG9nZ2luZyByb3dzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29yZS51bmRpc3RyaWJ1dGVIZWlnaHQodGhpcy5kYXlHcmlkLnJvd0Vscyk7IC8vIGxldCB0aGUgcm93cyBiZSB0aGVpciBuYXR1cmFsIGhlaWdodCB3aXRoIG5vIGV4cGFuZGluZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29yZS5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgdHJ1ZSk7IC8vIHRydWUgPSBjb21wZW5zYXRlIGZvciBoZWlnaHQtaG9nZ2luZyByb3dzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIFNjcm9sbFxyXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgRGF5R3JpZFZpZXcucHJvdG90eXBlLmNvbXB1dGVEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHRvcDogMCB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGF5R3JpZFZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbFRvcCgpIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXlHcmlkVmlldy5wcm90b3R5cGUuYXBwbHlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldFNjcm9sbFRvcChzY3JvbGwudG9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERheUdyaWRWaWV3O1xyXG4gICAgfShjb3JlLlZpZXcpKTtcclxuICAgIERheUdyaWRWaWV3LnByb3RvdHlwZS5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gRGF5R3JpZERhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG5cclxuICAgIHZhciBTaW1wbGVEYXlHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTaW1wbGVEYXlHcmlkLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFNpbXBsZURheUdyaWQoY29udGV4dCwgZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0LCBkYXlHcmlkLmVsKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5zbGljZXIgPSBuZXcgRGF5R3JpZFNsaWNlcigpO1xyXG4gICAgICAgICAgICBfdGhpcy5kYXlHcmlkID0gZGF5R3JpZDtcclxuICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhci5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzLCB7IGVsOiBfdGhpcy5kYXlHcmlkLmVsIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNpbXBsZURheUdyaWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNpbXBsZURheUdyaWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgICAgICB2YXIgZGF5R3JpZCA9IHRoaXMuZGF5R3JpZDtcclxuICAgICAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gcHJvcHMuZGF0ZVByb2ZpbGUsIGRheVRhYmxlID0gcHJvcHMuZGF5VGFibGU7XHJcbiAgICAgICAgICAgIGRheUdyaWQucmVjZWl2ZVByb3BzKF9fYXNzaWduKHt9LCB0aGlzLnNsaWNlci5zbGljZVByb3BzKHByb3BzLCBkYXRlUHJvZmlsZSwgcHJvcHMubmV4dERheVRocmVzaG9sZCwgZGF5R3JpZCwgZGF5VGFibGUpLCB7IGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgY2VsbHM6IGRheVRhYmxlLmNlbGxzLCBpc1JpZ2lkOiBwcm9wcy5pc1JpZ2lkIH0pKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNpbXBsZURheUdyaWQucHJvdG90eXBlLmJ1aWxkUG9zaXRpb25DYWNoZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5idWlsZFBvc2l0aW9uQ2FjaGVzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTaW1wbGVEYXlHcmlkLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wKSB7XHJcbiAgICAgICAgICAgIHZhciByYXdIaXQgPSB0aGlzLmRheUdyaWQucG9zaXRpb25Ub0hpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wKTtcclxuICAgICAgICAgICAgaWYgKHJhd0hpdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMuZGF5R3JpZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlU3BhbjogcmF3SGl0LmRhdGVTcGFuLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUVsOiByYXdIaXQuZGF5RWwsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiByYXdIaXQucmVsYXRpdmVSZWN0LmxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByYXdIaXQucmVsYXRpdmVSZWN0LnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHJhd0hpdC5yZWxhdGl2ZVJlY3QudG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHJhd0hpdC5yZWxhdGl2ZVJlY3QuYm90dG9tXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBsYXllcjogMFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNpbXBsZURheUdyaWQ7XHJcbiAgICB9KGNvcmUuRGF0ZUNvbXBvbmVudCkpO1xyXG4gICAgdmFyIERheUdyaWRTbGljZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKERheUdyaWRTbGljZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRGF5R3JpZFNsaWNlcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEYXlHcmlkU2xpY2VyLnByb3RvdHlwZS5zbGljZVJhbmdlID0gZnVuY3Rpb24gKGRhdGVSYW5nZSwgZGF5VGFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRheVRhYmxlLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEYXlHcmlkU2xpY2VyO1xyXG4gICAgfShjb3JlLlNsaWNlcikpO1xyXG5cclxuICAgIHZhciBEYXlHcmlkVmlldyQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhEYXlHcmlkVmlldywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBEYXlHcmlkVmlldyhfY29udGV4dCwgdmlld1NwZWMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBwYXJlbnRFbCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfY29udGV4dCwgdmlld1NwZWMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBwYXJlbnRFbCkgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuYnVpbGREYXlUYWJsZSA9IGNvcmUubWVtb2l6ZShidWlsZERheVRhYmxlKTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnY29sdW1uSGVhZGVyJykpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmhlYWRlciA9IG5ldyBjb3JlLkRheUhlYWRlcihfdGhpcy5jb250ZXh0LCBfdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZmMtaGVhZC1jb250YWluZXInKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuc2ltcGxlRGF5R3JpZCA9IG5ldyBTaW1wbGVEYXlHcmlkKF90aGlzLmNvbnRleHQsIF90aGlzLmRheUdyaWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERheUdyaWRWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaW1wbGVEYXlHcmlkLmRlc3Ryb3koKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERheUdyaWRWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgICAgIHZhciBkYXlUYWJsZSA9IHRoaXMuZGF5VGFibGUgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZERheVRhYmxlKGRhdGVQcm9maWxlLCB0aGlzLmRhdGVQcm9maWxlR2VuZXJhdG9yKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlci5yZWNlaXZlUHJvcHMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlczogZGF5VGFibGUuaGVhZGVyRGF0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZXNSZXBEaXN0aW5jdERheXM6IGRheVRhYmxlLnJvd0NudCA9PT0gMSxcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJJbnRyb0h0bWw6IHRoaXMucmVuZGVySGVhZEludHJvSHRtbFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaW1wbGVEYXlHcmlkLnJlY2VpdmVQcm9wcyh7XHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsXHJcbiAgICAgICAgICAgICAgICBkYXlUYWJsZTogZGF5VGFibGUsXHJcbiAgICAgICAgICAgICAgICBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLFxyXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbixcclxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHByb3BzLmV2ZW50U3RvcmUsXHJcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcyxcclxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcclxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLFxyXG4gICAgICAgICAgICAgICAgaXNSaWdpZDogdGhpcy5oYXNSaWdpZFJvd3MoKSxcclxuICAgICAgICAgICAgICAgIG5leHREYXlUaHJlc2hvbGQ6IHRoaXMubmV4dERheVRocmVzaG9sZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEYXlHcmlkVmlldztcclxuICAgIH0oRGF5R3JpZFZpZXcpKTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF5VGFibGUoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGRheVNlcmllcyA9IG5ldyBjb3JlLkRheVNlcmllcyhkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xyXG4gICAgICAgIHJldHVybiBuZXcgY29yZS5EYXlUYWJsZShkYXlTZXJpZXMsIC95ZWFyfG1vbnRofHdlZWsvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtYWluID0gY29yZS5jcmVhdGVQbHVnaW4oe1xyXG4gICAgICAgIGRlZmF1bHRWaWV3OiAnZGF5R3JpZE1vbnRoJyxcclxuICAgICAgICB2aWV3czoge1xyXG4gICAgICAgICAgICBkYXlHcmlkOiBEYXlHcmlkVmlldyQxLFxyXG4gICAgICAgICAgICBkYXlHcmlkRGF5OiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGF5R3JpZFdlZWs6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGF5R3JpZE1vbnRoOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBtb250aHM6IDEgfSxcclxuICAgICAgICAgICAgICAgIG1vbnRoTW9kZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBleHBvcnRzLkFic3RyYWN0RGF5R3JpZFZpZXcgPSBEYXlHcmlkVmlldztcclxuICAgIGV4cG9ydHMuRGF5QmdSb3cgPSBEYXlCZ1JvdztcclxuICAgIGV4cG9ydHMuRGF5R3JpZCA9IERheUdyaWQ7XHJcbiAgICBleHBvcnRzLkRheUdyaWRTbGljZXIgPSBEYXlHcmlkU2xpY2VyO1xyXG4gICAgZXhwb3J0cy5EYXlHcmlkVmlldyA9IERheUdyaWRWaWV3JDE7XHJcbiAgICBleHBvcnRzLlNpbXBsZURheUdyaWQgPSBTaW1wbGVEYXlHcmlkO1xyXG4gICAgZXhwb3J0cy5idWlsZEJhc2ljRGF5VGFibGUgPSBidWlsZERheVRhYmxlO1xyXG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gbWFpbjtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxufSkpO1xyXG4iLCIvKiFcclxuRnVsbENhbGVuZGFyIEludGVyYWN0aW9uIFBsdWdpbiB2NC4zLjBcclxuRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xyXG4oYykgMjAxOSBBZGFtIFNoYXdcclxuKi9cclxuXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0BmdWxsY2FsZW5kYXIvY29yZScpKSA6XHJcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0BmdWxsY2FsZW5kYXIvY29yZSddLCBmYWN0b3J5KSA6XHJcbiAgICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLkZ1bGxDYWxlbmRhckludGVyYWN0aW9uID0ge30sIGdsb2JhbC5GdWxsQ2FsZW5kYXIpKTtcclxufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgY29yZSkgeyAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG4gICAgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuICAgIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gICAgVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gICAgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG4gICAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuICAgIE1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG4gICAgU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbiAgICBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4gICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb3JlLmNvbmZpZy50b3VjaE1vdXNlSWdub3JlV2FpdCA9IDUwMDtcclxuICAgIHZhciBpZ25vcmVNb3VzZURlcHRoID0gMDtcclxuICAgIHZhciBsaXN0ZW5lckNudCA9IDA7XHJcbiAgICB2YXIgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgIC8qXHJcbiAgICBVc2VzIGEgXCJwb2ludGVyXCIgYWJzdHJhY3Rpb24sIHdoaWNoIG1vbml0b3JzIFVJIGV2ZW50cyBmb3IgYm90aCBtb3VzZSBhbmQgdG91Y2guXHJcbiAgICBUcmFja3Mgd2hlbiB0aGUgcG9pbnRlciBcImRyYWdzXCIgb24gYSBjZXJ0YWluIGVsZW1lbnQsIG1lYW5pbmcgZG93bittb3ZlK3VwLlxyXG5cclxuICAgIEFsc28sIHRyYWNrcyBpZiB0aGVyZSB3YXMgdG91Y2gtc2Nyb2xsaW5nLlxyXG4gICAgQWxzbywgY2FuIHByZXZlbnQgdG91Y2gtc2Nyb2xsaW5nIGZyb20gaGFwcGVuaW5nLlxyXG4gICAgQWxzbywgY2FuIGZpcmUgcG9pbnRlcm1vdmUgZXZlbnRzIHdoZW4gc2Nyb2xsaW5nIGhhcHBlbnMgdW5kZXJuZWF0aCwgZXZlbiB3aGVuIG5vIHJlYWwgcG9pbnRlciBtb3ZlbWVudC5cclxuXHJcbiAgICBlbWl0czpcclxuICAgIC0gcG9pbnRlcmRvd25cclxuICAgIC0gcG9pbnRlcm1vdmVcclxuICAgIC0gcG9pbnRlcnVwXHJcbiAgICAqL1xyXG4gICAgdmFyIFBvaW50ZXJEcmFnZ2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQb2ludGVyRHJhZ2dpbmcoY29udGFpbmVyRWwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmRvd25FbCA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgZGlyZWN0bHkgYXNzaWduZWQgYnkgY2FsbGVyXHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSAnJzsgLy8gd2lsbCBjYXVzZSBzdWJqZWN0RWwgaW4gYWxsIGVtaXR0ZWQgZXZlbnRzIHRvIGJlIHRoaXMgZWxlbWVudFxyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdG9yID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnNob3VsZFdhdGNoU2Nyb2xsID0gdHJ1ZTsgLy8gZm9yIHNpbXVsYXRpbmcgcG9pbnRlcm1vdmUgb24gc2Nyb2xsXHJcbiAgICAgICAgICAgIC8vIGludGVybmFsIHN0YXRlc1xyXG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc1RvdWNoRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy53YXNUb3VjaFNjcm9sbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBNb3VzZVxyXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikgJiZcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cnlTdGFydChldikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGV2ID0gX3RoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmluaXRTY3JvbGxXYXRjaChwZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3RoaXMuaGFuZGxlTW91c2VVcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGV2ID0gX3RoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucmVjb3JkQ29vcmRzKHBldik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgcGV2KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF90aGlzLmhhbmRsZU1vdXNlVXApO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBfdGhpcy5jcmVhdGVFdmVudEZyb21Nb3VzZShldikpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBUb3VjaFxyXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRyeVN0YXJ0KGV2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzVG91Y2hEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBldiA9IF90aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgcGV2KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbml0U2Nyb2xsV2F0Y2gocGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1bmxpa2UgbW91c2UsIG5lZWQgdG8gYXR0YWNoIHRvIHRhcmdldCwgbm90IGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ1NzYwMDE0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF90aGlzLmhhbmRsZVRvdWNoTW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF90aGlzLmhhbmRsZVRvdWNoRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfdGhpcy5oYW5kbGVUb3VjaEVuZCk7IC8vIHRyZWF0IGl0IGFzIGEgdG91Y2ggZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0YWNoIGEgaGFuZGxlciB0byBnZXQgY2FsbGVkIHdoZW4gQU5ZIHNjcm9sbCBhY3Rpb24gaGFwcGVucyBvbiB0aGUgcGFnZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBpbXBvc3NpYmxlIHRvIGRvIHdpdGggbm9ybWFsIG9uL29mZiBiZWNhdXNlICdzY3JvbGwnIGRvZXNuJ3QgYnViYmxlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyOTU0NTY1Lzk2MzQyXHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF90aGlzLmhhbmRsZVRvdWNoU2Nyb2xsLCB0cnVlIC8vIHVzZUNhcHR1cmVcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBldiA9IF90aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnJlY29yZENvb3JkcyhwZXYpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIHBldik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7IC8vIGRvbmUgdG8gZ3VhcmQgYWdhaW5zdCB0b3VjaGVuZCBmb2xsb3dlZCBieSB0b3VjaGNhbmNlbFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF90aGlzLmhhbmRsZVRvdWNoTW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX3RoaXMuaGFuZGxlVG91Y2hFbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIF90aGlzLmhhbmRsZVRvdWNoRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMuaGFuZGxlVG91Y2hTY3JvbGwsIHRydWUpOyAvLyB1c2VDYXB0dXJlZD10cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBfdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldikpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFudXAoKTsgLy8gY2FsbCBsYXN0IHNvIHRoYXQgcG9pbnRlcnVwIGhhcyBhY2Nlc3MgdG8gcHJvcHNcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc1RvdWNoRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydElnbm9yaW5nTW91c2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLndhc1RvdWNoU2Nyb2xsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWdlWCA9ICh3aW5kb3cucGFnZVhPZmZzZXQgLSBfdGhpcy5wcmV2U2Nyb2xsWCkgKyBfdGhpcy5wcmV2UGFnZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZ2VZID0gKHdpbmRvdy5wYWdlWU9mZnNldCAtIF90aGlzLnByZXZTY3JvbGxZKSArIF90aGlzLnByZXZQYWdlWTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoOiBfdGhpcy5pc1RvdWNoRHJhZ2dpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3RFbDogX3RoaXMuc3ViamVjdEVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWDogcGFnZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBwYWdlWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFYOiBwYWdlWCAtIF90aGlzLm9yaWdQYWdlWCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFZOiBwYWdlWSAtIF90aGlzLm9yaWdQYWdlWVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBjb3JlLkVtaXR0ZXJNaXhpbigpO1xyXG4gICAgICAgICAgICBjb250YWluZXJFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgbGlzdGVuZXJDcmVhdGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBsaXN0ZW5lckRlc3Ryb3llZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS50cnlTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgc3ViamVjdEVsID0gdGhpcy5xdWVyeVN1YmplY3RFbChldik7XHJcbiAgICAgICAgICAgIHZhciBkb3duRWwgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGlmIChzdWJqZWN0RWwgJiZcclxuICAgICAgICAgICAgICAgICghdGhpcy5oYW5kbGVTZWxlY3RvciB8fCBjb3JlLmVsZW1lbnRDbG9zZXN0KGRvd25FbCwgdGhpcy5oYW5kbGVTZWxlY3RvcikpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmplY3RFbCA9IHN1YmplY3RFbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG93bkVsID0gZG93bkVsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTsgLy8gZG8gdGhpcyBmaXJzdCBzbyBjYW5jZWxUb3VjaFNjcm9sbCB3aWxsIHdvcmtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FzVG91Y2hTY3JvbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdEVsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5kb3duRWwgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBrZWVwIHdhc1RvdWNoU2Nyb2xsIGFyb3VuZCBmb3IgbGF0ZXIgYWNjZXNzXHJcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVNjcm9sbFdhdGNoKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLnF1ZXJ5U3ViamVjdEVsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5lbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHRoaXMuc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyRWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUuc2hvdWxkSWdub3JlTW91c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpZ25vcmVNb3VzZURlcHRoIHx8IHRoaXMuaXNUb3VjaERyYWdnaW5nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gY2FuIGJlIGNhbGxlZCBieSB1c2VyIG9mIHRoaXMgY2xhc3MsIHRvIGNhbmNlbCB0b3VjaC1iYXNlZCBzY3JvbGxpbmcgZm9yIHRoZSBjdXJyZW50IGRyYWdcclxuICAgICAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmNhbmNlbFRvdWNoU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFNjcm9sbGluZyB0aGF0IHNpbXVsYXRlcyBwb2ludGVybW92ZXNcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5pbml0U2Nyb2xsV2F0Y2ggPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkQ29vcmRzKGV2KTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmU9dHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLnJlY29yZENvb3JkcyA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2UGFnZVggPSBldi5wYWdlWDtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldlBhZ2VZID0gZXYucGFnZVk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxYID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2U2Nyb2xsWSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95U2Nyb2xsV2F0Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHRydWUpOyAvLyB1c2VDYXB0dXJlZD10cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEV2ZW50IE5vcm1hbGl6YXRpb25cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5jcmVhdGVFdmVudEZyb21Nb3VzZSA9IGZ1bmN0aW9uIChldiwgaXNGaXJzdCkge1xyXG4gICAgICAgICAgICB2YXIgZGVsdGFYID0gMDtcclxuICAgICAgICAgICAgdmFyIGRlbHRhWSA9IDA7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGVhdCBjb2RlXHJcbiAgICAgICAgICAgIGlmIChpc0ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdQYWdlWCA9IGV2LnBhZ2VYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVkgPSBldi5wYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlbHRhWCA9IGV2LnBhZ2VYIC0gdGhpcy5vcmlnUGFnZVg7XHJcbiAgICAgICAgICAgICAgICBkZWx0YVkgPSBldi5wYWdlWSAtIHRoaXMub3JpZ1BhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgaXNUb3VjaDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzdWJqZWN0RWw6IHRoaXMuc3ViamVjdEVsLFxyXG4gICAgICAgICAgICAgICAgcGFnZVg6IGV2LnBhZ2VYLFxyXG4gICAgICAgICAgICAgICAgcGFnZVk6IGV2LnBhZ2VZLFxyXG4gICAgICAgICAgICAgICAgZGVsdGFYOiBkZWx0YVgsXHJcbiAgICAgICAgICAgICAgICBkZWx0YVk6IGRlbHRhWVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5jcmVhdGVFdmVudEZyb21Ub3VjaCA9IGZ1bmN0aW9uIChldiwgaXNGaXJzdCkge1xyXG4gICAgICAgICAgICB2YXIgdG91Y2hlcyA9IGV2LnRvdWNoZXM7XHJcbiAgICAgICAgICAgIHZhciBwYWdlWDtcclxuICAgICAgICAgICAgdmFyIHBhZ2VZO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGFYID0gMDtcclxuICAgICAgICAgICAgdmFyIGRlbHRhWSA9IDA7XHJcbiAgICAgICAgICAgIC8vIGlmIHRvdWNoIGNvb3JkcyBhdmFpbGFibGUsIHByZWZlcixcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBGRiB3b3VsZCBnaXZlIGJhZCBldi5wYWdlWCBldi5wYWdlWVxyXG4gICAgICAgICAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcGFnZVggPSB0b3VjaGVzWzBdLnBhZ2VYO1xyXG4gICAgICAgICAgICAgICAgcGFnZVkgPSB0b3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFnZVggPSBldi5wYWdlWDtcclxuICAgICAgICAgICAgICAgIHBhZ2VZID0gZXYucGFnZVk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogcmVwZWF0IGNvZGVcclxuICAgICAgICAgICAgaWYgKGlzRmlyc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VYID0gcGFnZVg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdQYWdlWSA9IHBhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVsdGFYID0gcGFnZVggLSB0aGlzLm9yaWdQYWdlWDtcclxuICAgICAgICAgICAgICAgIGRlbHRhWSA9IHBhZ2VZIC0gdGhpcy5vcmlnUGFnZVk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXHJcbiAgICAgICAgICAgICAgICBpc1RvdWNoOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcclxuICAgICAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcclxuICAgICAgICAgICAgICAgIHBhZ2VZOiBwYWdlWSxcclxuICAgICAgICAgICAgICAgIGRlbHRhWDogZGVsdGFYLFxyXG4gICAgICAgICAgICAgICAgZGVsdGFZOiBkZWx0YVlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQb2ludGVyRHJhZ2dpbmc7XHJcbiAgICB9KCkpO1xyXG4gICAgLy8gUmV0dXJucyBhIGJvb2xlYW4gd2hldGhlciB0aGlzIHdhcyBhIGxlZnQgbW91c2UgY2xpY2sgYW5kIG5vIGN0cmwga2V5ICh3aGljaCBtZWFucyByaWdodCBjbGljayBvbiBNYWMpXHJcbiAgICBmdW5jdGlvbiBpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikge1xyXG4gICAgICAgIHJldHVybiBldi5idXR0b24gPT09IDAgJiYgIWV2LmN0cmxLZXk7XHJcbiAgICB9XHJcbiAgICAvLyBJZ25vcmluZyBmYWtlIG1vdXNlIGV2ZW50cyBnZW5lcmF0ZWQgYnkgdG91Y2hcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGZ1bmN0aW9uIHN0YXJ0SWdub3JpbmdNb3VzZSgpIHtcclxuICAgICAgICBpZ25vcmVNb3VzZURlcHRoKys7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlnbm9yZU1vdXNlRGVwdGgtLTtcclxuICAgICAgICB9LCBjb3JlLmNvbmZpZy50b3VjaE1vdXNlSWdub3JlV2FpdCk7XHJcbiAgICB9XHJcbiAgICAvLyBXZSB3YW50IHRvIGF0dGFjaCB0b3VjaG1vdmUgYXMgZWFybHkgYXMgcG9zc2libGUgZm9yIFNhZmFyaVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gbGlzdGVuZXJDcmVhdGVkKCkge1xyXG4gICAgICAgIGlmICghKGxpc3RlbmVyQ250KyspKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbldpbmRvd1RvdWNoTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBsaXN0ZW5lckRlc3Ryb3llZCgpIHtcclxuICAgICAgICBpZiAoISgtLWxpc3RlbmVyQ250KSkge1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25XaW5kb3dUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25XaW5kb3dUb3VjaE1vdmUoZXYpIHtcclxuICAgICAgICBpZiAoaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIEFuIGVmZmVjdCBpbiB3aGljaCBhbiBlbGVtZW50IGZvbGxvd3MgdGhlIG1vdmVtZW50IG9mIGEgcG9pbnRlciBhY3Jvc3MgdGhlIHNjcmVlbi5cclxuICAgIFRoZSBtb3ZpbmcgZWxlbWVudCBpcyBhIGNsb25lIG9mIHNvbWUgb3RoZXIgZWxlbWVudC5cclxuICAgIE11c3QgY2FsbCBzdGFydCArIGhhbmRsZU1vdmUgKyBzdG9wLlxyXG4gICAgKi9cclxuICAgIHZhciBFbGVtZW50TWlycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEVsZW1lbnRNaXJyb3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7IC8vIG11c3QgYmUgZXhwbGljaXRseSBlbmFibGVkXHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlRWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm1pcnJvckVsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VFbFJlY3QgPSBudWxsOyAvLyBzY3JlZW4gY29vcmRzIHJlbGF0aXZlIHRvIHZpZXdwb3J0XHJcbiAgICAgICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGRpcmVjdGx5IGJ5IGNhbGxlclxyXG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgICAgICAgICB0aGlzLnpJbmRleCA9IDk5OTk7XHJcbiAgICAgICAgICAgIHRoaXMucmV2ZXJ0RHVyYXRpb24gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFbGVtZW50TWlycm9yLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChzb3VyY2VFbCwgcGFnZVgsIHBhZ2VZKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlRWwgPSBzb3VyY2VFbDtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VFbFJlY3QgPSB0aGlzLnNvdXJjZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdTY3JlZW5YID0gcGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ1NjcmVlblkgPSBwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5kZWx0YVggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmRlbHRhWSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWxlbWVudE1pcnJvci5wcm90b3R5cGUuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChwYWdlWCwgcGFnZVkpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWx0YVggPSAocGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQpIC0gdGhpcy5vcmlnU2NyZWVuWDtcclxuICAgICAgICAgICAgdGhpcy5kZWx0YVkgPSAocGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQpIC0gdGhpcy5vcmlnU2NyZWVuWTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBjYW4gYmUgY2FsbGVkIGJlZm9yZSBzdGFydFxyXG4gICAgICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLnNldElzVmlzaWJsZSA9IGZ1bmN0aW9uIChib29sKSB7XHJcbiAgICAgICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gYm9vbDsgLy8gbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB1cGRhdGVFbFBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7IC8vIGJlY2F1c2Ugd2FzIG5vdCB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgaW52aXNpYmxlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5taXJyb3JFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gYm9vbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gYWx3YXlzIGFzeW5jXHJcbiAgICAgICAgRWxlbWVudE1pcnJvci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChuZWVkc1JldmVydEFuaW1hdGlvbiwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAobmVlZHNSZXZlcnRBbmltYXRpb24gJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubWlycm9yRWwgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJldmVydER1cmF0aW9uICYmIC8vIGlmIDAsIHRyYW5zaXRpb24gd29uJ3Qgd29ya1xyXG4gICAgICAgICAgICAgICAgKHRoaXMuZGVsdGFYIHx8IHRoaXMuZGVsdGFZKSAvLyBpZiBzYW1lIGNvb3JkcywgdHJhbnNpdGlvbiB3b24ndCB3b3JrXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb1JldmVydEFuaW1hdGlvbihkb25lLCB0aGlzLnJldmVydER1cmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLmRvUmV2ZXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24gKGNhbGxiYWNrLCByZXZlcnREdXJhdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgbWlycm9yRWwgPSB0aGlzLm1pcnJvckVsO1xyXG4gICAgICAgICAgICB2YXIgZmluYWxTb3VyY2VFbFJlY3QgPSB0aGlzLnNvdXJjZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBiZWNhdXNlIGF1dG9zY3JvbGxpbmcgbWlnaHQgaGF2ZSBoYXBwZW5lZFxyXG4gICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS50cmFuc2l0aW9uID1cclxuICAgICAgICAgICAgICAgICd0b3AgJyArIHJldmVydER1cmF0aW9uICsgJ21zLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdsZWZ0ICcgKyByZXZlcnREdXJhdGlvbiArICdtcyc7XHJcbiAgICAgICAgICAgIGNvcmUuYXBwbHlTdHlsZShtaXJyb3JFbCwge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogZmluYWxTb3VyY2VFbFJlY3QubGVmdCxcclxuICAgICAgICAgICAgICAgIHRvcDogZmluYWxTb3VyY2VFbFJlY3QudG9wXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb3JlLndoZW5UcmFuc2l0aW9uRG9uZShtaXJyb3JFbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbWlycm9yRWwuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbGVtZW50TWlycm9yLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5taXJyb3JFbCkge1xyXG4gICAgICAgICAgICAgICAgY29yZS5yZW1vdmVFbGVtZW50KHRoaXMubWlycm9yRWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VFbCA9IG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbGVtZW50TWlycm9yLnByb3RvdHlwZS51cGRhdGVFbFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VFbCAmJiB0aGlzLmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY29yZS5hcHBseVN0eWxlKHRoaXMuZ2V0TWlycm9yRWwoKSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuc291cmNlRWxSZWN0LmxlZnQgKyB0aGlzLmRlbHRhWCxcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRoaXMuc291cmNlRWxSZWN0LnRvcCArIHRoaXMuZGVsdGFZXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWxlbWVudE1pcnJvci5wcm90b3R5cGUuZ2V0TWlycm9yRWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VFbFJlY3QgPSB0aGlzLnNvdXJjZUVsUmVjdDtcclxuICAgICAgICAgICAgdmFyIG1pcnJvckVsID0gdGhpcy5taXJyb3JFbDtcclxuICAgICAgICAgICAgaWYgKCFtaXJyb3JFbCkge1xyXG4gICAgICAgICAgICAgICAgbWlycm9yRWwgPSB0aGlzLm1pcnJvckVsID0gdGhpcy5zb3VyY2VFbC5jbG9uZU5vZGUodHJ1ZSk7IC8vIGNsb25lQ2hpbGRyZW49dHJ1ZVxyXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCBsb25nIHRhcHMgb3IgYW55IG1vdXNlIGludGVyYWN0aW9uIGNhdXNpbmcgc2VsZWN0aW9uL21lbnVzLlxyXG4gICAgICAgICAgICAgICAgLy8gd291bGQgdXNlIHByZXZlbnRTZWxlY3Rpb24oKSwgYnV0IHRoYXQgcHJldmVudHMgc2VsZWN0c3RhcnQsIGNhdXNpbmcgcHJvYmxlbXMuXHJcbiAgICAgICAgICAgICAgICBtaXJyb3JFbC5jbGFzc0xpc3QuYWRkKCdmYy11bnNlbGVjdGFibGUnKTtcclxuICAgICAgICAgICAgICAgIG1pcnJvckVsLmNsYXNzTGlzdC5hZGQoJ2ZjLWRyYWdnaW5nJyk7XHJcbiAgICAgICAgICAgICAgICBjb3JlLmFwcGx5U3R5bGUobWlycm9yRWwsIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcclxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IHRoaXMuekluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzb3VyY2VFbFJlY3QucmlnaHQgLSBzb3VyY2VFbFJlY3QubGVmdCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHNvdXJjZUVsUmVjdC5ib3R0b20gLSBzb3VyY2VFbFJlY3QudG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChtaXJyb3JFbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1pcnJvckVsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRNaXJyb3I7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIC8qXHJcbiAgICBJcyBhIGNhY2hlIGZvciBhIGdpdmVuIGVsZW1lbnQncyBzY3JvbGwgaW5mb3JtYXRpb24gKGFsbCB0aGUgaW5mbyB0aGF0IFNjcm9sbENvbnRyb2xsZXIgc3RvcmVzKVxyXG4gICAgaW4gYWRkaXRpb24gdGhlIFwiY2xpZW50IHJlY3RhbmdsZVwiIG9mIHRoZSBlbGVtZW50Li4gdGhlIGFyZWEgd2l0aGluIHRoZSBzY3JvbGxiYXJzLlxyXG5cclxuICAgIFRoZSBjYWNoZSBjYW4gYmUgaW4gb25lIG9mIHR3byBtb2RlczpcclxuICAgIC0gZG9lc0xpc3RlbmluZzpmYWxzZSAtIGlnbm9yZXMgd2hlbiB0aGUgY29udGFpbmVyIGlzIHNjcm9sbGVkIGJ5IHNvbWVvbmUgZWxzZVxyXG4gICAgLSBkb2VzTGlzdGVuaW5nOnRydWUgLSB3YXRjaCBmb3Igc2Nyb2xsaW5nIGFuZCB1cGRhdGUgdGhlIGNhY2hlXHJcbiAgICAqL1xyXG4gICAgdmFyIFNjcm9sbEdlb21DYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU2Nyb2xsR2VvbUNhY2hlLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFNjcm9sbEdlb21DYWNoZShzY3JvbGxDb250cm9sbGVyLCBkb2VzTGlzdGVuaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNjcm9sbFRvcCA9IF90aGlzLnNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsVG9wKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zY3JvbGxMZWZ0ID0gX3RoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsQ29udHJvbGxlciA9IHNjcm9sbENvbnRyb2xsZXI7XHJcbiAgICAgICAgICAgIF90aGlzLmRvZXNMaXN0ZW5pbmcgPSBkb2VzTGlzdGVuaW5nO1xyXG4gICAgICAgICAgICBfdGhpcy5zY3JvbGxUb3AgPSBfdGhpcy5vcmlnU2Nyb2xsVG9wID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxUb3AoKTtcclxuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsTGVmdCA9IF90aGlzLm9yaWdTY3JvbGxMZWZ0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KCk7XHJcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbFdpZHRoID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxXaWR0aCgpO1xyXG4gICAgICAgICAgICBfdGhpcy5zY3JvbGxIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbEhlaWdodCgpO1xyXG4gICAgICAgICAgICBfdGhpcy5jbGllbnRXaWR0aCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0Q2xpZW50V2lkdGgoKTtcclxuICAgICAgICAgICAgX3RoaXMuY2xpZW50SGVpZ2h0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRDbGllbnRIZWlnaHQoKTtcclxuICAgICAgICAgICAgX3RoaXMuY2xpZW50UmVjdCA9IF90aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7IC8vIGRvIGxhc3QgaW4gY2FzZSBpdCBuZWVkcyBjYWNoZWQgdmFsdWVzXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5kb2VzTGlzdGVuaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5nZXRFdmVudFRhcmdldCgpLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF90aGlzLmhhbmRsZVNjcm9sbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRUYXJnZXQoKS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUb3A7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmdldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjcm9sbExlZnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICh0b3ApIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb250cm9sbGVyLnNldFNjcm9sbFRvcCh0b3ApO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9lc0xpc3RlbmluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCByZWx5aW5nIG9uIHRoZSBlbGVtZW50IHRvIG5vcm1hbGl6ZSBvdXQtb2YtYm91bmRzIHNjcm9sbCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gc2FuaXRpemUgb3Vyc2VsdmVzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IE1hdGgubWF4KE1hdGgubWluKHRvcCwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKSksIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKHRvcCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIuc2V0U2Nyb2xsTGVmdCh0b3ApO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9lc0xpc3RlbmluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCByZWx5aW5nIG9uIHRoZSBlbGVtZW50IHRvIG5vcm1hbGl6ZSBvdXQtb2YtYm91bmRzIHNjcm9sbCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gc2FuaXRpemUgb3Vyc2VsdmVzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSBNYXRoLm1heChNYXRoLm1pbih0b3AsIHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpKSwgMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmdldENsaWVudFdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRXaWR0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0Q2xpZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmdldFNjcm9sbFdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxXaWR0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmhhbmRsZVNjcm9sbENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTY3JvbGxHZW9tQ2FjaGU7XHJcbiAgICB9KGNvcmUuU2Nyb2xsQ29udHJvbGxlcikpO1xyXG4gICAgdmFyIEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRWxlbWVudFNjcm9sbEdlb21DYWNoZShlbCwgZG9lc0xpc3RlbmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmV3IGNvcmUuRWxlbWVudFNjcm9sbENvbnRyb2xsZXIoZWwpLCBkb2VzTGlzdGVuaW5nKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRFdmVudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5lbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmNvbXB1dGVDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZS5jb21wdXRlSW5uZXJSZWN0KHRoaXMuc2Nyb2xsQ29udHJvbGxlci5lbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRWxlbWVudFNjcm9sbEdlb21DYWNoZTtcclxuICAgIH0oU2Nyb2xsR2VvbUNhY2hlKSk7XHJcbiAgICB2YXIgV2luZG93U2Nyb2xsR2VvbUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhXaW5kb3dTY3JvbGxHZW9tQ2FjaGUsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gV2luZG93U2Nyb2xsR2VvbUNhY2hlKGRvZXNMaXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5ldyBjb3JlLldpbmRvd1Njcm9sbENvbnRyb2xsZXIoKSwgZG9lc0xpc3RlbmluZykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgV2luZG93U2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRFdmVudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdpbmRvd1Njcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuY29tcHV0ZUNsaWVudFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLnNjcm9sbExlZnQsXHJcbiAgICAgICAgICAgICAgICByaWdodDogdGhpcy5zY3JvbGxMZWZ0ICsgdGhpcy5jbGllbnRXaWR0aCxcclxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5zY3JvbGxUb3AsXHJcbiAgICAgICAgICAgICAgICBib3R0b206IHRoaXMuc2Nyb2xsVG9wICsgdGhpcy5jbGllbnRIZWlnaHRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHRoZSB3aW5kb3cgaXMgdGhlIG9ubHkgc2Nyb2xsIG9iamVjdCB0aGF0IGNoYW5nZXMgaXQncyByZWN0YW5nbGUgcmVsYXRpdmVcclxuICAgICAgICAvLyB0byB0aGUgZG9jdW1lbnQncyB0b3BsZWZ0IGFzIGl0IHNjcm9sbHNcclxuICAgICAgICBXaW5kb3dTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmhhbmRsZVNjcm9sbENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGllbnRSZWN0ID0gdGhpcy5jb21wdXRlQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFdpbmRvd1Njcm9sbEdlb21DYWNoZTtcclxuICAgIH0oU2Nyb2xsR2VvbUNhY2hlKSk7XHJcblxyXG4gICAgLy8gSWYgYXZhaWxhYmxlIHdlIGFyZSB1c2luZyBuYXRpdmUgXCJwZXJmb3JtYW5jZVwiIEFQSSBpbnN0ZWFkIG9mIFwiRGF0ZVwiXHJcbiAgICAvLyBSZWFkIG1vcmUgYWJvdXQgaXQgb24gTUROOlxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BlcmZvcm1hbmNlXHJcbiAgICB2YXIgZ2V0VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ2Z1bmN0aW9uJyA/IHBlcmZvcm1hbmNlLm5vdyA6IERhdGUubm93O1xyXG4gICAgLypcclxuICAgIEZvciBhIHBvaW50ZXIgaW50ZXJhY3Rpb24sIGF1dG9tYXRpY2FsbHkgc2Nyb2xscyBjZXJ0YWluIHNjcm9sbCBjb250YWluZXJzIHdoZW4gdGhlIHBvaW50ZXJcclxuICAgIGFwcHJvYWNoZXMgdGhlIGVkZ2UuXHJcblxyXG4gICAgVGhlIGNhbGxlciBtdXN0IGNhbGwgc3RhcnQgKyBoYW5kbGVNb3ZlICsgc3RvcC5cclxuICAgICovXHJcbiAgICB2YXIgQXV0b1Njcm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEF1dG9TY3JvbGxlcigpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgYnkgY2FsbGVyXHJcbiAgICAgICAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxRdWVyeSA9IFt3aW5kb3csICcuZmMtc2Nyb2xsZXInXTtcclxuICAgICAgICAgICAgdGhpcy5lZGdlVGhyZXNob2xkID0gNTA7IC8vIHBpeGVsc1xyXG4gICAgICAgICAgICB0aGlzLm1heFZlbG9jaXR5ID0gMzAwOyAvLyBwaXhlbHMgcGVyIHNlY29uZFxyXG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZVxyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxDYWNoZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBwcm90ZWN0IGFnYWluc3QgdGhlIGluaXRpYWwgcG9pbnRlcmRvd24gYmVpbmcgdG9vIGNsb3NlIHRvIGFuIGVkZ2UgYW5kIHN0YXJ0aW5nIHRoZSBzY3JvbGxcclxuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZERvd24gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzQW5pbWF0aW5nKSB7IC8vIHdhc24ndCBjYW5jZWxsZWQgYmV0d2VlbiBhbmltYXRpb24gY2FsbHNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IF90aGlzLmNvbXB1dGVCZXN0RWRnZShfdGhpcy5wb2ludGVyU2NyZWVuWCArIHdpbmRvdy5wYWdlWE9mZnNldCwgX3RoaXMucG9pbnRlclNjcmVlblkgKyB3aW5kb3cucGFnZVlPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBnZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVNpZGUoZWRnZSwgKG5vdyAtIF90aGlzLm1zU2luY2VSZXF1ZXN0KSAvIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKG5vdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHBhZ2VYLCBwYWdlWSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gdGhpcy5idWlsZENhY2hlcygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5ZID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkVXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkRG93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vdmUocGFnZVgsIHBhZ2VZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXV0b1Njcm9sbGVyLnByb3RvdHlwZS5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gKHBhZ2VYLCBwYWdlWSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludGVyU2NyZWVuWCA9IHBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ZXJTY3JlZW5ZID0gcGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgeURlbHRhID0gdGhpcy5wb2ludGVyU2NyZWVuWSA9PT0gbnVsbCA/IDAgOiBwb2ludGVyU2NyZWVuWSAtIHRoaXMucG9pbnRlclNjcmVlblk7XHJcbiAgICAgICAgICAgICAgICB2YXIgeERlbHRhID0gdGhpcy5wb2ludGVyU2NyZWVuWCA9PT0gbnVsbCA/IDAgOiBwb2ludGVyU2NyZWVuWCAtIHRoaXMucG9pbnRlclNjcmVlblg7XHJcbiAgICAgICAgICAgICAgICBpZiAoeURlbHRhIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkVXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeURlbHRhID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkRG93biA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeERlbHRhIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4RGVsdGEgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRSaWdodCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gcG9pbnRlclNjcmVlblg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5ZID0gcG9pbnRlclNjcmVlblk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNBbmltYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb24oZ2V0VGltZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXV0b1Njcm9sbGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTsgLy8gd2lsbCBzdG9wIGFuaW1hdGlvblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2Nyb2xsQ2FjaGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1dG9TY3JvbGxlci5wcm90b3R5cGUucmVxdWVzdEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChub3cpIHtcclxuICAgICAgICAgICAgdGhpcy5tc1NpbmNlUmVxdWVzdCA9IG5vdztcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLmhhbmRsZVNpZGUgPSBmdW5jdGlvbiAoZWRnZSwgc2Vjb25kcykge1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsQ2FjaGUgPSBlZGdlLnNjcm9sbENhY2hlO1xyXG4gICAgICAgICAgICB2YXIgZWRnZVRocmVzaG9sZCA9IHRoaXMuZWRnZVRocmVzaG9sZDtcclxuICAgICAgICAgICAgdmFyIGludkRpc3RhbmNlID0gZWRnZVRocmVzaG9sZCAtIGVkZ2UuZGlzdGFuY2U7XHJcbiAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IC8vIHRoZSBjbG9zZXIgdG8gdGhlIGVkZ2UsIHRoZSBmYXN0ZXIgd2Ugc2Nyb2xsXHJcbiAgICAgICAgICAgICAoaW52RGlzdGFuY2UgKiBpbnZEaXN0YW5jZSkgLyAoZWRnZVRocmVzaG9sZCAqIGVkZ2VUaHJlc2hvbGQpICogLy8gcXVhZHJhdGljXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heFZlbG9jaXR5ICogc2Vjb25kcztcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSAxO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGVkZ2UubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbENhY2hlLnNldFNjcm9sbExlZnQoc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsTGVmdCgpICsgdmVsb2NpdHkgKiBzaWduKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5zZXRTY3JvbGxUb3Aoc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsVG9wKCkgKyB2ZWxvY2l0eSAqIHNpZ24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBsZWZ0L3RvcCBhcmUgcmVsYXRpdmUgdG8gZG9jdW1lbnQgdG9wbGVmdFxyXG4gICAgICAgIEF1dG9TY3JvbGxlci5wcm90b3R5cGUuY29tcHV0ZUJlc3RFZGdlID0gZnVuY3Rpb24gKGxlZnQsIHRvcCkge1xyXG4gICAgICAgICAgICB2YXIgZWRnZVRocmVzaG9sZCA9IHRoaXMuZWRnZVRocmVzaG9sZDtcclxuICAgICAgICAgICAgdmFyIGJlc3RTaWRlID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2Nyb2xsQ2FjaGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbENhY2hlID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBzY3JvbGxDYWNoZS5jbGllbnRSZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZnREaXN0ID0gbGVmdCAtIHJlY3QubGVmdDtcclxuICAgICAgICAgICAgICAgIHZhciByaWdodERpc3QgPSByZWN0LnJpZ2h0IC0gbGVmdDtcclxuICAgICAgICAgICAgICAgIHZhciB0b3BEaXN0ID0gdG9wIC0gcmVjdC50b3A7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm90dG9tRGlzdCA9IHJlY3QuYm90dG9tIC0gdG9wO1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcGxldGVseSB3aXRoaW4gdGhlIHJlY3Q/XHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdERpc3QgPj0gMCAmJiByaWdodERpc3QgPj0gMCAmJiB0b3BEaXN0ID49IDAgJiYgYm90dG9tRGlzdCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZFVwICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbFVwKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IHRvcERpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZTogc2Nyb2xsQ2FjaGUsIG5hbWU6ICd0b3AnLCBkaXN0YW5jZTogdG9wRGlzdCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tRGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkRG93biAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxEb3duKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGJvdHRvbURpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZTogc2Nyb2xsQ2FjaGUsIG5hbWU6ICdib3R0b20nLCBkaXN0YW5jZTogYm90dG9tRGlzdCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZExlZnQgJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsTGVmdCgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiBsZWZ0RGlzdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlOiBzY3JvbGxDYWNoZSwgbmFtZTogJ2xlZnQnLCBkaXN0YW5jZTogbGVmdERpc3QgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0RGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkUmlnaHQgJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsUmlnaHQoKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gcmlnaHREaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGU6IHNjcm9sbENhY2hlLCBuYW1lOiAncmlnaHQnLCBkaXN0YW5jZTogcmlnaHREaXN0IH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiZXN0U2lkZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1dG9TY3JvbGxlci5wcm90b3R5cGUuYnVpbGRDYWNoZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2Nyb2xsRWxzKCkubWFwKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsID09PSB3aW5kb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdpbmRvd1Njcm9sbEdlb21DYWNoZShmYWxzZSk7IC8vIGZhbHNlID0gZG9uJ3QgbGlzdGVuIHRvIHVzZXItZ2VuZXJhdGVkIHNjcm9sbHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudFNjcm9sbEdlb21DYWNoZShlbCwgZmFsc2UpOyAvLyBmYWxzZSA9IGRvbid0IGxpc3RlbiB0byB1c2VyLWdlbmVyYXRlZCBzY3JvbGxzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXV0b1Njcm9sbGVyLnByb3RvdHlwZS5xdWVyeVNjcm9sbEVscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVscyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zY3JvbGxRdWVyeTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzLnB1c2gocXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzLnB1c2guYXBwbHkoZWxzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlbHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQXV0b1Njcm9sbGVyO1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICAvKlxyXG4gICAgTW9uaXRvcnMgZHJhZ2dpbmcgb24gYW4gZWxlbWVudC4gSGFzIGEgbnVtYmVyIG9mIGhpZ2gtbGV2ZWwgZmVhdHVyZXM6XHJcbiAgICAtIG1pbmltdW0gZGlzdGFuY2UgcmVxdWlyZWQgYmVmb3JlIGRyYWdnaW5nXHJcbiAgICAtIG1pbmltdW0gd2FpdCB0aW1lIChcImRlbGF5XCIpIGJlZm9yZSBkcmFnZ2luZ1xyXG4gICAgLSBhIG1pcnJvciBlbGVtZW50IHRoYXQgZm9sbG93cyB0aGUgcG9pbnRlclxyXG4gICAgKi9cclxuICAgIHZhciBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoY29udGFpbmVyRWwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGFpbmVyRWwpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgZGlyZWN0bHkgc2V0IGJ5IGNhbGxlclxyXG4gICAgICAgICAgICAvLyB0aGUgY2FsbGVyIGNhbiBhbHNvIHNldCB0aGUgUG9pbnRlckRyYWdnaW5nJ3Mgb3B0aW9ucyBhcyB3ZWxsXHJcbiAgICAgICAgICAgIF90aGlzLmRlbGF5ID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMubWluRGlzdGFuY2UgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy50b3VjaFNjcm9sbEFsbG93ZWQgPSB0cnVlOyAvLyBwcmV2ZW50cyBkcmFnIGZyb20gc3RhcnRpbmcgYW5kIGJsb2NrcyBzY3JvbGxpbmcgZHVyaW5nIGRyYWdcclxuICAgICAgICAgICAgX3RoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuaXNJbnRlcmFjdGluZyA9IGZhbHNlOyAvLyBpcyB0aGUgdXNlciB2YWxpZGx5IG1vdmluZyB0aGUgcG9pbnRlcj8gbGFzdHMgdW50aWwgcG9pbnRlcnVwXHJcbiAgICAgICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTsgLy8gaXMgaXQgSU5URU5URlVMTFkgZHJhZ2dpbmc/IGxhc3RzIHVudGlsIGFmdGVyIHJldmVydCBhbmltYXRpb25cclxuICAgICAgICAgICAgX3RoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5vblBvaW50ZXJEb3duID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzRHJhZ2dpbmcpIHsgLy8gc28gbmV3IGRyYWcgZG9lc24ndCBoYXBwZW4gd2hpbGUgcmV2ZXJ0IGFuaW1hdGlvbiBpcyBnb2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzSW50ZXJhY3RpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLnByZXZlbnRTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29yZS5wcmV2ZW50Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBsaW5rcyBmcm9tIGJlaW5nIHZpc2l0ZWQgaWYgdGhlcmUncyBhbiBldmVudHVhbCBkcmFnLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gcHJldmVudHMgc2VsZWN0aW9uIGluIG9sZGVyIGJyb3dzZXJzIChtYXliZT8pLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgZm9yIHRvdWNoLCBiZXNpZGVzLCBicm93c2VyIHdvdWxkIGNvbXBsYWluIGFib3V0IHBhc3NpdmVuZXNzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXYuaXNUb3VjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldi5vcmlnRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY3Rpb25zIHJlbGF0ZWQgdG8gaW5pdGlhdGluZyBkcmFnc3RhcnQrZHJhZ21vdmUrZHJhZ2VuZC4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5taXJyb3Iuc2V0SXNWaXNpYmxlKGZhbHNlKTsgLy8gcmVzZXQuIGNhbGxlciBtdXN0IHNldC12aXNpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1pcnJvci5zdGFydChldi5zdWJqZWN0RWwsIGV2LnBhZ2VYLCBldi5wYWdlWSk7IC8vIG11c3QgaGFwcGVuIG9uIGZpcnN0IHBvaW50ZXIgZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydERlbGF5KGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5taW5EaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5vblBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNJbnRlcmFjdGluZykgeyAvLyBpZiBmYWxzZSwgc3RpbGwgd2FpdGluZyBmb3IgcHJldmlvdXMgZHJhZydzIHJldmVydFxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5EaXN0YW5jZSA9IF90aGlzLm1pbkRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VTcSA9IHZvaWQgMDsgLy8gY3VycmVudCBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4sIHNxdWFyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhWCA9IGV2LmRlbHRhWCwgZGVsdGFZID0gZXYuZGVsdGFZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVNxID0gZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VTcSA+PSBtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlKSB7IC8vIHVzZSBweXRoYWdvcmVhbiB0aGVvcmVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSByZWFsIHBvaW50ZXIgbW92ZT8gKG5vdCBvbmUgc2ltdWxhdGVkIGJ5IHNjcm9sbGluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2Lm9yaWdFdmVudC50eXBlICE9PSAnc2Nyb2xsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWlycm9yLmhhbmRsZU1vdmUoZXYucGFnZVgsIGV2LnBhZ2VZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF1dG9TY3JvbGxlci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLm9uUG9pbnRlclVwID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNJbnRlcmFjdGluZykgeyAvLyBpZiBmYWxzZSwgc3RpbGwgd2FpdGluZyBmb3IgcHJldmlvdXMgZHJhZydzIHJldmVydFxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLmFsbG93U2VsZWN0aW9uKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuYWxsb3dDb250ZXh0TWVudShkb2N1bWVudC5ib2R5KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTsgLy8gY2FuIHBvdGVudGlhbGx5IHNldCBtaXJyb3JOZWVkc1JldmVydFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF1dG9TY3JvbGxlci5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRyeVN0b3BEcmFnKGV2KTsgLy8gd2hpY2ggd2lsbCBzdG9wIHRoZSBtaXJyb3JcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmRlbGF5VGltZW91dElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5kZWxheVRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBwb2ludGVyID0gX3RoaXMucG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoY29udGFpbmVyRWwpO1xyXG4gICAgICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgX3RoaXMub25Qb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcm1vdmUnLCBfdGhpcy5vblBvaW50ZXJNb3ZlKTtcclxuICAgICAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCBfdGhpcy5vblBvaW50ZXJVcCk7XHJcbiAgICAgICAgICAgIF90aGlzLm1pcnJvciA9IG5ldyBFbGVtZW50TWlycm9yKCk7XHJcbiAgICAgICAgICAgIF90aGlzLmF1dG9TY3JvbGxlciA9IG5ldyBBdXRvU2Nyb2xsZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuc3RhcnREZWxheSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGVsYXkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZURlbGF5RW5kKGV2KTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMuZGVsYXkpOyAvLyBub3QgYXNzaWduYWJsZSB0byBudW1iZXIhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURlbGF5RW5kKGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuaGFuZGxlRGVsYXlFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyeVN0YXJ0RHJhZyhldik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyeVN0YXJ0RHJhZyhldik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS50cnlTdGFydERyYWcgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZWxheUVuZGVkICYmIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvaW50ZXIud2FzVG91Y2hTY3JvbGwgfHwgdGhpcy50b3VjaFNjcm9sbEFsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5zdGFydChldi5wYWdlWCwgZXYucGFnZVkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG91Y2hTY3JvbGxBbGxvd2VkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXIuY2FuY2VsVG91Y2hTY3JvbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnRyeVN0b3BEcmFnID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIC8vIC5zdG9wKCkgaXMgQUxXQVlTIGFzeW5jaHJvbm91cywgd2hpY2ggd2UgTkVFRCBiZWNhdXNlIHdlIHdhbnQgYWxsIHBvaW50ZXJ1cCBldmVudHNcclxuICAgICAgICAgICAgLy8gdGhhdCBjb21lIGZyb20gdGhlIGRvY3VtZW50IHRvIGZpcmUgYmVmb3JlaGFuZC4gbXVjaCBtb3JlIGNvbnZlbmllbnQgdGhpcyB3YXkuXHJcbiAgICAgICAgICAgIHRoaXMubWlycm9yLnN0b3AodGhpcy5taXJyb3JOZWVkc1JldmVydCwgdGhpcy5zdG9wRHJhZy5iaW5kKHRoaXMsIGV2KSAvLyBib3VuZCB3aXRoIGFyZ3NcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnN0b3BEcmFnID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ2VuZCcsIGV2KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGZpbGwgaW4gdGhlIGltcGxlbWVudGF0aW9ucy4uLlxyXG4gICAgICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldElnbm9yZU1vdmUgPSBmdW5jdGlvbiAoYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2w7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JJc1Zpc2libGUgPSBmdW5jdGlvbiAoYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLm1pcnJvci5zZXRJc1Zpc2libGUoYm9vbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JOZWVkc1JldmVydCA9IGZ1bmN0aW9uIChib29sKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBib29sO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuc2V0QXV0b1Njcm9sbEVuYWJsZWQgPSBmdW5jdGlvbiAoYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBib29sO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmc7XHJcbiAgICB9KGNvcmUuRWxlbWVudERyYWdnaW5nKSk7XHJcblxyXG4gICAgLypcclxuICAgIFdoZW4gdGhpcyBjbGFzcyBpcyBpbnN0YW50aWF0ZWQsIGl0IHJlY29yZHMgdGhlIG9mZnNldCBvZiBhbiBlbGVtZW50IChyZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG9wbGVmdCksXHJcbiAgICBhbmQgY29udGludWVzIHRvIG1vbml0b3Igc2Nyb2xsaW5nLCB1cGRhdGluZyB0aGUgY2FjaGVkIGNvb3JkaW5hdGVzIGlmIGl0IG5lZWRzIHRvLlxyXG4gICAgRG9lcyBub3QgYWNjZXNzIHRoZSBET00gYWZ0ZXIgaW5zdGFudGlhdGlvbiwgc28gaGlnaGx5IHBlcmZvcm1hbnQuXHJcblxyXG4gICAgQWxzbyBrZWVwcyB0cmFjayBvZiBhbGwgc2Nyb2xsaW5nL292ZXJmbG93OmhpZGRlbiBjb250YWluZXJzIHRoYXQgYXJlIHBhcmVudHMgb2YgdGhlIGdpdmVuIGVsZW1lbnRcclxuICAgIGFuZCBhbiBkZXRlcm1pbmUgaWYgYSBnaXZlbiBwb2ludCBpcyBpbnNpZGUgdGhlIGNvbWJpbmVkIGNsaXBwaW5nIHJlY3RhbmdsZS5cclxuICAgICovXHJcbiAgICB2YXIgT2Zmc2V0VHJhY2tlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBPZmZzZXRUcmFja2VyKGVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ1JlY3QgPSBjb3JlLmNvbXB1dGVSZWN0KGVsKTtcclxuICAgICAgICAgICAgLy8gd2lsbCB3b3JrIGZpbmUgZm9yIGRpdnMgdGhhdCBoYXZlIG92ZXJmbG93OmhpZGRlblxyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IGNvcmUuZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKS5tYXAoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUoZWwsIHRydWUpOyAvLyBsaXN0ZW49dHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2Zmc2V0VHJhY2tlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2Nyb2xsQ2FjaGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbENhY2hlID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPZmZzZXRUcmFja2VyLnByb3RvdHlwZS5jb21wdXRlTGVmdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLm9yaWdSZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNjcm9sbENhY2hlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGxlZnQgKz0gc2Nyb2xsQ2FjaGUub3JpZ1Njcm9sbExlZnQgLSBzY3JvbGxDYWNoZS5nZXRTY3JvbGxMZWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPZmZzZXRUcmFja2VyLnByb3RvdHlwZS5jb21wdXRlVG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdG9wID0gdGhpcy5vcmlnUmVjdC50b3A7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNjcm9sbENhY2hlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHRvcCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsVG9wIC0gc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsVG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRvcDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9mZnNldFRyYWNrZXIucHJvdG90eXBlLmlzV2l0aGluQ2xpcHBpbmcgPSBmdW5jdGlvbiAocGFnZVgsIHBhZ2VZKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHsgbGVmdDogcGFnZVgsIHRvcDogcGFnZVkgfTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2Nyb2xsQ2FjaGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbENhY2hlID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0lnbm9yZWRDbGlwcGluZyhzY3JvbGxDYWNoZS5nZXRFdmVudFRhcmdldCgpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFjb3JlLnBvaW50SW5zaWRlUmVjdChwb2ludCwgc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2Zmc2V0VHJhY2tlcjtcclxuICAgIH0oKSk7XHJcbiAgICAvLyBjZXJ0YWluIGNsaXBwaW5nIGNvbnRhaW5lcnMgc2hvdWxkIG5ldmVyIGNvbnN0cmFpbiBpbnRlcmFjdGlvbnMsIGxpa2UgPGh0bWw+IGFuZCA8Ym9keT5cclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mdWxsY2FsZW5kYXIvZnVsbGNhbGVuZGFyL2lzc3Vlcy8zNjE1XHJcbiAgICBmdW5jdGlvbiBpc0lnbm9yZWRDbGlwcGluZyhub2RlKSB7XHJcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBub2RlLnRhZ05hbWU7XHJcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdIVE1MJyB8fCB0YWdOYW1lID09PSAnQk9EWSc7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIFRyYWNrcyBtb3ZlbWVudCBvdmVyIG11bHRpcGxlIGRyb3BwYWJsZSBhcmVhcyAoYWthIFwiaGl0c1wiKVxyXG4gICAgdGhhdCBleGlzdCBpbiBvbmUgb3IgbW9yZSBEYXRlQ29tcG9uZW50cy5cclxuICAgIFJlbGllcyBvbiBhbiBleGlzdGluZyBkcmFnZ2FibGUuXHJcblxyXG4gICAgZW1pdHM6XHJcbiAgICAtIHBvaW50ZXJkb3duXHJcbiAgICAtIGRyYWdzdGFydFxyXG4gICAgLSBoaXRjaGFuZ2UgLSBmaXJlcyBpbml0aWFsbHksIGV2ZW4gaWYgbm90IG92ZXIgYSBoaXRcclxuICAgIC0gcG9pbnRlcnVwXHJcbiAgICAtIChoaXRjaGFuZ2UgLSBhZ2FpbiwgdG8gbnVsbCwgaWYgZW5kZWQgb3ZlciBhIGhpdClcclxuICAgIC0gZHJhZ2VuZFxyXG4gICAgKi9cclxuICAgIHZhciBIaXREcmFnZ2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBIaXREcmFnZ2luZyhkcmFnZ2luZywgZHJvcHBhYmxlU3RvcmUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgYnkgY2FsbGVyXHJcbiAgICAgICAgICAgIHRoaXMudXNlU3ViamVjdENlbnRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVJbml0aWFsID0gdHJ1ZTsgLy8gaWYgZG9lc24ndCBzdGFydCBvdXQgb24gYSBoaXQsIHdvbid0IGVtaXQgYW55IGV2ZW50c1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZmluYWxIaXQgPSBudWxsOyAvLyB3b24ndCBldmVyIGJlIHBvcHVsYXRlZCBpZiBzaG91bGRJZ25vcmVNb3ZlXHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkcmFnZ2luZyA9IF90aGlzLmRyYWdnaW5nO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaW5pdGlhbEhpdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5tb3ZpbmdIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZmluYWxIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucHJlcGFyZUhpdHMoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnByb2Nlc3NGaXJzdENvb3JkKGV2KTtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pbml0aWFsSGl0IHx8ICFfdGhpcy5yZXF1aXJlSW5pdGlhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBldik7IC8vIFRPRE86IGZpcmUgdGhpcyBiZWZvcmUgY29tcHV0aW5nIHByb2Nlc3NGaXJzdENvb3JkLCBzbyBsaXN0ZW5lcnMgY2FuIGNhbmNlbC4gdGhpcyBnZXRzIGZpcmVkIGJ5IGFsbW9zdCBldmVyeSBoYW5kbGVyIDooXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVNb3ZlKGV2LCB0cnVlKTsgLy8gZm9yY2UgPSBmaXJlIGV2ZW4gaWYgaW5pdGlhbGx5IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZU1vdmUoZXYpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucmVsZWFzZUhpdHMoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgZXYpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5tb3ZpbmdIaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2hpdHVwZGF0ZScsIG51bGwsIHRydWUsIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmZpbmFsSGl0ID0gX3RoaXMubW92aW5nSGl0O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubW92aW5nSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ2VuZCcsIGV2KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5kcm9wcGFibGVTdG9yZSA9IGRyb3BwYWJsZVN0b3JlO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdtb3ZlJywgdGhpcy5oYW5kbGVEcmFnTW92ZSk7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBkcmFnZ2luZztcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IGNvcmUuRW1pdHRlck1peGluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHMgaW5pdGlhbEhpdFxyXG4gICAgICAgIC8vIHNldHMgY29vcmRBZGp1c3RcclxuICAgICAgICBIaXREcmFnZ2luZy5wcm90b3R5cGUucHJvY2Vzc0ZpcnN0Q29vcmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIG9yaWdQb2ludCA9IHsgbGVmdDogZXYucGFnZVgsIHRvcDogZXYucGFnZVkgfTtcclxuICAgICAgICAgICAgdmFyIGFkanVzdGVkUG9pbnQgPSBvcmlnUG9pbnQ7XHJcbiAgICAgICAgICAgIHZhciBzdWJqZWN0RWwgPSBldi5zdWJqZWN0RWw7XHJcbiAgICAgICAgICAgIHZhciBzdWJqZWN0UmVjdDtcclxuICAgICAgICAgICAgaWYgKHN1YmplY3RFbCAhPT0gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gY29yZS5jb21wdXRlUmVjdChzdWJqZWN0RWwpO1xyXG4gICAgICAgICAgICAgICAgYWRqdXN0ZWRQb2ludCA9IGNvcmUuY29uc3RyYWluUG9pbnQoYWRqdXN0ZWRQb2ludCwgc3ViamVjdFJlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbml0aWFsSGl0ID0gdGhpcy5pbml0aWFsSGl0ID0gdGhpcy5xdWVyeUhpdEZvck9mZnNldChhZGp1c3RlZFBvaW50LmxlZnQsIGFkanVzdGVkUG9pbnQudG9wKTtcclxuICAgICAgICAgICAgaWYgKGluaXRpYWxIaXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZVN1YmplY3RDZW50ZXIgJiYgc3ViamVjdFJlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpY2VkU3ViamVjdFJlY3QgPSBjb3JlLmludGVyc2VjdFJlY3RzKHN1YmplY3RSZWN0LCBpbml0aWFsSGl0LnJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGljZWRTdWJqZWN0UmVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZFBvaW50ID0gY29yZS5nZXRSZWN0Q2VudGVyKHNsaWNlZFN1YmplY3RSZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3JkQWRqdXN0ID0gY29yZS5kaWZmUG9pbnRzKGFkanVzdGVkUG9pbnQsIG9yaWdQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3JkQWRqdXN0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgSGl0RHJhZ2dpbmcucHJvdG90eXBlLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAoZXYsIGZvcmNlSGFuZGxlKSB7XHJcbiAgICAgICAgICAgIHZhciBoaXQgPSB0aGlzLnF1ZXJ5SGl0Rm9yT2Zmc2V0KGV2LnBhZ2VYICsgdGhpcy5jb29yZEFkanVzdC5sZWZ0LCBldi5wYWdlWSArIHRoaXMuY29vcmRBZGp1c3QudG9wKTtcclxuICAgICAgICAgICAgaWYgKGZvcmNlSGFuZGxlIHx8ICFpc0hpdHNFcXVhbCh0aGlzLm1vdmluZ0hpdCwgaGl0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZpbmdIaXQgPSBoaXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignaGl0dXBkYXRlJywgaGl0LCBmYWxzZSwgZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBIaXREcmFnZ2luZy5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0VHJhY2tlcnMgPSBjb3JlLm1hcEhhc2godGhpcy5kcm9wcGFibGVTdG9yZSwgZnVuY3Rpb24gKGludGVyYWN0aW9uU2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3MuY29tcG9uZW50LmJ1aWxkUG9zaXRpb25DYWNoZXMoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT2Zmc2V0VHJhY2tlcihpbnRlcmFjdGlvblNldHRpbmdzLmVsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBIaXREcmFnZ2luZy5wcm90b3R5cGUucmVsZWFzZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXRUcmFja2VycyA9IHRoaXMub2Zmc2V0VHJhY2tlcnM7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIG9mZnNldFRyYWNrZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRUcmFja2Vyc1tpZF0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0VHJhY2tlcnMgPSB7fTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEhpdERyYWdnaW5nLnByb3RvdHlwZS5xdWVyeUhpdEZvck9mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXRMZWZ0LCBvZmZzZXRUb3ApIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgZHJvcHBhYmxlU3RvcmUgPSBfYS5kcm9wcGFibGVTdG9yZSwgb2Zmc2V0VHJhY2tlcnMgPSBfYS5vZmZzZXRUcmFja2VycztcclxuICAgICAgICAgICAgdmFyIGJlc3RIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBkcm9wcGFibGVTdG9yZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGRyb3BwYWJsZVN0b3JlW2lkXS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0VHJhY2tlciA9IG9mZnNldFRyYWNrZXJzW2lkXTtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRUcmFja2VyLmlzV2l0aGluQ2xpcHBpbmcob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5MZWZ0ID0gb2Zmc2V0VHJhY2tlci5jb21wdXRlTGVmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5Ub3AgPSBvZmZzZXRUcmFja2VyLmNvbXB1dGVUb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25MZWZ0ID0gb2Zmc2V0TGVmdCAtIG9yaWdpbkxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uVG9wID0gb2Zmc2V0VG9wIC0gb3JpZ2luVG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnUmVjdCA9IG9mZnNldFRyYWNrZXIub3JpZ1JlY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gb3JpZ1JlY3QucmlnaHQgLSBvcmlnUmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBvcmlnUmVjdC5ib3R0b20gLSBvcmlnUmVjdC50b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgd2l0aGluIHRoZSBlbGVtZW50J3MgYm91bmRzXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25MZWZ0ID49IDAgJiYgcG9zaXRpb25MZWZ0IDwgd2lkdGggJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Ub3AgPj0gMCAmJiBwb3NpdGlvblRvcCA8IGhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGl0ID0gY29tcG9uZW50LnF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGl0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGhpdCBpcyB3aXRoaW4gYWN0aXZlUmFuZ2UsIG1lYW5pbmcgaXQncyBub3QgYSBkZWFsIGNlbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFjb21wb25lbnQucHJvcHMuZGF0ZVByb2ZpbGUgfHwgLy8gaGFjayBmb3IgRGF5VGlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUucmFuZ2VDb250YWluc1JhbmdlKGNvbXBvbmVudC5wcm9wcy5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgaGl0LmRhdGVTcGFuLnJhbmdlKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghYmVzdEhpdCB8fCBoaXQubGF5ZXIgPiBiZXN0SGl0LmxheWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogYmV0dGVyIHdheSB0byByZS1vcmllbnQgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC5sZWZ0ICs9IG9yaWdpbkxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC5yaWdodCArPSBvcmlnaW5MZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QudG9wICs9IG9yaWdpblRvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LmJvdHRvbSArPSBvcmlnaW5Ub3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0SGl0ID0gaGl0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiZXN0SGl0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEhpdERyYWdnaW5nO1xyXG4gICAgfSgpKTtcclxuICAgIGZ1bmN0aW9uIGlzSGl0c0VxdWFsKGhpdDAsIGhpdDEpIHtcclxuICAgICAgICBpZiAoIWhpdDAgJiYgIWhpdDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChCb29sZWFuKGhpdDApICE9PSBCb29sZWFuKGhpdDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvcmUuaXNEYXRlU3BhbnNFcXVhbChoaXQwLmRhdGVTcGFuLCBoaXQxLmRhdGVTcGFuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgTW9uaXRvcnMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYSBzcGVjaWZpYyBkYXRlL3RpbWUgb2YgYSBjb21wb25lbnQuXHJcbiAgICBBIHBvaW50ZXJkb3duK3BvaW50ZXJ1cCBvbiB0aGUgc2FtZSBcImhpdFwiIGNvbnN0aXR1dGVzIGEgY2xpY2suXHJcbiAgICAqL1xyXG4gICAgdmFyIERhdGVDbGlja2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRGF0ZUNsaWNraW5nLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIERhdGVDbGlja2luZyhzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkcmFnZ2luZyA9IF90aGlzLmRyYWdnaW5nO1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gdGhpcyBpbiBwb2ludGVyZG93biAobm90IGRyYWdlbmQpIGJlY2F1c2UgRE9NIG1pZ2h0IGJlIG11dGF0ZWQgYnkgdGhlIHRpbWUgZHJhZ2VuZCBpcyBmaXJlZFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghX3RoaXMuY29tcG9uZW50LmlzVmFsaWREYXRlRG93bkVsKGRyYWdnaW5nLnBvaW50ZXIuZG93bkVsKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHdvbid0IGV2ZW4gZmlyZSBpZiBtb3Zpbmcgd2FzIGlnbm9yZWRcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlRHJhZ0VuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludGVyID0gX3RoaXMuZHJhZ2dpbmcucG9pbnRlcjtcclxuICAgICAgICAgICAgICAgIGlmICghcG9pbnRlci53YXNUb3VjaFNjcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmhpdERyYWdnaW5nLCBpbml0aWFsSGl0ID0gX2EuaW5pdGlhbEhpdCwgZmluYWxIaXQgPSBfYS5maW5hbEhpdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEhpdCAmJiBmaW5hbEhpdCAmJiBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBmaW5hbEhpdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmNhbGVuZGFyLnRyaWdnZXJEYXRlQ2xpY2soaW5pdGlhbEhpdC5kYXRlU3BhbiwgaW5pdGlhbEhpdC5kYXlFbCwgY29tcG9uZW50LnZpZXcsIGV2Lm9yaWdFdmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xyXG4gICAgICAgICAgICAvLyB3ZSBETyB3YW50IHRvIHdhdGNoIHBvaW50ZXIgbW92ZXMgYmVjYXVzZSBvdGhlcndpc2UgZmluYWxIaXQgd29uJ3QgZ2V0IHBvcHVsYXRlZFxyXG4gICAgICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKGNvbXBvbmVudC5lbCk7XHJcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGhpdERyYWdnaW5nID0gX3RoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcoX3RoaXMuZHJhZ2dpbmcsIGNvcmUuaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCBfdGhpcy5oYW5kbGVEcmFnRW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERhdGVDbGlja2luZztcclxuICAgIH0oY29yZS5JbnRlcmFjdGlvbikpO1xyXG5cclxuICAgIC8qXHJcbiAgICBUcmFja3Mgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgcG9ydGlvbiBvZiB0aW1lIG9mIGEgY29tcG9uZW50LFxyXG4gICAgY29uc3RpdHV0ZWQgYnkgYSBkcmFnIG92ZXIgZGF0ZSBjZWxscywgd2l0aCBhIHBvc3NpYmxlIGRlbGF5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRyYWcuXHJcbiAgICAqL1xyXG4gICAgdmFyIERhdGVTZWxlY3RpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKERhdGVTZWxlY3RpbmcsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRGF0ZVNlbGVjdGluZyhzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZHJhZ1NlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgY29tcG9uZW50ID0gX2EuY29tcG9uZW50LCBkcmFnZ2luZyA9IF9hLmRyYWdnaW5nO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhblNlbGVjdCA9IGNvbXBvbmVudC5vcHQoJ3NlbGVjdGFibGUnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc1ZhbGlkRGF0ZURvd25FbChldi5vcmlnRXZlbnQudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGJvdGhlciB0byB3YXRjaCBleHBlbnNpdmUgbW92ZXMgaWYgY29tcG9uZW50IHdvbid0IGRvIHNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghY2FuU2VsZWN0KTtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRvdWNoLCByZXF1aXJlIHVzZXIgdG8gaG9sZCBkb3duXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9IGV2LmlzVG91Y2ggPyBnZXRDb21wb25lbnRUb3VjaERlbGF5KGNvbXBvbmVudCkgOiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudC5jYWxlbmRhci51bnNlbGVjdChldik7IC8vIHVuc2VsZWN0IHByZXZpb3VzIHNlbGVjdGlvbnNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlSGl0VXBkYXRlID0gZnVuY3Rpb24gKGhpdCwgaXNGaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gX3RoaXMuY29tcG9uZW50LmNhbGVuZGFyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdTZWxlY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzSW52YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYWdTZWxlY3Rpb24gPSBqb2luSGl0c0ludG9TZWxlY3Rpb24oX3RoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdCwgaGl0LCBjYWxlbmRhci5wbHVnaW5TeXN0ZW0uaG9va3MuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmFnU2VsZWN0aW9uIHx8ICFfdGhpcy5jb21wb25lbnQuaXNEYXRlU2VsZWN0aW9uVmFsaWQoZHJhZ1NlbGVjdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhci5kaXNwYXRjaCh7IHR5cGU6ICdTRUxFQ1RfREFURVMnLCBzZWxlY3Rpb246IGRyYWdTZWxlY3Rpb24gfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNGaW5hbCkgeyAvLyBvbmx5IHVuc2VsZWN0IGlmIG1vdmVkIGF3YXkgd2hpbGUgZHJhZ2dpbmdcclxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhci5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9EQVRFUycgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuZW5hYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRyYWdTZWxlY3Rpb24gPSBkcmFnU2VsZWN0aW9uOyAvLyBvbmx5IGNsZWFyIGlmIG1vdmVkIGF3YXkgZnJvbSBhbGwgaGl0cyB3aGlsZSBkcmFnZ2luZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiAocGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZHJhZ1NlbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBpcyBhbHJlYWR5IHJlbmRlcmVkLCBzbyBqdXN0IG5lZWQgdG8gcmVwb3J0IHNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudC5jYWxlbmRhci50cmlnZ2VyRGF0ZVNlbGVjdChfdGhpcy5kcmFnU2VsZWN0aW9uLCBwZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRyYWdTZWxlY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xyXG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmcgPSBfdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKGNvbXBvbmVudC5lbCk7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy5taW5EaXN0YW5jZSA9IGNvbXBvbmVudC5vcHQoJ3NlbGVjdE1pbkRpc3RhbmNlJykgfHwgMDtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGNvbXBvbmVudC5vcHQoJ2RyYWdTY3JvbGwnKTtcclxuICAgICAgICAgICAgdmFyIGhpdERyYWdnaW5nID0gX3RoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcoX3RoaXMuZHJhZ2dpbmcsIGNvcmUuaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIF90aGlzLmhhbmRsZURyYWdTdGFydCk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIF90aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIF90aGlzLmhhbmRsZVBvaW50ZXJVcCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRGF0ZVNlbGVjdGluZztcclxuICAgIH0oY29yZS5JbnRlcmFjdGlvbikpO1xyXG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50VG91Y2hEZWxheShjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgZGVsYXkgPSBjb21wb25lbnQub3B0KCdzZWxlY3RMb25nUHJlc3NEZWxheScpO1xyXG4gICAgICAgIGlmIChkZWxheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gY29tcG9uZW50Lm9wdCgnbG9uZ1ByZXNzRGVsYXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbGF5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gam9pbkhpdHNJbnRvU2VsZWN0aW9uKGhpdDAsIGhpdDEsIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpIHtcclxuICAgICAgICB2YXIgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcclxuICAgICAgICB2YXIgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcclxuICAgICAgICB2YXIgbXMgPSBbXHJcbiAgICAgICAgICAgIGRhdGVTcGFuMC5yYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgZGF0ZVNwYW4wLnJhbmdlLmVuZCxcclxuICAgICAgICAgICAgZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICBkYXRlU3BhbjEucmFuZ2UuZW5kXHJcbiAgICAgICAgXTtcclxuICAgICAgICBtcy5zb3J0KGNvcmUuY29tcGFyZU51bWJlcnMpO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyc18xID0gZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczsgX2kgPCBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnNfMVtfaV07XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0cmFuc2Zvcm1lcihoaXQwLCBoaXQxKTtcclxuICAgICAgICAgICAgaWYgKHJlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcykge1xyXG4gICAgICAgICAgICAgICAgX19hc3NpZ24ocHJvcHMsIHJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcHMucmFuZ2UgPSB7IHN0YXJ0OiBtc1swXSwgZW5kOiBtc1szXSB9O1xyXG4gICAgICAgIHByb3BzLmFsbERheSA9IGRhdGVTcGFuMC5hbGxEYXk7XHJcbiAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBFdmVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhFdmVudERyYWdnaW5nLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50RHJhZ2dpbmcoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZ3MpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIC8vIGludGVybmFsIHN0YXRlXHJcbiAgICAgICAgICAgIF90aGlzLnN1YmplY3RTZWcgPSBudWxsOyAvLyB0aGUgc2VnIGJlaW5nIHNlbGVjdGVkL2RyYWdnZWRcclxuICAgICAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudFJhbmdlID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsOyAvLyB0aGUgZXZlbnRzIGJlaW5nIGRyYWdnZWRcclxuICAgICAgICAgICAgX3RoaXMucmVjZWl2aW5nQ2FsZW5kYXIgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnVGFyZ2V0ID0gZXYub3JpZ0V2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLCBjb21wb25lbnQgPSBfYS5jb21wb25lbnQsIGRyYWdnaW5nID0gX2EuZHJhZ2dpbmc7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWlycm9yID0gZHJhZ2dpbmcubWlycm9yO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxDYWxlbmRhciA9IGNvbXBvbmVudC5jYWxlbmRhcjtcclxuICAgICAgICAgICAgICAgIHZhciBzdWJqZWN0U2VnID0gX3RoaXMuc3ViamVjdFNlZyA9IGNvcmUuZ2V0RWxTZWcoZXYuc3ViamVjdEVsKTtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudFJhbmdlID0gX3RoaXMuZXZlbnRSYW5nZSA9IHN1YmplY3RTZWcuZXZlbnRSYW5nZTtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudEluc3RhbmNlSWQgPSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWxldmFudEV2ZW50cyA9IGNvcmUuZ2V0UmVsZXZhbnRFdmVudHMoaW5pdGlhbENhbGVuZGFyLnN0YXRlLmV2ZW50U3RvcmUsIGV2ZW50SW5zdGFuY2VJZCk7XHJcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5taW5EaXN0YW5jZSA9IGV2LmlzVG91Y2ggPyAwIDogY29tcG9uZW50Lm9wdCgnZXZlbnREcmFnTWluRGlzdGFuY2UnKTtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID1cclxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGRvIGEgdG91Y2ggZGVsYXkgaWYgdG91Y2ggYW5kIHRoaXMgZXZlbnQgaGFzbid0IGJlZW4gc2VsZWN0ZWQgeWV0XHJcbiAgICAgICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggJiYgZXZlbnRJbnN0YW5jZUlkICE9PSBjb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50VG91Y2hEZWxheSQxKGNvbXBvbmVudCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICAgICAgbWlycm9yLnBhcmVudE5vZGUgPSBpbml0aWFsQ2FsZW5kYXIuZWw7XHJcbiAgICAgICAgICAgICAgICBtaXJyb3IucmV2ZXJ0RHVyYXRpb24gPSBjb21wb25lbnQub3B0KCdkcmFnUmV2ZXJ0RHVyYXRpb24nKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwob3JpZ1RhcmdldCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhY29yZS5lbGVtZW50Q2xvc2VzdChvcmlnVGFyZ2V0LCAnLmZjLXJlc2l6ZXInKTsgLy8gTk9UIG9uIGEgcmVzaXplclxyXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghaXNWYWxpZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIGRyYWdnaW5nIGZvciBlbGVtZW50cyB0aGF0IGFyZSByZXNpemFibGUgKGllLCBzZWxlY3RhYmxlKVxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IGFyZSBub3QgZHJhZ2dhYmxlXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gaXNWYWxpZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWRyYWdnYWJsZScpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsQ2FsZW5kYXIgPSBfdGhpcy5jb21wb25lbnQuY2FsZW5kYXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IF90aGlzLmV2ZW50UmFuZ2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUlkID0gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2LmlzVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHNlbGVjdCBhIGRpZmZlcmVudCBldmVudD9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZUlkICE9PSBfdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENhbGVuZGFyLmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9FVkVOVCcsIGV2ZW50SW5zdGFuY2VJZDogZXZlbnRJbnN0YW5jZUlkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdyB1c2luZyBtb3VzZSwgYnV0IHdhcyBwcmV2aW91cyB0b3VjaCBpbnRlcmFjdGlvbiwgY2xlYXIgc2VsZWN0ZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ2FsZW5kYXIuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfRVZFTlQnIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ2FsZW5kYXIudW5zZWxlY3QoZXYpOyAvLyB1bnNlbGVjdCAqZGF0ZSogc2VsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENhbGVuZGFyLnB1YmxpY2x5VHJpZ2dlcignZXZlbnREcmFnU3RhcnQnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBfdGhpcy5zdWJqZWN0U2VnLmVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBjb3JlLkV2ZW50QXBpKGluaXRpYWxDYWxlbmRhciwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogX3RoaXMuY29tcG9uZW50LnZpZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSBmdW5jdGlvbiAoaGl0LCBpc0ZpbmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVsZXZhbnRFdmVudHMgPSBfdGhpcy5yZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsSGl0ID0gX3RoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcclxuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsQ2FsZW5kYXIgPSBfdGhpcy5jb21wb25lbnQuY2FsZW5kYXI7XHJcbiAgICAgICAgICAgICAgICAvLyBzdGF0ZXMgYmFzZWQgb24gbmV3IGhpdFxyXG4gICAgICAgICAgICAgICAgdmFyIHJlY2VpdmluZ0NhbGVuZGFyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBpc0ludmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY29yZS5jcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcclxuICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdTZWc6IF90aGlzLnN1YmplY3RTZWdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoaGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY2VpdmluZ0NvbXBvbmVudCA9IGhpdC5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ2FsZW5kYXIgPSByZWNlaXZpbmdDb21wb25lbnQuY2FsZW5kYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWxDYWxlbmRhciA9PT0gcmVjZWl2aW5nQ2FsZW5kYXIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29tcG9uZW50Lm9wdCgnZWRpdGFibGUnKSAmJiByZWNlaXZpbmdDb21wb25lbnQub3B0KCdkcm9wcGFibGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IGNvbXB1dGVFdmVudE11dGF0aW9uKGluaXRpYWxIaXQsIGhpdCwgcmVjZWl2aW5nQ2FsZW5kYXIucGx1Z2luU3lzdGVtLmhvb2tzLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBjb3JlLmFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUocmVsZXZhbnRFdmVudHMsIHJlY2VpdmluZ0NhbGVuZGFyLmV2ZW50VWlCYXNlcywgbXV0YXRpb24sIHJlY2VpdmluZ0NhbGVuZGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpdmluZ0NvbXBvbmVudC5pc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gY29yZS5jcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ2FsZW5kYXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BsYXlEcmFnKHJlY2VpdmluZ0NhbGVuZGFyLCBpbnRlcmFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuZW5hYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ2FsZW5kYXIgPT09IHJlY2VpdmluZ0NhbGVuZGFyICYmIC8vIFRPRE86IHdyaXRlIHRlc3QgZm9yIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNIaXRzRXF1YWwoaW5pdGlhbEhpdCwgaGl0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nLnNldE1pcnJvck5lZWRzUmV2ZXJ0KCFtdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHNvbWVob3cgd2FpdCBmb3IgZGlzcGF0Y2ggdG8gZ3VhcmFudGVlIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nLnNldE1pcnJvcklzVmlzaWJsZSghaGl0IHx8ICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZmMtbWlycm9yJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBzdGF0ZXMgYmFzZWQgb24gbmV3IGhpdFxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlY2VpdmluZ0NhbGVuZGFyID0gcmVjZWl2aW5nQ2FsZW5kYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsaWRNdXRhdGlvbiA9IG11dGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlclVwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYW51cCgpOyAvLyBiZWNhdXNlIGhhbmRsZURyYWdFbmQgd29uJ3QgZmlyZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0aWFsQ2FsZW5kYXJfMSA9IF90aGlzLmNvbXBvbmVudC5jYWxlbmRhcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFZpZXcgPSBfdGhpcy5jb21wb25lbnQudmlldztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgcmVjZWl2aW5nQ2FsZW5kYXIgPSBfYS5yZWNlaXZpbmdDYWxlbmRhciwgdmFsaWRNdXRhdGlvbiA9IF9hLnZhbGlkTXV0YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50RGVmID0gX3RoaXMuZXZlbnRSYW5nZS5kZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2UgPSBfdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudEFwaSA9IG5ldyBjb3JlLkV2ZW50QXBpKGluaXRpYWxDYWxlbmRhcl8xLCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbGV2YW50RXZlbnRzXzEgPSBfdGhpcy5yZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbEhpdCA9IF90aGlzLmhpdERyYWdnaW5nLmZpbmFsSGl0O1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyRHJhZygpOyAvLyBtdXN0IGhhcHBlbiBhZnRlciByZXZlcnQgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENhbGVuZGFyXzEucHVibGljbHlUcmlnZ2VyKCdldmVudERyYWdTdG9wJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbDogX3RoaXMuc3ViamVjdFNlZy5lbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxWaWV3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIHdpdGhpbiBzYW1lIGNhbGVuZGFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZpbmdDYWxlbmRhciA9PT0gaW5pdGlhbENhbGVuZGFyXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDYWxlbmRhcl8xLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBtdXRhdGVkUmVsZXZhbnRFdmVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gaW5pdGlhbENhbGVuZGFyXzEucGx1Z2luU3lzdGVtLmhvb2tzLmV2ZW50RHJvcFRyYW5zZm9ybWVyczsgX2kgPCBfYi5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBfYltfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19hc3NpZ24odHJhbnNmb3JtZWQsIHRyYW5zZm9ybWVyKHZhbGlkTXV0YXRpb24sIGluaXRpYWxDYWxlbmRhcl8xKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnREcm9wQXJnID0gX19hc3NpZ24oe30sIHRyYW5zZm9ybWVkLCB7IGVsOiBldi5zdWJqZWN0RWwsIGRlbHRhOiB2YWxpZE11dGF0aW9uLmRhdGVzRGVsdGEsIG9sZEV2ZW50OiBldmVudEFwaSwgZXZlbnQ6IG5ldyBjb3JlLkV2ZW50QXBpKC8vIHRoZSBkYXRhIEFGVEVSIHRoZSBtdXRhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDYWxlbmRhcl8xLCBtdXRhdGVkUmVsZXZhbnRFdmVudHMuZGVmc1tldmVudERlZi5kZWZJZF0sIGV2ZW50SW5zdGFuY2UgPyBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF0gOiBudWxsKSwgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDYWxlbmRhcl8xLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHNfMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGluaXRpYWxWaWV3IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENhbGVuZGFyXzEucHVibGljbHlUcmlnZ2VyKCdldmVudERyb3AnLCBbZXZlbnREcm9wQXJnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIGluIGRpZmZlcmVudCBjYWxlbmRhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY2VpdmluZ0NhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ2FsZW5kYXJfMS5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50TGVhdmUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBpbml0aWFsVmlld1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENhbGVuZGFyXzEuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfSU5TVEFOQ0VTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IF90aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ2FsZW5kYXIuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IF90aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXYuaXNUb3VjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NhbGVuZGFyLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFTEVDVF9FVkVOVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VJZDogZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcEFyZyA9IF9fYXNzaWduKHt9LCByZWNlaXZpbmdDYWxlbmRhci5idWlsZERhdGVQb2ludEFwaShmaW5hbEhpdC5kYXRlU3BhbiksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogZmluYWxIaXQuY29tcG9uZW50IC8vIHNob3VsZCB0aGlzIGJlIGZpbmFsSGl0LmNvbXBvbmVudC52aWV3PyBTZWUgIzQ2NDRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NhbGVuZGFyLnB1YmxpY2x5VHJpZ2dlcignZHJvcCcsIFtkcm9wQXJnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDYWxlbmRhci5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnZWRFbDogZXYuc3ViamVjdEVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IGNvcmUuRXZlbnRBcGkoLy8gdGhlIGRhdGEgQUZURVIgdGhlIG11dGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NhbGVuZGFyLCBtdXRhdGVkUmVsZXZhbnRFdmVudHMuZGVmc1tldmVudERlZi5kZWZJZF0sIG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGZpbmFsSGl0LmNvbXBvbmVudCAvLyBzaG91bGQgdGhpcyBiZSBmaW5hbEhpdC5jb21wb25lbnQudmlldz8gU2VlICM0NjQ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDYWxlbmRhcl8xLnB1YmxpY2x5VHJpZ2dlcignX25vRXZlbnREcm9wJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYW51cCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuY29tcG9uZW50O1xyXG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmcgPSBfdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKGNvbXBvbmVudC5lbCk7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBFdmVudERyYWdnaW5nLlNFTEVDVE9SO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGNvbXBvbmVudC5vcHQoJ2RyYWdTY3JvbGwnKTtcclxuICAgICAgICAgICAgdmFyIGhpdERyYWdnaW5nID0gX3RoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcoX3RoaXMuZHJhZ2dpbmcsIGNvcmUuaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcudXNlU3ViamVjdENlbnRlciA9IHNldHRpbmdzLnVzZUV2ZW50Q2VudGVyO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIF90aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgX3RoaXMuaGFuZGxlSGl0VXBkYXRlKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgX3RoaXMuaGFuZGxlUG9pbnRlclVwKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIF90aGlzLmhhbmRsZURyYWdFbmQpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gcmVuZGVyIGEgZHJhZyBzdGF0ZSBvbiB0aGUgbmV4dCByZWNlaXZpbmdDYWxlbmRhclxyXG4gICAgICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmRpc3BsYXlEcmFnID0gZnVuY3Rpb24gKG5leHRDYWxlbmRhciwgc3RhdGUpIHtcclxuICAgICAgICAgICAgdmFyIGluaXRpYWxDYWxlbmRhciA9IHRoaXMuY29tcG9uZW50LmNhbGVuZGFyO1xyXG4gICAgICAgICAgICB2YXIgcHJldkNhbGVuZGFyID0gdGhpcy5yZWNlaXZpbmdDYWxlbmRhcjtcclxuICAgICAgICAgICAgLy8gZG9lcyB0aGUgcHJldmlvdXMgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xyXG4gICAgICAgICAgICBpZiAocHJldkNhbGVuZGFyICYmIHByZXZDYWxlbmRhciAhPT0gbmV4dENhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkb2VzIHRoZSBpbml0aWFsIGNhbGVuZGFyIG5lZWQgdG8gYmUgY2xlYXJlZD9cclxuICAgICAgICAgICAgICAgIC8vIGlmIHNvLCBkb24ndCBjbGVhciBhbGwgdGhlIHdheS4gd2Ugc3RpbGwgbmVlZCB0byB0byBoaWRlIHRoZSBhZmZlY3RlZEV2ZW50c1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZDYWxlbmRhciA9PT0gaW5pdGlhbENhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldkNhbGVuZGFyLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBzdGF0ZS5hZmZlY3RlZEV2ZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNvcmUuY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ1NlZzogc3RhdGUub3JpZ1NlZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGVseSBjbGVhciB0aGUgb2xkIGNhbGVuZGFyIGlmIGl0IHdhc24ndCB0aGUgaW5pdGlhbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldkNhbGVuZGFyLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXh0Q2FsZW5kYXIpIHtcclxuICAgICAgICAgICAgICAgIG5leHRDYWxlbmRhci5kaXNwYXRjaCh7IHR5cGU6ICdTRVRfRVZFTlRfRFJBRycsIHN0YXRlOiBzdGF0ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuY2xlYXJEcmFnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaW5pdGlhbENhbGVuZGFyID0gdGhpcy5jb21wb25lbnQuY2FsZW5kYXI7XHJcbiAgICAgICAgICAgIHZhciByZWNlaXZpbmdDYWxlbmRhciA9IHRoaXMucmVjZWl2aW5nQ2FsZW5kYXI7XHJcbiAgICAgICAgICAgIGlmIChyZWNlaXZpbmdDYWxlbmRhcikge1xyXG4gICAgICAgICAgICAgICAgcmVjZWl2aW5nQ2FsZW5kYXIuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhlIGluaXRpYWwgY2FsZW5kYXIgbWlnaHQgaGF2ZSBhbiBkdW1teSBkcmFnIHN0YXRlIGZyb20gZGlzcGxheURyYWdcclxuICAgICAgICAgICAgaWYgKGluaXRpYWxDYWxlbmRhciAhPT0gcmVjZWl2aW5nQ2FsZW5kYXIpIHtcclxuICAgICAgICAgICAgICAgIGluaXRpYWxDYWxlbmRhci5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0U2VnID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSYW5nZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NhbGVuZGFyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXZlbnREcmFnZ2luZy5TRUxFQ1RPUiA9ICcuZmMtZHJhZ2dhYmxlLCAuZmMtcmVzaXphYmxlJzsgLy8gVE9ETzogdGVzdCB0aGlzIGluIElFMTFcclxuICAgICAgICByZXR1cm4gRXZlbnREcmFnZ2luZztcclxuICAgIH0oY29yZS5JbnRlcmFjdGlvbikpO1xyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUV2ZW50TXV0YXRpb24oaGl0MCwgaGl0MSwgbWFzc2FnZXJzKSB7XHJcbiAgICAgICAgdmFyIGRhdGVTcGFuMCA9IGhpdDAuZGF0ZVNwYW47XHJcbiAgICAgICAgdmFyIGRhdGVTcGFuMSA9IGhpdDEuZGF0ZVNwYW47XHJcbiAgICAgICAgdmFyIGRhdGUwID0gZGF0ZVNwYW4wLnJhbmdlLnN0YXJ0O1xyXG4gICAgICAgIHZhciBkYXRlMSA9IGRhdGVTcGFuMS5yYW5nZS5zdGFydDtcclxuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHt9O1xyXG4gICAgICAgIGlmIChkYXRlU3BhbjAuYWxsRGF5ICE9PSBkYXRlU3BhbjEuYWxsRGF5KSB7XHJcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuYWxsRGF5ID0gZGF0ZVNwYW4xLmFsbERheTtcclxuICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBoaXQxLmNvbXBvbmVudC5vcHQoJ2FsbERheU1haW50YWluRHVyYXRpb24nKTtcclxuICAgICAgICAgICAgaWYgKGRhdGVTcGFuMS5hbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1lYW5zIGRhdGUxIGlzIGFscmVhZHkgc3RhcnQtb2YtZGF5LFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IGRhdGUwIG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxyXG4gICAgICAgICAgICAgICAgZGF0ZTAgPSBjb3JlLnN0YXJ0T2ZEYXkoZGF0ZTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkZWx0YSA9IGNvcmUuZGlmZkRhdGVzKGRhdGUwLCBkYXRlMSwgaGl0MC5jb21wb25lbnQuZGF0ZUVudiwgaGl0MC5jb21wb25lbnQgPT09IGhpdDEuY29tcG9uZW50ID9cclxuICAgICAgICAgICAgaGl0MC5jb21wb25lbnQubGFyZ2VVbml0IDpcclxuICAgICAgICAgICAgbnVsbCk7XHJcbiAgICAgICAgaWYgKGRlbHRhLm1pbGxpc2Vjb25kcykgeyAvLyBoYXMgaG91cnMvbWludXRlcy9zZWNvbmRzXHJcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuYWxsRGF5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtdXRhdGlvbiA9IHtcclxuICAgICAgICAgICAgZGF0ZXNEZWx0YTogZGVsdGEsXHJcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHM6IHN0YW5kYXJkUHJvcHNcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbWFzc2FnZXJzXzEgPSBtYXNzYWdlcnM7IF9pIDwgbWFzc2FnZXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXNzYWdlciA9IG1hc3NhZ2Vyc18xW19pXTtcclxuICAgICAgICAgICAgbWFzc2FnZXIobXV0YXRpb24sIGhpdDAsIGhpdDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbXV0YXRpb247XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRUb3VjaERlbGF5JDEoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIGRlbGF5ID0gY29tcG9uZW50Lm9wdCgnZXZlbnRMb25nUHJlc3NEZWxheScpO1xyXG4gICAgICAgIGlmIChkZWxheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gY29tcG9uZW50Lm9wdCgnbG9uZ1ByZXNzRGVsYXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbGF5O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBFdmVudERyYWdnaW5nJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEV2ZW50RHJhZ2dpbmcsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRXZlbnREcmFnZ2luZyhzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcclxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcclxuICAgICAgICAgICAgX3RoaXMuZHJhZ2dpbmdTZWcgPSBudWxsOyAvLyBUT0RPOiByZW5hbWUgdG8gcmVzaXppbmdTZWc/IHN1YmplY3RTZWc/XHJcbiAgICAgICAgICAgIF90aGlzLmV2ZW50UmFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLnZhbGlkTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIHZhciBzZWcgPSBfdGhpcy5xdWVyeVNlZyhldik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IF90aGlzLmV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nLm1pbkRpc3RhbmNlID0gY29tcG9uZW50Lm9wdCgnZXZlbnREcmFnTWluRGlzdGFuY2UnKTtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRvdWNoLCBuZWVkIHRvIGJlIHdvcmtpbmcgd2l0aCBhIHNlbGVjdGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFfdGhpcy5jb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi5vcmlnRXZlbnQudGFyZ2V0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChldi5pc1RvdWNoICYmIF90aGlzLmNvbXBvbmVudC5wcm9wcy5ldmVudFNlbGVjdGlvbiAhPT0gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gX3RoaXMuY29tcG9uZW50LmNhbGVuZGFyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBfdGhpcy5ldmVudFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucmVsZXZhbnRFdmVudHMgPSBjb3JlLmdldFJlbGV2YW50RXZlbnRzKGNhbGVuZGFyLnN0YXRlLmV2ZW50U3RvcmUsIF90aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZ1NlZyA9IF90aGlzLnF1ZXJ5U2VnKGV2KTtcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyLnVuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjYWxlbmRhci5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVzaXplU3RhcnQnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbDogX3RoaXMuZHJhZ2dpbmdTZWcuZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgY29yZS5FdmVudEFwaShjYWxlbmRhciwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IF90aGlzLmNvbXBvbmVudC52aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IGZ1bmN0aW9uIChoaXQsIGlzRmluYWwsIGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsZW5kYXIgPSBfdGhpcy5jb21wb25lbnQuY2FsZW5kYXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVsZXZhbnRFdmVudHMgPSBfdGhpcy5yZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsSGl0ID0gX3RoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudEluc3RhbmNlID0gX3RoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBpc0ludmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY29yZS5jcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcclxuICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdTZWc6IF90aGlzLmRyYWdnaW5nU2VnXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZU11dGF0aW9uKGluaXRpYWxIaXQsIGhpdCwgZXYuc3ViamVjdEVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtc3RhcnQtcmVzaXplcicpLCBldmVudEluc3RhbmNlLnJhbmdlLCBjYWxlbmRhci5wbHVnaW5TeXN0ZW0uaG9va3MuZXZlbnRSZXNpemVKb2luVHJhbnNmb3Jtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBjb3JlLmFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUocmVsZXZhbnRFdmVudHMsIGNhbGVuZGFyLmV2ZW50VWlCYXNlcywgbXV0YXRpb24sIGNhbGVuZGFyKTtcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuY29tcG9uZW50LmlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobXV0YXRlZFJlbGV2YW50RXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXIuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX0VWRU5UX1JFU0laRScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBpbnRlcmFjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXIuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfUkVTSVpFJyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNJbnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29yZS5lbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uICYmIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbXV0YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsZW5kYXIgPSBfdGhpcy5jb21wb25lbnQuY2FsZW5kYXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IF90aGlzLmNvbXBvbmVudC52aWV3O1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50RGVmID0gX3RoaXMuZXZlbnRSYW5nZS5kZWY7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IF90aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRBcGkgPSBuZXcgY29yZS5FdmVudEFwaShjYWxlbmRhciwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbGV2YW50RXZlbnRzID0gX3RoaXMucmVsZXZhbnRFdmVudHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXIucHVibGljbHlUcmlnZ2VyKCdldmVudFJlc2l6ZVN0b3AnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbDogX3RoaXMuZHJhZ2dpbmdTZWcuZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiB2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudmFsaWRNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRSZXNpemUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBfdGhpcy5kcmFnZ2luZ1NlZy5lbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGVsdGE6IF90aGlzLnZhbGlkTXV0YXRpb24uc3RhcnREZWx0YSB8fCBjb3JlLmNyZWF0ZUR1cmF0aW9uKDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGVsdGE6IF90aGlzLnZhbGlkTXV0YXRpb24uZW5kRGVsdGEgfHwgY29yZS5jcmVhdGVEdXJhdGlvbigwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZFdmVudDogZXZlbnRBcGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IGNvcmUuRXZlbnRBcGkoLy8gdGhlIGRhdGEgQUZURVIgdGhlIG11dGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhciwgbXV0YXRlZFJlbGV2YW50RXZlbnRzLmRlZnNbZXZlbnREZWYuZGVmSWRdLCBldmVudEluc3RhbmNlID8gbXV0YXRlZFJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tldmVudEluc3RhbmNlLmluc3RhbmNlSWRdIDogbnVsbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhci5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXIucHVibGljbHlUcmlnZ2VyKCdfbm9FdmVudFJlc2l6ZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZ1NlZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vIG9rYXkgdG8ga2VlcCBldmVudEluc3RhbmNlIGFyb3VuZC4gdXNlZnVsIHRvIHNldCBpdCBpbiBoYW5kbGVQb2ludGVyRG93blxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xyXG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmcgPSBfdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKGNvbXBvbmVudC5lbCk7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSAnLmZjLXJlc2l6ZXInO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGNvbXBvbmVudC5vcHQoJ2RyYWdTY3JvbGwnKTtcclxuICAgICAgICAgICAgdmFyIGhpdERyYWdnaW5nID0gX3RoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcoX3RoaXMuZHJhZ2dpbmcsIGNvcmUuaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIF90aGlzLmhhbmRsZURyYWdTdGFydCk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIF90aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCBfdGhpcy5oYW5kbGVEcmFnRW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLnF1ZXJ5U2VnID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb3JlLmdldEVsU2VnKGNvcmUuZWxlbWVudENsb3Nlc3QoZXYuc3ViamVjdEVsLCB0aGlzLmNvbXBvbmVudC5mZ1NlZ1NlbGVjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRXZlbnREcmFnZ2luZztcclxuICAgIH0oY29yZS5JbnRlcmFjdGlvbikpO1xyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU11dGF0aW9uKGhpdDAsIGhpdDEsIGlzRnJvbVN0YXJ0LCBpbnN0YW5jZVJhbmdlLCB0cmFuc2Zvcm1zKSB7XHJcbiAgICAgICAgdmFyIGRhdGVFbnYgPSBoaXQwLmNvbXBvbmVudC5kYXRlRW52O1xyXG4gICAgICAgIHZhciBkYXRlMCA9IGhpdDAuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgdmFyIGRhdGUxID0gaGl0MS5kYXRlU3Bhbi5yYW5nZS5zdGFydDtcclxuICAgICAgICB2YXIgZGVsdGEgPSBjb3JlLmRpZmZEYXRlcyhkYXRlMCwgZGF0ZTEsIGRhdGVFbnYsIGhpdDAuY29tcG9uZW50LmxhcmdlVW5pdCk7XHJcbiAgICAgICAgdmFyIHByb3BzID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB0cmFuc2Zvcm1zXzEgPSB0cmFuc2Zvcm1zOyBfaSA8IHRyYW5zZm9ybXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNfMVtfaV07XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0cmFuc2Zvcm0oaGl0MCwgaGl0MSk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgICAgIF9fYXNzaWduKHByb3BzLCByZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Zyb21TdGFydCkge1xyXG4gICAgICAgICAgICBpZiAoZGF0ZUVudi5hZGQoaW5zdGFuY2VSYW5nZS5zdGFydCwgZGVsdGEpIDwgaW5zdGFuY2VSYW5nZS5lbmQpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLnN0YXJ0RGVsdGEgPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGRhdGVFbnYuYWRkKGluc3RhbmNlUmFuZ2UuZW5kLCBkZWx0YSkgPiBpbnN0YW5jZVJhbmdlLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5lbmREZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBVbnNlbGVjdEF1dG8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gVW5zZWxlY3RBdXRvKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IGZhbHNlOyAvLyB3aXNoIHdlIGNvdWxkIHVzZSBhIHNlbGVjdG9yIHRvIGRldGVjdCBkYXRlIHNlbGVjdGlvbiwgYnV0IHVzZXMgaGl0IHN5c3RlbVxyXG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdEluZm8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RJbmZvLmpzRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwID0gZnVuY3Rpb24gKHBldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIGNhbGVuZGFyID0gX2EuY2FsZW5kYXIsIGRvY3VtZW50UG9pbnRlciA9IF9hLmRvY3VtZW50UG9pbnRlcjtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGNhbGVuZGFyLnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgLy8gdG91Y2gtc2Nyb2xsaW5nIHNob3VsZCBuZXZlciB1bmZvY3VzIGFueSB0eXBlIG9mIHNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudFBvaW50ZXIud2FzVG91Y2hTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZGF0ZVNlbGVjdGlvbiAmJiAvLyBhbiBleGlzdGluZyBkYXRlIHNlbGVjdGlvbj9cclxuICAgICAgICAgICAgICAgICAgICAgICAgIV90aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgLy8gYSBuZXcgcG9pbnRlci1pbml0aWF0ZWQgZGF0ZSBzZWxlY3Rpb24gc2luY2UgbGFzdCBvbkRvY3VtZW50UG9pbnRlclVwP1xyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5zZWxlY3RBdXRvID0gY2FsZW5kYXIudmlld09wdCgndW5zZWxlY3RBdXRvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bnNlbGVjdENhbmNlbCA9IGNhbGVuZGFyLnZpZXdPcHQoJ3Vuc2VsZWN0Q2FuY2VsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bnNlbGVjdEF1dG8gJiYgKCF1bnNlbGVjdEF1dG8gfHwgIWNvcmUuZWxlbWVudENsb3Nlc3QoZG9jdW1lbnRQb2ludGVyLmRvd25FbCwgdW5zZWxlY3RDYW5jZWwpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXIudW5zZWxlY3QocGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZXZlbnRTZWxlY3Rpb24gJiYgLy8gYW4gZXhpc3RpbmcgZXZlbnQgc2VsZWN0ZWQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFjb3JlLmVsZW1lbnRDbG9zZXN0KGRvY3VtZW50UG9pbnRlci5kb3duRWwsIEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1IpIC8vIGludGVyYWN0aW9uIERJRE4nVCBzdGFydCBvbiBhbiBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhci5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9FVkVOVCcgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICAgICAgICAgIHZhciBkb2N1bWVudFBvaW50ZXIgPSB0aGlzLmRvY3VtZW50UG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICBkb2N1bWVudFBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGRvY3VtZW50UG9pbnRlci5zaG91bGRXYXRjaFNjcm9sbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkb2N1bWVudFBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwKTtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgVE9ETzogYmV0dGVyIHdheSB0byBrbm93IGFib3V0IHdoZXRoZXIgdGhlcmUgd2FzIGEgc2VsZWN0aW9uIHdpdGggdGhlIHBvaW50ZXJcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2FsZW5kYXIub24oJ3NlbGVjdCcsIHRoaXMub25TZWxlY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBVbnNlbGVjdEF1dG8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIub2ZmKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KTtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFVuc2VsZWN0QXV0bztcclxuICAgIH0oKSk7XHJcblxyXG4gICAgLypcclxuICAgIEdpdmVuIGFuIGFscmVhZHkgaW5zdGFudGlhdGVkIGRyYWdnYWJsZSBvYmplY3QgZm9yIG9uZS1vci1tb3JlIGVsZW1lbnRzLFxyXG4gICAgSW50ZXJwcmV0cyBhbnkgZHJhZ2dpbmcgYXMgYW4gYXR0ZW1wdCB0byBkcmFnIGFuIGV2ZW50cyB0aGF0IGxpdmVzIG91dHNpZGVcclxuICAgIG9mIGEgY2FsZW5kYXIgb250byBhIGNhbGVuZGFyLlxyXG4gICAgKi9cclxuICAgIHZhciBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyhkcmFnZ2luZywgc3VwcGxpZWREcmFnTWV0YSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NhbGVuZGFyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5kcm9wcGFibGVFdmVudCA9IG51bGw7IC8vIHdpbGwgZXhpc3QgZm9yIGFsbCBkcmFncywgZXZlbiBpZiBjcmVhdGU6ZmFsc2VcclxuICAgICAgICAgICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5kcmFnTWV0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTWV0YSA9IF90aGlzLmJ1aWxkRHJhZ01ldGEoZXYuc3ViamVjdEVsKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSBmdW5jdGlvbiAoaGl0LCBpc0ZpbmFsLCBldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuaGl0RHJhZ2dpbmcuZHJhZ2dpbmc7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjZWl2aW5nQ2FsZW5kYXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBpc0ludmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogY29yZS5jcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjb3JlLmNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IF90aGlzLmRyYWdNZXRhLmNyZWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBvcmlnU2VnOiBudWxsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NhbGVuZGFyID0gaGl0LmNvbXBvbmVudC5jYWxlbmRhcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2FuRHJvcEVsT25DYWxlbmRhcihldi5zdWJqZWN0RWwsIHJlY2VpdmluZ0NhbGVuZGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wcGFibGVFdmVudCA9IGNvbXB1dGVFdmVudEZvckRhdGVTcGFuKGhpdC5kYXRlU3BhbiwgX3RoaXMuZHJhZ01ldGEsIHJlY2VpdmluZ0NhbGVuZGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IGNvcmUuZXZlbnRUdXBsZVRvU3RvcmUoZHJvcHBhYmxlRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSAhY29yZS5pc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIHJlY2VpdmluZ0NhbGVuZGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IGNvcmUuY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wcGFibGVFdmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNwbGF5RHJhZyhyZWNlaXZpbmdDYWxlbmRhciwgaW50ZXJhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgLy8gc2hvdyBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3IgZWxlbWVudCBPUiBpZiB3ZSBhcmUgc2h1dHRpbmcgZG93biB0aGUgbWlycm9yICg/KVxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCBzb21laG93IHdhaXQgZm9yIGRpc3BhdGNoIHRvIGd1YXJhbnRlZSByZW5kZXJcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldE1pcnJvcklzVmlzaWJsZShpc0ZpbmFsIHx8ICFkcm9wcGFibGVFdmVudCB8fCAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZjLW1pcnJvcicpKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNJbnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29yZS5lbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0TWlycm9yTmVlZHNSZXZlcnQoIWRyb3BwYWJsZUV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWNlaXZpbmdDYWxlbmRhciA9IHJlY2VpdmluZ0NhbGVuZGFyO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRyb3BwYWJsZUV2ZW50ID0gZHJvcHBhYmxlRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IGZ1bmN0aW9uIChwZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLCByZWNlaXZpbmdDYWxlbmRhciA9IF9hLnJlY2VpdmluZ0NhbGVuZGFyLCBkcm9wcGFibGVFdmVudCA9IF9hLmRyb3BwYWJsZUV2ZW50O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJEcmFnKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2aW5nQ2FsZW5kYXIgJiYgZHJvcHBhYmxlRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxIaXQgPSBfdGhpcy5oaXREcmFnZ2luZy5maW5hbEhpdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxWaWV3ID0gZmluYWxIaXQuY29tcG9uZW50LnZpZXc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdNZXRhID0gX3RoaXMuZHJhZ01ldGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IF9fYXNzaWduKHt9LCByZWNlaXZpbmdDYWxlbmRhci5idWlsZERhdGVQb2ludEFwaShmaW5hbEhpdC5kYXRlU3BhbiksIHsgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLCBqc0V2ZW50OiBwZXYub3JpZ0V2ZW50LCB2aWV3OiBmaW5hbFZpZXcgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ2FsZW5kYXIucHVibGljbHlUcmlnZ2VyKCdkcm9wJywgW2FyZ10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnTWV0YS5jcmVhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ2FsZW5kYXIuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBjb3JlLmV2ZW50VHVwbGVUb1N0b3JlKGRyb3BwYWJsZUV2ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBldi5pc1RvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDYWxlbmRhci5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFTEVDVF9FVkVOVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUlkOiBkcm9wcGFibGVFdmVudC5pbnN0YW5jZS5pbnN0YW5jZUlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaWduYWwgdGhhdCBhbiBleHRlcm5hbCBldmVudCBsYW5kZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ2FsZW5kYXIucHVibGljbHlUcmlnZ2VyKCdldmVudFJlY2VpdmUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgY29yZS5FdmVudEFwaShyZWNlaXZpbmdDYWxlbmRhciwgZHJvcHBhYmxlRXZlbnQuZGVmLCBkcm9wcGFibGVFdmVudC5pbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogZmluYWxWaWV3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLnJlY2VpdmluZ0NhbGVuZGFyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhkcmFnZ2luZywgY29yZS5pbnRlcmFjdGlvblNldHRpbmdzU3RvcmUpO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5yZXF1aXJlSW5pdGlhbCA9IGZhbHNlOyAvLyB3aWxsIHN0YXJ0IG91dHNpZGUgb2YgYSBjb21wb25lbnRcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xyXG4gICAgICAgICAgICB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPSBzdXBwbGllZERyYWdNZXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuYnVpbGREcmFnTWV0YSA9IGZ1bmN0aW9uIChzdWJqZWN0RWwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5wYXJzZURyYWdNZXRhKHRoaXMuc3VwcGxpZWREcmFnTWV0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUucGFyc2VEcmFnTWV0YSh0aGlzLnN1cHBsaWVkRHJhZ01ldGEoc3ViamVjdEVsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RHJhZ01ldGFGcm9tRWwoc3ViamVjdEVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmRpc3BsYXlEcmFnID0gZnVuY3Rpb24gKG5leHRDYWxlbmRhciwgc3RhdGUpIHtcclxuICAgICAgICAgICAgdmFyIHByZXZDYWxlbmRhciA9IHRoaXMucmVjZWl2aW5nQ2FsZW5kYXI7XHJcbiAgICAgICAgICAgIGlmIChwcmV2Q2FsZW5kYXIgJiYgcHJldkNhbGVuZGFyICE9PSBuZXh0Q2FsZW5kYXIpIHtcclxuICAgICAgICAgICAgICAgIHByZXZDYWxlbmRhci5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV4dENhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0Q2FsZW5kYXIuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZTogc3RhdGUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEV4dGVybmFsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5jbGVhckRyYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY2VpdmluZ0NhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NhbGVuZGFyLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuY2FuRHJvcEVsT25DYWxlbmRhciA9IGZ1bmN0aW9uIChlbCwgcmVjZWl2aW5nQ2FsZW5kYXIpIHtcclxuICAgICAgICAgICAgdmFyIGRyb3BBY2NlcHQgPSByZWNlaXZpbmdDYWxlbmRhci5vcHQoJ2Ryb3BBY2NlcHQnKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkcm9wQWNjZXB0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJvcEFjY2VwdChlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRyb3BBY2NlcHQgPT09ICdzdHJpbmcnICYmIGRyb3BBY2NlcHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGNvcmUuZWxlbWVudE1hdGNoZXMoZWwsIGRyb3BBY2NlcHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZztcclxuICAgIH0oKSk7XHJcbiAgICAvLyBVdGlscyBmb3IgY29tcHV0aW5nIGV2ZW50IHN0b3JlIGZyb20gdGhlIERyYWdNZXRhXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRXZlbnRGb3JEYXRlU3BhbihkYXRlU3BhbiwgZHJhZ01ldGEsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIGRlZlByb3BzID0gX19hc3NpZ24oe30sIGRyYWdNZXRhLmxlZnRvdmVyUHJvcHMpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjYWxlbmRhci5wbHVnaW5TeXN0ZW0uaG9va3MuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBfX2Fzc2lnbihkZWZQcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBkcmFnTWV0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVmID0gY29yZS5wYXJzZUV2ZW50RGVmKGRlZlByb3BzLCBkcmFnTWV0YS5zb3VyY2VJZCwgZGF0ZVNwYW4uYWxsRGF5LCBjYWxlbmRhci5vcHQoJ2ZvcmNlRXZlbnREdXJhdGlvbicpIHx8IEJvb2xlYW4oZHJhZ01ldGEuZHVyYXRpb24pLCAvLyBoYXNFbmRcclxuICAgICAgICBjYWxlbmRhcik7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgLy8gb25seSByZWx5IG9uIHRpbWUgaW5mbyBpZiBkcm9wIHpvbmUgaXMgYWxsLWRheSxcclxuICAgICAgICAvLyBvdGhlcndpc2UsIHdlIGFscmVhZHkga25vdyB0aGUgdGltZVxyXG4gICAgICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkgJiYgZHJhZ01ldGEuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gY2FsZW5kYXIuZGF0ZUVudi5hZGQoc3RhcnQsIGRyYWdNZXRhLnN0YXJ0VGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbmQgPSBkcmFnTWV0YS5kdXJhdGlvbiA/XHJcbiAgICAgICAgICAgIGNhbGVuZGFyLmRhdGVFbnYuYWRkKHN0YXJ0LCBkcmFnTWV0YS5kdXJhdGlvbikgOlxyXG4gICAgICAgICAgICBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoZGF0ZVNwYW4uYWxsRGF5LCBzdGFydCk7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY29yZS5jcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgeyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH0pO1xyXG4gICAgICAgIHJldHVybiB7IGRlZjogZGVmLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcclxuICAgIH1cclxuICAgIC8vIFV0aWxzIGZvciBleHRyYWN0aW5nIGRhdGEgZnJvbSBlbGVtZW50XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBnZXREcmFnTWV0YUZyb21FbChlbCkge1xyXG4gICAgICAgIHZhciBzdHIgPSBnZXRFbWJlZGRlZEVsRGF0YShlbCwgJ2V2ZW50Jyk7XHJcbiAgICAgICAgdmFyIG9iaiA9IHN0ciA/XHJcbiAgICAgICAgICAgIEpTT04ucGFyc2Uoc3RyKSA6XHJcbiAgICAgICAgICAgIHsgY3JlYXRlOiBmYWxzZSB9OyAvLyBpZiBubyBlbWJlZGRlZCBkYXRhLCBhc3N1bWUgbm8gZXZlbnQgY3JlYXRpb25cclxuICAgICAgICByZXR1cm4gY29yZS5wYXJzZURyYWdNZXRhKG9iaik7XHJcbiAgICB9XHJcbiAgICBjb3JlLmNvbmZpZy5kYXRhQXR0clByZWZpeCA9ICcnO1xyXG4gICAgZnVuY3Rpb24gZ2V0RW1iZWRkZWRFbERhdGEoZWwsIG5hbWUpIHtcclxuICAgICAgICB2YXIgcHJlZml4ID0gY29yZS5jb25maWcuZGF0YUF0dHJQcmVmaXg7XHJcbiAgICAgICAgdmFyIHByZWZpeGVkTmFtZSA9IChwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJykgKyBuYW1lO1xyXG4gICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIHByZWZpeGVkTmFtZSkgfHwgJyc7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIE1ha2VzIGFuIGVsZW1lbnQgKHRoYXQgaXMgKmV4dGVybmFsKiB0byBhbnkgY2FsZW5kYXIpIGRyYWdnYWJsZS5cclxuICAgIENhbiBwYXNzIGluIGRhdGEgdGhhdCBkZXRlcm1pbmVzIGhvdyBhbiBldmVudCB3aWxsIGJlIGNyZWF0ZWQgd2hlbiBkcm9wcGVkIG9udG8gYSBjYWxlbmRhci5cclxuICAgIExldmVyYWdlcyBGdWxsQ2FsZW5kYXIncyBpbnRlcm5hbCBkcmFnLW4tZHJvcCBmdW5jdGlvbmFsaXR5IFdJVEhPVVQgYSB0aGlyZC1wYXJ0eSBkcmFnIHN5c3RlbS5cclxuICAgICovXHJcbiAgICB2YXIgRXh0ZXJuYWxEcmFnZ2FibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRXh0ZXJuYWxEcmFnZ2FibGUoZWwsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncyA9PT0gdm9pZCAwKSB7IHNldHRpbmdzID0ge307IH1cclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuZHJhZ2dpbmc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zZXR0aW5ncywgbWluRGlzdGFuY2UgPSBfYS5taW5EaXN0YW5jZSwgbG9uZ1ByZXNzRGVsYXkgPSBfYS5sb25nUHJlc3NEZWxheTtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLm1pbkRpc3RhbmNlID1cclxuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSAhPSBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXYuaXNUb3VjaCA/IDAgOiBjb3JlLmdsb2JhbERlZmF1bHRzLmV2ZW50RHJhZ01pbkRpc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID1cclxuICAgICAgICAgICAgICAgICAgICBldi5pc1RvdWNoID8gLy8gVE9ETzogZXZlbnR1YWxseSByZWFkIGV2ZW50TG9uZ1ByZXNzRGVsYXkgaW5zdGVhZCB2dnZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvbmdQcmVzc0RlbGF5ICE9IG51bGwgPyBsb25nUHJlc3NEZWxheSA6IGNvcmUuZ2xvYmFsRGVmYXVsdHMubG9uZ1ByZXNzRGVsYXkpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldi5pc1RvdWNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZHJhZ2dpbmcuZGVsYXkgJiZcclxuICAgICAgICAgICAgICAgICAgICBldi5zdWJqZWN0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZHJhZ2dpbmcubWlycm9yLmdldE1pcnJvckVsKCkuY2xhc3NMaXN0LmFkZCgnZmMtc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoZWwpO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLml0ZW1TZWxlY3RvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gc2V0dGluZ3MuaXRlbVNlbGVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hcHBlbmRUbyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5taXJyb3IucGFyZW50Tm9kZSA9IHNldHRpbmdzLmFwcGVuZFRvOyAvLyBUT0RPOiB3cml0ZSB0ZXN0c1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcclxuICAgICAgICAgICAgbmV3IEV4dGVybmFsRWxlbWVudERyYWdnaW5nKGRyYWdnaW5nLCBzZXR0aW5ncy5ldmVudERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFeHRlcm5hbERyYWdnYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRXh0ZXJuYWxEcmFnZ2FibGU7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIC8qXHJcbiAgICBEZXRlY3RzIHdoZW4gYSAqVEhJUkQtUEFSVFkqIGRyYWctbi1kcm9wIHN5c3RlbSBpbnRlcmFjdHMgd2l0aCBlbGVtZW50cy5cclxuICAgIFRoZSB0aGlyZC1wYXJ0eSBzeXN0ZW0gaXMgcmVzcG9uc2libGUgZm9yIGRyYXdpbmcgdGhlIHZpc3VhbHMgZWZmZWN0cyBvZiB0aGUgZHJhZy5cclxuICAgIFRoaXMgY2xhc3Mgc2ltcGx5IG1vbml0b3JzIGZvciBwb2ludGVyIG1vdmVtZW50cyBhbmQgZmlyZXMgZXZlbnRzLlxyXG4gICAgSXQgYWxzbyBoYXMgdGhlIGFiaWxpdHkgdG8gaGlkZSB0aGUgbW92aW5nIGVsZW1lbnQgKHRoZSBcIm1pcnJvclwiKSBkdXJpbmcgdGhlIGRyYWcuXHJcbiAgICAqL1xyXG4gICAgdmFyIEluZmVycmVkRWxlbWVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhJbmZlcnJlZEVsZW1lbnREcmFnZ2luZywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyhjb250YWluZXJFbCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250YWluZXJFbCkgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5taXJyb3JTZWxlY3RvciA9ICcnO1xyXG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50TWlycm9yRWwgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcclxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgZHJhZ3N0YXJ0IHJpZ2h0IGF3YXkuIGRvZXMgbm90IHN1cHBvcnQgZGVsYXkgb3IgbWluLWRpc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSBkcmFnZW5kIHJpZ2h0IGF3YXkuIGRvZXMgbm90IHN1cHBvcnQgYSByZXZlcnQgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRlciA9IF90aGlzLnBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGNvbnRhaW5lckVsKTtcclxuICAgICAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIF90aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVybW92ZScsIF90aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKTtcclxuICAgICAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCBfdGhpcy5oYW5kbGVQb2ludGVyVXApO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEluZmVycmVkRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldElnbm9yZU1vdmUgPSBmdW5jdGlvbiAoYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBib29sO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvcklzVmlzaWJsZSA9IGZ1bmN0aW9uIChib29sKSB7XHJcbiAgICAgICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGEgcHJldmlvdXNseSBoaWRkZW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgcmVmZXJlbmNlIGluIGNhc2UgdGhlIHNlbGVjdG9yIGNsYXNzIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNaXJyb3JFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWlycm9yRWwgPSB0aGlzLm1pcnJvclNlbGVjdG9yID9cclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMubWlycm9yU2VsZWN0b3IpIDpcclxuICAgICAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pcnJvckVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwgPSBtaXJyb3JFbDtcclxuICAgICAgICAgICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZztcclxuICAgIH0oY29yZS5FbGVtZW50RHJhZ2dpbmcpKTtcclxuXHJcbiAgICAvKlxyXG4gICAgQnJpZGdlcyB0aGlyZC1wYXJ0eSBkcmFnLW4tZHJvcCBzeXN0ZW1zIHdpdGggRnVsbENhbGVuZGFyLlxyXG4gICAgTXVzdCBiZSBpbnN0YW50aWF0ZWQgYW5kIGRlc3Ryb3llZCBieSBjYWxsZXIuXHJcbiAgICAqL1xyXG4gICAgdmFyIFRoaXJkUGFydHlEcmFnZ2FibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gVGhpcmRQYXJ0eURyYWdnYWJsZShjb250YWluZXJPclNldHRpbmdzLCBzZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyRWwgPSBkb2N1bWVudDtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAvLyB3aXNoIHdlIGNvdWxkIGp1c3QgdGVzdCBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0LCBidXQgZG9lc24ndCB3b3JrIGluIElFMTFcclxuICAgICAgICAgICAgY29udGFpbmVyT3JTZXR0aW5ncyA9PT0gZG9jdW1lbnQgfHxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lck9yU2V0dGluZ3MgaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbCA9IGNvbnRhaW5lck9yU2V0dGluZ3M7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAoY29udGFpbmVyT3JTZXR0aW5ncyB8fCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyhjb250YWluZXJFbCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuaXRlbVNlbGVjdG9yID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IHNldHRpbmdzLml0ZW1TZWxlY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb250YWluZXJFbCA9PT0gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSAnW2RhdGEtZXZlbnRdJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLm1pcnJvclNlbGVjdG9yID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcubWlycm9yU2VsZWN0b3IgPSBzZXR0aW5ncy5taXJyb3JTZWxlY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXcgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHNldHRpbmdzLmV2ZW50RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFRoaXJkUGFydHlEcmFnZ2FibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRoaXJkUGFydHlEcmFnZ2FibGU7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIHZhciBtYWluID0gY29yZS5jcmVhdGVQbHVnaW4oe1xyXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW0RhdGVDbGlja2luZywgRGF0ZVNlbGVjdGluZywgRXZlbnREcmFnZ2luZywgRXZlbnREcmFnZ2luZyQxXSxcclxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogW1Vuc2VsZWN0QXV0b10sXHJcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZ1xyXG4gICAgfSk7XHJcblxyXG4gICAgZXhwb3J0cy5EcmFnZ2FibGUgPSBFeHRlcm5hbERyYWdnYWJsZTtcclxuICAgIGV4cG9ydHMuRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyA9IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmc7XHJcbiAgICBleHBvcnRzLlBvaW50ZXJEcmFnZ2luZyA9IFBvaW50ZXJEcmFnZ2luZztcclxuICAgIGV4cG9ydHMuVGhpcmRQYXJ0eURyYWdnYWJsZSA9IFRoaXJkUGFydHlEcmFnZ2FibGU7XHJcbiAgICBleHBvcnRzLmRlZmF1bHQgPSBtYWluO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG59KSk7XHJcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiIsIi8qIVxyXG5GdWxsQ2FsZW5kYXIgTGlzdCBWaWV3IFBsdWdpbiB2NC4zLjBcclxuRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xyXG4oYykgMjAxOSBBZGFtIFNoYXdcclxuKi9cclxuXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0BmdWxsY2FsZW5kYXIvY29yZScpKSA6XHJcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0BmdWxsY2FsZW5kYXIvY29yZSddLCBmYWN0b3J5KSA6XHJcbiAgICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLkZ1bGxDYWxlbmRhckxpc3QgPSB7fSwgZ2xvYmFsLkZ1bGxDYWxlbmRhcikpO1xyXG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBjb3JlKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbiAgICB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG4gICAgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiAgICBUSElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAgICBLSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbiAgICBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG4gICAgTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcbiAgICBTZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuICAgIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbiAgICAvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgTGlzdEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKExpc3RFdmVudFJlbmRlcmVyLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIExpc3RFdmVudFJlbmRlcmVyKGxpc3RWaWV3KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxpc3RWaWV3LmNvbnRleHQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmxpc3RWaWV3ID0gbGlzdFZpZXc7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgTGlzdEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaFNlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgICAgICBpZiAoIXNlZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RWaWV3LnJlbmRlckVtcHR5TWVzc2FnZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Vmlldy5yZW5kZXJTZWdMaXN0KHNlZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBMaXN0RXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZGV0YWNoU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgYSBzaW5nbGUgZXZlbnQgcm93XHJcbiAgICAgICAgTGlzdEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dCwgdmlldyA9IF9hLnZpZXcsIHRoZW1lID0gX2EudGhlbWU7XHJcbiAgICAgICAgICAgIHZhciBldmVudFJhbmdlID0gc2VnLmV2ZW50UmFuZ2U7XHJcbiAgICAgICAgICAgIHZhciBldmVudERlZiA9IGV2ZW50UmFuZ2UuZGVmO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2U7XHJcbiAgICAgICAgICAgIHZhciBldmVudFVpID0gZXZlbnRSYW5nZS51aTtcclxuICAgICAgICAgICAgdmFyIHVybCA9IGV2ZW50RGVmLnVybDtcclxuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbJ2ZjLWxpc3QtaXRlbSddLmNvbmNhdChldmVudFVpLmNsYXNzTmFtZXMpO1xyXG4gICAgICAgICAgICB2YXIgYmdDb2xvciA9IGV2ZW50VWkuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICB2YXIgdGltZUh0bWw7XHJcbiAgICAgICAgICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIHRpbWVIdG1sID0gY29yZS5nZXRBbGxEYXlIdG1sKHZpZXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvcmUuaXNNdWx0aURheVJhbmdlKGV2ZW50UmFuZ2UucmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmlzU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lSHRtbCA9IGNvcmUuaHRtbEVzY2FwZSh0aGlzLl9nZXRUaW1lVGV4dChldmVudEluc3RhbmNlLnJhbmdlLnN0YXJ0LCBzZWcuZW5kLCBmYWxzZSAvLyBhbGxEYXlcclxuICAgICAgICAgICAgICAgICAgICApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZy5pc0VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVIdG1sID0gY29yZS5odG1sRXNjYXBlKHRoaXMuX2dldFRpbWVUZXh0KHNlZy5zdGFydCwgZXZlbnRJbnN0YW5jZS5yYW5nZS5lbmQsIGZhbHNlIC8vIGFsbERheVxyXG4gICAgICAgICAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIGlubmVyIHNlZ21lbnQgdGhhdCBsYXN0cyB0aGUgd2hvbGUgZGF5XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZUh0bWwgPSBjb3JlLmdldEFsbERheUh0bWwodmlldyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBub3JtYWwgdGltZSB0ZXh0IGZvciB0aGUgKmV2ZW50J3MqIHRpbWVzXHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCA9IGNvcmUuaHRtbEVzY2FwZSh0aGlzLmdldFRpbWVUZXh0KGV2ZW50UmFuZ2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXJsKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWhhcy11cmwnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJzx0ciBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICh0aGlzLmRpc3BsYXlFdmVudFRpbWUgP1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1saXN0LWl0ZW0tdGltZSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRpbWVIdG1sIHx8ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L3RkPicgOlxyXG4gICAgICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtbGlzdC1pdGVtLW1hcmtlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLWV2ZW50LWRvdFwiJyArXHJcbiAgICAgICAgICAgICAgICAoYmdDb2xvciA/XHJcbiAgICAgICAgICAgICAgICAgICAgJyBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGJnQ29sb3IgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAgICAgJz48L3NwYW4+JyArXHJcbiAgICAgICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1saXN0LWl0ZW0tdGl0bGUgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICAnPGEnICsgKHVybCA/ICcgaHJlZj1cIicgKyBjb3JlLmh0bWxFc2NhcGUodXJsKSArICdcIicgOiAnJykgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgY29yZS5odG1sRXNjYXBlKGV2ZW50RGVmLnRpdGxlIHx8ICcnKSArXHJcbiAgICAgICAgICAgICAgICAnPC9hPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gbGlrZSBcIjQ6MDBhbVwiXHJcbiAgICAgICAgTGlzdEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBob3VyOiAnbnVtZXJpYycsXHJcbiAgICAgICAgICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcclxuICAgICAgICAgICAgICAgIG1lcmlkaWVtOiAnc2hvcnQnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTGlzdEV2ZW50UmVuZGVyZXI7XHJcbiAgICB9KGNvcmUuRmdFdmVudFJlbmRlcmVyKSk7XHJcblxyXG4gICAgLypcclxuICAgIFJlc3BvbnNpYmxlIGZvciB0aGUgc2Nyb2xsZXIsIGFuZCBmb3J3YXJkaW5nIGV2ZW50LXJlbGF0ZWQgYWN0aW9ucyBpbnRvIHRoZSBcImdyaWRcIi5cclxuICAgICovXHJcbiAgICB2YXIgTGlzdFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKExpc3RWaWV3LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIExpc3RWaWV3KGNvbnRleHQsIHZpZXdTcGVjLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgcGFyZW50RWwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCwgdmlld1NwZWMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBwYXJlbnRFbCkgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuY29tcHV0ZURhdGVWYXJzID0gY29yZS5tZW1vaXplKGNvbXB1dGVEYXRlVmFycyk7XHJcbiAgICAgICAgICAgIF90aGlzLmV2ZW50U3RvcmVUb1NlZ3MgPSBjb3JlLm1lbW9pemUoX3RoaXMuX2V2ZW50U3RvcmVUb1NlZ3MpO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRSZW5kZXJlciA9IF90aGlzLmV2ZW50UmVuZGVyZXIgPSBuZXcgTGlzdEV2ZW50UmVuZGVyZXIoX3RoaXMpO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJDb250ZW50ID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGV2ZW50UmVuZGVyZXIucmVuZGVyU2Vncy5iaW5kKGV2ZW50UmVuZGVyZXIpLCBldmVudFJlbmRlcmVyLnVucmVuZGVyLmJpbmQoZXZlbnRSZW5kZXJlcikpO1xyXG4gICAgICAgICAgICBfdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdmYy1saXN0LXZpZXcnKTtcclxuICAgICAgICAgICAgdmFyIGxpc3RWaWV3Q2xhc3NOYW1lcyA9IChfdGhpcy50aGVtZS5nZXRDbGFzcygnbGlzdFZpZXcnKSB8fCAnJykuc3BsaXQoJyAnKTsgLy8gd2lzaCB3ZSBkaWRuJ3QgaGF2ZSB0byBkbyB0aGlzXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbGlzdFZpZXdDbGFzc05hbWVzXzEgPSBsaXN0Vmlld0NsYXNzTmFtZXM7IF9pIDwgbGlzdFZpZXdDbGFzc05hbWVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdFZpZXdDbGFzc05hbWUgPSBsaXN0Vmlld0NsYXNzTmFtZXNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdFZpZXdDbGFzc05hbWUpIHsgLy8gaW4gY2FzZSBpbnB1dCB3YXMgZW1wdHkgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZChsaXN0Vmlld0NsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsZXIgPSBuZXcgY29yZS5TY3JvbGxDb21wb25lbnQoJ2hpZGRlbicsIC8vIG92ZXJmbG93IHhcclxuICAgICAgICAgICAgJ2F1dG8nIC8vIG92ZXJmbG93IHlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgX3RoaXMuZWwuYXBwZW5kQ2hpbGQoX3RoaXMuc2Nyb2xsZXIuZWwpO1xyXG4gICAgICAgICAgICBfdGhpcy5jb250ZW50RWwgPSBfdGhpcy5zY3JvbGxlci5lbDsgLy8gc2hvcnRjdXRcclxuICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhci5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzLCB7XHJcbiAgICAgICAgICAgICAgICBlbDogX3RoaXMuZWxcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgYXdhcmUgdGhhdCBpdCBkb2Vzbid0IGRvIEhpdHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgTGlzdFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbXB1dGVEYXRlVmFycyhwcm9wcy5kYXRlUHJvZmlsZSksIGRheURhdGVzID0gX2EuZGF5RGF0ZXMsIGRheVJhbmdlcyA9IF9hLmRheVJhbmdlcztcclxuICAgICAgICAgICAgdGhpcy5kYXlEYXRlcyA9IGRheURhdGVzO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNvbnRlbnQodGhpcy5ldmVudFN0b3JlVG9TZWdzKHByb3BzLmV2ZW50U3RvcmUsIHByb3BzLmV2ZW50VWlCYXNlcywgZGF5UmFuZ2VzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBMaXN0Vmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ29udGVudC51bnJlbmRlcigpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTsgLy8gd2lsbCByZW1vdmUgdGhlIEdyaWQgdG9vXHJcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGlzdFZpZXcucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoaXNSZXNpemUsIHZpZXdIZWlnaHQsIGlzQXV0bykge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCBpc1Jlc2l6ZSwgdmlld0hlaWdodCwgaXNBdXRvKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLmNvbXB1dGVTaXplcyhpc1Jlc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5hc3NpZ25TaXplcyhpc1Jlc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuY2xlYXIoKTsgLy8gc2V0cyBoZWlnaHQgdG8gJ2F1dG8nIGFuZCBjbGVhcnMgb3ZlcmZsb3dcclxuICAgICAgICAgICAgaWYgKCFpc0F1dG8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHZpZXdIZWlnaHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGlzdFZpZXcucHJvdG90eXBlLmNvbXB1dGVTY3JvbGxlckhlaWdodCA9IGZ1bmN0aW9uICh2aWV3SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2aWV3SGVpZ2h0IC1cclxuICAgICAgICAgICAgICAgIGNvcmUuc3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXHJcbiAgICAgICAgfTtcclxuICAgICAgICBMaXN0Vmlldy5wcm90b3R5cGUuX2V2ZW50U3RvcmVUb1NlZ3MgPSBmdW5jdGlvbiAoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXlSYW5nZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSYW5nZXNUb1NlZ3MoY29yZS5zbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCB0aGlzLnByb3BzLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCB0aGlzLm5leHREYXlUaHJlc2hvbGQpLmZnLCBkYXlSYW5nZXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGlzdFZpZXcucHJvdG90eXBlLmV2ZW50UmFuZ2VzVG9TZWdzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzLCBkYXlSYW5nZXMpIHtcclxuICAgICAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBldmVudFJhbmdlc18xID0gZXZlbnRSYW5nZXM7IF9pIDwgZXZlbnRSYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudFJhbmdlID0gZXZlbnRSYW5nZXNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2guYXBwbHkoc2VncywgdGhpcy5ldmVudFJhbmdlVG9TZWdzKGV2ZW50UmFuZ2UsIGRheVJhbmdlcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGlzdFZpZXcucHJvdG90eXBlLmV2ZW50UmFuZ2VUb1NlZ3MgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZSwgZGF5UmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCBuZXh0RGF5VGhyZXNob2xkID0gX2EubmV4dERheVRocmVzaG9sZDtcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcclxuICAgICAgICAgICAgdmFyIGFsbERheSA9IGV2ZW50UmFuZ2UuZGVmLmFsbERheTtcclxuICAgICAgICAgICAgdmFyIGRheUluZGV4O1xyXG4gICAgICAgICAgICB2YXIgc2VnUmFuZ2U7XHJcbiAgICAgICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IGRheVJhbmdlcy5sZW5ndGg7IGRheUluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIHNlZ1JhbmdlID0gY29yZS5pbnRlcnNlY3RSYW5nZXMocmFuZ2UsIGRheVJhbmdlc1tkYXlJbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZ1JhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50UmFuZ2U6IGV2ZW50UmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWdSYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWdSYW5nZS5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWdSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IGV2ZW50UmFuZ2UuaXNFbmQgJiYgc2VnUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gcmFuZ2UuZW5kLnZhbHVlT2YoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5SW5kZXg6IGRheUluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBzZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlY3Qgd2hlbiByYW5nZSB3b24ndCBnbyBmdWxseSBpbnRvIHRoZSBuZXh0IGRheSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbXV0YXRlIHRoZSBsYXRlc3Qgc2VnIHRvIHRoZSBiZSB0aGUgZW5kLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VnLmlzRW5kICYmICFhbGxEYXkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5SW5kZXggKyAxIDwgZGF5UmFuZ2VzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmQgPFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZUVudi5hZGQoZGF5UmFuZ2VzW2RheUluZGV4ICsgMV0uc3RhcnQsIG5leHREYXlUaHJlc2hvbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZy5lbmQgPSByYW5nZS5lbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZy5pc0VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VncztcclxuICAgICAgICB9O1xyXG4gICAgICAgIExpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJFbXB0eU1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsLmlubmVySFRNTCA9XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHktd3JhcDJcIj4nICsgLy8gVE9ETzogdHJ5IGxlc3Mgd3JhcHNcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHktd3JhcDFcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHlcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLmh0bWxFc2NhcGUodGhpcy5vcHQoJ25vRXZlbnRzTWVzc2FnZScpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGNhbGxlZCBieSBMaXN0RXZlbnRSZW5kZXJlclxyXG4gICAgICAgIExpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJTZWdMaXN0ID0gZnVuY3Rpb24gKGFsbFNlZ3MpIHtcclxuICAgICAgICAgICAgdmFyIHNlZ3NCeURheSA9IHRoaXMuZ3JvdXBTZWdzQnlEYXkoYWxsU2Vncyk7IC8vIHNwYXJzZSBhcnJheVxyXG4gICAgICAgICAgICB2YXIgZGF5SW5kZXg7XHJcbiAgICAgICAgICAgIHZhciBkYXlTZWdzO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIHRhYmxlRWwgPSBjb3JlLmh0bWxUb0VsZW1lbnQoJzx0YWJsZSBjbGFzcz1cImZjLWxpc3QtdGFibGUgJyArIHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlTGlzdCcpICsgJ1wiPjx0Ym9keT48L3Rib2R5PjwvdGFibGU+Jyk7XHJcbiAgICAgICAgICAgIHZhciB0Ym9keUVsID0gdGFibGVFbC5xdWVyeVNlbGVjdG9yKCd0Ym9keScpO1xyXG4gICAgICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBzZWdzQnlEYXkubGVuZ3RoOyBkYXlJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICBkYXlTZWdzID0gc2Vnc0J5RGF5W2RheUluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXlTZWdzKSB7IC8vIHNwYXJzZSBhcnJheSwgc28gbWlnaHQgYmUgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIGEgZGF5IGhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIHRib2R5RWwuYXBwZW5kQ2hpbGQodGhpcy5idWlsZERheUhlYWRlclJvdyh0aGlzLmRheURhdGVzW2RheUluZGV4XSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRheVNlZ3MgPSB0aGlzLmV2ZW50UmVuZGVyZXIuc29ydEV2ZW50U2VncyhkYXlTZWdzKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF5U2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0Ym9keUVsLmFwcGVuZENoaWxkKGRheVNlZ3NbaV0uZWwpOyAvLyBhcHBlbmQgZXZlbnQgcm93XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbC5hcHBlbmRDaGlsZCh0YWJsZUVsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFJldHVybnMgYSBzcGFyc2UgYXJyYXkgb2YgYXJyYXlzLCBzZWdzIGdyb3VwZWQgYnkgdGhlaXIgZGF5SW5kZXhcclxuICAgICAgICBMaXN0Vmlldy5wcm90b3R5cGUuZ3JvdXBTZWdzQnlEYXkgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgICAgICB2YXIgc2Vnc0J5RGF5ID0gW107IC8vIHNwYXJzZSBhcnJheVxyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIHNlZztcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gfHwgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdID0gW10pKVxyXG4gICAgICAgICAgICAgICAgICAgIC5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlZ3NCeURheTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGRheSBoZWFkZXJzIHRoYXQgbGl2ZSBhbW9uZ3N0IHRoZSBldmVudCByb3dzXHJcbiAgICAgICAgTGlzdFZpZXcucHJvdG90eXBlLmJ1aWxkRGF5SGVhZGVyUm93ID0gZnVuY3Rpb24gKGRheURhdGUpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmRhdGVFbnY7XHJcbiAgICAgICAgICAgIHZhciBtYWluRm9ybWF0ID0gY29yZS5jcmVhdGVGb3JtYXR0ZXIodGhpcy5vcHQoJ2xpc3REYXlGb3JtYXQnKSk7IC8vIFRPRE86IGNhY2hlXHJcbiAgICAgICAgICAgIHZhciBhbHRGb3JtYXQgPSBjb3JlLmNyZWF0ZUZvcm1hdHRlcih0aGlzLm9wdCgnbGlzdERheUFsdEZvcm1hdCcpKTsgLy8gVE9ETzogY2FjaGVcclxuICAgICAgICAgICAgcmV0dXJuIGNvcmUuY3JlYXRlRWxlbWVudCgndHInLCB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdmYy1saXN0LWhlYWRpbmcnLFxyXG4gICAgICAgICAgICAgICAgJ2RhdGEtZGF0ZSc6IGRhdGVFbnYuZm9ybWF0SXNvKGRheURhdGUsIHsgb21pdFRpbWU6IHRydWUgfSlcclxuICAgICAgICAgICAgfSwgJzx0ZCBjbGFzcz1cIicgKyAodGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygndGFibGVMaXN0SGVhZGluZycpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSkgKyAnXCIgY29sc3Bhbj1cIjNcIj4nICtcclxuICAgICAgICAgICAgICAgIChtYWluRm9ybWF0ID9cclxuICAgICAgICAgICAgICAgICAgICBjb3JlLmJ1aWxkR290b0FuY2hvckh0bWwodGhpcywgZGF5RGF0ZSwgeyAnY2xhc3MnOiAnZmMtbGlzdC1oZWFkaW5nLW1haW4nIH0sIGNvcmUuaHRtbEVzY2FwZShkYXRlRW52LmZvcm1hdChkYXlEYXRlLCBtYWluRm9ybWF0KSkgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICAgICAgICAgICkgOlxyXG4gICAgICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICAgICAoYWx0Rm9ybWF0ID9cclxuICAgICAgICAgICAgICAgICAgICBjb3JlLmJ1aWxkR290b0FuY2hvckh0bWwodGhpcywgZGF5RGF0ZSwgeyAnY2xhc3MnOiAnZmMtbGlzdC1oZWFkaW5nLWFsdCcgfSwgY29yZS5odG1sRXNjYXBlKGRhdGVFbnYuZm9ybWF0KGRheURhdGUsIGFsdEZvcm1hdCkpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgICAgICAgICApIDpcclxuICAgICAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGQ+Jyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTGlzdFZpZXc7XHJcbiAgICB9KGNvcmUuVmlldykpO1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLmZnU2VnU2VsZWN0b3IgPSAnLmZjLWxpc3QtaXRlbSc7IC8vIHdoaWNoIGVsZW1lbnRzIGFjY2VwdCBldmVudCBhY3Rpb25zXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRGF0ZVZhcnMoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgZGF5U3RhcnQgPSBjb3JlLnN0YXJ0T2ZEYXkoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIHZhciB2aWV3RW5kID0gZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UuZW5kO1xyXG4gICAgICAgIHZhciBkYXlEYXRlcyA9IFtdO1xyXG4gICAgICAgIHZhciBkYXlSYW5nZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoZGF5U3RhcnQgPCB2aWV3RW5kKSB7XHJcbiAgICAgICAgICAgIGRheURhdGVzLnB1c2goZGF5U3RhcnQpO1xyXG4gICAgICAgICAgICBkYXlSYW5nZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogZGF5U3RhcnQsXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGNvcmUuYWRkRGF5cyhkYXlTdGFydCwgMSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRheVN0YXJ0ID0gY29yZS5hZGREYXlzKGRheVN0YXJ0LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgZGF5RGF0ZXM6IGRheURhdGVzLCBkYXlSYW5nZXM6IGRheVJhbmdlcyB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtYWluID0gY29yZS5jcmVhdGVQbHVnaW4oe1xyXG4gICAgICAgIHZpZXdzOiB7XHJcbiAgICAgICAgICAgIGxpc3Q6IHtcclxuICAgICAgICAgICAgICAgIGNsYXNzOiBMaXN0VmlldyxcclxuICAgICAgICAgICAgICAgIGJ1dHRvblRleHRLZXk6ICdsaXN0JyxcclxuICAgICAgICAgICAgICAgIGxpc3REYXlGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9IC8vIGxpa2UgXCJKYW51YXJ5IDEsIDIwMTZcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsaXN0RGF5OiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXHJcbiAgICAgICAgICAgICAgICBsaXN0RGF5Rm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9IC8vIGRheS1vZi13ZWVrIGlzIGFsbCB3ZSBuZWVkLiBmdWxsIGRhdGUgaXMgcHJvYmFibHkgaW4gaGVhZGVyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxpc3RXZWVrOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxyXG4gICAgICAgICAgICAgICAgbGlzdERheUZvcm1hdDogeyB3ZWVrZGF5OiAnbG9uZycgfSxcclxuICAgICAgICAgICAgICAgIGxpc3REYXlBbHRGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxpc3RNb250aDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgbW9udGg6IDEgfSxcclxuICAgICAgICAgICAgICAgIGxpc3REYXlBbHRGb3JtYXQ6IHsgd2Vla2RheTogJ2xvbmcnIH0gLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxpc3RZZWFyOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyB5ZWFyOiAxIH0sXHJcbiAgICAgICAgICAgICAgICBsaXN0RGF5QWx0Rm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9IC8vIGRheS1vZi13ZWVrIGlzIG5pY2UtdG8taGF2ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZXhwb3J0cy5MaXN0VmlldyA9IExpc3RWaWV3O1xyXG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gbWFpbjtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxufSkpO1xyXG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCIvKiFcclxuRnVsbENhbGVuZGFyIFRpbWUgR3JpZCBQbHVnaW4gdjQuMy4wXHJcbkRvY3MgJiBMaWNlbnNlOiBodHRwczovL2Z1bGxjYWxlbmRhci5pby9cclxuKGMpIDIwMTkgQWRhbSBTaGF3XHJcbiovXHJcblxyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAZnVsbGNhbGVuZGFyL2NvcmUnKSwgcmVxdWlyZSgnQGZ1bGxjYWxlbmRhci9kYXlncmlkJykpIDpcclxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGZ1bGxjYWxlbmRhci9jb3JlJywgJ0BmdWxsY2FsZW5kYXIvZGF5Z3JpZCddLCBmYWN0b3J5KSA6XHJcbiAgICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLkZ1bGxDYWxlbmRhclRpbWVHcmlkID0ge30sIGdsb2JhbC5GdWxsQ2FsZW5kYXIsIGdsb2JhbC5GdWxsQ2FsZW5kYXJEYXlHcmlkKSk7XHJcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGNvcmUsIGRheWdyaWQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxuICAgIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbiAgICBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuICAgIFRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICAgIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuICAgIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbiAgICBNRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuICAgIFNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG4gICAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuICAgIC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgIE9ubHkgaGFuZGxlcyBmb3JlZ3JvdW5kIHNlZ3MuXHJcbiAgICBEb2VzIG5vdCBvd24gcmVuZGVyaW5nLiBVc2UgZm9yIGxvdy1sZXZlbCB1dGlsIG1ldGhvZHMgYnkgVGltZUdyaWQuXHJcbiAgICAqL1xyXG4gICAgdmFyIFRpbWVHcmlkRXZlbnRSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVGltZUdyaWRFdmVudFJlbmRlcmVyLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFRpbWVHcmlkRXZlbnRSZW5kZXJlcih0aW1lR3JpZCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0aW1lR3JpZC5jb250ZXh0KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50aW1lR3JpZCA9IHRpbWVHcmlkO1xyXG4gICAgICAgICAgICBfdGhpcy5mdWxsVGltZUZvcm1hdCA9IGNvcmUuY3JlYXRlRm9ybWF0dGVyKHtcclxuICAgICAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJyxcclxuICAgICAgICAgICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxyXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yOiBfdGhpcy5jb250ZXh0Lm9wdGlvbnMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdpdmVuIGFuIGFycmF5IG9mIGZvcmVncm91bmQgc2VnbWVudHMsIHJlbmRlciBhIERPTSBlbGVtZW50IGZvciBlYWNoLCBjb21wdXRlcyBwb3NpdGlvbixcclxuICAgICAgICAvLyBhbmQgYXR0YWNoZXMgdG8gdGhlIGNvbHVtbiBpbm5lci1jb250YWluZXIgZWxlbWVudHMuXHJcbiAgICAgICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIG1pcnJvckluZm8pIHtcclxuICAgICAgICAgICAgdmFyIHNlZ3NCeUNvbCA9IHRoaXMudGltZUdyaWQuZ3JvdXBTZWdzQnlDb2woc2Vncyk7XHJcbiAgICAgICAgICAgIC8vIG9yZGVyIHRoZSBzZWdzIHdpdGhpbiBlYWNoIGNvbHVtblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBoYXZlIGdyb3VwU2Vnc0J5Q29sIGRvIHRoaXM/XHJcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHNlZ3NCeUNvbC5sZW5ndGg7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzQnlDb2xbY29sXSA9IHRoaXMuc29ydEV2ZW50U2VncyhzZWdzQnlDb2xbY29sXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZWdzQnlDb2wgPSBzZWdzQnlDb2w7XHJcbiAgICAgICAgICAgIHRoaXMudGltZUdyaWQuYXR0YWNoU2Vnc0J5Q29sKHNlZ3NCeUNvbCwgdGhpcy50aW1lR3JpZC5mZ0NvbnRhaW5lckVscyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmRldGFjaFNlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgICAgICBzZWdzLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgY29yZS5yZW1vdmVFbGVtZW50KHNlZy5lbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNlZ3NCeUNvbCA9IG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVTZWdTaXplcyA9IGZ1bmN0aW9uIChhbGxTZWdzKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHRpbWVHcmlkID0gX2EudGltZUdyaWQsIHNlZ3NCeUNvbCA9IF9hLnNlZ3NCeUNvbDtcclxuICAgICAgICAgICAgdmFyIGNvbENudCA9IHRpbWVHcmlkLmNvbENudDtcclxuICAgICAgICAgICAgdGltZUdyaWQuY29tcHV0ZVNlZ1ZlcnRpY2FscyhhbGxTZWdzKTsgLy8gaG9yaXpvbnRhbHMgcmVsaWVzIG9uIHRoaXNcclxuICAgICAgICAgICAgaWYgKHNlZ3NCeUNvbCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZVNlZ0hvcml6b250YWxzKHNlZ3NCeUNvbFtjb2xdKTsgLy8gY29tcHV0ZSBob3Jpem9udGFsIGNvb3JkaW5hdGVzLCB6LWluZGV4J3MsIGFuZCByZW9yZGVyIHRoZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmFzc2lnblNlZ1NpemVzID0gZnVuY3Rpb24gKGFsbFNlZ3MpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgdGltZUdyaWQgPSBfYS50aW1lR3JpZCwgc2Vnc0J5Q29sID0gX2Euc2Vnc0J5Q29sO1xyXG4gICAgICAgICAgICB2YXIgY29sQ250ID0gdGltZUdyaWQuY29sQ250O1xyXG4gICAgICAgICAgICB0aW1lR3JpZC5hc3NpZ25TZWdWZXJ0aWNhbHMoYWxsU2Vncyk7IC8vIGhvcml6b250YWxzIHJlbGllcyBvbiB0aGlzXHJcbiAgICAgICAgICAgIGlmIChzZWdzQnlDb2wpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzc2lnblNlZ0NzcyhzZWdzQnlDb2xbY29sXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENvbXB1dGVzIGEgZGVmYXVsdCBldmVudCB0aW1lIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGBldmVudFRpbWVGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcclxuICAgICAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBob3VyOiAnbnVtZXJpYycsXHJcbiAgICAgICAgICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcclxuICAgICAgICAgICAgICAgIG1lcmlkaWVtOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcclxuICAgICAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gUmVuZGVycyB0aGUgSFRNTCBmb3IgYSBzaW5nbGUgZXZlbnQgc2VnbWVudCdzIGRlZmF1bHQgcmVuZGVyaW5nXHJcbiAgICAgICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdIdG1sID0gZnVuY3Rpb24gKHNlZywgbWlycm9ySW5mbykge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuY29udGV4dC52aWV3O1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnREZWYgPSBldmVudFJhbmdlLmRlZjtcclxuICAgICAgICAgICAgdmFyIGV2ZW50VWkgPSBldmVudFJhbmdlLnVpO1xyXG4gICAgICAgICAgICB2YXIgYWxsRGF5ID0gZXZlbnREZWYuYWxsRGF5O1xyXG4gICAgICAgICAgICB2YXIgaXNEcmFnZ2FibGUgPSB2aWV3LmNvbXB1dGVFdmVudERyYWdnYWJsZShldmVudERlZiwgZXZlbnRVaSk7XHJcbiAgICAgICAgICAgIHZhciBpc1Jlc2l6YWJsZUZyb21TdGFydCA9IHNlZy5pc1N0YXJ0ICYmIHZpZXcuY29tcHV0ZUV2ZW50U3RhcnRSZXNpemFibGUoZXZlbnREZWYsIGV2ZW50VWkpO1xyXG4gICAgICAgICAgICB2YXIgaXNSZXNpemFibGVGcm9tRW5kID0gc2VnLmlzRW5kICYmIHZpZXcuY29tcHV0ZUV2ZW50RW5kUmVzaXphYmxlKGV2ZW50RGVmLCBldmVudFVpKTtcclxuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSB0aGlzLmdldFNlZ0NsYXNzZXMoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGVGcm9tU3RhcnQgfHwgaXNSZXNpemFibGVGcm9tRW5kLCBtaXJyb3JJbmZvKTtcclxuICAgICAgICAgICAgdmFyIHNraW5Dc3MgPSBjb3JlLmNzc1RvU3RyKHRoaXMuZ2V0U2tpbkNzcyhldmVudFVpKSk7XHJcbiAgICAgICAgICAgIHZhciB0aW1lVGV4dDtcclxuICAgICAgICAgICAgdmFyIGZ1bGxUaW1lVGV4dDsgLy8gbW9yZSB2ZXJib3NlIHRpbWUgdGV4dC4gZm9yIHRoZSBwcmludCBzdHlsZXNoZWV0XHJcbiAgICAgICAgICAgIHZhciBzdGFydFRpbWVUZXh0OyAvLyBqdXN0IHRoZSBzdGFydCB0aW1lIHRleHRcclxuICAgICAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy10aW1lLWdyaWQtZXZlbnQnKTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIGV2ZW50IGFwcGVhcnMgdG8gc3BhbiBtb3JlIHRoYW4gb25lIGRheS4uLlxyXG4gICAgICAgICAgICBpZiAoY29yZS5pc011bHRpRGF5UmFuZ2UoZXZlbnRSYW5nZS5yYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGRpc3BsYXkgdGltZSB0ZXh0IG9uIHNlZ21lbnRzIHRoYXQgcnVuIGVudGlyZWx5IHRocm91Z2ggYSBkYXkuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGF0IHdvdWxkIGFwcGVhciBhcyBtaWRuaWdodC1taWRuaWdodCBhbmQgd291bGQgbG9vayBkdW1iLlxyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBkaXNwbGF5IHRoZSB0aW1lIHRleHQgZm9yIHRoZSAqc2VnbWVudCdzKiB0aW1lcyAobGlrZSA2cG0tbWlkbmlnaHQgb3IgbWlkbmlnaHQtMTBhbSlcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuaXNTdGFydCB8fCBzZWcuaXNFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdW56b25lZFN0YXJ0ID0gc2VnLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bnpvbmVkRW5kID0gc2VnLmVuZDtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lVGV4dCA9IHRoaXMuX2dldFRpbWVUZXh0KHVuem9uZWRTdGFydCwgdW56b25lZEVuZCwgYWxsRGF5KTsgLy8gVE9ETzogZ2l2ZSB0aGUgdGltZXpvbmVzXHJcbiAgICAgICAgICAgICAgICAgICAgZnVsbFRpbWVUZXh0ID0gdGhpcy5fZ2V0VGltZVRleHQodW56b25lZFN0YXJ0LCB1bnpvbmVkRW5kLCBhbGxEYXksIHRoaXMuZnVsbFRpbWVGb3JtYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZVRleHQgPSB0aGlzLl9nZXRUaW1lVGV4dCh1bnpvbmVkU3RhcnQsIHVuem9uZWRFbmQsIGFsbERheSwgbnVsbCwgZmFsc2UpOyAvLyBkaXNwbGF5RW5kPWZhbHNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBub3JtYWwgdGltZSB0ZXh0IGZvciB0aGUgKmV2ZW50J3MqIHRpbWVzXHJcbiAgICAgICAgICAgICAgICB0aW1lVGV4dCA9IHRoaXMuZ2V0VGltZVRleHQoZXZlbnRSYW5nZSk7XHJcbiAgICAgICAgICAgICAgICBmdWxsVGltZVRleHQgPSB0aGlzLmdldFRpbWVUZXh0KGV2ZW50UmFuZ2UsIHRoaXMuZnVsbFRpbWVGb3JtYXQpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lVGV4dCA9IHRoaXMuZ2V0VGltZVRleHQoZXZlbnRSYW5nZSwgbnVsbCwgZmFsc2UpOyAvLyBkaXNwbGF5RW5kPWZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICc8YSBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAgICAgKGV2ZW50RGVmLnVybCA/XHJcbiAgICAgICAgICAgICAgICAgICAgJyBocmVmPVwiJyArIGNvcmUuaHRtbEVzY2FwZShldmVudERlZi51cmwpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgICAgIChza2luQ3NzID9cclxuICAgICAgICAgICAgICAgICAgICAnIHN0eWxlPVwiJyArIHNraW5Dc3MgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY29udGVudFwiPicgK1xyXG4gICAgICAgICAgICAgICAgKHRpbWVUZXh0ID9cclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXRpbWVcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGRhdGEtc3RhcnQ9XCInICsgY29yZS5odG1sRXNjYXBlKHN0YXJ0VGltZVRleHQpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcgZGF0YS1mdWxsPVwiJyArIGNvcmUuaHRtbEVzY2FwZShmdWxsVGltZVRleHQpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8c3Bhbj4nICsgY29yZS5odG1sRXNjYXBlKHRpbWVUZXh0KSArICc8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nIDpcclxuICAgICAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAgICAgKGV2ZW50RGVmLnRpdGxlID9cclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuaHRtbEVzY2FwZShldmVudERlZi50aXRsZSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgIC8qIFRPRE86IHdyaXRlIENTUyBmb3IgdGhpc1xyXG4gICAgICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbVN0YXJ0ID9cclxuICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLXN0YXJ0LXJlc2l6ZXJcIj48L2Rpdj4nIDpcclxuICAgICAgICAgICAgICAgICAgJydcclxuICAgICAgICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbUVuZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLWVuZC1yZXNpemVyXCI+PC9kaXY+JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgICAgICc8L2E+JztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdpdmVuIGFuIGFycmF5IG9mIHNlZ21lbnRzIHRoYXQgYXJlIGFsbCBpbiB0aGUgc2FtZSBjb2x1bW4sIHNldHMgdGhlIGJhY2t3YXJkQ29vcmQgYW5kIGZvcndhcmRDb29yZCBvbiBlYWNoLlxyXG4gICAgICAgIC8vIEFzc3VtZWQgdGhlIHNlZ3MgYXJlIGFscmVhZHkgb3JkZXJlZC5cclxuICAgICAgICAvLyBOT1RFOiBBbHNvIHJlb3JkZXJzIHRoZSBnaXZlbiBhcnJheSBieSBkYXRlIVxyXG4gICAgICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZVNlZ0hvcml6b250YWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGxldmVscztcclxuICAgICAgICAgICAgdmFyIGxldmVsMDtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGxldmVscyA9IGJ1aWxkU2xvdFNlZ0xldmVscyhzZWdzKTtcclxuICAgICAgICAgICAgY29tcHV0ZUZvcndhcmRTbG90U2VncyhsZXZlbHMpO1xyXG4gICAgICAgICAgICBpZiAoKGxldmVsMCA9IGxldmVsc1swXSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZXZlbDAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2xvdFNlZ1ByZXNzdXJlcyhsZXZlbDBbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsMC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZVNlZ0ZvcndhcmRCYWNrKGxldmVsMFtpXSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzZWcuZm9yd2FyZENvb3JkIGFuZCBzZWcuYmFja3dhcmRDb29yZCBmb3IgdGhlIHNlZ21lbnQsIHdoZXJlIGJvdGggdmFsdWVzIHJhbmdlXHJcbiAgICAgICAgLy8gZnJvbSAwIHRvIDEuIElmIHRoZSBjYWxlbmRhciBpcyBsZWZ0LXRvLXJpZ2h0LCB0aGUgc2VnLmJhY2t3YXJkQ29vcmQgbWFwcyB0byBcImxlZnRcIiBhbmRcclxuICAgICAgICAvLyBzZWcuZm9yd2FyZENvb3JkIG1hcHMgdG8gXCJyaWdodFwiICh2aWEgcGVyY2VudGFnZSkuIFZpY2UtdmVyc2EgaWYgdGhlIGNhbGVuZGFyIGlzIHJpZ2h0LXRvLWxlZnQuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUaGUgc2VnbWVudCBtaWdodCBiZSBwYXJ0IG9mIGEgXCJzZXJpZXNcIiwgd2hpY2ggbWVhbnMgY29uc2VjdXRpdmUgc2VnbWVudHMgd2l0aCB0aGUgc2FtZSBwcmVzc3VyZVxyXG4gICAgICAgIC8vIHdobydzIHdpZHRoIGlzIHVua25vd24gdW50aWwgYW4gZWRnZSBoYXMgYmVlbiBoaXQuIGBzZXJpZXNCYWNrd2FyZFByZXNzdXJlYCBpcyB0aGUgbnVtYmVyIG9mXHJcbiAgICAgICAgLy8gc2VnbWVudHMgYmVoaW5kIHRoaXMgb25lIGluIHRoZSBjdXJyZW50IHNlcmllcywgYW5kIGBzZXJpZXNCYWNrd2FyZENvb3JkYCBpcyB0aGUgc3RhcnRpbmdcclxuICAgICAgICAvLyBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBzZWdtZW50IGluIHRoZSBzZXJpZXMuXHJcbiAgICAgICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlU2VnRm9yd2FyZEJhY2sgPSBmdW5jdGlvbiAoc2VnLCBzZXJpZXNCYWNrd2FyZFByZXNzdXJlLCBzZXJpZXNCYWNrd2FyZENvb3JkKSB7XHJcbiAgICAgICAgICAgIHZhciBmb3J3YXJkU2VncyA9IHNlZy5mb3J3YXJkU2VncztcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGlmIChzZWcuZm9yd2FyZENvb3JkID09PSB1bmRlZmluZWQpIHsgLy8gbm90IGFscmVhZHkgY29tcHV0ZWRcclxuICAgICAgICAgICAgICAgIGlmICghZm9yd2FyZFNlZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGZvcndhcmQgc2VnbWVudHMsIHRoaXMgc2VnbWVudCBzaG91bGQgYnV0dCB1cCBhZ2FpbnN0IHRoZSBlZGdlXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmZvcndhcmRDb29yZCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzb3J0IGhpZ2hlc3QgcHJlc3N1cmUgZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRGb3J3YXJkU2Vncyhmb3J3YXJkU2Vncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBzZWdtZW50J3MgZm9yd2FyZENvb3JkIHdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBiYWNrd2FyZENvb3JkIG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZ2hlc3QtcHJlc3N1cmUgZm9yd2FyZCBzZWdtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZVNlZ0ZvcndhcmRCYWNrKGZvcndhcmRTZWdzWzBdLCBzZXJpZXNCYWNrd2FyZFByZXNzdXJlICsgMSwgc2VyaWVzQmFja3dhcmRDb29yZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmZvcndhcmRDb29yZCA9IGZvcndhcmRTZWdzWzBdLmJhY2t3YXJkQ29vcmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGJhY2t3YXJkQ29vcmQgZnJvbSB0aGUgZm9yd2FyZENvb3JkLiBjb25zaWRlciB0aGUgc2VyaWVzXHJcbiAgICAgICAgICAgICAgICBzZWcuYmFja3dhcmRDb29yZCA9IHNlZy5mb3J3YXJkQ29vcmQgLVxyXG4gICAgICAgICAgICAgICAgICAgIChzZWcuZm9yd2FyZENvb3JkIC0gc2VyaWVzQmFja3dhcmRDb29yZCkgLyAvLyBhdmFpbGFibGUgd2lkdGggZm9yIHNlcmllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VyaWVzQmFja3dhcmRQcmVzc3VyZSArIDEpOyAvLyAjIG9mIHNlZ21lbnRzIGluIHRoZSBzZXJpZXNcclxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGlzIHNlZ21lbnQncyBjb29yZGluYXRlcyB0byBjb21wdXRlZCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGxlc3MtcHJlc3N1cml6ZWRcclxuICAgICAgICAgICAgICAgIC8vIGZvcndhcmQgc2VnbWVudHNcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmb3J3YXJkU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZVNlZ0ZvcndhcmRCYWNrKGZvcndhcmRTZWdzW2ldLCAwLCBzZWcuZm9yd2FyZENvb3JkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5zb3J0Rm9yd2FyZFNlZ3MgPSBmdW5jdGlvbiAoZm9yd2FyZFNlZ3MpIHtcclxuICAgICAgICAgICAgdmFyIG9ianMgPSBmb3J3YXJkU2Vncy5tYXAoYnVpbGRUaW1lR3JpZFNlZ0NvbXBhcmVPYmopO1xyXG4gICAgICAgICAgICB2YXIgc3BlY3MgPSBbXHJcbiAgICAgICAgICAgICAgICAvLyBwdXQgaGlnaGVyLXByZXNzdXJlIGZpcnN0XHJcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiAnZm9yd2FyZFByZXNzdXJlJywgb3JkZXI6IC0xIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBwdXQgc2VnbWVudHMgdGhhdCBhcmUgY2xvc2VyIHRvIGluaXRpYWwgZWRnZSBmaXJzdCAoYW5kIGZhdm9yIG9uZXMgd2l0aCBubyBjb29yZHMgeWV0KVxyXG4gICAgICAgICAgICAgICAgeyBmaWVsZDogJ2JhY2t3YXJkQ29vcmQnLCBvcmRlcjogMSB9XHJcbiAgICAgICAgICAgIF0uY29uY2F0KHRoaXMuY29udGV4dC52aWV3LmV2ZW50T3JkZXJTcGVjcyk7XHJcbiAgICAgICAgICAgIG9ianMuc29ydChmdW5jdGlvbiAob2JqMCwgb2JqMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBzcGVjcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gb2Jqcy5tYXAoZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjLl9zZWc7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2l2ZW4gZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBoYWQgdGhlaXIgcG9zaXRpb24gY29vcmRpbmF0ZXMgY29tcHV0ZWQsXHJcbiAgICAgICAgLy8gYXNzaWducyBwb3NpdGlvbi1yZWxhdGVkIENTUyB2YWx1ZXMgdG8gdGhlaXIgZWxlbWVudHMuXHJcbiAgICAgICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5hc3NpZ25TZWdDc3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ3NfMSA9IHNlZ3M7IF9pIDwgc2Vnc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMVtfaV07XHJcbiAgICAgICAgICAgICAgICBjb3JlLmFwcGx5U3R5bGUoc2VnLmVsLCB0aGlzLmdlbmVyYXRlU2VnQ3NzKHNlZykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5sZXZlbCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcuZWwuY2xhc3NMaXN0LmFkZCgnZmMtdGltZS1ncmlkLWV2ZW50LWluc2V0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZXZlbnQgaXMgc2hvcnQgdGhhdCB0aGUgdGl0bGUgd2lsbCBiZSBjdXQgb2ZmLFxyXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIGEgY2xhc3NOYW1lIHRoYXQgY29uZGVuc2VzIHRoZSB0aXRsZSBpbnRvIHRoZSB0aW1lIGFyZWEuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmV2ZW50UmFuZ2UuZGVmLnRpdGxlICYmIHNlZy5ib3R0b20gLSBzZWcudG9wIDwgMzApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcuZWwuY2xhc3NMaXN0LmFkZCgnZmMtc2hvcnQnKTsgLy8gVE9ETzogXCJjb25kZW5zZWRcIiBpcyBhIGJldHRlciBuYW1lXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdlbmVyYXRlcyBhbiBvYmplY3Qgd2l0aCBDU1MgcHJvcGVydGllcy92YWx1ZXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBhbiBldmVudCBzZWdtZW50IGVsZW1lbnQuXHJcbiAgICAgICAgLy8gQ29udGFpbnMgaW1wb3J0YW50IHBvc2l0aW9uaW5nLXJlbGF0ZWQgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGFueSBldmVudCBlbGVtZW50LCBjdXN0b21pemVkIG9yIG5vdC5cclxuICAgICAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlU2VnQ3NzID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICB2YXIgc2hvdWxkT3ZlcmxhcCA9IHRoaXMuY29udGV4dC5vcHRpb25zLnNsb3RFdmVudE92ZXJsYXA7XHJcbiAgICAgICAgICAgIHZhciBiYWNrd2FyZENvb3JkID0gc2VnLmJhY2t3YXJkQ29vcmQ7IC8vIHRoZSBsZWZ0IHNpZGUgaWYgTFRSLiB0aGUgcmlnaHQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XHJcbiAgICAgICAgICAgIHZhciBmb3J3YXJkQ29vcmQgPSBzZWcuZm9yd2FyZENvb3JkOyAvLyB0aGUgcmlnaHQgc2lkZSBpZiBMVFIuIHRoZSBsZWZ0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxyXG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnRpbWVHcmlkLmdlbmVyYXRlU2VnVmVydGljYWxDc3Moc2VnKTsgLy8gZ2V0IHRvcC9ib3R0b20gZmlyc3RcclxuICAgICAgICAgICAgdmFyIGlzUnRsID0gdGhpcy50aW1lR3JpZC5pc1J0bDtcclxuICAgICAgICAgICAgdmFyIGxlZnQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIGxlZnQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcclxuICAgICAgICAgICAgdmFyIHJpZ2h0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSByaWdodCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlIHRoZSB3aWR0aCwgYnV0IGRvbid0IGdvIGJleW9uZCB0aGUgbWF4aW11bSBmb3J3YXJkIGNvb3JkaW5hdGUgKDEuMClcclxuICAgICAgICAgICAgICAgIGZvcndhcmRDb29yZCA9IE1hdGgubWluKDEsIGJhY2t3YXJkQ29vcmQgKyAoZm9yd2FyZENvb3JkIC0gYmFja3dhcmRDb29yZCkgKiAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNSdGwpIHtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSAxIC0gZm9yd2FyZENvb3JkO1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBiYWNrd2FyZENvb3JkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IGJhY2t3YXJkQ29vcmQ7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IDEgLSBmb3J3YXJkQ29vcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcHMuekluZGV4ID0gc2VnLmxldmVsICsgMTsgLy8gY29udmVydCBmcm9tIDAtYmFzZSB0byAxLWJhc2VkXHJcbiAgICAgICAgICAgIHByb3BzLmxlZnQgPSBsZWZ0ICogMTAwICsgJyUnO1xyXG4gICAgICAgICAgICBwcm9wcy5yaWdodCA9IHJpZ2h0ICogMTAwICsgJyUnO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCAmJiBzZWcuZm9yd2FyZFByZXNzdXJlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgcGFkZGluZyB0byB0aGUgZWRnZSBzbyB0aGF0IGZvcndhcmQgc3RhY2tlZCBldmVudHMgZG9uJ3QgY292ZXIgdGhlIHJlc2l6ZXIncyBpY29uXHJcbiAgICAgICAgICAgICAgICBwcm9wc1tpc1J0bCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCddID0gMTAgKiAyOyAvLyAxMCBpcyBhIGd1ZXNzdGltYXRlIG9mIHRoZSBpY29uJ3Mgd2lkdGhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVGltZUdyaWRFdmVudFJlbmRlcmVyO1xyXG4gICAgfShjb3JlLkZnRXZlbnRSZW5kZXJlcikpO1xyXG4gICAgLy8gQnVpbGRzIGFuIGFycmF5IG9mIHNlZ21lbnRzIFwibGV2ZWxzXCIuIFRoZSBmaXJzdCBsZXZlbCB3aWxsIGJlIHRoZSBsZWZ0bW9zdCB0aWVyIG9mIHNlZ21lbnRzIGlmIHRoZSBjYWxlbmRhciBpc1xyXG4gICAgLy8gbGVmdC10by1yaWdodCwgb3IgdGhlIHJpZ2h0bW9zdCBpZiB0aGUgY2FsZW5kYXIgaXMgcmlnaHQtdG8tbGVmdC4gQXNzdW1lcyB0aGUgc2VnbWVudHMgYXJlIGFscmVhZHkgb3JkZXJlZCBieSBkYXRlLlxyXG4gICAgZnVuY3Rpb24gYnVpbGRTbG90U2VnTGV2ZWxzKHNlZ3MpIHtcclxuICAgICAgICB2YXIgbGV2ZWxzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICAvLyBnbyB0aHJvdWdoIGFsbCB0aGUgbGV2ZWxzIGFuZCBzdG9wIG9uIHRoZSBmaXJzdCBsZXZlbCB3aGVyZSB0aGVyZSBhcmUgbm8gY29sbGlzaW9uc1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXB1dGVTbG90U2VnQ29sbGlzaW9ucyhzZWcsIGxldmVsc1tqXSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VnLmxldmVsID0gajtcclxuICAgICAgICAgICAgKGxldmVsc1tqXSB8fCAobGV2ZWxzW2pdID0gW10pKS5wdXNoKHNlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsZXZlbHM7XHJcbiAgICB9XHJcbiAgICAvLyBGb3IgZXZlcnkgc2VnbWVudCwgZmlndXJlIG91dCB0aGUgb3RoZXIgc2VnbWVudHMgdGhhdCBhcmUgaW4gc3Vic2VxdWVudFxyXG4gICAgLy8gbGV2ZWxzIHRoYXQgYWxzbyBvY2N1cHkgdGhlIHNhbWUgdmVydGljYWwgc3BhY2UuIEFjY3VtdWxhdGUgaW4gc2VnLmZvcndhcmRTZWdzXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRm9yd2FyZFNsb3RTZWdzKGxldmVscykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBsZXZlbDtcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBrO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV2ZWwgPSBsZXZlbHNbaV07XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgc2VnID0gbGV2ZWxbal07XHJcbiAgICAgICAgICAgICAgICBzZWcuZm9yd2FyZFNlZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IGkgKyAxOyBrIDwgbGV2ZWxzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVNsb3RTZWdDb2xsaXNpb25zKHNlZywgbGV2ZWxzW2tdLCBzZWcuZm9yd2FyZFNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRmlndXJlIG91dCB3aGljaCBwYXRoIGZvcndhcmQgKHZpYSBzZWcuZm9yd2FyZFNlZ3MpIHJlc3VsdHMgaW4gdGhlIGxvbmdlc3QgcGF0aCB1bnRpbFxyXG4gICAgLy8gdGhlIGZ1cnRoZXN0IGVkZ2UgaXMgcmVhY2hlZC4gVGhlIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGlzIHBhdGggd2lsbCBiZSBzZWcuZm9yd2FyZFByZXNzdXJlXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlU2xvdFNlZ1ByZXNzdXJlcyhzZWcpIHtcclxuICAgICAgICB2YXIgZm9yd2FyZFNlZ3MgPSBzZWcuZm9yd2FyZFNlZ3M7XHJcbiAgICAgICAgdmFyIGZvcndhcmRQcmVzc3VyZSA9IDA7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGZvcndhcmRTZWc7XHJcbiAgICAgICAgaWYgKHNlZy5mb3J3YXJkUHJlc3N1cmUgPT09IHVuZGVmaW5lZCkgeyAvLyBub3QgYWxyZWFkeSBjb21wdXRlZFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZm9yd2FyZFNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZvcndhcmRTZWcgPSBmb3J3YXJkU2Vnc1tpXTtcclxuICAgICAgICAgICAgICAgIC8vIGZpZ3VyZSBvdXQgdGhlIGNoaWxkJ3MgbWF4aW11bSBmb3J3YXJkIHBhdGhcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVTbG90U2VnUHJlc3N1cmVzKGZvcndhcmRTZWcpO1xyXG4gICAgICAgICAgICAgICAgLy8gZWl0aGVyIHVzZSB0aGUgZXhpc3RpbmcgbWF4aW11bSwgb3IgdXNlIHRoZSBjaGlsZCdzIGZvcndhcmQgcHJlc3N1cmVcclxuICAgICAgICAgICAgICAgIC8vIHBsdXMgb25lIChmb3IgdGhlIGZvcndhcmRTZWcgaXRzZWxmKVxyXG4gICAgICAgICAgICAgICAgZm9yd2FyZFByZXNzdXJlID0gTWF0aC5tYXgoZm9yd2FyZFByZXNzdXJlLCAxICsgZm9yd2FyZFNlZy5mb3J3YXJkUHJlc3N1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlZy5mb3J3YXJkUHJlc3N1cmUgPSBmb3J3YXJkUHJlc3N1cmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRmluZCBhbGwgdGhlIHNlZ21lbnRzIGluIGBvdGhlclNlZ3NgIHRoYXQgdmVydGljYWxseSBjb2xsaWRlIHdpdGggYHNlZ2AuXHJcbiAgICAvLyBBcHBlbmQgaW50byBhbiBvcHRpb25hbGx5LXN1cHBsaWVkIGByZXN1bHRzYCBhcnJheSBhbmQgcmV0dXJuLlxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVNsb3RTZWdDb2xsaXNpb25zKHNlZywgb3RoZXJTZWdzLCByZXN1bHRzKSB7XHJcbiAgICAgICAgaWYgKHJlc3VsdHMgPT09IHZvaWQgMCkgeyByZXN1bHRzID0gW107IH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaXNTbG90U2VnQ29sbGlzaW9uKHNlZywgb3RoZXJTZWdzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG90aGVyU2Vnc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcbiAgICAvLyBEbyB0aGVzZSBzZWdtZW50cyBvY2N1cHkgdGhlIHNhbWUgdmVydGljYWwgc3BhY2U/XHJcbiAgICBmdW5jdGlvbiBpc1Nsb3RTZWdDb2xsaXNpb24oc2VnMSwgc2VnMikge1xyXG4gICAgICAgIHJldHVybiBzZWcxLmJvdHRvbSA+IHNlZzIudG9wICYmIHNlZzEudG9wIDwgc2VnMi5ib3R0b207XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZFRpbWVHcmlkU2VnQ29tcGFyZU9iaihzZWcpIHtcclxuICAgICAgICB2YXIgb2JqID0gY29yZS5idWlsZFNlZ0NvbXBhcmVPYmooc2VnKTtcclxuICAgICAgICBvYmouZm9yd2FyZFByZXNzdXJlID0gc2VnLmZvcndhcmRQcmVzc3VyZTtcclxuICAgICAgICBvYmouYmFja3dhcmRDb29yZCA9IHNlZy5iYWNrd2FyZENvb3JkO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFRpbWVHcmlkTWlycm9yUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFRpbWVHcmlkTWlycm9yUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVGltZUdyaWRNaXJyb3JSZW5kZXJlcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBUaW1lR3JpZE1pcnJvclJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIG1pcnJvckluZm8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZWdzQnlDb2wgPSB0aGlzLnRpbWVHcmlkLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVHcmlkLmF0dGFjaFNlZ3NCeUNvbCh0aGlzLnNlZ3NCeUNvbCwgdGhpcy50aW1lR3JpZC5taXJyb3JDb250YWluZXJFbHMpO1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZVNlZyA9IG1pcnJvckluZm8uc291cmNlU2VnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGltZUdyaWRNaXJyb3JSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVTZWdDc3MgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IF9zdXBlci5wcm90b3R5cGUuZ2VuZXJhdGVTZWdDc3MuY2FsbCh0aGlzLCBzZWcpO1xyXG4gICAgICAgICAgICB2YXIgc291cmNlU2VnID0gdGhpcy5zb3VyY2VTZWc7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VTZWcgJiYgc291cmNlU2VnLmNvbCA9PT0gc2VnLmNvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZVNlZ1Byb3BzID0gX3N1cGVyLnByb3RvdHlwZS5nZW5lcmF0ZVNlZ0Nzcy5jYWxsKHRoaXMsIHNvdXJjZVNlZyk7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5sZWZ0ID0gc291cmNlU2VnUHJvcHMubGVmdDtcclxuICAgICAgICAgICAgICAgIHByb3BzLnJpZ2h0ID0gc291cmNlU2VnUHJvcHMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5tYXJnaW5MZWZ0ID0gc291cmNlU2VnUHJvcHMubWFyZ2luTGVmdDtcclxuICAgICAgICAgICAgICAgIHByb3BzLm1hcmdpblJpZ2h0ID0gc291cmNlU2VnUHJvcHMubWFyZ2luUmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRpbWVHcmlkTWlycm9yUmVuZGVyZXI7XHJcbiAgICB9KFRpbWVHcmlkRXZlbnRSZW5kZXJlcikpO1xyXG5cclxuICAgIHZhciBUaW1lR3JpZEZpbGxSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVGltZUdyaWRGaWxsUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVGltZUdyaWRGaWxsUmVuZGVyZXIodGltZUdyaWQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdGltZUdyaWQuY29udGV4dCkgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGltZUdyaWQgPSB0aW1lR3JpZDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBUaW1lR3JpZEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoU2VncyA9IGZ1bmN0aW9uICh0eXBlLCBzZWdzKSB7XHJcbiAgICAgICAgICAgIHZhciB0aW1lR3JpZCA9IHRoaXMudGltZUdyaWQ7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXJFbHM7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1vcmUgZWZmaWNpZW50IGxvb2t1cFxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2JnRXZlbnQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbHMgPSB0aW1lR3JpZC5iZ0NvbnRhaW5lckVscztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYnVzaW5lc3NIb3VycycpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVscyA9IHRpbWVHcmlkLmJ1c2luZXNzQ29udGFpbmVyRWxzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdoaWdobGlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbHMgPSB0aW1lR3JpZC5oaWdobGlnaHRDb250YWluZXJFbHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGltZUdyaWQuYXR0YWNoU2Vnc0J5Q29sKHRpbWVHcmlkLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpLCBjb250YWluZXJFbHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2Vncy5tYXAoZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZy5lbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaW1lR3JpZEZpbGxSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZVNlZ1NpemVzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lR3JpZC5jb21wdXRlU2VnVmVydGljYWxzKHNlZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGltZUdyaWRGaWxsUmVuZGVyZXIucHJvdG90eXBlLmFzc2lnblNlZ1NpemVzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lR3JpZC5hc3NpZ25TZWdWZXJ0aWNhbHMoc2Vncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVGltZUdyaWRGaWxsUmVuZGVyZXI7XHJcbiAgICB9KGNvcmUuRmlsbFJlbmRlcmVyKSk7XHJcblxyXG4gICAgLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIG9uZSBvciBtb3JlIGNvbHVtbnMgb2YgdmVydGljYWwgdGltZSBzbG90c1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBwb3RlbnRpYWwgbmljZSB2YWx1ZXMgZm9yIHRoZSBzbG90LWR1cmF0aW9uIGFuZCBpbnRlcnZhbC1kdXJhdGlvblxyXG4gICAgLy8gZnJvbSBsYXJnZXN0IHRvIHNtYWxsZXN0XHJcbiAgICB2YXIgQUdFTkRBX1NUT0NLX1NVQl9EVVJBVElPTlMgPSBbXHJcbiAgICAgICAgeyBob3VyczogMSB9LFxyXG4gICAgICAgIHsgbWludXRlczogMzAgfSxcclxuICAgICAgICB7IG1pbnV0ZXM6IDE1IH0sXHJcbiAgICAgICAgeyBzZWNvbmRzOiAzMCB9LFxyXG4gICAgICAgIHsgc2Vjb25kczogMTUgfVxyXG4gICAgXTtcclxuICAgIHZhciBUaW1lR3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVGltZUdyaWQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVGltZUdyaWQoY29udGV4dCwgZWwsIHJlbmRlclByb3BzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQsIGVsKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5pc1NsYXRTaXplc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLmlzQ29sU2l6ZXNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJTbGF0cyA9IGNvcmUubWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5fcmVuZGVyU2xhdHMpO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRSZW5kZXJlciA9IF90aGlzLmV2ZW50UmVuZGVyZXIgPSBuZXcgVGltZUdyaWRFdmVudFJlbmRlcmVyKF90aGlzKTtcclxuICAgICAgICAgICAgdmFyIGZpbGxSZW5kZXJlciA9IF90aGlzLmZpbGxSZW5kZXJlciA9IG5ldyBUaW1lR3JpZEZpbGxSZW5kZXJlcihfdGhpcyk7XHJcbiAgICAgICAgICAgIF90aGlzLm1pcnJvclJlbmRlcmVyID0gbmV3IFRpbWVHcmlkTWlycm9yUmVuZGVyZXIoX3RoaXMpO1xyXG4gICAgICAgICAgICB2YXIgcmVuZGVyQ29sdW1ucyA9IF90aGlzLnJlbmRlckNvbHVtbnMgPSBjb3JlLm1lbW9pemVSZW5kZXJpbmcoX3RoaXMuX3JlbmRlckNvbHVtbnMsIF90aGlzLl91bnJlbmRlckNvbHVtbnMpO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJCdXNpbmVzc0hvdXJzID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGZpbGxSZW5kZXJlci5yZW5kZXJTZWdzLmJpbmQoZmlsbFJlbmRlcmVyLCAnYnVzaW5lc3NIb3VycycpLCBmaWxsUmVuZGVyZXIudW5yZW5kZXIuYmluZChmaWxsUmVuZGVyZXIsICdidXNpbmVzc0hvdXJzJyksIFtyZW5kZXJDb2x1bW5zXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckRhdGVTZWxlY3Rpb24gPSBjb3JlLm1lbW9pemVSZW5kZXJpbmcoX3RoaXMuX3JlbmRlckRhdGVTZWxlY3Rpb24sIF90aGlzLl91bnJlbmRlckRhdGVTZWxlY3Rpb24sIFtyZW5kZXJDb2x1bW5zXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckZnRXZlbnRzID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGV2ZW50UmVuZGVyZXIucmVuZGVyU2Vncy5iaW5kKGV2ZW50UmVuZGVyZXIpLCBldmVudFJlbmRlcmVyLnVucmVuZGVyLmJpbmQoZXZlbnRSZW5kZXJlciksIFtyZW5kZXJDb2x1bW5zXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckJnRXZlbnRzID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGZpbGxSZW5kZXJlci5yZW5kZXJTZWdzLmJpbmQoZmlsbFJlbmRlcmVyLCAnYmdFdmVudCcpLCBmaWxsUmVuZGVyZXIudW5yZW5kZXIuYmluZChmaWxsUmVuZGVyZXIsICdiZ0V2ZW50JyksIFtyZW5kZXJDb2x1bW5zXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckV2ZW50U2VsZWN0aW9uID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKGV2ZW50UmVuZGVyZXIuc2VsZWN0QnlJbnN0YW5jZUlkLmJpbmQoZXZlbnRSZW5kZXJlciksIGV2ZW50UmVuZGVyZXIudW5zZWxlY3RCeUluc3RhbmNlSWQuYmluZChldmVudFJlbmRlcmVyKSwgW190aGlzLnJlbmRlckZnRXZlbnRzXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckV2ZW50RHJhZyA9IGNvcmUubWVtb2l6ZVJlbmRlcmluZyhfdGhpcy5fcmVuZGVyRXZlbnREcmFnLCBfdGhpcy5fdW5yZW5kZXJFdmVudERyYWcsIFtyZW5kZXJDb2x1bW5zXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckV2ZW50UmVzaXplID0gY29yZS5tZW1vaXplUmVuZGVyaW5nKF90aGlzLl9yZW5kZXJFdmVudFJlc2l6ZSwgX3RoaXMuX3VucmVuZGVyRXZlbnRSZXNpemUsIFtyZW5kZXJDb2x1bW5zXSk7XHJcbiAgICAgICAgICAgIF90aGlzLnByb2Nlc3NPcHRpb25zKCk7XHJcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJnXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1zbGF0c1wiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8aHIgY2xhc3M9XCJmYy1kaXZpZGVyICcgKyBfdGhpcy50aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiAvPic7XHJcbiAgICAgICAgICAgIF90aGlzLnJvb3RCZ0NvbnRhaW5lckVsID0gZWwucXVlcnlTZWxlY3RvcignLmZjLWJnJyk7XHJcbiAgICAgICAgICAgIF90aGlzLnNsYXRDb250YWluZXJFbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zbGF0cycpO1xyXG4gICAgICAgICAgICBfdGhpcy5ib3R0b21SdWxlRWwgPSBlbC5xdWVyeVNlbGVjdG9yKCcuZmMtZGl2aWRlcicpO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJQcm9wcyA9IHJlbmRlclByb3BzO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIE9wdGlvbnNcclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgIC8vIFBhcnNlcyB2YXJpb3VzIG9wdGlvbnMgaW50byBwcm9wZXJ0aWVzIG9mIHRoaXMgb2JqZWN0XHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLnByb2Nlc3NPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2xvdER1cmF0aW9uID0gdGhpcy5vcHQoJ3Nsb3REdXJhdGlvbicpO1xyXG4gICAgICAgICAgICB2YXIgc25hcER1cmF0aW9uID0gdGhpcy5vcHQoJ3NuYXBEdXJhdGlvbicpO1xyXG4gICAgICAgICAgICB2YXIgc25hcHNQZXJTbG90O1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQ7XHJcbiAgICAgICAgICAgIHNsb3REdXJhdGlvbiA9IGNvcmUuY3JlYXRlRHVyYXRpb24oc2xvdER1cmF0aW9uKTtcclxuICAgICAgICAgICAgc25hcER1cmF0aW9uID0gc25hcER1cmF0aW9uID8gY29yZS5jcmVhdGVEdXJhdGlvbihzbmFwRHVyYXRpb24pIDogc2xvdER1cmF0aW9uO1xyXG4gICAgICAgICAgICBzbmFwc1BlclNsb3QgPSBjb3JlLndob2xlRGl2aWRlRHVyYXRpb25zKHNsb3REdXJhdGlvbiwgc25hcER1cmF0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHNuYXBzUGVyU2xvdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc25hcER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgc25hcHNQZXJTbG90ID0gMTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHNheSB3YXJuaW5nP1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2xvdER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLnNuYXBEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5zbmFwc1BlclNsb3QgPSBzbmFwc1BlclNsb3Q7XHJcbiAgICAgICAgICAgIC8vIG1pZ2h0IGJlIGFuIGFycmF5IHZhbHVlIChmb3IgVGltZWxpbmVWaWV3KS5cclxuICAgICAgICAgICAgLy8gaWYgc28sIGdldHRpbmcgdGhlIG1vc3QgZ3JhbnVsYXIgZW50cnkgKHRoZSBsYXN0IG9uZSBwcm9iYWJseSkuXHJcbiAgICAgICAgICAgIGlucHV0ID0gdGhpcy5vcHQoJ3Nsb3RMYWJlbEZvcm1hdCcpO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXRbaW5wdXQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sYWJlbEZvcm1hdCA9IGNvcmUuY3JlYXRlRm9ybWF0dGVyKGlucHV0IHx8IHtcclxuICAgICAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJyxcclxuICAgICAgICAgICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxyXG4gICAgICAgICAgICAgICAgb21pdFplcm9NaW51dGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtZXJpZGllbTogJ3Nob3J0J1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaW5wdXQgPSB0aGlzLm9wdCgnc2xvdExhYmVsSW50ZXJ2YWwnKTtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbEludGVydmFsID0gaW5wdXQgP1xyXG4gICAgICAgICAgICAgICAgY29yZS5jcmVhdGVEdXJhdGlvbihpbnB1dCkgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlTGFiZWxJbnRlcnZhbChzbG90RHVyYXRpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQ29tcHV0ZXMgYW4gYXV0b21hdGljIHZhbHVlIGZvciBzbG90TGFiZWxJbnRlcnZhbFxyXG4gICAgICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlTGFiZWxJbnRlcnZhbCA9IGZ1bmN0aW9uIChzbG90RHVyYXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbEludGVydmFsO1xyXG4gICAgICAgICAgICB2YXIgc2xvdHNQZXJMYWJlbDtcclxuICAgICAgICAgICAgLy8gZmluZCB0aGUgc21hbGxlc3Qgc3RvY2sgbGFiZWwgaW50ZXJ2YWwgdGhhdCByZXN1bHRzIGluIG1vcmUgdGhhbiBvbmUgc2xvdHMtcGVyLWxhYmVsXHJcbiAgICAgICAgICAgIGZvciAoaSA9IEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbEludGVydmFsID0gY29yZS5jcmVhdGVEdXJhdGlvbihBR0VOREFfU1RPQ0tfU1VCX0RVUkFUSU9OU1tpXSk7XHJcbiAgICAgICAgICAgICAgICBzbG90c1BlckxhYmVsID0gY29yZS53aG9sZURpdmlkZUR1cmF0aW9ucyhsYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNsb3RzUGVyTGFiZWwgIT09IG51bGwgJiYgc2xvdHNQZXJMYWJlbCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxJbnRlcnZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2xvdER1cmF0aW9uOyAvLyBmYWxsIGJhY2tcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIFJlbmRlcmluZ1xyXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBwcm9wcy5jZWxscztcclxuICAgICAgICAgICAgdGhpcy5jb2xDbnQgPSBjZWxscy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2xhdHMocHJvcHMuZGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNvbHVtbnMocHJvcHMuY2VsbHMsIHByb3BzLmRhdGVQcm9maWxlKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJCdXNpbmVzc0hvdXJzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckRhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckZnRXZlbnRzKHByb3BzLmZnRXZlbnRTZWdzKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJCZ0V2ZW50cyhwcm9wcy5iZ0V2ZW50U2Vncyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnRTZWxlY3Rpb24ocHJvcHMuZXZlbnRTZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbWVHcmlkLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgLy8gc2hvdWxkIHVucmVuZGVyIGV2ZXJ5dGhpbmcgZWxzZSB0b29cclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTbGF0cy51bnJlbmRlcigpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNvbHVtbnMudW5yZW5kZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbWVHcmlkLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKGlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGZpbGxSZW5kZXJlciA9IF9hLmZpbGxSZW5kZXJlciwgZXZlbnRSZW5kZXJlciA9IF9hLmV2ZW50UmVuZGVyZXIsIG1pcnJvclJlbmRlcmVyID0gX2EubWlycm9yUmVuZGVyZXI7XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6ZSB8fCB0aGlzLmlzU2xhdFNpemVzRGlydHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRTbGF0UG9zaXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2xhdFNpemVzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNSZXNpemUgfHwgdGhpcy5pc0NvbFNpemVzRGlydHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRDb2xQb3NpdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNDb2xTaXplc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmlsbFJlbmRlcmVyLmNvbXB1dGVTaXplcyhpc1Jlc2l6ZSk7XHJcbiAgICAgICAgICAgIGV2ZW50UmVuZGVyZXIuY29tcHV0ZVNpemVzKGlzUmVzaXplKTtcclxuICAgICAgICAgICAgbWlycm9yUmVuZGVyZXIuY29tcHV0ZVNpemVzKGlzUmVzaXplKTtcclxuICAgICAgICAgICAgZmlsbFJlbmRlcmVyLmFzc2lnblNpemVzKGlzUmVzaXplKTtcclxuICAgICAgICAgICAgZXZlbnRSZW5kZXJlci5hc3NpZ25TaXplcyhpc1Jlc2l6ZSk7XHJcbiAgICAgICAgICAgIG1pcnJvclJlbmRlcmVyLmFzc2lnblNpemVzKGlzUmVzaXplKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbWVHcmlkLnByb3RvdHlwZS5fcmVuZGVyU2xhdHMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICAgICAgdmFyIHRoZW1lID0gdGhpcy50aGVtZTtcclxuICAgICAgICAgICAgdGhpcy5zbGF0Q29udGFpbmVyRWwuaW5uZXJIVE1MID1cclxuICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU2xhdFJvd0h0bWwoZGF0ZVByb2ZpbGUpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90YWJsZT4nO1xyXG4gICAgICAgICAgICB0aGlzLnNsYXRFbHMgPSBjb3JlLmZpbmRFbGVtZW50cyh0aGlzLnNsYXRDb250YWluZXJFbCwgJ3RyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2xhdFBvc2l0aW9ucyA9IG5ldyBjb3JlLlBvc2l0aW9uQ2FjaGUodGhpcy5lbCwgdGhpcy5zbGF0RWxzLCBmYWxzZSwgdHJ1ZSAvLyB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLmlzU2xhdFNpemVzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgaG9yaXpvbnRhbCBcInNsYXRzXCIgdGhhdCBydW4gd2lkdGgtd2lzZS4gSGFzIGEgdGltZSBheGlzIG9uIGEgc2lkZS4gRGVwZW5kcyBvbiBSVEwuXHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlclNsYXRSb3dIdG1sID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCB0aGVtZSA9IF9hLnRoZW1lLCBpc1J0bCA9IF9hLmlzUnRsO1xyXG4gICAgICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgICAgICB2YXIgZGF5U3RhcnQgPSBjb3JlLnN0YXJ0T2ZEYXkoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgICAgICB2YXIgc2xvdFRpbWUgPSBkYXRlUHJvZmlsZS5taW5UaW1lO1xyXG4gICAgICAgICAgICB2YXIgc2xvdEl0ZXJhdG9yID0gY29yZS5jcmVhdGVEdXJhdGlvbigwKTtcclxuICAgICAgICAgICAgdmFyIHNsb3REYXRlOyAvLyB3aWxsIGJlIG9uIHRoZSB2aWV3J3MgZmlyc3QgZGF5LCBidXQgd2Ugb25seSBjYXJlIGFib3V0IGl0cyB0aW1lXHJcbiAgICAgICAgICAgIHZhciBpc0xhYmVsZWQ7XHJcbiAgICAgICAgICAgIHZhciBheGlzSHRtbDtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0aW1lIGZvciBlYWNoIHNsb3RcclxuICAgICAgICAgICAgd2hpbGUgKGNvcmUuYXNSb3VnaE1zKHNsb3RUaW1lKSA8IGNvcmUuYXNSb3VnaE1zKGRhdGVQcm9maWxlLm1heFRpbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBzbG90RGF0ZSA9IGRhdGVFbnYuYWRkKGRheVN0YXJ0LCBzbG90VGltZSk7XHJcbiAgICAgICAgICAgICAgICBpc0xhYmVsZWQgPSBjb3JlLndob2xlRGl2aWRlRHVyYXRpb25zKHNsb3RJdGVyYXRvciwgdGhpcy5sYWJlbEludGVydmFsKSAhPT0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGF4aXNIdG1sID1cclxuICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtYXhpcyBmYy10aW1lICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNMYWJlbGVkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3Bhbj4nICsgLy8gZm9yIG1hdGNoQ2VsbFdpZHRoc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuaHRtbEVzY2FwZShkYXRlRW52LmZvcm1hdChzbG90RGF0ZSwgdGhpcy5sYWJlbEZvcm1hdCkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvdGQ+JztcclxuICAgICAgICAgICAgICAgIGh0bWwgKz1cclxuICAgICAgICAgICAgICAgICAgICAnPHRyIGRhdGEtdGltZT1cIicgKyBjb3JlLmZvcm1hdElzb1RpbWVTdHJpbmcoc2xvdERhdGUpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc0xhYmVsZWQgPyAnJyA6ICcgY2xhc3M9XCJmYy1taW5vclwiJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWlzUnRsID8gYXhpc0h0bWwgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGlzUnRsID8gYXhpc0h0bWwgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgICAgICAgICAgICAgc2xvdFRpbWUgPSBjb3JlLmFkZER1cmF0aW9ucyhzbG90VGltZSwgdGhpcy5zbG90RHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgc2xvdEl0ZXJhdG9yID0gY29yZS5hZGREdXJhdGlvbnMoc2xvdEl0ZXJhdG9yLCB0aGlzLnNsb3REdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaW1lR3JpZC5wcm90b3R5cGUuX3JlbmRlckNvbHVtbnMgPSBmdW5jdGlvbiAoY2VsbHMsIGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHRoZW1lID0gX2EudGhlbWUsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCB2aWV3ID0gX2EudmlldztcclxuICAgICAgICAgICAgdmFyIGJnUm93ID0gbmV3IGRheWdyaWQuRGF5QmdSb3codGhpcy5jb250ZXh0KTtcclxuICAgICAgICAgICAgdGhpcy5yb290QmdDb250YWluZXJFbC5pbm5lckhUTUwgPVxyXG4gICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgYmdSb3cucmVuZGVySHRtbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzOiBjZWxscyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJJbnRyb0h0bWw6IHRoaXMucmVuZGVyUHJvcHMucmVuZGVyQmdJbnRyb0h0bWxcclxuICAgICAgICAgICAgICAgICAgICB9KSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGFibGU+JztcclxuICAgICAgICAgICAgdGhpcy5jb2xFbHMgPSBjb3JlLmZpbmRFbGVtZW50cyh0aGlzLmVsLCAnLmZjLWRheSwgLmZjLWRpc2FibGVkLWRheScpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdkYXlSZW5kZXInLCBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShjZWxsc1tjb2xdLmRhdGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbDogdGhpcy5jb2xFbHNbY29sXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogdmlld1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUnRsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbEVscy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb2xQb3NpdGlvbnMgPSBuZXcgY29yZS5Qb3NpdGlvbkNhY2hlKHRoaXMuZWwsIHRoaXMuY29sRWxzLCB0cnVlLCAvLyBob3Jpem9udGFsXHJcbiAgICAgICAgICAgIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJDb250ZW50U2tlbGV0b24oKTtcclxuICAgICAgICAgICAgdGhpcy5pc0NvbFNpemVzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLl91bnJlbmRlckNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5yZW5kZXJDb250ZW50U2tlbGV0b24oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIENvbnRlbnQgU2tlbGV0b25cclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgIC8vIFJlbmRlcnMgdGhlIERPTSB0aGF0IHRoZSB2aWV3J3MgY29udGVudCB3aWxsIGxpdmUgaW5cclxuICAgICAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyQ29udGVudFNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHNrZWxldG9uRWw7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5yZW5kZXJQcm9wcy5yZW5kZXJJbnRyb0h0bWwoKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb2xDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCgnPHRkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY29udGVudC1jb2xcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lciBmYy1taXJyb3ItY29udGFpbmVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWhpZ2hsaWdodC1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJnZXZlbnQtY29udGFpbmVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1idXNpbmVzcy1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGQ+Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSdGwpIHtcclxuICAgICAgICAgICAgICAgIHBhcnRzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBza2VsZXRvbkVsID0gdGhpcy5jb250ZW50U2tlbGV0b25FbCA9IGNvcmUuaHRtbFRvRWxlbWVudCgnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtc2tlbGV0b25cIj4nICtcclxuICAgICAgICAgICAgICAgICc8dGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAnPHRyPicgKyBwYXJ0cy5qb2luKCcnKSArICc8L3RyPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29sQ29udGFpbmVyRWxzID0gY29yZS5maW5kRWxlbWVudHMoc2tlbGV0b25FbCwgJy5mYy1jb250ZW50LWNvbCcpO1xyXG4gICAgICAgICAgICB0aGlzLm1pcnJvckNvbnRhaW5lckVscyA9IGNvcmUuZmluZEVsZW1lbnRzKHNrZWxldG9uRWwsICcuZmMtbWlycm9yLWNvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICB0aGlzLmZnQ29udGFpbmVyRWxzID0gY29yZS5maW5kRWxlbWVudHMoc2tlbGV0b25FbCwgJy5mYy1ldmVudC1jb250YWluZXI6bm90KC5mYy1taXJyb3ItY29udGFpbmVyKScpO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29udGFpbmVyRWxzID0gY29yZS5maW5kRWxlbWVudHMoc2tlbGV0b25FbCwgJy5mYy1iZ2V2ZW50LWNvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodENvbnRhaW5lckVscyA9IGNvcmUuZmluZEVsZW1lbnRzKHNrZWxldG9uRWwsICcuZmMtaGlnaGxpZ2h0LWNvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1c2luZXNzQ29udGFpbmVyRWxzID0gY29yZS5maW5kRWxlbWVudHMoc2tlbGV0b25FbCwgJy5mYy1idXNpbmVzcy1jb250YWluZXInKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSdGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sQ29udGFpbmVyRWxzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWlycm9yQ29udGFpbmVyRWxzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmdDb250YWluZXJFbHMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iZ0NvbnRhaW5lckVscy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodENvbnRhaW5lckVscy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1c2luZXNzQ29udGFpbmVyRWxzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHNrZWxldG9uRWwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyQ29udGVudFNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb3JlLnJlbW92ZUVsZW1lbnQodGhpcy5jb250ZW50U2tlbGV0b25FbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHaXZlbiBhIGZsYXQgYXJyYXkgb2Ygc2VnbWVudHMsIHJldHVybiBhbiBhcnJheSBvZiBzdWItYXJyYXlzLCBncm91cGVkIGJ5IGVhY2ggc2VnbWVudCdzIGNvbFxyXG4gICAgICAgIFRpbWVHcmlkLnByb3RvdHlwZS5ncm91cFNlZ3NCeUNvbCA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdzQnlDb2wgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbENudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzQnlDb2wucHVzaChbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNlZ3NCeUNvbFtzZWdzW2ldLmNvbF0ucHVzaChzZWdzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2Vnc0J5Q29sO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2l2ZW4gc2VnbWVudHMgZ3JvdXBlZCBieSBjb2x1bW4sIGluc2VydCB0aGUgc2VnbWVudHMnIGVsZW1lbnRzIGludG8gYSBwYXJhbGxlbCBhcnJheSBvZiBjb250YWluZXJcclxuICAgICAgICAvLyBlbGVtZW50cywgZWFjaCBsaXZpbmcgd2l0aGluIGEgY29sdW1uLlxyXG4gICAgICAgIFRpbWVHcmlkLnByb3RvdHlwZS5hdHRhY2hTZWdzQnlDb2wgPSBmdW5jdGlvbiAoc2Vnc0J5Q29sLCBjb250YWluZXJFbHMpIHtcclxuICAgICAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICAgICAgdmFyIHNlZ3M7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykgeyAvLyBpdGVyYXRlIGVhY2ggY29sdW1uIGdyb3VwaW5nXHJcbiAgICAgICAgICAgICAgICBzZWdzID0gc2Vnc0J5Q29sW2NvbF07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsc1tjb2xdLmFwcGVuZENoaWxkKHNlZ3NbaV0uZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBOb3cgSW5kaWNhdG9yXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2V0Tm93SW5kaWNhdG9yVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtaW51dGUnOyAvLyB3aWxsIHJlZnJlc2ggb24gdGhlIG1pbnV0ZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uIChzZWdzLCBkYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIEhBQ0s6IGlmIGRhdGUgY29sdW1ucyBub3QgcmVhZHkgZm9yIHNvbWUgcmVhc29uIChzY2hlZHVsZXIpXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jb2xDb250YWluZXJFbHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdG9wID0gdGhpcy5jb21wdXRlRGF0ZVRvcChkYXRlKTtcclxuICAgICAgICAgICAgdmFyIG5vZGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAvLyByZW5kZXIgbGluZXMgd2l0aGluIHRoZSBjb2x1bW5zXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZUVsID0gY29yZS5jcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2ZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1saW5lJyB9KTtcclxuICAgICAgICAgICAgICAgIGxpbmVFbC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xDb250YWluZXJFbHNbc2Vnc1tpXS5jb2xdLmFwcGVuZENoaWxkKGxpbmVFbCk7XHJcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGxpbmVFbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVuZGVyIGFuIGFycm93IG92ZXIgdGhlIGF4aXNcclxuICAgICAgICAgICAgaWYgKHNlZ3MubGVuZ3RoID4gMCkgeyAvLyBpcyB0aGUgY3VycmVudCB0aW1lIGluIHZpZXc/XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyb3dFbCA9IGNvcmUuY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdmYy1ub3ctaW5kaWNhdG9yIGZjLW5vdy1pbmRpY2F0b3ItYXJyb3cnIH0pO1xyXG4gICAgICAgICAgICAgICAgYXJyb3dFbC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50U2tlbGV0b25FbC5hcHBlbmRDaGlsZChhcnJvd0VsKTtcclxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goYXJyb3dFbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JFbHMgPSBub2RlcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubm93SW5kaWNhdG9yRWxzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvckVscy5mb3JFYWNoKGNvcmUucmVtb3ZlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvckVscyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIENvb3JkaW5hdGVzXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2V0VG90YWxTbGF0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbGF0Q29udGFpbmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgICAgICAvLyBBIGBzdGFydE9mRGF5RGF0ZWAgbXVzdCBiZSBnaXZlbiBmb3IgYXZvaWRpbmcgYW1iaWd1aXR5IG92ZXIgaG93IHRvIHRyZWF0IG1pZG5pZ2h0LlxyXG4gICAgICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlRGF0ZVRvcCA9IGZ1bmN0aW9uICh3aGVuLCBzdGFydE9mRGF5RGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0T2ZEYXlEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE9mRGF5RGF0ZSA9IGNvcmUuc3RhcnRPZkRheSh3aGVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjb3JlLmNyZWF0ZUR1cmF0aW9uKHdoZW4udmFsdWVPZigpIC0gc3RhcnRPZkRheURhdGUudmFsdWVPZigpKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiB0aW1lIChhIER1cmF0aW9uKS5cclxuICAgICAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcHV0ZVRpbWVUb3AgPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuc2xhdEVscy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgICAgIHZhciBzbGF0Q292ZXJhZ2UgPSAoZHVyYXRpb24ubWlsbGlzZWNvbmRzIC0gY29yZS5hc1JvdWdoTXMoZGF0ZVByb2ZpbGUubWluVGltZSkpIC8gY29yZS5hc1JvdWdoTXModGhpcy5zbG90RHVyYXRpb24pOyAvLyBmbG9hdGluZy1wb2ludCB2YWx1ZSBvZiAjIG9mIHNsb3RzIGNvdmVyZWRcclxuICAgICAgICAgICAgdmFyIHNsYXRJbmRleDtcclxuICAgICAgICAgICAgdmFyIHNsYXRSZW1haW5kZXI7XHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgZm9yIGhvdyBtYW55IHNsYXRzIHNob3VsZCBiZSBwcm9ncmVzc2VkIHRocm91Z2guXHJcbiAgICAgICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgb2Ygc2xhdHMgKGluY2x1c2l2ZSlcclxuICAgICAgICAgICAgLy8gY29uc3RyYWluZWQgYmVjYXVzZSBtaW5UaW1lL21heFRpbWUgbWlnaHQgYmUgY3VzdG9taXplZC5cclxuICAgICAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5tYXgoMCwgc2xhdENvdmVyYWdlKTtcclxuICAgICAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5taW4obGVuLCBzbGF0Q292ZXJhZ2UpO1xyXG4gICAgICAgICAgICAvLyBhbiBpbnRlZ2VyIGluZGV4IG9mIHRoZSBmdXJ0aGVzdCB3aG9sZSBzbGF0XHJcbiAgICAgICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgc2xhdHMgKCpleGNsdXNpdmUqLCBzbyBsZW4tMSlcclxuICAgICAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5mbG9vcihzbGF0Q292ZXJhZ2UpO1xyXG4gICAgICAgICAgICBzbGF0SW5kZXggPSBNYXRoLm1pbihzbGF0SW5kZXgsIGxlbiAtIDEpO1xyXG4gICAgICAgICAgICAvLyBob3cgbXVjaCBmdXJ0aGVyIHRocm91Z2ggdGhlIHNsYXRJbmRleCBzbGF0IChmcm9tIDAuMC0xLjApIG11c3QgYmUgY292ZXJlZCBpbiBhZGRpdGlvbi5cclxuICAgICAgICAgICAgLy8gY291bGQgYmUgMS4wIGlmIHNsYXRDb3ZlcmFnZSBpcyBjb3ZlcmluZyAqYWxsKiB0aGUgc2xvdHNcclxuICAgICAgICAgICAgc2xhdFJlbWFpbmRlciA9IHNsYXRDb3ZlcmFnZSAtIHNsYXRJbmRleDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xhdFBvc2l0aW9ucy50b3BzW3NsYXRJbmRleF0gK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zbGF0UG9zaXRpb25zLmdldEhlaWdodChzbGF0SW5kZXgpICogc2xhdFJlbWFpbmRlcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEZvciBlYWNoIHNlZ21lbnQgaW4gYW4gYXJyYXksIGNvbXB1dGVzIGFuZCBhc3NpZ25zIGl0cyB0b3AgYW5kIGJvdHRvbSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXB1dGVTZWdWZXJ0aWNhbHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRNaW5IZWlnaHQgPSB0aGlzLm9wdCgndGltZUdyaWRFdmVudE1pbkhlaWdodCcpO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIHNlZztcclxuICAgICAgICAgICAgdmFyIGRheURhdGU7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICAgICAgZGF5RGF0ZSA9IHRoaXMucHJvcHMuY2VsbHNbc2VnLmNvbF0uZGF0ZTtcclxuICAgICAgICAgICAgICAgIHNlZy50b3AgPSB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgZGF5RGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBzZWcuYm90dG9tID0gTWF0aC5tYXgoc2VnLnRvcCArIGV2ZW50TWluSGVpZ2h0LCB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5lbmQsIGRheURhdGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2l2ZW4gc2VnbWVudHMgdGhhdCBhbHJlYWR5IGhhdmUgdGhlaXIgdG9wL2JvdHRvbSBwcm9wZXJ0aWVzIGNvbXB1dGVkLCBhcHBsaWVzIHRob3NlIHZhbHVlcyB0b1xyXG4gICAgICAgIC8vIHRoZSBzZWdtZW50cycgZWxlbWVudHMuXHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLmFzc2lnblNlZ1ZlcnRpY2FscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgICAgIGNvcmUuYXBwbHlTdHlsZShzZWcuZWwsIHRoaXMuZ2VuZXJhdGVTZWdWZXJ0aWNhbENzcyhzZWcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIGFuIG9iamVjdCB3aXRoIENTUyBwcm9wZXJ0aWVzIGZvciB0aGUgdG9wL2JvdHRvbSBjb29yZGluYXRlcyBvZiBhIHNlZ21lbnQgZWxlbWVudFxyXG4gICAgICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZW5lcmF0ZVNlZ1ZlcnRpY2FsQ3NzID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdG9wOiBzZWcudG9wLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiAtc2VnLmJvdHRvbSAvLyBmbGlwcGVkIGJlY2F1c2UgbmVlZHMgdG8gYmUgc3BhY2UgYmV5b25kIGJvdHRvbSBlZGdlIG9mIGV2ZW50IGNvbnRhaW5lclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogU2l6aW5nXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICBUaW1lR3JpZC5wcm90b3R5cGUuYnVpbGRQb3NpdGlvbkNhY2hlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZENvbFBvc2l0aW9ucygpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkU2xhdFBvc2l0aW9ucygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLmJ1aWxkQ29sUG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbFBvc2l0aW9ucy5idWlsZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLmJ1aWxkU2xhdFBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zbGF0UG9zaXRpb25zLmJ1aWxkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBIaXQgU3lzdGVtXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICBUaW1lR3JpZC5wcm90b3R5cGUucG9zaXRpb25Ub0hpdCA9IGZ1bmN0aW9uIChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCBzbmFwc1BlclNsb3QgPSBfYS5zbmFwc1BlclNsb3QsIHNsYXRQb3NpdGlvbnMgPSBfYS5zbGF0UG9zaXRpb25zLCBjb2xQb3NpdGlvbnMgPSBfYS5jb2xQb3NpdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciBjb2xJbmRleCA9IGNvbFBvc2l0aW9ucy5sZWZ0VG9JbmRleChwb3NpdGlvbkxlZnQpO1xyXG4gICAgICAgICAgICB2YXIgc2xhdEluZGV4ID0gc2xhdFBvc2l0aW9ucy50b3BUb0luZGV4KHBvc2l0aW9uVG9wKTtcclxuICAgICAgICAgICAgaWYgKGNvbEluZGV4ICE9IG51bGwgJiYgc2xhdEluZGV4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbGF0VG9wID0gc2xhdFBvc2l0aW9ucy50b3BzW3NsYXRJbmRleF07XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xhdEhlaWdodCA9IHNsYXRQb3NpdGlvbnMuZ2V0SGVpZ2h0KHNsYXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFydGlhbCA9IChwb3NpdGlvblRvcCAtIHNsYXRUb3ApIC8gc2xhdEhlaWdodDsgLy8gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsU25hcEluZGV4ID0gTWF0aC5mbG9vcihwYXJ0aWFsICogc25hcHNQZXJTbG90KTsgLy8gdGhlIHNuYXAgIyByZWxhdGl2ZSB0byBzdGFydCBvZiBzbGF0XHJcbiAgICAgICAgICAgICAgICB2YXIgc25hcEluZGV4ID0gc2xhdEluZGV4ICogc25hcHNQZXJTbG90ICsgbG9jYWxTbmFwSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF5RGF0ZSA9IHRoaXMucHJvcHMuY2VsbHNbY29sSW5kZXhdLmRhdGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZSA9IGNvcmUuYWRkRHVyYXRpb25zKHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUubWluVGltZSwgY29yZS5tdWx0aXBseUR1cmF0aW9uKHRoaXMuc25hcER1cmF0aW9uLCBzbmFwSW5kZXgpKTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGRhdGVFbnYuYWRkKGRheURhdGUsIHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCB0aGlzLnNuYXBEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVNwYW46IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxEYXk6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBkYXlFbDogdGhpcy5jb2xFbHNbY29sSW5kZXhdLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUmVjdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb2xQb3NpdGlvbnMubGVmdHNbY29sSW5kZXhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogY29sUG9zaXRpb25zLnJpZ2h0c1tjb2xJbmRleF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogc2xhdFRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBzbGF0VG9wICsgc2xhdEhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIEV2ZW50IERyYWcgVmlzdWFsaXphdGlvblxyXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLl9yZW5kZXJFdmVudERyYWcgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIuaGlkZUJ5SGFzaChzdGF0ZS5hZmZlY3RlZEluc3RhbmNlcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yUmVuZGVyZXIucmVuZGVyU2VncyhzdGF0ZS5zZWdzLCB7IGlzRHJhZ2dpbmc6IHRydWUsIHNvdXJjZVNlZzogc3RhdGUuc291cmNlU2VnIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyU2VncygnaGlnaGxpZ2h0Jywgc3RhdGUuc2Vncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbWVHcmlkLnByb3RvdHlwZS5fdW5yZW5kZXJFdmVudERyYWcgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIuc2hvd0J5SGFzaChzdGF0ZS5hZmZlY3RlZEluc3RhbmNlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvclJlbmRlcmVyLnVucmVuZGVyKHN0YXRlLnNlZ3MsIHsgaXNEcmFnZ2luZzogdHJ1ZSwgc291cmNlU2VnOiBzdGF0ZS5zb3VyY2VTZWcgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci51bnJlbmRlcignaGlnaGxpZ2h0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIEV2ZW50IFJlc2l6ZSBWaXN1YWxpemF0aW9uXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICBUaW1lR3JpZC5wcm90b3R5cGUuX3JlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLmhpZGVCeUhhc2goc3RhdGUuYWZmZWN0ZWRJbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JSZW5kZXJlci5yZW5kZXJTZWdzKHN0YXRlLnNlZ3MsIHsgaXNSZXNpemluZzogdHJ1ZSwgc291cmNlU2VnOiBzdGF0ZS5zb3VyY2VTZWcgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbWVHcmlkLnByb3RvdHlwZS5fdW5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5zaG93QnlIYXNoKHN0YXRlLmFmZmVjdGVkSW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWlycm9yUmVuZGVyZXIudW5yZW5kZXIoc3RhdGUuc2VncywgeyBpc1Jlc2l6aW5nOiB0cnVlLCBzb3VyY2VTZWc6IHN0YXRlLnNvdXJjZVNlZyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogU2VsZWN0aW9uXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb24uIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCwgd2hpY2ggd2FzIHRvIHNpbXBseSByZW5kZXIgYSBoaWdobGlnaHQuXHJcbiAgICAgICAgVGltZUdyaWQucHJvdG90eXBlLl9yZW5kZXJEYXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICAgICAgaWYgKHNlZ3MpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdCgnc2VsZWN0TWlycm9yJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvclJlbmRlcmVyLnJlbmRlclNlZ3Moc2VncywgeyBpc1NlbGVjdGluZzogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnJlbmRlclNlZ3MoJ2hpZ2hsaWdodCcsIHNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaW1lR3JpZC5wcm90b3R5cGUuX3VucmVuZGVyRGF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWlycm9yUmVuZGVyZXIudW5yZW5kZXIoc2VncywgeyBpc1NlbGVjdGluZzogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIudW5yZW5kZXIoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRpbWVHcmlkO1xyXG4gICAgfShjb3JlLkRhdGVDb21wb25lbnQpKTtcclxuXHJcbiAgICB2YXIgQWxsRGF5U3BsaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEFsbERheVNwbGl0dGVyLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEFsbERheVNwbGl0dGVyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEFsbERheVNwbGl0dGVyLnByb3RvdHlwZS5nZXRLZXlJbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYWxsRGF5OiB7fSxcclxuICAgICAgICAgICAgICAgIHRpbWVkOiB7fVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWxsRGF5U3BsaXR0ZXIucHJvdG90eXBlLmdldEtleXNGb3JEYXRlU3BhbiA9IGZ1bmN0aW9uIChkYXRlU3Bhbikge1xyXG4gICAgICAgICAgICBpZiAoZGF0ZVNwYW4uYWxsRGF5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ3RpbWVkJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFsbERheVNwbGl0dGVyLnByb3RvdHlwZS5nZXRLZXlzRm9yRXZlbnREZWYgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgaWYgKCFldmVudERlZi5hbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ3RpbWVkJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29yZS5oYXNCZ1JlbmRlcmluZyhldmVudERlZikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ3RpbWVkJywgJ2FsbERheSddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnYWxsRGF5J107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBbGxEYXlTcGxpdHRlcjtcclxuICAgIH0oY29yZS5TcGxpdHRlcikpO1xyXG5cclxuICAgIHZhciBUSU1FR1JJRF9BTExfREFZX0VWRU5UX0xJTUlUID0gNTtcclxuICAgIHZhciBXRUVLX0hFQURFUl9GT1JNQVQgPSBjb3JlLmNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICdzaG9ydCcgfSk7XHJcbiAgICAvKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgYWxsIHRpbWVncmlkLXJlbGF0ZWQgdmlld3MuIERpc3BsYXlzIG9uZSBtb3JlIGNvbHVtbnMgd2l0aCB0aW1lIHNsb3RzIHJ1bm5pbmcgdmVydGljYWxseS5cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gSXMgYSBtYW5hZ2VyIGZvciB0aGUgVGltZUdyaWQgc3ViY29tcG9uZW50IGFuZCBwb3NzaWJseSB0aGUgRGF5R3JpZCBzdWJjb21wb25lbnQgKGlmIGFsbERheVNsb3QgaXMgb24pLlxyXG4gICAgLy8gUmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cclxuICAgIHZhciBUaW1lR3JpZFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFRpbWVHcmlkVmlldywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBUaW1lR3JpZFZpZXcoY29udGV4dCwgdmlld1NwZWMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBwYXJlbnRFbCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0LCB2aWV3U3BlYywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHBhcmVudEVsKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5zcGxpdHRlciA9IG5ldyBBbGxEYXlTcGxpdHRlcigpO1xyXG4gICAgICAgICAgICAvKiBIZWFkZXIgUmVuZGVyIE1ldGhvZHNcclxuICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgdGhlIGRheS1vZiB3ZWVrIGhlYWRlciBjZWxsc1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJIZWFkSW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIHRoZW1lID0gX2EudGhlbWUsIGRhdGVFbnYgPSBfYS5kYXRlRW52O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMucHJvcHMuZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF5Q250ID0gY29yZS5kaWZmRGF5cyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcclxuICAgICAgICAgICAgICAgIHZhciB3ZWVrVGV4dDtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcHQoJ3dlZWtOdW1iZXJzJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZWVrVGV4dCA9IGRhdGVFbnYuZm9ybWF0KHJhbmdlLnN0YXJ0LCBXRUVLX0hFQURFUl9GT1JNQVQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8dGggY2xhc3M9XCJmYy1heGlzIGZjLXdlZWstbnVtYmVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCIgJyArIF90aGlzLmF4aXNTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuYnVpbGRHb3RvQW5jaG9ySHRtbCgvLyBhc2lkZSBmcm9tIGxpbmssIGltcG9ydGFudCBmb3IgbWF0Y2hDZWxsV2lkdGhzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLCB7IGRhdGU6IHJhbmdlLnN0YXJ0LCB0eXBlOiAnd2VlaycsIGZvcmNlT2ZmOiBkYXlDbnQgPiAxIH0sIGNvcmUuaHRtbEVzY2FwZSh3ZWVrVGV4dCkgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvdGg+JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnPHRoIGNsYXNzPVwiZmMtYXhpcyAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiICcgKyBfdGhpcy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGg+JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyogVGltZSBHcmlkIFJlbmRlciBNZXRob2RzXHJcbiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBiZyBvZiB0aGUgVGltZUdyaWQgc2xvdCBhcmVhLiBMb25nIHZlcnRpY2FsIGNvbHVtbi5cclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyVGltZUdyaWRCZ0ludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aGVtZSA9IF90aGlzLnRoZW1lO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgKyBfdGhpcy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgYWxsIG90aGVyIHR5cGVzIG9mIGNlbGxzLlxyXG4gICAgICAgICAgICAvLyBBZmZlY3RzIGNvbnRlbnQtc2tlbGV0b24sIG1pcnJvci1za2VsZXRvbiwgaGlnaGxpZ2h0LXNrZWxldG9uIGZvciBib3RoIHRoZSB0aW1lLWdyaWQgYW5kIGRheS1ncmlkLlxyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJUaW1lR3JpZEludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpc1wiICcgKyBfdGhpcy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyogRGF5IEdyaWQgUmVuZGVyIE1ldGhvZHNcclxuICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgdGhlIGFsbC1kYXkgY2VsbHNcclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyRGF5R3JpZEJnSW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoZW1lID0gX3RoaXMudGhlbWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1heGlzICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgKyBfdGhpcy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8c3Bhbj4nICsgLy8gbmVlZGVkIGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLmdldEFsbERheUh0bWwoX3RoaXMpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RkPic7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGFsbCBvdGhlciB0eXBlcyBvZiBjZWxscy5cclxuICAgICAgICAgICAgLy8gQWZmZWN0cyBjb250ZW50LXNrZWxldG9uLCBtaXJyb3Itc2tlbGV0b24sIGhpZ2hsaWdodC1za2VsZXRvbiBmb3IgYm90aCB0aGUgdGltZS1ncmlkIGFuZCBkYXktZ3JpZC5cclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyRGF5R3JpZEludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpc1wiICcgKyBfdGhpcy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnZmMtdGltZUdyaWQtdmlldycpO1xyXG4gICAgICAgICAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSBfdGhpcy5yZW5kZXJTa2VsZXRvbkh0bWwoKTtcclxuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsZXIgPSBuZXcgY29yZS5TY3JvbGxDb21wb25lbnQoJ2hpZGRlbicsIC8vIG92ZXJmbG93IHhcclxuICAgICAgICAgICAgJ2F1dG8nIC8vIG92ZXJmbG93IHlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdmFyIHRpbWVHcmlkV3JhcEVsID0gX3RoaXMuc2Nyb2xsZXIuZWw7XHJcbiAgICAgICAgICAgIF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1ib2R5ID4gdHIgPiB0ZCcpLmFwcGVuZENoaWxkKHRpbWVHcmlkV3JhcEVsKTtcclxuICAgICAgICAgICAgdGltZUdyaWRXcmFwRWwuY2xhc3NMaXN0LmFkZCgnZmMtdGltZS1ncmlkLWNvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICB2YXIgdGltZUdyaWRFbCA9IGNvcmUuY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdmYy10aW1lLWdyaWQnIH0pO1xyXG4gICAgICAgICAgICB0aW1lR3JpZFdyYXBFbC5hcHBlbmRDaGlsZCh0aW1lR3JpZEVsKTtcclxuICAgICAgICAgICAgX3RoaXMudGltZUdyaWQgPSBuZXcgVGltZUdyaWQoX3RoaXMuY29udGV4dCwgdGltZUdyaWRFbCwge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyQmdJbnRyb0h0bWw6IF90aGlzLnJlbmRlclRpbWVHcmlkQmdJbnRyb0h0bWwsXHJcbiAgICAgICAgICAgICAgICByZW5kZXJJbnRyb0h0bWw6IF90aGlzLnJlbmRlclRpbWVHcmlkSW50cm9IdG1sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0KCdhbGxEYXlTbG90JykpIHsgLy8gc2hvdWxkIHdlIGRpc3BsYXkgdGhlIFwiYWxsLWRheVwiIGFyZWE/XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXlHcmlkID0gbmV3IGRheWdyaWQuRGF5R3JpZCgvLyB0aGUgYWxsLWRheSBzdWJjb21wb25lbnQgb2YgdGhpcyB2aWV3XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LCBfdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZmMtZGF5LWdyaWQnKSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck51bWJlckludHJvSHRtbDogX3RoaXMucmVuZGVyRGF5R3JpZEludHJvSHRtbCxcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJCZ0ludHJvSHRtbDogX3RoaXMucmVuZGVyRGF5R3JpZEJnSW50cm9IdG1sLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckludHJvSHRtbDogX3RoaXMucmVuZGVyRGF5R3JpZEludHJvSHRtbCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xXZWVrTnVtYmVyc1Zpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxXZWVrTnVtYmVyc1Zpc2libGU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgdGhlIGRheS1ncmlkIGV4dGVuZCBpdCdzIGNvb3JkaW5hdGUgYXJlYSBvdmVyIHRoZSA8aHI+IGRpdmlkaW5nIHRoZSB0d28gZ3JpZHNcclxuICAgICAgICAgICAgICAgIHZhciBkaXZpZGVyRWwgPSBfdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZmMtZGl2aWRlcicpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGF5R3JpZC5ib3R0b21Db29yZFBhZGRpbmcgPSBkaXZpZGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgVGltZUdyaWRWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lR3JpZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5kZXN0cm95KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBSZW5kZXJpbmdcclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCBza2VsZXRvbiBmb3IgdGhlIHZpZXcuXHJcbiAgICAgICAgLy8gVGhlIGRheS1ncmlkIGFuZCB0aW1lLWdyaWQgY29tcG9uZW50cyB3aWxsIHJlbmRlciBpbnNpZGUgY29udGFpbmVycyBkZWZpbmVkIGJ5IHRoaXMgSFRNTC5cclxuICAgICAgICBUaW1lR3JpZFZpZXcucHJvdG90eXBlLnJlbmRlclNrZWxldG9uSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRoZW1lID0gdGhpcy50aGVtZTtcclxuICAgICAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0KCdjb2x1bW5IZWFkZXInKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgJzx0aGVhZCBjbGFzcz1cImZjLWhlYWRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWhlYWQtY29udGFpbmVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCI+Jm5ic3A7PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L3RoZWFkPicgOlxyXG4gICAgICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICAgICAnPHRib2R5IGNsYXNzPVwiZmMtYm9keVwiPicgK1xyXG4gICAgICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICh0aGlzLm9wdCgnYWxsRGF5U2xvdCcpID9cclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWRheS1ncmlkXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8aHIgY2xhc3M9XCJmYy1kaXZpZGVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCIgLz4nIDpcclxuICAgICAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICc8L3Rib2R5PicgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGFibGU+JztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIE5vdyBJbmRpY2F0b3JcclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgIFRpbWVHcmlkVmlldy5wcm90b3R5cGUuZ2V0Tm93SW5kaWNhdG9yVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZUdyaWQuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gcmVuZGVyTm93SW5kaWNhdG9yKGRhdGU6IERhdGVNYXJrZXIpIHtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgVGltZUdyaWRWaWV3LnByb3RvdHlwZS51bnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lR3JpZC51bnJlbmRlck5vd0luZGljYXRvcigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogRGltZW5zaW9uc1xyXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgVGltZUdyaWRWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKGlzUmVzaXplLCB2aWV3SGVpZ2h0LCBpc0F1dG8pIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgaXNSZXNpemUsIHZpZXdIZWlnaHQsIGlzQXV0byk7IC8vIHdpbGwgY2FsbCB1cGRhdGVCYXNlU2l6ZS4gaW1wb3J0YW50IHRoYXQgZXhlY3V0ZXMgZmlyc3RcclxuICAgICAgICAgICAgdGhpcy50aW1lR3JpZC51cGRhdGVTaXplKGlzUmVzaXplKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnVwZGF0ZVNpemUoaXNSZXNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBBZGp1c3RzIHRoZSB2ZXJ0aWNhbCBkaW1lbnNpb25zIG9mIHRoZSB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgdmFsdWVzXHJcbiAgICAgICAgVGltZUdyaWRWaWV3LnByb3RvdHlwZS51cGRhdGVCYXNlU2l6ZSA9IGZ1bmN0aW9uIChpc1Jlc2l6ZSwgdmlld0hlaWdodCwgaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBldmVudExpbWl0O1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aHM7XHJcbiAgICAgICAgICAgIC8vIG1ha2UgYWxsIGF4aXMgY2VsbHMgbGluZSB1cFxyXG4gICAgICAgICAgICB0aGlzLmF4aXNXaWR0aCA9IGNvcmUubWF0Y2hDZWxsV2lkdGhzKGNvcmUuZmluZEVsZW1lbnRzKHRoaXMuZWwsICcuZmMtYXhpcycpKTtcclxuICAgICAgICAgICAgLy8gaGFjayB0byBnaXZlIHRoZSB2aWV3IHNvbWUgaGVpZ2h0IHByaW9yIHRvIHRpbWVHcmlkJ3MgY29sdW1ucyBiZWluZyByZW5kZXJlZFxyXG4gICAgICAgICAgICAvLyBUT0RPOiBzZXBhcmF0ZSBzZXR0aW5nIGhlaWdodCBmcm9tIHNjcm9sbGVyIFZTIHRpbWVHcmlkLlxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudGltZUdyaWQuY29sRWxzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXV0bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodmlld0hlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNldCBvZiBmYWtlIHJvdyBlbGVtZW50cyB0aGF0IG11c3QgY29tcGVuc2F0ZSB3aGVuIHNjcm9sbGVyIGhhcyBzY3JvbGxiYXJzXHJcbiAgICAgICAgICAgIHZhciBub1Njcm9sbFJvd0VscyA9IGNvcmUuZmluZEVsZW1lbnRzKHRoaXMuZWwsICcuZmMtcm93JykuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIV90aGlzLnNjcm9sbGVyLmVsLmNvbnRhaW5zKG5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGRpbWVuc2lvbnMgYmFjayB0byB0aGUgb3JpZ2luYWwgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy50aW1lR3JpZC5ib3R0b21SdWxlRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gd2lsbCBiZSBzaG93biBsYXRlciBpZiB0aGlzIDxocj4gaXMgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuY2xlYXIoKTsgLy8gc2V0cyBoZWlnaHQgdG8gJ2F1dG8nIGFuZCBjbGVhcnMgb3ZlcmZsb3dcclxuICAgICAgICAgICAgbm9TY3JvbGxSb3dFbHMuZm9yRWFjaChjb3JlLnVuY29tcGVuc2F0ZVNjcm9sbCk7XHJcbiAgICAgICAgICAgIC8vIGxpbWl0IG51bWJlciBvZiBldmVudHMgaW4gdGhlIGFsbC1kYXkgYXJlYVxyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlU2VnUG9wb3ZlcigpOyAvLyBraWxsIHRoZSBcIm1vcmVcIiBwb3BvdmVyIGlmIGRpc3BsYXllZFxyXG4gICAgICAgICAgICAgICAgZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudExpbWl0ID0gVElNRUdSSURfQUxMX0RBWV9FVkVOVF9MSU1JVDsgLy8gbWFrZSBzdXJlIFwiYXV0b1wiIGdvZXMgdG8gYSByZWFsIG51bWJlclxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TGltaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRheUdyaWQubGltaXRSb3dzKGV2ZW50TGltaXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNBdXRvKSB7IC8vIHNob3VsZCB3ZSBmb3JjZSBkaW1lbnNpb25zIG9mIHRoZSBzY3JvbGwgY29udGFpbmVyP1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh2aWV3SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHNjcm9sbGJhcldpZHRocyA9IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7IC8vIHVzaW5nIHNjcm9sbGJhcnM/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgYWxsLWRheSBhbmQgaGVhZGVyIHJvd3MgbGluZXMgdXBcclxuICAgICAgICAgICAgICAgICAgICBub1Njcm9sbFJvd0Vscy5mb3JFYWNoKGZ1bmN0aW9uIChyb3dFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLmNvbXBlbnNhdGVTY3JvbGwocm93RWwsIHNjcm9sbGJhcldpZHRocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNjcm9sbGJhciBjb21wZW5zYXRpb24gbWlnaHQgaGF2ZSBjaGFuZ2VkIHRleHQgZmxvdywgd2hpY2ggbWlnaHQgYWZmZWN0IGhlaWdodCwgc28gcmVjYWxjdWxhdGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmVhcHBseSB0aGUgZGVzaXJlZCBoZWlnaHQgdG8gdGhlIHNjcm9sbGVyLlxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodmlld0hlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZ3VhcmFudGVlcyB0aGUgc2FtZSBzY3JvbGxiYXIgd2lkdGhzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLmxvY2tPdmVyZmxvdyhzY3JvbGxiYXJXaWR0aHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhbnkgc3BhY2UgYmVsb3cgdGhlIHNsYXRzLCBzaG93IHRoZSBob3Jpem9udGFsIHJ1bGUuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdvbid0IGNhdXNlIGFueSBuZXcgb3ZlcmZsb3csIGJlY2F1c2UgbG9ja092ZXJmbG93IGFscmVhZHkgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGltZUdyaWQuZ2V0VG90YWxTbGF0SGVpZ2h0KCkgPCBzY3JvbGxlckhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZUdyaWQuYm90dG9tUnVsZUVsLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gZ2l2ZW4gYSBkZXNpcmVkIHRvdGFsIGhlaWdodCBvZiB0aGUgdmlldywgcmV0dXJucyB3aGF0IHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbGVyIHNob3VsZCBiZVxyXG4gICAgICAgIFRpbWVHcmlkVmlldy5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVySGVpZ2h0ID0gZnVuY3Rpb24gKHZpZXdIZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdIZWlnaHQgLVxyXG4gICAgICAgICAgICAgICAgY29yZS5zdWJ0cmFjdElubmVyRWxIZWlnaHQodGhpcy5lbCwgdGhpcy5zY3JvbGxlci5lbCk7IC8vIGV2ZXJ5dGhpbmcgdGhhdCdzIE5PVCB0aGUgc2Nyb2xsZXJcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIFNjcm9sbFxyXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIGluaXRpYWwgcHJlLWNvbmZpZ3VyZWQgc2Nyb2xsIHN0YXRlIHByaW9yIHRvIGFsbG93aW5nIHRoZSB1c2VyIHRvIGNoYW5nZSBpdFxyXG4gICAgICAgIFRpbWVHcmlkVmlldy5wcm90b3R5cGUuY29tcHV0ZURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMudGltZUdyaWQuY29tcHV0ZVRpbWVUb3AoZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAvLyB6b29tIGNhbiBnaXZlIHdlaXJkIGZsb2F0aW5nLXBvaW50IHZhbHVlcy4gcmF0aGVyIHNjcm9sbCBhIGxpdHRsZSBiaXQgZnVydGhlclxyXG4gICAgICAgICAgICB0b3AgPSBNYXRoLmNlaWwodG9wKTtcclxuICAgICAgICAgICAgaWYgKHRvcCkge1xyXG4gICAgICAgICAgICAgICAgdG9wKys7IC8vIHRvIG92ZXJjb21lIHRvcCBib3JkZXIgdGhhdCBzbG90cyBiZXlvbmQgdGhlIGZpcnN0IGhhdmUuIGxvb2tzIGJldHRlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IHRvcDogdG9wIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaW1lR3JpZFZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbFRvcCgpIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaW1lR3JpZFZpZXcucHJvdG90eXBlLmFwcGx5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIChzY3JvbGwpIHtcclxuICAgICAgICAgICAgaWYgKHNjcm9sbC50b3AgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRTY3JvbGxUb3Aoc2Nyb2xsLnRvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSBheGlzLCBpZiBpdCBpcyBrbm93blxyXG4gICAgICAgIFRpbWVHcmlkVmlldy5wcm90b3R5cGUuYXhpc1N0eWxlQXR0ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXhpc1dpZHRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnc3R5bGU9XCJ3aWR0aDonICsgdGhpcy5heGlzV2lkdGggKyAncHhcIic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRpbWVHcmlkVmlldztcclxuICAgIH0oY29yZS5WaWV3KSk7XHJcbiAgICBUaW1lR3JpZFZpZXcucHJvdG90eXBlLnVzZXNNaW5NYXhUaW1lID0gdHJ1ZTsgLy8gaW5kaWNhdGVzIHRoYXQgbWluVGltZS9tYXhUaW1lIGFmZmVjdHMgcmVuZGVyaW5nXHJcblxyXG4gICAgdmFyIFNpbXBsZVRpbWVHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTaW1wbGVUaW1lR3JpZCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTaW1wbGVUaW1lR3JpZChjb250ZXh0LCB0aW1lR3JpZCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0LCB0aW1lR3JpZC5lbCkgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuYnVpbGREYXlSYW5nZXMgPSBjb3JlLm1lbW9pemUoYnVpbGREYXlSYW5nZXMpO1xyXG4gICAgICAgICAgICBfdGhpcy5zbGljZXIgPSBuZXcgVGltZUdyaWRTbGljZXIoKTtcclxuICAgICAgICAgICAgX3RoaXMudGltZUdyaWQgPSB0aW1lR3JpZDtcclxuICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhci5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzLCB7XHJcbiAgICAgICAgICAgICAgICBlbDogX3RoaXMudGltZUdyaWQuZWxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgU2ltcGxlVGltZUdyaWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNpbXBsZVRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gcHJvcHMuZGF0ZVByb2ZpbGUsIGRheVRhYmxlID0gcHJvcHMuZGF5VGFibGU7XHJcbiAgICAgICAgICAgIHZhciBkYXlSYW5nZXMgPSB0aGlzLmRheVJhbmdlcyA9IHRoaXMuYnVpbGREYXlSYW5nZXMoZGF5VGFibGUsIGRhdGVQcm9maWxlLCB0aGlzLmRhdGVFbnYpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVHcmlkLnJlY2VpdmVQcm9wcyhfX2Fzc2lnbih7fSwgdGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgZGF0ZVByb2ZpbGUsIG51bGwsIHRoaXMudGltZUdyaWQsIGRheVJhbmdlcyksIHsgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBjZWxsczogZGF5VGFibGUuY2VsbHNbMF0gfSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2ltcGxlVGltZUdyaWQucHJvdG90eXBlLnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZUdyaWQucmVuZGVyTm93SW5kaWNhdG9yKHRoaXMuc2xpY2VyLnNsaWNlTm93RGF0ZShkYXRlLCB0aGlzLnRpbWVHcmlkLCB0aGlzLmRheVJhbmdlcyksIGRhdGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2ltcGxlVGltZUdyaWQucHJvdG90eXBlLmJ1aWxkUG9zaXRpb25DYWNoZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZUdyaWQuYnVpbGRQb3NpdGlvbkNhY2hlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2ltcGxlVGltZUdyaWQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcclxuICAgICAgICAgICAgdmFyIHJhd0hpdCA9IHRoaXMudGltZUdyaWQucG9zaXRpb25Ub0hpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wKTtcclxuICAgICAgICAgICAgaWYgKHJhd0hpdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMudGltZUdyaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVNwYW46IHJhd0hpdC5kYXRlU3BhbixcclxuICAgICAgICAgICAgICAgICAgICBkYXlFbDogcmF3SGl0LmRheUVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmF3SGl0LnJlbGF0aXZlUmVjdC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmF3SGl0LnJlbGF0aXZlUmVjdC5yaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiByYXdIaXQucmVsYXRpdmVSZWN0LnRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiByYXdIaXQucmVsYXRpdmVSZWN0LmJvdHRvbVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IDBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTaW1wbGVUaW1lR3JpZDtcclxuICAgIH0oY29yZS5EYXRlQ29tcG9uZW50KSk7XHJcbiAgICBmdW5jdGlvbiBidWlsZERheVJhbmdlcyhkYXlUYWJsZSwgZGF0ZVByb2ZpbGUsIGRhdGVFbnYpIHtcclxuICAgICAgICB2YXIgcmFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRheVRhYmxlLmhlYWRlckRhdGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGRhdGUsIGRhdGVQcm9maWxlLm1pblRpbWUpLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChkYXRlLCBkYXRlUHJvZmlsZS5tYXhUaW1lKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcclxuICAgIH1cclxuICAgIHZhciBUaW1lR3JpZFNsaWNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVGltZUdyaWRTbGljZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVGltZUdyaWRTbGljZXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgVGltZUdyaWRTbGljZXIucHJvdG90eXBlLnNsaWNlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsIGRheVJhbmdlcykge1xyXG4gICAgICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBkYXlSYW5nZXMubGVuZ3RoOyBjb2wrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZ1JhbmdlID0gY29yZS5pbnRlcnNlY3RSYW5nZXMocmFuZ2UsIGRheVJhbmdlc1tjb2xdKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWdSYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWdSYW5nZS5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gcmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gcmFuZ2UuZW5kLnZhbHVlT2YoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBjb2xcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VncztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBUaW1lR3JpZFNsaWNlcjtcclxuICAgIH0oY29yZS5TbGljZXIpKTtcclxuXHJcbiAgICB2YXIgVGltZUdyaWRWaWV3JDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFRpbWVHcmlkVmlldywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBUaW1lR3JpZFZpZXcoX2NvbnRleHQsIHZpZXdTcGVjLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgcGFyZW50RWwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX2NvbnRleHQsIHZpZXdTcGVjLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgcGFyZW50RWwpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmJ1aWxkRGF5VGFibGUgPSBjb3JlLm1lbW9pemUoYnVpbGREYXlUYWJsZSk7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHQoJ2NvbHVtbkhlYWRlcicpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oZWFkZXIgPSBuZXcgY29yZS5EYXlIZWFkZXIoX3RoaXMuY29udGV4dCwgX3RoaXMuZWwucXVlcnlTZWxlY3RvcignLmZjLWhlYWQtY29udGFpbmVyJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnNpbXBsZVRpbWVHcmlkID0gbmV3IFNpbXBsZVRpbWVHcmlkKF90aGlzLmNvbnRleHQsIF90aGlzLnRpbWVHcmlkKTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNpbXBsZURheUdyaWQgPSBuZXcgZGF5Z3JpZC5TaW1wbGVEYXlHcmlkKF90aGlzLmNvbnRleHQsIF90aGlzLmRheUdyaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgVGltZUdyaWRWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaW1wbGVUaW1lR3JpZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNpbXBsZURheUdyaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2ltcGxlRGF5R3JpZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbWVHcmlkVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgcHJvcHMpOyAvLyBmb3IgZmxhZ3MgZm9yIHVwZGF0ZVNpemVcclxuICAgICAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICAgICAgdmFyIGRheVRhYmxlID0gdGhpcy5idWlsZERheVRhYmxlKGRhdGVQcm9maWxlLCB0aGlzLmRhdGVQcm9maWxlR2VuZXJhdG9yKTtcclxuICAgICAgICAgICAgdmFyIHNwbGl0UHJvcHMgPSB0aGlzLnNwbGl0dGVyLnNwbGl0UHJvcHMocHJvcHMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyLnJlY2VpdmVQcm9wcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVzOiBkYXlUYWJsZS5oZWFkZXJEYXRlcyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlc1JlcERpc3RpbmN0RGF5czogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJJbnRyb0h0bWw6IHRoaXMucmVuZGVySGVhZEludHJvSHRtbFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaW1wbGVUaW1lR3JpZC5yZWNlaXZlUHJvcHMoX19hc3NpZ24oe30sIHNwbGl0UHJvcHNbJ3RpbWVkJ10sIHsgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLFxyXG4gICAgICAgICAgICAgICAgZGF5VGFibGU6IGRheVRhYmxlIH0pKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2ltcGxlRGF5R3JpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaW1wbGVEYXlHcmlkLnJlY2VpdmVQcm9wcyhfX2Fzc2lnbih7fSwgc3BsaXRQcm9wc1snYWxsRGF5J10sIHsgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheVRhYmxlOiBkYXlUYWJsZSwgbmV4dERheVRocmVzaG9sZDogdGhpcy5uZXh0RGF5VGhyZXNob2xkLCBpc1JpZ2lkOiBmYWxzZSB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbWVHcmlkVmlldy5wcm90b3R5cGUucmVuZGVyTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zaW1wbGVUaW1lR3JpZC5yZW5kZXJOb3dJbmRpY2F0b3IoZGF0ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVGltZUdyaWRWaWV3O1xyXG4gICAgfShUaW1lR3JpZFZpZXcpKTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF5VGFibGUoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGRheVNlcmllcyA9IG5ldyBjb3JlLkRheVNlcmllcyhkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xyXG4gICAgICAgIHJldHVybiBuZXcgY29yZS5EYXlUYWJsZShkYXlTZXJpZXMsIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWFpbiA9IGNvcmUuY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBkZWZhdWx0VmlldzogJ3RpbWVHcmlkV2VlaycsXHJcbiAgICAgICAgdmlld3M6IHtcclxuICAgICAgICAgICAgdGltZUdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGNsYXNzOiBUaW1lR3JpZFZpZXckMSxcclxuICAgICAgICAgICAgICAgIGFsbERheVNsb3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzbG90RHVyYXRpb246ICcwMDozMDowMCcsXHJcbiAgICAgICAgICAgICAgICBzbG90RXZlbnRPdmVybGFwOiB0cnVlIC8vIGEgYmFkIG5hbWUuIGNvbmZ1c2VkIHdpdGggb3ZlcmxhcC9jb25zdHJhaW50IHN5c3RlbVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0aW1lR3JpZERheToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RpbWVHcmlkJyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0aW1lR3JpZFdlZWs6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICd0aW1lR3JpZCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBleHBvcnRzLkFic3RyYWN0VGltZUdyaWRWaWV3ID0gVGltZUdyaWRWaWV3O1xyXG4gICAgZXhwb3J0cy5UaW1lR3JpZCA9IFRpbWVHcmlkO1xyXG4gICAgZXhwb3J0cy5UaW1lR3JpZFNsaWNlciA9IFRpbWVHcmlkU2xpY2VyO1xyXG4gICAgZXhwb3J0cy5UaW1lR3JpZFZpZXcgPSBUaW1lR3JpZFZpZXckMTtcclxuICAgIGV4cG9ydHMuYnVpbGREYXlSYW5nZXMgPSBidWlsZERheVJhbmdlcztcclxuICAgIGV4cG9ydHMuYnVpbGREYXlUYWJsZSA9IGJ1aWxkRGF5VGFibGU7XHJcbiAgICBleHBvcnRzLmRlZmF1bHQgPSBtYWluO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG59KSk7XHJcbiIsIi8qXG4gKiBXZWxjb21lIHRvIHlvdXIgYXBwJ3MgbWFpbiBKYXZhU2NyaXB0IGZpbGUhXG4gKlxuICogV2UgcmVjb21tZW5kIGluY2x1ZGluZyB0aGUgYnVpbHQgdmVyc2lvbiBvZiB0aGlzIEphdmFTY3JpcHQgZmlsZVxuICogKGFuZCBpdHMgQ1NTIGZpbGUpIGluIHlvdXIgYmFzZSBsYXlvdXQgKGJhc2UuaHRtbC50d2lnKS5cbiAqL1xuXG4vLyBOZWVkIGpRdWVyeT8gSW5zdGFsbCBpdCB3aXRoIFwieWFybiBhZGQganF1ZXJ5XCIsIHRoZW4gdW5jb21tZW50IHRvIGltcG9ydCBpdC5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5cbi8vIGFueSBDU1MgeW91IGltcG9ydCB3aWxsIG91dHB1dCBpbnRvIGEgc2luZ2xlIGNzcyBmaWxlIChhcHAuY3NzIGluIHRoaXMgY2FzZSlcbmltcG9ydCAnLi4vY3NzL2FwcC5jc3MnO1xuaW1wb3J0ICcuLi9jc3MvYm9vdHN0cmFwLm1pbi5jc3MnO1xucmVxdWlyZSAoJy4uL2Z1bGxjYWxlbmRhci9jb3JlL21haW4uY3NzJyk7XG5yZXF1aXJlICgnLi4vZnVsbGNhbGVuZGFyL2RheWdyaWQvbWFpbi5jc3MnKTtcbnJlcXVpcmUgKCcuLi9mdWxsY2FsZW5kYXIvbGlzdC9tYWluLmNzcycpO1xucmVxdWlyZSAoJy4uL2Z1bGxjYWxlbmRhci90aW1lZ3JpZC9tYWluLmNzcycpO1xucmVxdWlyZSAoJy4uL2Z1bGxjYWxlbmRhci9jb3JlL21haW4uanMnKTtcbnJlcXVpcmUgKCcuLi9mdWxsY2FsZW5kYXIvZGF5Z3JpZC9tYWluLmpzJyk7XG5yZXF1aXJlICgnLi4vZnVsbGNhbGVuZGFyL2ludGVyYWN0aW9uL21haW4uanMnKTtcbnJlcXVpcmUgKCcuLi9mdWxsY2FsZW5kYXIvbGlzdC9tYWluLmpzJyk7XG5yZXF1aXJlICgnLi4vZnVsbGNhbGVuZGFyL3RpbWVncmlkL21haW4uanMnKTtcblxuJChcIi5kYXRldGltZXBpY2tlclwiKS5kYXRldGltZXBpY2tlcigpO1xuXG5jb25zb2xlLmxvZygnSGVsbG8gV2VicGFjayBFbmNvcmUhIEVkaXQgbWUgaW4gYXNzZXRzL2pzL2FwcC5qcycpOyJdLCJzb3VyY2VSb290IjoiIn0=